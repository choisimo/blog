---
title: "운영체제 공부하면서 헷갈렸던 핵심 개념들 정리"
date: "2025-01-24"
category: "Computer Science"
tags: ['OS', 'CPU 스케줄링', '메모리 관리', '교착상태', '공부 노트']
excerpt: "운영체제 공부하면서 반복해서 헷갈렸던 개념들을 정리해본 개인 노트"
readTime: "3분"
---

운영체제를 공부하면서 계속 헷갈리는 개념들이 있었다. 특히 시험 준비할 때마다 다시 찾아보게 되는 내용들을 한번 정리해두려고 한다.

## CPU 스케줄링 - 버스트 길이 예측이 중요한 이유

CPU 스케줄링에서 가장 헷갈렸던 부분이 바로 **다음 CPU 버스트 길이 예측**이었다. 왜 굳이 예측을 해야 하는 걸까?

답은 SJF(Shortest Job First) 알고리즘 때문이다. SJF가 평균 대기 시간을 최소화하는 이론적으로 최적의 알고리즘인데, 문제는 미래의 CPU 버스트 길이를 알 수 없다는 것이다.

### 지수 평균 방식

그래서 나온 게 **지수 평균(Exponential Averaging)** 방식이다:

```
τn+1 = α × tn + (1-α) × τn
```

- `τn+1`: 다음 CPU 버스트 예측값
- `tn`: 현재 실제 CPU 버스트 길이  
- `τn`: 이전 예측값
- `α`: 가중치 (0 ≤ α ≤ 1)

α값에 따라 동작이 달라진다:
- **α = 0**: 과거 예측만 신뢰, 새로운 패턴에 적응 못함
- **α = 1**: 최근 값만 사용, 변동에 너무 민감
- **0 < α < 1**: 적절한 균형 (보통 1/2 사용)

결국 최근 기록에 더 큰 가중치를 두면서도 과거 데이터의 안정성을 유지하는 방식이다.

## 메모리 단편화 - 외부 vs 내부

메모리 단편화도 처음엔 정말 헷갈렸다. 외부 단편화와 내부 단편화의 차이를 명확히 구분하는 게 중요하다.

### 외부 단편화 (External Fragmentation)
프로세스들이 메모리에서 할당되고 해제되다 보니, 여기저기 작은 **홀(hole)**들이 생긴다. 이 홀들의 총합은 새 프로세스를 담을 만큼 크지만, 연속된 공간이 아니라서 할당할 수 없는 상황이다.

예시: 10KB + 20KB + 15KB = 45KB 가용 공간이 있지만, 30KB 연속 공간이 필요한 프로세스는 할당 불가

### 내부 단편화 (Internal Fragmentation)  
고정 크기 블록으로 메모리를 할당할 때, 프로세스 크기가 블록 크기보다 작아서 블록 내부에 낭비되는 공간이다.

예시: 4KB 블록에 10KB 프로세스를 할당하면 3개 블록(12KB) 필요 → 2KB 낭비

### 페이징으로 해결

페이징 기법은 이 문제들을 다음과 같이 해결한다:

- **외부 단편화**: 완전 해결! 페이지를 어떤 프레임에나 비연속적으로 로드 가능
- **내부 단편화**: 여전히 발생하지만, 평균적으로 페이지 크기의 절반 정도로 감수할 만함

## 페이지 테이블과 TLB

페이징을 공부하면서 TLB의 필요성을 이해하는 게 중요했다.

### 페이지 테이블의 문제점
논리 주소를 물리 주소로 변환하려면 페이지 테이블을 참조해야 한다. 그런데 페이지 테이블이 메모리에 있다보니, 실제 데이터에 접근하려면:

1. 페이지 테이블 접근 (주소 변환)
2. 실제 데이터 접근

총 **2번의 메모리 접근**이 필요해서 성능이 반으로 줄어든다!

### TLB로 해결
**TLB(Translation Lookaside Buffer)**는 페이지 테이블의 일부를 저장하는 고속 캐시다.

- **TLB Hit**: TLB에서 바로 주소 변환 → 1번의 메모리 접근
- **TLB Miss**: 페이지 테이블 참조 필요 → 2번의 메모리 접근

다행히 프로그램의 지역성 원리 덕분에 TLB 히트율이 높아서 성능 저하를 크게 완화할 수 있다.

## 교착상태 - 4가지 조건과 해결 방법

교착상태(Deadlock)는 프로세스들이 서로 상대방의 자원을 기다리며 무한 대기에 빠지는 상황이다.

### 코프만 조건 (4가지 필요조건)
1. **상호 배제**: 자원을 한 번에 하나의 프로세스만 사용
2. **점유와 대기**: 자원을 가진 채로 다른 자원을 기다림  
3. **비선점**: 자원을 강제로 빼앗을 수 없음
4. **순환 대기**: 프로세스들이 원형으로 서로를 기다림

### 해결 접근법

**1. 예방 (Prevention)**
4가지 조건 중 하나를 원천 차단:
- 상호 배제 제거 → 현실적으로 어려움
- 점유와 대기 제거 → 모든 자원을 한번에 요청
- 비선점 제거 → 자원 강제 회수 허용
- 순환 대기 제거 → 자원에 순서를 매겨 순서대로만 요청

**2. 회피 (Avoidance)**  
은행원 알고리즘 등을 사용해 안전한 상태만 유지. 하지만 미래 요청을 알아야 해서 현실적으로 어렵다.

**3. 탐지 및 복구 (Detection & Recovery)**
교착상태 발생을 허용하되, 주기적으로 탐지해서 복구:
- 프로세스 종료
- 자원 선점
- 체크포인트와 롤백

실제 시스템에서는 보통 3번 방식을 많이 사용한다고 한다.

## 마무리

운영체제 개념들이 처음엔 추상적으로 느껴졌는데, 각각이 해결하려는 실제 문제를 이해하니까 훨씬 명확해졌다. 특히 성능과 안정성 사이의 트레이드오프를 고려하는 부분들이 인상적이었다.

다음엔 가상 메모리와 파일 시스템 부분도 정리해봐야겠다.
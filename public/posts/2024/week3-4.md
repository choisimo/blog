---
title: "3-4주차: 정렬 및 탐색 기법"
date: "2024-01-22"
category: "Algorithm"
tags: ['정렬', '탐색', '이진탐색', '시간복잡도', '알고리즘']
excerpt: "핵심 정렬 알고리즘과 이진 탐색을 마스터하여 효율적인 데이터 처리의 기초를 다진다"
readTime: "3분"
---

<div class="week-badge">3-4주차</div>

# 🔄 정렬 및 탐색 기법

> **학습 목표**: 주요 정렬 알고리즘 구현 및 시간복잡도 이해, 이진 탐색 마스터

데이터를 효율적으로 정리하고 찾는 것은 프로그래밍의 핵심입니다. 이번 주차에서는 가장 중요한 정렬과 탐색 알고리즘들을 깊이 있게 학습합니다.

## 📖 주요 학습 내용

### 정렬 알고리즘
- **버블 정렬**: O(n²) - 기본 개념 이해
- **선택 정렬**: O(n²) - 최솟값 찾기 원리  
- **삽입 정렬**: O(n²) - 부분 정렬된 배열에 효율적
- **병합 정렬**: O(n log n) - 분할 정복의 대표 사례
- **퀵 정렬**: O(n log n) - 실전에서 가장 빠른 정렬

### 탐색 기법
- **선형 탐색**: O(n) - 순차적 검색
- **이진 탐색**: O(log n) - 정렬된 배열에서의 효율적 검색
- **이진 탐색 트리**: 동적 검색 구조의 기초

## 🎯 추천 학습 자료

### 필수 교재
- 『알고리즘 문제 해결 전략』 정렬 챕터
- 백준 알고리즘 정렬 분류 문제 목록

### 시각화 도구
- **VisuAlgo**: 정렬 과정 시각화
- **Sorting Algorithms Animations**: 다양한 정렬 비교

## 💻 실습 문제

### 필수 문제
```markdown
🟢 BOJ 2750: 수 정렬하기
   - 기본 정렬 구현
   - 난이도: ⭐

🟡 BOJ 1920: 수 찾기
   - 이진 탐색 활용
   - 난이도: ⭐⭐
```

### 추가 연습 문제
- BOJ 2751: 수 정렬하기 2 (병합정렬/퀵정렬)
- BOJ 10989: 수 정렬하기 3 (계수정렬)
- BOJ 1654: 랜선 자르기 (매개변수 탐색)

## 📊 시간복잡도 비교표

| 정렬 알고리즘 | 최선 | 평균 | 최악 | 공간복잡도 |
|---------------|------|------|------|------------|
| 버블 정렬 | O(n) | O(n²) | O(n²) | O(1) |
| 선택 정렬 | O(n²) | O(n²) | O(n²) | O(1) |
| 삽입 정렬 | O(n) | O(n²) | O(n²) | O(1) |
| 병합 정렬 | O(n log n) | O(n log n) | O(n log n) | O(n) |
| 퀵 정렬 | O(n log n) | O(n log n) | O(n²) | O(log n) |

## ⏰ 학습 스케줄

| 일차 | 학습 내용 | 소요 시간 |
|------|-----------|-----------|
| 1-3일 | 기본 정렬(버블, 선택, 삽입) | 4-5시간 |
| 4-6일 | 고급 정렬(병합, 퀵) | 4-5시간 |
| 7-9일 | 이진 탐색 완전 정복 | 3-4시간 |
| 10-14일 | 문제 풀이 및 응용 | 매일 2시간 |

## 🎉 학습 완료 체크리스트

- [ ] 5가지 정렬 알고리즘을 직접 구현할 수 있다
- [ ] 각 정렬의 시간복잡도를 정확히 알고 있다
- [ ] 이진 탐색을 반복문과 재귀로 모두 구현할 수 있다  
- [ ] 언제 어떤 정렬을 사용해야 하는지 판단할 수 있다
- [ ] 필수 문제를 모두 해결했다

## 💡 핵심 코드 스니펫

### 이진 탐색 구현
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1
```

## ⚡ 실전 팁

1. **정렬은 Python sorted() 사용**: 실전에서는 내장 함수 활용
2. **이진 탐색 직접 구현**: bisect 모듈 사용 전 원리 이해 필수
3. **경계 조건 주의**: left ≤ right, mid 계산 오버플로우 고려
4. **시간 제한 체크**: O(n²) vs O(n log n) 선택 기준 명확히

---

**이전 주차**: [1-2주차: 기초 수학 및 자료구조](../week1-2) ⬅️
**다음 주차**: [5-6주차: 재귀와 분할 정복](../week5-6) ➡️

<div class="text-center">
  <a href="../week1-2" class="btn-secondary">← 이전 주차</a>
  <a href="../week5-6" class="btn">다음 주차로 →</a>
</div>
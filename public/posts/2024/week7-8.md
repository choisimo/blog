---
title: "7-8주차: 동적 계획법(DP) 기초"
date: "2024-02-05"
category: "Algorithm"
tags: ['동적계획법', 'DP', '메모이제이션', '최적화', '알고리즘']
excerpt: "최적 부분 구조와 중복 부분 문제를 이용한 효율적 문제 해결 기법을 마스터한다"
readTime: "3분"
---

<div class="week-badge">7-8주차</div>

# 💎 동적 계획법(DP) 기초

> **학습 목표**: DP의 핵심 원리(최적 부분 구조·중복 부분 문제) 완전 이해

알고리즘의 꽃이라 불리는 동적 계획법을 본격적으로 학습합니다. 복잡한 최적화 문제를 효율적으로 해결하는 강력한 패러다임입니다.

## 📖 주요 학습 내용

### 동적 계획법 핵심 개념
- **최적 부분 구조**: 큰 문제의 최적해가 작은 문제들의 최적해로 구성
- **중복 부분 문제**: 같은 하위 문제가 여러 번 반복
- **메모이제이션**: 계산 결과를 저장하여 중복 계산 방지

### DP 구현 방식
- **Top-down**: 재귀 + 메모이제이션
- **Bottom-up**: 반복문을 이용한 테이블 채우기

### 1차원 DP 문제들
- **계단 오르기**: 경우의 수 계산
- **최대 연속 합**: 카데인 알고리즘
- **가장 긴 증가하는 부분 수열(LIS)**

### 2차원 DP 입문
- **최장 공통 부분 수열(LCS)**
- **편집 거리**: 문자열 간 최소 편집 횟수

## 🎯 추천 학습 자료

### 필수 자료
- **프로그래머스**: DP 입문 강의
- **백준**: DP 분류 문제집
- 『알고리즘 문제 해결 전략』 DP 챕터

### 시각화 도구
- **DP Visualizer**: 상태 전이 과정 시각화
- **LeetCode**: DP 패턴별 문제 모음

## 💻 실습 문제

### 필수 문제
```markdown
🟡 BOJ 10844: 쉬운 계단 수
   - 1차원 DP의 대표 문제
   - 난이도: ⭐⭐⭐

🟡 BOJ 11053: 가장 긴 증가하는 부분 수열
   - LIS 알고리즘 기초
   - 난이도: ⭐⭐⭐
```

### 추가 연습 문제  
- BOJ 1463: 1로 만들기
- BOJ 9095: 1, 2, 3 더하기
- BOJ 2579: 계단 오르기
- BOJ 1149: RGB거리

## 📊 DP 문제 해결 단계

### 1단계: 문제 분석
```
1. 최적 부분 구조 확인
2. 중복 부분 문제 식별  
3. 상태(State) 정의
4. 점화식 도출
```

### 2단계: 구현 선택
```
Top-down: 직관적, 재귀 깊이 주의
Bottom-up: 효율적, 공간 최적화 가능
```

## ⏰ 학습 스케줄

| 일차 | 학습 내용 | 소요 시간 |
|------|-----------|-----------|
| 1-2일 | DP 개념과 피보나치 최적화 | 3-4시간 |
| 3-5일 | 1차원 DP 문제들 | 4-5시간 |
| 6-8일 | 계단 오르기, 1로 만들기 | 4-5시간 |
| 9-11일 | LIS, LCS 학습 | 5-6시간 |
| 12-14일 | 종합 문제 풀이 | 매일 2-3시간 |

## 🎉 학습 완료 체크리스트

- [ ] DP의 두 가지 조건을 명확히 이해했다
- [ ] Top-down과 Bottom-up 방식을 모두 구현할 수 있다
- [ ] 1차원 DP 점화식을 스스로 도출할 수 있다  
- [ ] LIS 알고리즘을 완전히 이해했다
- [ ] 필수 문제를 모두 해결했다

## 💡 핵심 코드 패턴

### LIS (O(n²) 버전)
```python
def lis(arr):
    n = len(arr)
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if arr[j] < arr[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)
```

### 계단 오르기
```python
def stairs(n, cost):
    if n <= 2:
        return cost[n-1]
    
    dp = [0] * n
    dp[0] = cost[0]
    dp[1] = cost[1]
    
    for i in range(2, n):
        dp[i] = cost[i] + min(dp[i-1], dp[i-2])
    
    return min(dp[n-1], dp[n-2])
```

## ⚡ DP 마스터 전략

1. **상태 정의가 핵심**: dp[i]가 무엇을 의미하는지 명확히
2. **점화식 도출**: 작은 예시로 규칙 찾기
3. **초기값 설정**: Base case 신중히 설정
4. **공간 최적화**: 이전 값만 필요하면 배열 크기 줄이기

## 🔥 다음 단계 예고

- **2차원 DP 심화**: 배낭 문제, 편집 거리
- **비트마스크 DP**: 상태 압축 기법
- **트리 DP**: 트리 구조에서의 동적 계획법
- **확률 DP**: 기댓값 계산 문제

---

**이전 주차**: [5-6주차: 재귀와 분할 정복](../week5-6) ⬅️  
**다음 주차**: [9-10주차: 그래프 이론 기초](../week9-10) ➡️

<div class="text-center">
  <a href="../week5-6" class="btn-secondary">← 이전 주차</a>
  <a href="../week9-10" class="btn">다음 주차로 →</a>
</div>
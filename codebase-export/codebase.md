# blog-1120 - Complete Codebase

> Generated at: 2025-12-26T08:43:43.028Z
> Total files: 554

## Table of Contents

- [.](#-)
- [.github](#-github)
- [.github/workflows](#-github-workflows)
- [.roo](#-roo)
- [backend](#backend)
- [backend/deploy](#backend-deploy)
- [backend/scripts](#backend-scripts)
- [backend/src](#backend-src)
- [backend/src/lib](#backend-src-lib)
- [backend/src/lib/agent](#backend-src-lib-agent)
- [backend/src/lib/agent/memory](#backend-src-lib-agent-memory)
- [backend/src/lib/agent/prompts](#backend-src-lib-agent-prompts)
- [backend/src/lib/agent/tools](#backend-src-lib-agent-tools)
- [backend/src/middleware](#backend-src-middleware)
- [backend/src/routes](#backend-src-routes)
- [backend/terminal-server](#backend-terminal-server)
- [backend/terminal-server/sandbox](#backend-terminal-server-sandbox)
- [backend/terminal-server/src](#backend-terminal-server-src)
- [doc-converter](#doc-converter)
- [doc-converter/src](#doc-converter-src)
- [doc-converter/src/components](#doc-converter-src-components)
- [doc-converter/src/stores](#doc-converter-src-stores)
- [doc-converter/src/utils](#doc-converter-src-utils)
- [docs](#docs)
- [docs/tasks/catalyst](#docs-tasks-catalyst)
- [docs/tasks/chat](#docs-tasks-chat)
- [docs/tasks/memo](#docs-tasks-memo)
- [docs/tasks/terminal](#docs-tasks-terminal)
- [frontend](#frontend)
- [frontend/config](#frontend-config)
- [frontend/public](#frontend-public)
- [frontend/public/ai-memo](#frontend-public-ai-memo)
- [frontend/public/posts](#frontend-public-posts)
- [frontend/public/posts/2024](#frontend-public-posts-2024)
- [frontend/public/posts/2025](#frontend-public-posts-2025)
- [frontend/public/posts/en/2025](#frontend-public-posts-en-2025)
- [frontend/public/posts/ko/2025](#frontend-public-posts-ko-2025)
- [frontend/scripts](#frontend-scripts)
- [frontend/src](#frontend-src)
- [frontend/src/components](#frontend-src-components)
- [frontend/src/components/atoms](#frontend-src-components-atoms)
- [frontend/src/components/common](#frontend-src-components-common)
- [frontend/src/components/features/admin](#frontend-src-components-features-admin)
- [frontend/src/components/features/admin/ai](#frontend-src-components-features-admin-ai)
- [frontend/src/components/features/blog](#frontend-src-components-features-blog)
- [frontend/src/components/features/chat](#frontend-src-components-features-chat)
- [frontend/src/components/features/chat/widget](#frontend-src-components-features-chat-widget)
- [frontend/src/components/features/chat/widget/components](#frontend-src-components-features-chat-widget-components)
- [frontend/src/components/features/chat/widget/hooks](#frontend-src-components-features-chat-widget-hooks)
- [frontend/src/components/features/memo](#frontend-src-components-features-memo)
- [frontend/src/components/features/memo/fab](#frontend-src-components-features-memo-fab)
- [frontend/src/components/features/memo/fab/components](#frontend-src-components-features-memo-fab-components)
- [frontend/src/components/features/memo/fab/hooks](#frontend-src-components-features-memo-fab-hooks)
- [frontend/src/components/features/navigation](#frontend-src-components-features-navigation)
- [frontend/src/components/features/search](#frontend-src-components-features-search)
- [frontend/src/components/features/sentio](#frontend-src-components-features-sentio)
- [frontend/src/components/molecules](#frontend-src-components-molecules)
- [frontend/src/components/organisms](#frontend-src-components-organisms)
- [frontend/src/components/ui](#frontend-src-components-ui)
- [frontend/src/config](#frontend-src-config)
- [frontend/src/contexts](#frontend-src-contexts)
- [frontend/src/data](#frontend-src-data)
- [frontend/src/hooks](#frontend-src-hooks)
- [frontend/src/hooks/seo](#frontend-src-hooks-seo)
- [frontend/src/lib](#frontend-src-lib)
- [frontend/src/pages](#frontend-src-pages)
- [frontend/src/services](#frontend-src-services)
- [frontend/src/services/chat](#frontend-src-services-chat)
- [frontend/src/stores](#frontend-src-stores)
- [frontend/src/test](#frontend-src-test)
- [frontend/src/types](#frontend-src-types)
- [frontend/src/utils](#frontend-src-utils)
- [frontend/src/utils/seo](#frontend-src-utils-seo)
- [my-app/alembic](#my-app-alembic)
- [my-app/alembic/versions](#my-app-alembic-versions)
- [scripts](#scripts)
- [scripts/rag](#scripts-rag)
- [shared](#shared)
- [shared/ai](#shared-ai)
- [shared/types](#shared-types)
- [workers](#workers)
- [workers/ai-check-gateway](#workers-ai-check-gateway)
- [workers/ai-check-gateway/src](#workers-ai-check-gateway-src)
- [workers/db-api](#workers-db-api)
- [workers/db-api/src](#workers-db-api-src)
- [workers/migrations](#workers-migrations)
- [workers/r2-gateway](#workers-r2-gateway)
- [workers/r2-gateway/src](#workers-r2-gateway-src)
- [workers/scripts](#workers-scripts)
- [workers/src](#workers-src)
- [workers/src/lib](#workers-src-lib)
- [workers/src/middleware](#workers-src-middleware)
- [workers/src/routes](#workers-src-routes)
- [workers/terminal-gateway](#workers-terminal-gateway)
- [workers/terminal-gateway/src](#workers-terminal-gateway-src)

---

## .

### .env.example

**Path:** `.env.example`

```bash
# Unified .env (single source of truth)
# Copy this file to .env at the repo root and edit values.
# Backend reads ../.env first then backend/.env overrides. Frontend Vite also
# loads env from the repo root via envDir.

# --- App/Server ---
APP_ENV=development
HOST=0.0.0.0
PORT=5080
TRUST_PROXY=1
LOG_LEVEL=info

# --- URLs & CORS ---
# Public site base URL (protocol + domain, no trailing slash)
SITE_BASE_URL=https://noblog.nodove.com
# The backend's externally reachable base URL (used in public config and clients)
API_BASE_URL=http://localhost:5080
# Comma-separated list of allowed origins for CORS
ALLOWED_ORIGINS=https://noblog.nodove.com,http://localhost:8080,http://localhost:5173

# --- Frontend (Vite) ---
# Values exposed to the client must be prefixed with VITE_
VITE_SITE_BASE_URL=https://noblog.nodove.com
VITE_API_BASE_URL=http://localhost:5080
# Dev server host/port overrides (optional)
VITE_DEV_HOST=::
VITE_DEV_PORT=8080

# --- Rate limit ---
RATE_LIMIT_MAX=60
RATE_LIMIT_WINDOW_MS=60000

# --- Gemini (optional) ---
GEMINI_API_KEY=
GEMINI_MODEL=gemini-1.5-flash

# --- Firebase Admin (optional) ---
# Provide a single-line, minified JSON string for the service account
# Example: {"project_id":"...","client_email":"...","private_key":"-----BEGIN PRIVATE KEY-----\\n...\\n-----END PRIVATE KEY-----\\n"}
FIREBASE_SERVICE_ACCOUNT_JSON=
FIREBASE_PROJECT_ID=

# --- GitHub (optional, used by admin routes) ---
GITHUB_TOKEN=
GITHUB_REPO_OWNER=
GITHUB_REPO_NAME=
GIT_USER_NAME=
GIT_USER_EMAIL=

# --- Admin/Auth (optional) ---
ADMIN_BEARER_TOKEN=
JWT_SECRET=
ADMIN_USERNAME=
ADMIN_PASSWORD=

# --- Integrations ---
# Optional deploy hook called after archival operations
VERCEL_DEPLOY_HOOK_URL=

```

### .gitignore

**Path:** `.gitignore`

```gitignore
# =============================================================================
# Git Ignore - Blog Project
# =============================================================================

# -----------------------------------------------------------------------------
# Dependencies
# -----------------------------------------------------------------------------
node_modules/
*/node_modules/
**/node_modules/

# -----------------------------------------------------------------------------
# Build outputs
# -----------------------------------------------------------------------------
dist/
dist-ssr/
build/
.next/
out/
.nuxt/
.cache/
.parcel-cache
storybook-static/

# -----------------------------------------------------------------------------
# Environment Variables (SENSITIVE - NEVER COMMIT)
# -----------------------------------------------------------------------------
.env
.env.*
!.env.example
!.env.*.example
.env.local
.env.development.local
.env.test.local
.env.production.local
*.env.backup*

# Backend specific env files
backend/.env
backend/.env.*
!backend/.env.example
!backend/.env.*.example

# Workers specific
workers/.dev.vars
workers/.dev.vars.*

# OpenCode Serve specific
backend/opencode-serve/.env
backend/opencode-serve/.env.*

# -----------------------------------------------------------------------------
# Secrets & Credentials (SENSITIVE - NEVER COMMIT)
# -----------------------------------------------------------------------------
# Service accounts
serviceAccount*.json
**/serviceAccount*.json
firebase-adminsdk*.json
**/firebase-adminsdk*.json

# Private keys
*.pem
*.key
*.p12
*.pfx
id_rsa
id_rsa.*
id_ed25519
id_ed25519.*

# JWT secrets
jwt.secret
*.secret

# API keys files
api-keys.json
secrets.json
credentials.json

# Token files
*.jwt
*.token
auto-token.jwt

# SSH keys
.ssh/
ssh_host_*

# -----------------------------------------------------------------------------
# Wrangler / Cloudflare
# -----------------------------------------------------------------------------
.wrangler/
workers/.wrangler/
**/node_modules/.cache/wrangler/
wrangler-account.json

# -----------------------------------------------------------------------------
# Database files
# -----------------------------------------------------------------------------
*.db
*.sqlite
*.sqlite3
*.db-journal
*.db-shm
*.db-wal

# -----------------------------------------------------------------------------
# Logs
# -----------------------------------------------------------------------------
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Node diagnostic reports
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# -----------------------------------------------------------------------------
# Runtime / Process
# -----------------------------------------------------------------------------
pids/
*.pid
*.seed
*.pid.lock

# -----------------------------------------------------------------------------
# IDE / Editor
# -----------------------------------------------------------------------------
.idea/
.vscode/
*.swp
*.swo
*~
*.sublime-workspace
*.sublime-project

# -----------------------------------------------------------------------------
# OS Generated
# -----------------------------------------------------------------------------
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
Desktop.ini

# Windows
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# -----------------------------------------------------------------------------
# Testing / Coverage
# -----------------------------------------------------------------------------
coverage/
*.lcov
.nyc_output/

# -----------------------------------------------------------------------------
# TypeScript
# -----------------------------------------------------------------------------
*.tsbuildinfo

# -----------------------------------------------------------------------------
# Temporary / Backup
# -----------------------------------------------------------------------------
*.tmp
*.temp
*.backup
*.bak
*.old
*.orig
post-temp/

# -----------------------------------------------------------------------------
# Archives
# -----------------------------------------------------------------------------
*.zip
*.tar.gz
*.rar
*.7z

# -----------------------------------------------------------------------------
# Docker (sensitive)
# -----------------------------------------------------------------------------
docker-compose.override.yml
docker-compose.local.yml

# -----------------------------------------------------------------------------
# Misc
# -----------------------------------------------------------------------------
.vercel
.turbo
.cache/
.npm/
.eslintcache
.stylelintcache

# Python (for scripts)
__pycache__/
*.py[cod]
*$py.class
.Python
*.so
.venv/
venv/
ENV/

```

### CNAME

**Path:** `CNAME`

```
noblog.nodove.com

```

### LOCAL_DEV.md

**Path:** `LOCAL_DEV.md`

```markdown
# Local Development Setup

Production과 동일한 구조로 **단일 Docker Compose 명령**으로 전체 블로그 시스템을 로컬에서 실행합니다.

## Quick Start

```bash
# 1. 환경변수 설정
cp .env.local.example .env.local
# .env.local 편집: GOOGLE_API_KEY 설정 (필수)

# 2. 전체 서비스 실행
docker compose -f docker-compose.local.yml up --build

# 3. 브라우저에서 확인
open http://localhost:8080
```

## Architecture

Production과 동일한 구조:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Local Development Stack                             │
│                                                                          │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                   nginx:8080 (Gateway)                            │   │
│  │  /                → frontend:80          (React SPA)              │   │
│  │  /api/*           → backend:5080         (Blog API)               │   │
│  │  /ai/*            → litellm:4000         (LiteLLM Gateway)        │   │
│  │  /workers/*       → workers:8787         (CF Workers Emulation)   │   │
│  │  /terminal/*      → terminal-server:8080 (WebSocket PTY)          │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │              LiteLLM AI Gateway (port 4000)                      │   │
│  │  - OpenAI-compatible API for ALL providers                       │   │
│  │  - Supports: Gemini, OpenAI, Anthropic, Ollama                   │   │
│  │  - Automatic fallback and load balancing                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  Services:                                                               │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│  │ frontend │ │ backend  │ │ litellm  │ │ workers  │ │ terminal │      │
│  │   :80    │ │  :5080   │ │  :4000   │ │  :8787   │ │  :8080   │      │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘      │
└─────────────────────────────────────────────────────────────────────────┘
```

## Access Points

| URL | Description |
|-----|-------------|
| http://localhost:8080 | Main Entry (Blog UI) |
| http://localhost:8080/api/v1/healthz | Backend Health Check |
| http://localhost:8080/ai/health/liveliness | LiteLLM Health Check |
| http://localhost:8080/workers/ | Workers API |

### Direct Access (Debugging)

| URL | Description |
|-----|-------------|
| http://localhost:5080 | Backend API (direct) |
| http://localhost:4000 | LiteLLM Gateway (direct) |
| http://localhost:8787 | Workers API (direct) |
| http://localhost:5173 | Frontend Vite HMR (optional) |

## Services

### 1. Frontend (React + Vite)
- **Location**: `frontend/`
- **Port**: 80 (Nginx served)
- **Features**: Blog UI, AI Chat, Memo, Terminal UI

### 2. Backend API (Node.js)
- **Location**: `backend/`
- **Port**: 5080
- **Features**: Blog API, AI Integration via LiteLLM

### 3. LiteLLM Gateway
- **Image**: `ghcr.io/berriai/litellm:main-latest`
- **Port**: 4000
- **Features**: Unified OpenAI-compatible API for all LLM providers
- **Config**: `litellm_config.local.yaml`

### 4. Workers (Cloudflare Emulation)
- **Location**: `workers/`
- **Port**: 8787
- **Features**: D1 Database, Comments, Analytics, Search
- **Data**: SQLite (persisted in Docker volume)

### 5. Terminal Server
- **Location**: `backend/terminal-server/`
- **Port**: 8080
- **Features**: Web-based terminal with Docker sandbox

## AI Provider Configuration

LiteLLM Gateway를 통해 여러 AI Provider 사용 가능:

### Option 1: Google Gemini (Recommended)
무료 tier 제공, 가장 쉬운 설정

```env
GOOGLE_API_KEY=your-api-key
AI_DEFAULT_MODEL=gemini-1.5-flash
```

Get API key: https://aistudio.google.com/app/apikey

### Option 2: OpenAI
```env
OPENAI_API_KEY=sk-...
AI_DEFAULT_MODEL=gpt-4o-mini
```

### Option 3: Anthropic Claude
```env
ANTHROPIC_API_KEY=sk-ant-...
AI_DEFAULT_MODEL=claude-3.5-sonnet
```

### Option 4: Local LLM (Ollama)
인터넷 연결 없이 로컬에서 실행

```bash
# Host에서 Ollama 실행
ollama serve
ollama pull llama3.2

# .env.local 설정
AI_DEFAULT_MODEL=local/llama3
```

## LiteLLM API 사용법

LiteLLM은 OpenAI-compatible API를 제공합니다:

```bash
# Chat completion
curl http://localhost:4000/v1/chat/completions \
  -H "Authorization: Bearer sk-local-dev-key" \
  -H "Content-Type: application/json" \
  -d '{
    "model": "gemini-1.5-flash",
    "messages": [{"role": "user", "content": "Hello!"}]
  }'

# List available models
curl http://localhost:4000/v1/models \
  -H "Authorization: Bearer sk-local-dev-key"
```

## Development Modes

### Mode 1: Full Docker (Recommended)
모든 서비스를 Docker로 실행. Production과 동일한 환경.

```bash
docker compose -f docker-compose.local.yml up --build
```

### Mode 2: Hybrid (Frontend HMR)
Frontend만 Vite dev server로 실행하여 Hot Module Replacement 활성화.

```bash
# Terminal 1: Backend services
docker compose -f docker-compose.local.yml up backend litellm workers terminal-server nginx

# Terminal 2: Frontend with HMR
cd frontend
npm install
VITE_API_BASE_URL=http://localhost:8080/api/v1 npm run dev
```

### Mode 3: Minimal
Workers 없이 핵심 기능만 실행.

```bash
docker compose -f docker-compose.local.yml up frontend backend litellm nginx
```

## Comparison: Local vs Production

| Component | Local | Production |
|-----------|-------|------------|
| Gateway | nginx:8080 | Cloudflare Tunnel → nginx |
| AI Gateway | LiteLLM (Gemini/OpenAI) | LiteLLM (+ GitHub Copilot via VAS) |
| Database | SQLite (D1 emulation) | Cloudflare D1 |
| Storage | Local filesystem | Cloudflare R2 |
| Terminal | Docker-in-Docker | Docker + Gateway Worker |

### Production-only Services (not in local)
- `cloudflared`: Cloudflare Tunnel
- `ai-engine` (vas-core): GitHub Copilot authentication
- `ai-admin`: Token management UI
- `vas-bootstrap`: Auto JWT token generation
- `embedding-server`: TEI for RAG
- `chromadb`: Vector database

## Troubleshooting

### LiteLLM 시작 실패
```bash
# 로그 확인
docker compose -f docker-compose.local.yml logs litellm

# API Key 확인
echo $GOOGLE_API_KEY  # .env.local에 설정되어 있는지
```

### Workers 빌드 실패
```bash
# shared 패키지 먼저 빌드
cd shared && npm install && npm run build
```

### AI 기능 동작 안함
```bash
# LiteLLM 직접 테스트
curl http://localhost:4000/health
curl http://localhost:4000/v1/models -H "Authorization: Bearer sk-local-dev-key"
```

### Terminal 연결 실패
- Docker socket 권한 확인: `/var/run/docker.sock`
- `ORIGIN_SECRET_KEY` 환경변수 설정 확인

## File Structure

```
.
├── docker-compose.local.yml    # 로컬 개발용 Docker Compose
├── litellm_config.local.yaml   # 로컬용 LiteLLM 설정
├── nginx.local.conf            # 로컬 Nginx Gateway 설정
├── .env.local.example          # 환경변수 템플릿
├── LOCAL_DEV.md                # 이 문서
│
├── frontend/                   # React Frontend
├── backend/                    # Node.js Backend
│   ├── litellm_config.yaml     # Production LiteLLM 설정
│   └── terminal-server/        # Terminal WebSocket Server
├── workers/                    # Cloudflare Workers
│   ├── Dockerfile.local        # Workers 로컬 빌드
│   └── migrations/             # D1 Migrations
└── shared/                     # Shared TypeScript Types
```

```

### docker-compose.local.yml

**Path:** `docker-compose.local.yml`

```yaml
# =============================================================================
# Docker Compose - Local Development (Full Stack)
# =============================================================================
#
# Production과 동일한 구조로 로컬에서 전체 서비스 실행
#
# Quick Start:
#   cp .env.local.example .env.local
#   # .env.local 편집: GOOGLE_API_KEY 또는 OPENAI_API_KEY 설정
#   docker compose -f docker-compose.local.yml up --build
#
# Architecture:
#
#   ┌─────────────────────────────────────────────────────────────────────────┐
#   │                      Local Development Stack                             │
#   │                                                                          │
#   │  ┌──────────────────────────────────────────────────────────────────┐   │
#   │  │                   nginx:8080 (Gateway)                            │   │
#   │  │  /                → frontend:80          (React SPA)              │   │
#   │  │  /api/*           → backend:5080         (Blog API)               │   │
#   │  │  /ai/*            → litellm:4000         (LiteLLM Gateway)        │   │
#   │  │  /workers/*       → workers:8787         (CF Workers Emulation)   │   │
#   │  │  /terminal/*      → terminal-server:8080 (WebSocket PTY)          │   │
#   │  └──────────────────────────────────────────────────────────────────┘   │
#   │                                                                          │
#   │  ┌─────────────────────────────────────────────────────────────────┐   │
#   │  │              LiteLLM AI Gateway (port 4000)                      │   │
#   │  │  - OpenAI-compatible API for ALL providers                       │   │
#   │  │  - Supports: OpenAI, Gemini, Anthropic, Ollama (local)           │   │
#   │  │  - Automatic fallback and load balancing                         │   │
#   │  └─────────────────────────────────────────────────────────────────┘   │
#   │                                                                          │
#   │  Services:                                                               │
#   │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
#   │  │ frontend │ │ backend  │ │ litellm  │ │ workers  │ │ terminal │      │
#   │  │   :80    │ │  :5080   │ │  :4000   │ │  :8787   │ │  :8080   │      │
#   │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘      │
#   └─────────────────────────────────────────────────────────────────────────┘
#
# Access Points:
#   http://localhost:8080           → Main Entry (Blog UI)
#   http://localhost:8080/api/*     → Backend API
#   http://localhost:8080/ai/*      → LiteLLM Gateway (OpenAI-compatible)
#   http://localhost:8080/workers/* → Workers API (D1, Comments, etc.)
#
# Direct Access (for debugging):
#   http://localhost:5080           → Backend API
#   http://localhost:4000           → LiteLLM Gateway
#   http://localhost:8787           → Workers API
#   http://localhost:5173           → Frontend (Vite HMR - optional)
#
# =============================================================================

services:
  # ---------------------------------------------------------------------------
  # Nginx Gateway (Single Entry Point)
  # ---------------------------------------------------------------------------
  nginx:
    image: nginx:alpine
    ports:
      - "8080:80"
    volumes:
      - ./nginx.local.conf:/etc/nginx/conf.d/default.conf:ro
    depends_on:
      frontend:
        condition: service_healthy
      backend:
        condition: service_healthy
      litellm:
        condition: service_healthy
    networks:
      - local-dev
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "wget -q --spider http://127.0.0.1/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 3

  # ---------------------------------------------------------------------------
  # Frontend (React SPA)
  # ---------------------------------------------------------------------------
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        # Note: VITE_API_BASE_URL should NOT include /api/v1 - that's appended by the code
        VITE_API_BASE_URL: http://localhost:8080
        VITE_WORKERS_BASE_URL: http://localhost:8080/workers
        VITE_TERMINAL_WS_URL: ws://localhost:8080/terminal
        VITE_SITE_BASE_URL: http://localhost:8080
    expose:
      - "80"
    networks:
      - local-dev
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "wget -q --spider http://127.0.0.1/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 3

  # ---------------------------------------------------------------------------
  # Backend API Server
  # ---------------------------------------------------------------------------
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    env_file:
      - path: .env.local
        required: false
    environment:
      - APP_ENV=development
      - HOST=0.0.0.0
      - PORT=5080
      - LOG_LEVEL=debug
      # URLs
      - SITE_BASE_URL=http://localhost:8080
      - API_BASE_URL=http://localhost:8080/api/v1
      - ALLOWED_ORIGINS=http://localhost:8080,http://localhost:5173,http://localhost:3000
      # LiteLLM Gateway (OpenAI-compatible endpoint)
      - AI_PROVIDER=litellm
      - LITELLM_BASE_URL=http://litellm:4000
      - LITELLM_API_KEY=${LITELLM_MASTER_KEY:-sk-local-dev-key}
      - AI_DEFAULT_MODEL=${AI_DEFAULT_MODEL:-gemini-1.5-flash}
      # Workers for D1/R2
      - WORKERS_BASE_URL=http://workers:8787
    expose:
      - "5080"
    ports:
      - "5080:5080"
    volumes:
      - ./frontend/public:/app/public:ro
    networks:
      - local-dev
    depends_on:
      litellm:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "node -e \"const http=require('http'); http.get('http://localhost:5080/api/v1/healthz', (r)=>process.exit(r.statusCode===200?0:1)).on('error',()=>process.exit(1))\""]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s

  # ===========================================================================
  # LiteLLM AI Gateway (Unified LLM Endpoint)
  # ===========================================================================
  # Single OpenAI-compatible endpoint for ALL LLM providers.
  # Supports: Gemini, OpenAI, Anthropic, Ollama (local)
  # ---------------------------------------------------------------------------
  litellm:
    image: ghcr.io/berriai/litellm:main-latest
    restart: unless-stopped
    ports:
      - "4000:4000"
    expose:
      - "4000"
    environment:
      # Master API key for authentication and Admin UI
      # Admin UI login: username=admin, password=<this key>
      LITELLM_MASTER_KEY: ${LITELLM_MASTER_KEY:-sk-local-dev-key}
      # Provider API Keys (set in .env.local)
      GOOGLE_API_KEY: ${GOOGLE_API_KEY:-}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-}
      ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY:-}
      # Logging
      LITELLM_LOG: DEBUG
    command:
      - --config
      - /app/config.yaml
      - --port
      - "4000"
      - --host
      - "0.0.0.0"
    volumes:
      - ./litellm_config.local.yaml:/app/config.yaml:ro
    networks:
      - local-dev
    healthcheck:
      test: ["CMD-SHELL", "python3 -c \"import urllib.request; urllib.request.urlopen('http://localhost:4000/health/liveliness')\""]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # ---------------------------------------------------------------------------
  # Cloudflare Workers Emulation (Wrangler Dev)
  # ---------------------------------------------------------------------------
  workers:
    build:
      context: .
      dockerfile: workers/Dockerfile.local
    environment:
      - NODE_ENV=development
    expose:
      - "8787"
    ports:
      - "8787:8787"
    volumes:
      - workers_d1_data:/app/.wrangler/state
    networks:
      - local-dev
    restart: unless-stopped

  # ---------------------------------------------------------------------------
  # Terminal Server (WebSocket PTY)
  # ---------------------------------------------------------------------------
  terminal-server:
    build:
      context: ./backend/terminal-server
      dockerfile: Dockerfile
    environment:
      - ORIGIN_SECRET_KEY=${ORIGIN_SECRET_KEY:-local-dev-secret}
      - SANDBOX_IMAGE=${SANDBOX_IMAGE:-alpine:latest}
      - ALLOWED_ORIGINS=http://localhost:8080,http://localhost:5173
    expose:
      - "8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - local-dev
    restart: unless-stopped

  # ===========================================================================
  # Optional Services (uncomment as needed)
  # ===========================================================================

  # ---------------------------------------------------------------------------
  # TEI Embedding Server (for RAG features)
  # ---------------------------------------------------------------------------
  # embedding-server:
  #   image: ghcr.io/huggingface/text-embeddings-inference:cpu-1.2.3
  #   command: --model-id sentence-transformers/all-MiniLM-L6-v2
  #   ports:
  #     - "8180:80"
  #   volumes:
  #     - tei-data:/data
  #   networks:
  #     - local-dev
  #   restart: unless-stopped

  # ---------------------------------------------------------------------------
  # ChromaDB Vector Database (for RAG features)
  # ---------------------------------------------------------------------------
  # chromadb:
  #   image: chromadb/chroma:0.5.23
  #   environment:
  #     - IS_PERSISTENT=TRUE
  #     - PERSIST_DIRECTORY=/chroma/chroma
  #     - ANONYMIZED_TELEMETRY=FALSE
  #   ports:
  #     - "8100:8000"
  #   volumes:
  #     - chroma-data:/chroma/chroma
  #   networks:
  #     - local-dev
  #   restart: unless-stopped

  # ---------------------------------------------------------------------------
  # Frontend Dev Server (Vite HMR) - Alternative to built frontend
  # ---------------------------------------------------------------------------
  # Uncomment this and comment out 'frontend' service for hot reload
  # frontend-dev:
  #   image: node:20-alpine
  #   working_dir: /app
  #   command: sh -c "npm install && npm run dev -- --host 0.0.0.0"
  #   ports:
  #     - "5173:5173"
  #   volumes:
  #     - ./frontend:/app
  #     - frontend_node_modules:/app/node_modules
  #   environment:
  #     # Note: VITE_API_BASE_URL should NOT include /api/v1 - that's appended by the code
  #     - VITE_API_BASE_URL=http://localhost:8080
  #     - VITE_WORKERS_BASE_URL=http://localhost:8080/workers
  #     - VITE_TERMINAL_WS_URL=ws://localhost:8080/terminal
  #   networks:
  #     - local-dev

# =============================================================================
# Networks
# =============================================================================
networks:
  local-dev:
    driver: bridge

# =============================================================================
# Volumes
# =============================================================================
volumes:
  workers_d1_data:
    driver: local
  frontend_node_modules:
    driver: local
  # tei-data:
  #   driver: local
  # chroma-data:
  #   driver: local

```

### export-codebase.js

**Path:** `export-codebase.js`

```javascript
#!/usr/bin/env node

/**
 * Export Codebase to Markdown
 * 
 * 전체 프로젝트 코드를 마크다운 파일로 저장하고
 * dolphin 파일 브라우저로 해당 디렉토리를 엽니다.
 */

const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');

// 설정
const CONFIG = {
  outputDir: path.join(__dirname, 'codebase-export'),
  outputFile: 'codebase.md',
  // 제외할 디렉토리
  excludeDirs: [
    'node_modules',
    '.git',
    'dist',
    'build',
    '.next',
    'coverage',
    '.cache',
    '.turbo',
    'codebase-export',
    '__pycache__',
    '.venv',
    'venv',
  ],
  // 제외할 파일 패턴
  excludeFiles: [
    'package-lock.json',
    'pnpm-lock.yaml',
    'yarn.lock',
    '.DS_Store',
    'Thumbs.db',
  ],
  // 포함할 파일 확장자
  includeExtensions: [
    '.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs',
    '.json', '.yaml', '.yml',
    '.md', '.mdx',
    '.css', '.scss', '.less',
    '.html', '.htm',
    '.sql',
    '.sh', '.bash',
    '.py',
    '.go',
    '.env.example',
    '.gitignore',
    '.prettierrc', '.eslintrc',
    'Dockerfile',
    '.toml',
  ],
  // 특별히 포함할 파일명 (확장자 없는 파일 등)
  includeFiles: [
    'Dockerfile',
    'Makefile',
    '.gitignore',
    '.env.example',
    '.env.production.example',
    '.env.test.example',
    'CNAME',
  ],
};

// 언어 매핑 (마크다운 코드블록용)
const LANG_MAP = {
  '.js': 'javascript',
  '.jsx': 'jsx',
  '.ts': 'typescript',
  '.tsx': 'tsx',
  '.mjs': 'javascript',
  '.cjs': 'javascript',
  '.json': 'json',
  '.yaml': 'yaml',
  '.yml': 'yaml',
  '.md': 'markdown',
  '.mdx': 'mdx',
  '.css': 'css',
  '.scss': 'scss',
  '.less': 'less',
  '.html': 'html',
  '.htm': 'html',
  '.sql': 'sql',
  '.sh': 'bash',
  '.bash': 'bash',
  '.py': 'python',
  '.go': 'go',
  '.toml': 'toml',
};

/**
 * 파일이 포함 대상인지 확인
 */
function shouldIncludeFile(filePath) {
  const fileName = path.basename(filePath);
  const ext = path.extname(filePath);

  // 제외 파일 체크
  if (CONFIG.excludeFiles.includes(fileName)) {
    return false;
  }

  // 특별 포함 파일 체크
  if (CONFIG.includeFiles.includes(fileName)) {
    return true;
  }

  // 확장자 체크
  return CONFIG.includeExtensions.includes(ext);
}

/**
 * 디렉토리가 제외 대상인지 확인
 */
function shouldExcludeDir(dirName) {
  return CONFIG.excludeDirs.includes(dirName);
}

/**
 * 파일 확장자에 따른 언어 반환
 */
function getLanguage(filePath) {
  const ext = path.extname(filePath);
  const fileName = path.basename(filePath);

  if (fileName === 'Dockerfile') return 'dockerfile';
  if (fileName === 'Makefile') return 'makefile';
  if (fileName.startsWith('.env')) return 'bash';
  if (fileName === '.gitignore') return 'gitignore';

  return LANG_MAP[ext] || '';
}

/**
 * 재귀적으로 파일 목록 수집
 */
function collectFiles(dir, baseDir = dir) {
  const files = [];

  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      const relativePath = path.relative(baseDir, fullPath);

      if (entry.isDirectory()) {
        if (!shouldExcludeDir(entry.name)) {
          files.push(...collectFiles(fullPath, baseDir));
        }
      } else if (entry.isFile()) {
        if (shouldIncludeFile(fullPath)) {
          files.push({
            fullPath,
            relativePath,
            name: entry.name,
          });
        }
      }
    }
  } catch (err) {
    console.error(`Error reading directory ${dir}:`, err.message);
  }

  return files;
}

/**
 * 파일 내용 읽기
 */
function readFileContent(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    return content;
  } catch (err) {
    return `// Error reading file: ${err.message}`;
  }
}

/**
 * 마크다운 생성
 */
function generateMarkdown(files, projectRoot) {
  const projectName = path.basename(projectRoot);
  const timestamp = new Date().toISOString();

  let markdown = `# ${projectName} - Complete Codebase

> Generated at: ${timestamp}
> Total files: ${files.length}

## Table of Contents

`;

  // 디렉토리별로 그룹화
  const filesByDir = {};
  for (const file of files) {
    const dir = path.dirname(file.relativePath) || '.';
    if (!filesByDir[dir]) {
      filesByDir[dir] = [];
    }
    filesByDir[dir].push(file);
  }

  // 목차 생성
  const sortedDirs = Object.keys(filesByDir).sort();
  for (const dir of sortedDirs) {
    const anchor = dir.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
    markdown += `- [${dir}](#${anchor})\n`;
  }

  markdown += '\n---\n\n';

  // 파일 내용 추가
  for (const dir of sortedDirs) {
    const anchor = dir.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
    markdown += `## ${dir}\n\n`;

    for (const file of filesByDir[dir]) {
      const lang = getLanguage(file.fullPath);
      const content = readFileContent(file.fullPath);

      markdown += `### ${file.name}\n\n`;
      markdown += `**Path:** \`${file.relativePath}\`\n\n`;
      markdown += `\`\`\`${lang}\n${content}\n\`\`\`\n\n`;
    }

    markdown += '---\n\n';
  }

  return markdown;
}

/**
 * Dolphin 파일 브라우저로 디렉토리 열기
 */
function openWithDolphin(dirPath) {
  console.log(`\nOpening directory with Dolphin: ${dirPath}`);

  try {
    // dolphin을 백그라운드로 실행
    const child = spawn('dolphin', [dirPath], {
      detached: true,
      stdio: 'ignore',
    });
    child.unref();
    console.log('Dolphin opened successfully!');
  } catch (err) {
    console.error('Failed to open Dolphin:', err.message);
    console.log('You can manually open the directory at:', dirPath);
  }
}

/**
 * 메인 함수
 */
function main() {
  const projectRoot = __dirname;

  console.log('='.repeat(50));
  console.log('Codebase Export Tool');
  console.log('='.repeat(50));
  console.log(`\nProject root: ${projectRoot}`);

  // 출력 디렉토리 생성
  if (!fs.existsSync(CONFIG.outputDir)) {
    fs.mkdirSync(CONFIG.outputDir, { recursive: true });
  }

  // 파일 수집
  console.log('\nCollecting files...');
  const files = collectFiles(projectRoot);
  console.log(`Found ${files.length} files to export.`);

  // 마크다운 생성
  console.log('\nGenerating markdown...');
  const markdown = generateMarkdown(files, projectRoot);

  // 파일 저장
  const outputPath = path.join(CONFIG.outputDir, CONFIG.outputFile);
  fs.writeFileSync(outputPath, markdown, 'utf-8');
  console.log(`\nMarkdown saved to: ${outputPath}`);

  // 파일 크기 표시
  const stats = fs.statSync(outputPath);
  const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
  console.log(`File size: ${sizeMB} MB`);

  // Dolphin으로 디렉토리 열기
  openWithDolphin(CONFIG.outputDir);

  console.log('\n' + '='.repeat(50));
  console.log('Export completed!');
  console.log('='.repeat(50));
}

// 실행
main();

```

### litellm_config.local.yaml

**Path:** `litellm_config.local.yaml`

```yaml
# =============================================================================
# LiteLLM Proxy Configuration - Local Development
# =============================================================================
#
# Simplified configuration for local development.
# Does NOT require GitHub Copilot/VAS authentication.
#
# Supported providers:
#   - Google Gemini (recommended - free tier available)
#   - OpenAI
#   - Anthropic Claude
#   - Ollama (local LLM)
#
# Usage:
#   curl http://localhost:4000/v1/chat/completions \
#     -H "Authorization: Bearer sk-local-dev-key" \
#     -d '{"model": "gemini-1.5-flash", "messages": [...]}'
#
# =============================================================================

# -----------------------------------------------------------------------------
# Model List
# -----------------------------------------------------------------------------
model_list:

  # ---------------------------------------------------------------------------
  # Google Gemini (Recommended for local dev - free tier available)
  # ---------------------------------------------------------------------------
  - model_name: gemini-1.5-flash
    litellm_params:
      model: gemini/gemini-1.5-flash
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "Google Gemini 1.5 Flash (fast, cheap)"

  - model_name: gemini-1.5-pro
    litellm_params:
      model: gemini/gemini-1.5-pro
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "Google Gemini 1.5 Pro"

  - model_name: gemini-2.0-flash
    litellm_params:
      model: gemini/gemini-2.0-flash-exp
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "Google Gemini 2.0 Flash Experimental"

  # ---------------------------------------------------------------------------
  # OpenAI (Optional)
  # ---------------------------------------------------------------------------
  - model_name: gpt-4o
    litellm_params:
      model: gpt-4o
      api_key: os.environ/OPENAI_API_KEY
    model_info:
      description: "OpenAI GPT-4o"

  - model_name: gpt-4o-mini
    litellm_params:
      model: gpt-4o-mini
      api_key: os.environ/OPENAI_API_KEY
    model_info:
      description: "OpenAI GPT-4o Mini (fast, cheap)"

  - model_name: gpt-4-turbo
    litellm_params:
      model: gpt-4-turbo
      api_key: os.environ/OPENAI_API_KEY
    model_info:
      description: "OpenAI GPT-4 Turbo"

  - model_name: gpt-3.5-turbo
    litellm_params:
      model: gpt-3.5-turbo
      api_key: os.environ/OPENAI_API_KEY
    model_info:
      description: "OpenAI GPT-3.5 Turbo"

  # ---------------------------------------------------------------------------
  # Anthropic Claude (Optional)
  # ---------------------------------------------------------------------------
  - model_name: claude-3.5-sonnet
    litellm_params:
      model: claude-3-5-sonnet-20241022
      api_key: os.environ/ANTHROPIC_API_KEY
    model_info:
      description: "Anthropic Claude 3.5 Sonnet"

  - model_name: claude-3-haiku
    litellm_params:
      model: claude-3-haiku-20240307
      api_key: os.environ/ANTHROPIC_API_KEY
    model_info:
      description: "Anthropic Claude 3 Haiku (fast)"

  # ---------------------------------------------------------------------------
  # Local LLM via Ollama (Optional - for offline development)
  # ---------------------------------------------------------------------------
  # Run: ollama serve (on host machine)
  # Then: ollama pull llama3.2
  - model_name: local
    litellm_params:
      model: ollama/llama3.2
      api_base: http://host.docker.internal:11434
    model_info:
      description: "Local Llama 3.2 via Ollama (default local model)"

  - model_name: local/llama3
    litellm_params:
      model: ollama/llama3.2
      api_base: http://host.docker.internal:11434
    model_info:
      description: "Local Llama 3.2 via Ollama"

  - model_name: local/codellama
    litellm_params:
      model: ollama/codellama
      api_base: http://host.docker.internal:11434
    model_info:
      description: "Local CodeLlama via Ollama"

  # ---------------------------------------------------------------------------
  # Aliases for compatibility with production config
  # ---------------------------------------------------------------------------
  # Map production model names to available local models
  - model_name: gpt-4.1
    litellm_params:
      model: gemini/gemini-1.5-flash
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "Alias: gpt-4.1 → gemini-1.5-flash (local dev)"

# -----------------------------------------------------------------------------
# Router Settings
# -----------------------------------------------------------------------------
router_settings:
  routing_strategy: simple
  num_retries: 2
  timeout: 120
  
  # Fallback configuration
  fallbacks:
    - gpt-4.1: ["gemini-1.5-flash", "gpt-4o-mini"]
    - gpt-4o: ["gemini-1.5-pro", "claude-3.5-sonnet"]
    - gemini-1.5-flash: ["gpt-4o-mini", "claude-3-haiku"]

  allowed_fails: 2
  cooldown_time: 30

# -----------------------------------------------------------------------------
# LiteLLM Settings
# -----------------------------------------------------------------------------
litellm_settings:
  set_verbose: true
  drop_params: true
  request_timeout: 120
  cache: false

# -----------------------------------------------------------------------------
# General Settings
# -----------------------------------------------------------------------------
general_settings:
  # Master key for API authentication and Admin UI access
  # Admin UI: username=admin, password=<LITELLM_MASTER_KEY value>
  master_key: os.environ/LITELLM_MASTER_KEY
  # Disable database for local development
  database_url: null
  store_model_in_db: false
  disable_spend_logs: true

```

### package.json

**Path:** `package.json`

```json
{
  "devDependencies": {
    "@cloudflare/playwright": "^1.0.0"
  },
  "dependencies": {
    "jose": "^6.1.2"
  }
}

```

### postcss.config.js

**Path:** `postcss.config.js`

```javascript
export default {
  plugins: {
    tailwindcss: { config: './config/tailwind.config.js' },
    autoprefixer: {},
  },
};

```

### start-all-local.sh

**Path:** `start-all-local.sh`

```bash
#!/bin/bash
# =============================================================================
# start-all-local.sh - Local Development Environment Startup Script
# =============================================================================
#
# Usage:
#   ./start-all-local.sh              # Docker 모드 (기본) - 모든 서비스 Docker로 실행
#   ./start-all-local.sh --hybrid     # Hybrid 모드 - Frontend/Workers 로컬 프로세스
#   ./start-all-local.sh --stop       # 모든 서비스 종료
#   ./start-all-local.sh --status     # 서비스 상태 확인
#
# =============================================================================

set -e

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$SCRIPT_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Service URLs
GATEWAY_URL="http://localhost:8080"
BACKEND_URL="http://localhost:5080"
LITELLM_URL="http://localhost:4000"
WORKERS_URL="http://localhost:8787"
FRONTEND_URL="http://localhost:5173"

# Timeouts
HEALTH_CHECK_TIMEOUT=120
HEALTH_CHECK_INTERVAL=3

# PID file for hybrid mode
PID_FILE="$PROJECT_ROOT/.local-dev-pids"

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_step() { echo -e "${CYAN}[STEP]${NC} $1"; }

print_banner() {
    echo -e "${CYAN}"
    echo "============================================================================="
    echo "                    Local Development Environment"
    echo "============================================================================="
    echo -e "${NC}"
}

# -----------------------------------------------------------------------------
# Prerequisites Check
# -----------------------------------------------------------------------------
check_prerequisites() {
    log_step "Checking prerequisites..."
    
    local missing=()
    
    # Check Docker
    if ! command -v docker &> /dev/null; then
        missing+=("docker")
    elif ! docker info &> /dev/null; then
        log_error "Docker daemon is not running"
        exit 1
    fi
    
    # Check Docker Compose
    if ! docker compose version &> /dev/null; then
        missing+=("docker-compose")
    fi
    
    # Check Node.js (for hybrid mode)
    if ! command -v node &> /dev/null; then
        log_warn "Node.js not found - hybrid mode will not be available"
    fi
    
    # Check npm
    if ! command -v npm &> /dev/null; then
        log_warn "npm not found - hybrid mode will not be available"
    fi
    
    if [ ${#missing[@]} -gt 0 ]; then
        log_error "Missing required tools: ${missing[*]}"
        echo ""
        echo "Please install the following:"
        for tool in "${missing[@]}"; do
            case $tool in
                docker)
                    echo "  - Docker: https://docs.docker.com/get-docker/"
                    ;;
                docker-compose)
                    echo "  - Docker Compose: https://docs.docker.com/compose/install/"
                    ;;
            esac
        done
        exit 1
    fi
    
    log_success "All prerequisites satisfied"
}

# -----------------------------------------------------------------------------
# Environment Setup (Fully Automated)
# -----------------------------------------------------------------------------
generate_random_key() {
    # Generate a random key for security tokens
    local prefix="${1:-sk}"
    local random_part=$(head -c 32 /dev/urandom 2>/dev/null | base64 2>/dev/null | tr -dc 'a-zA-Z0-9' | head -c 24)
    if [ -z "$random_part" ]; then
        # Fallback if /dev/urandom is not available
        random_part=$(date +%s%N | sha256sum | head -c 24)
    fi
    echo "${prefix}-${random_part}"
}

setup_environment() {
    log_step "Setting up environment files..."
    
    local env_file="$PROJECT_ROOT/.env.local"
    local created_new=false
    
    # Create .env.local if it doesn't exist
    if [ ! -f "$env_file" ]; then
        created_new=true
        log_info "Creating .env.local with auto-generated secure values..."
        
        # Generate secure random keys
        local master_key=$(generate_random_key "sk")
        local origin_secret=$(generate_random_key "secret")
        local jwt_secret=$(generate_random_key "jwt")
        local admin_token=$(generate_random_key "admin")
        
        cat > "$env_file" << EOF
# =============================================================================
# Local Development Environment Variables (Auto-Generated)
# =============================================================================
# Generated at: $(date -Iseconds)
#
# This file was automatically created by start-all-local.sh
# All non-AI services work immediately (posts, comments, terminal, etc.)
#
# 🤖 TO ENABLE AI FEATURES:
#
# Option 1 - Cloud AI (add one of these):
#   GOOGLE_API_KEY=AIza...  (free: https://aistudio.google.com/app/apikey)
#   OPENAI_API_KEY=sk-...   (paid)
#   ANTHROPIC_API_KEY=sk-... (paid)
#
# Option 2 - Local AI with Ollama (free, offline):
#   1. Install: https://ollama.ai
#   2. Run: ollama serve && ollama pull llama3.2
#   3. Change AI_DEFAULT_MODEL below to: local
# =============================================================================

# -----------------------------------------------------------------------------
# LiteLLM Gateway Configuration
# -----------------------------------------------------------------------------
LITELLM_MASTER_KEY=${master_key}

# Default AI model
# Cloud: gemini-1.5-flash, gpt-4o-mini, claude-3-haiku (requires API key)
# Local: local, local/llama3 (requires Ollama)
AI_DEFAULT_MODEL=gemini-1.5-flash

# -----------------------------------------------------------------------------
# AI Provider API Keys (Add at least one for cloud AI)
# -----------------------------------------------------------------------------
# Google Gemini (recommended - free tier available)
GOOGLE_API_KEY=

# OpenAI
OPENAI_API_KEY=

# Anthropic Claude
ANTHROPIC_API_KEY=

# -----------------------------------------------------------------------------
# Terminal Service
# -----------------------------------------------------------------------------
ORIGIN_SECRET_KEY=${origin_secret}
SANDBOX_IMAGE=alpine:latest

# -----------------------------------------------------------------------------
# Admin Configuration
# -----------------------------------------------------------------------------
ADMIN_BEARER_TOKEN=${admin_token}
JWT_SECRET=${jwt_secret}
ADMIN_USERNAME=admin
ADMIN_PASSWORD=admin123
EOF
        
        log_success "Created .env.local with secure auto-generated keys"
    fi
    
    # Determine which AI model to use based on available API keys
    local has_api_key=false
    local detected_provider=""
    
    if grep -qE "^GOOGLE_API_KEY=.+" "$env_file" 2>/dev/null; then
        has_api_key=true
        detected_provider="Google Gemini"
    elif grep -qE "^OPENAI_API_KEY=.+" "$env_file" 2>/dev/null; then
        has_api_key=true
        detected_provider="OpenAI"
    elif grep -qE "^ANTHROPIC_API_KEY=.+" "$env_file" 2>/dev/null; then
        has_api_key=true
        detected_provider="Anthropic"
    fi
    
    # Show status message
    echo ""
    if [ "$has_api_key" = true ]; then
        log_success "AI Provider detected: $detected_provider"
        echo -e "  ${GREEN}✓${NC} Real AI responses will be used"
    else
        log_info "No AI API key configured"
        echo -e "  ${YELLOW}→${NC} AI features require an API key or local Ollama"
        echo ""
        echo -e "  ${CYAN}Option 1: Cloud AI (recommended)${NC}"
        echo -e "     Edit .env.local and add: ${GREEN}GOOGLE_API_KEY=AIza...${NC}"
        echo -e "     Free tier: https://aistudio.google.com/app/apikey"
        echo ""
        echo -e "  ${CYAN}Option 2: Local AI with Ollama (free, offline)${NC}"
        echo -e "     1. Install: https://ollama.ai"
        echo -e "     2. Run: ${GREEN}ollama serve${NC}"
        echo -e "     3. Pull: ${GREEN}ollama pull llama3.2${NC}"
        echo -e "     4. Use model: ${GREEN}local${NC} or ${GREEN}local/llama3${NC}"
        echo ""
        echo -e "  ${YELLOW}Note:${NC} All other features (comments, posts, terminal) work without AI"
        echo ""
    fi
    
    # Show first-run message with generated credentials
    if [ "$created_new" = true ]; then
        echo ""
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${GREEN}  ✅ First-time Setup Complete!${NC}"
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "  ${CYAN}Auto-generated credentials:${NC}"
        echo -e "    LiteLLM Master Key: ${YELLOW}$(grep LITELLM_MASTER_KEY "$env_file" | cut -d= -f2)${NC}"
        echo -e "    Admin Username:     ${YELLOW}admin${NC}"
        echo -e "    Admin Password:     ${YELLOW}admin123${NC}"
        echo ""
        echo -e "  ${CYAN}Configuration file:${NC} $env_file"
        echo ""
    fi
    
    log_success "Environment configured"
}

# -----------------------------------------------------------------------------
# Health Check Functions
# -----------------------------------------------------------------------------
wait_for_service() {
    local name="$1"
    local url="$2"
    local timeout="${3:-$HEALTH_CHECK_TIMEOUT}"
    local elapsed=0
    
    log_info "Waiting for $name to be ready..."
    
    while [ $elapsed -lt $timeout ]; do
        if curl -sf "$url" > /dev/null 2>&1; then
            log_success "$name is ready ($url)"
            return 0
        fi
        sleep $HEALTH_CHECK_INTERVAL
        elapsed=$((elapsed + HEALTH_CHECK_INTERVAL))
        echo -ne "\r  Waiting... ${elapsed}s / ${timeout}s"
    done
    
    echo ""
    log_error "$name failed to start within ${timeout}s"
    return 1
}

check_all_services() {
    log_step "Checking all services..."
    
    local all_ok=true
    
    # Gateway (main entry point)
    if curl -sf "$GATEWAY_URL/health" > /dev/null 2>&1; then
        log_success "Gateway: $GATEWAY_URL"
    else
        log_error "Gateway not responding: $GATEWAY_URL"
        all_ok=false
    fi
    
    # Backend API
    if curl -sf "$BACKEND_URL/api/v1/healthz" > /dev/null 2>&1; then
        log_success "Backend API: $BACKEND_URL"
    else
        log_error "Backend not responding: $BACKEND_URL"
        all_ok=false
    fi
    
    # LiteLLM
    if curl -sf "$LITELLM_URL/health/liveliness" > /dev/null 2>&1; then
        log_success "LiteLLM Gateway: $LITELLM_URL"
    else
        log_error "LiteLLM not responding: $LITELLM_URL"
        all_ok=false
    fi
    
    # Workers
    if curl -sf "$WORKERS_URL" > /dev/null 2>&1; then
        log_success "Workers API: $WORKERS_URL"
    else
        log_warn "Workers not responding: $WORKERS_URL (may be optional)"
    fi
    
    if $all_ok; then
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------------------------------------
# Docker Mode
# -----------------------------------------------------------------------------
start_docker_mode() {
    log_step "Starting all services with Docker Compose..."
    
    cd "$PROJECT_ROOT"
    
    # Build and start
    docker compose -f docker-compose.local.yml up --build -d
    
    echo ""
    log_step "Waiting for services to be ready..."
    
    # Wait for main services
    wait_for_service "LiteLLM" "$LITELLM_URL/health/liveliness" 60 || true
    wait_for_service "Backend" "$BACKEND_URL/api/v1/healthz" 60 || true
    wait_for_service "Gateway" "$GATEWAY_URL/health" 30 || true
    
    echo ""
}

stop_docker_mode() {
    log_step "Stopping Docker services..."
    
    cd "$PROJECT_ROOT"
    docker compose -f docker-compose.local.yml down
    
    log_success "All Docker services stopped"
}

# -----------------------------------------------------------------------------
# Hybrid Mode (Frontend/Workers as local processes)
# -----------------------------------------------------------------------------
start_hybrid_mode() {
    log_step "Starting Hybrid mode..."
    
    # Check Node.js
    if ! command -v node &> /dev/null; then
        log_error "Node.js is required for hybrid mode"
        exit 1
    fi
    
    # Start Docker services (backend, litellm, nginx)
    log_info "Starting Docker services (backend, litellm)..."
    cd "$PROJECT_ROOT"
    docker compose -f docker-compose.local.yml up -d backend litellm nginx
    
    # Wait for backend services
    wait_for_service "LiteLLM" "$LITELLM_URL/health/liveliness" 60
    wait_for_service "Backend" "$BACKEND_URL/api/v1/healthz" 60
    
    # Initialize PID file
    echo "" > "$PID_FILE"
    
    # Start Workers locally
    log_info "Starting Workers locally..."
    cd "$PROJECT_ROOT/workers"
    
    # Install dependencies if needed
    if [ ! -d "node_modules" ]; then
        log_info "Installing Workers dependencies..."
        npm install
    fi
    
    # Build shared package if needed
    if [ ! -d "$PROJECT_ROOT/shared/dist" ]; then
        log_info "Building shared package..."
        cd "$PROJECT_ROOT/shared"
        npm install
        npm run build
        cd "$PROJECT_ROOT/workers"
    fi
    
    # Apply migrations
    log_info "Applying D1 migrations..."
    npx wrangler d1 migrations apply blog-db --local 2>/dev/null || true
    
    # Start wrangler dev in background
    npx wrangler dev --local --persist --ip 0.0.0.0 --port 8787 > /tmp/workers.log 2>&1 &
    echo $! >> "$PID_FILE"
    log_info "Workers started (PID: $!)"
    
    # Start Frontend locally
    log_info "Starting Frontend locally..."
    cd "$PROJECT_ROOT/frontend"
    
    # Install dependencies if needed
    if [ ! -d "node_modules" ]; then
        log_info "Installing Frontend dependencies..."
        npm install
    fi
    
    # Start Vite dev server in background
    # Note: VITE_API_BASE_URL should NOT include /api/v1 - that's appended by the frontend code
    VITE_API_BASE_URL="http://localhost:8080" \
    VITE_WORKERS_BASE_URL="http://localhost:8787" \
    npm run dev > /tmp/frontend.log 2>&1 &
    echo $! >> "$PID_FILE"
    log_info "Frontend started (PID: $!)"
    
    # Wait for local services
    sleep 5
    wait_for_service "Workers" "$WORKERS_URL" 30 || true
    wait_for_service "Frontend" "$FRONTEND_URL" 30 || true
    
    echo ""
}

stop_hybrid_mode() {
    log_step "Stopping Hybrid mode services..."
    
    # Stop local processes
    if [ -f "$PID_FILE" ]; then
        while read -r pid; do
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                log_info "Stopping process $pid..."
                kill "$pid" 2>/dev/null || true
            fi
        done < "$PID_FILE"
        rm -f "$PID_FILE"
    fi
    
    # Stop Docker services
    cd "$PROJECT_ROOT"
    docker compose -f docker-compose.local.yml down
    
    log_success "All services stopped"
}

# -----------------------------------------------------------------------------
# Cleanup Handler
# -----------------------------------------------------------------------------
cleanup() {
    echo ""
    log_warn "Shutting down..."
    
    if [ -f "$PID_FILE" ]; then
        stop_hybrid_mode
    else
        stop_docker_mode
    fi
    
    exit 0
}

# -----------------------------------------------------------------------------
# Print Status
# -----------------------------------------------------------------------------
print_status() {
    print_banner
    
    echo -e "${CYAN}Service Status:${NC}"
    echo ""
    
    # Docker containers
    echo "Docker Containers:"
    docker compose -f "$PROJECT_ROOT/docker-compose.local.yml" ps 2>/dev/null || echo "  No containers running"
    echo ""
    
    # Health checks
    check_all_services
    
    echo ""
    echo -e "${CYAN}Access Points:${NC}"
    echo "  Main UI:        $GATEWAY_URL"
    echo "  Backend API:    $GATEWAY_URL/api/v1/"
    echo "  LiteLLM API:    $GATEWAY_URL/ai/v1/"
    echo "  Workers API:    $GATEWAY_URL/workers/"
    echo ""
    echo "  Direct Backend: $BACKEND_URL"
    echo "  Direct LiteLLM: $LITELLM_URL"
    echo "  Direct Workers: $WORKERS_URL"
}

# -----------------------------------------------------------------------------
# Print Final Instructions
# -----------------------------------------------------------------------------
print_litellm_credentials() {
    # Credentials are now shown in setup_environment() on first run
    # This function is kept for backward compatibility but does nothing
    :
}

print_instructions() {
    # Show LiteLLM credentials on first run
    print_litellm_credentials
    
    echo ""
    echo -e "${GREEN}=============================================================================${NC}"
    echo -e "${GREEN}                    All Services Started Successfully!${NC}"
    echo -e "${GREEN}=============================================================================${NC}"
    echo ""
    echo -e "${CYAN}Access Points:${NC}"
    echo "  🌐 Main UI:        $GATEWAY_URL"
    echo "  📡 Backend API:    $GATEWAY_URL/api/v1/"
    echo "  🤖 LiteLLM API:    $GATEWAY_URL/ai/v1/"
    echo "  ⚡ Workers API:    $GATEWAY_URL/workers/"
    echo ""
    echo -e "${CYAN}Direct Access (debugging):${NC}"
    echo "  Backend:  $BACKEND_URL"
    echo "  LiteLLM:  $LITELLM_URL"
    echo "  Workers:  $WORKERS_URL"
    if [ "$MODE" = "hybrid" ]; then
        echo "  Frontend: $FRONTEND_URL (Vite HMR)"
    fi
    echo ""
    echo -e "${CYAN}Useful Commands:${NC}"
    echo "  View logs:    docker compose -f docker-compose.local.yml logs -f"
    echo "  Stop all:     ./start-all-local.sh --stop"
    echo "  Status:       ./start-all-local.sh --status"
    echo ""
    echo -e "${YELLOW}Press Ctrl+C to stop all services${NC}"
    echo ""
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
main() {
    local MODE="docker"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --hybrid|-h)
                MODE="hybrid"
                shift
                ;;
            --stop|-s)
                stop_docker_mode
                exit 0
                ;;
            --status)
                print_status
                exit 0
                ;;
            --help)
                echo "Usage: $0 [OPTIONS]"
                echo ""
                echo "Options:"
                echo "  --hybrid, -h    Start in hybrid mode (Frontend/Workers as local processes)"
                echo "  --stop, -s      Stop all services"
                echo "  --status        Show service status"
                echo "  --help          Show this help message"
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    # Print banner
    print_banner
    
    # Setup trap for cleanup
    trap cleanup SIGINT SIGTERM
    
    # Run checks and setup
    check_prerequisites
    setup_environment
    
    # Start services based on mode
    if [ "$MODE" = "hybrid" ]; then
        start_hybrid_mode
    else
        start_docker_mode
    fi
    
    # Final health check
    echo ""
    if check_all_services; then
        print_instructions
        
        # Keep script running (for Ctrl+C handling)
        if [ "$MODE" = "docker" ]; then
            # Follow docker logs
            docker compose -f "$PROJECT_ROOT/docker-compose.local.yml" logs -f
        else
            # Wait for interrupt
            while true; do
                sleep 1
            done
        fi
    else
        log_error "Some services failed to start. Check logs with:"
        echo "  docker compose -f docker-compose.local.yml logs"
        exit 1
    fi
}

# Run main
main "$@"

```

---

## .github

### GITHUB_SECRETS_SETUP.md

**Path:** `.github/GITHUB_SECRETS_SETUP.md`

```markdown
# GitHub Secrets 설정 가이드

GitHub Actions 배포를 위한 Secret 설정 방법입니다.

## 목차
- [Part 1: Cloudflare Workers 배포](#part-1-cloudflare-workers-배포)
- [Part 2: Backend 서버 배포 (SSH)](#part-2-backend-서버-배포-ssh)

---

# Part 1: Cloudflare Workers 배포

## 필요한 Secrets

다음 5개의 Secret을 설정해야 합니다:
1. `CLOUDFLARE_ACCOUNT_ID` - Cloudflare 계정 ID
2. `CLOUDFLARE_API_TOKEN` - Cloudflare API 토큰
3. `GEMINI_API_KEY` - Google Gemini API 키
4. `JWT_SECRET` - JWT 서명용 비밀 키
5. `VITE_API_BASE_URL` - 프론트엔드가 사용할 백엔드 API 기본 URL (프로덕션 권장)

---

## 1. CLOUDFLARE_ACCOUNT_ID 설정

### 계정 ID 확인 방법
1. https://dash.cloudflare.com 로그인
2. 오른쪽 사이드바에서 **Account ID** 확인
3. 또는 `wrangler.toml`에서 확인:
   ```toml
   account_id = "f6f11e2a4e5178d2f37476785018f761"
   ```

### GitHub Secret 설정
1. GitHub Repository → **Settings** → **Secrets and variables** → **Actions**
2. **New repository secret** 클릭
3. Name: `CLOUDFLARE_ACCOUNT_ID`
4. Value: 계정 ID 입력 (예: `f6f11e2a4e5178d2f37476785018f761`)
5. **Add secret** 클릭

---

## 2. CLOUDFLARE_API_TOKEN 설정

### API Token 생성
1. https://dash.cloudflare.com/profile/api-tokens 방문
2. **Create Token** 클릭
3. **Edit Cloudflare Workers** 템플릿 선택
4. 또는 **Custom token**으로 다음 권한 설정:
   - **Account**: 
     - D1: Edit
     - Workers Scripts: Edit
   - **Zone**: 
     - Workers Routes: Edit (선택사항)

5. **Continue to summary** → **Create Token**
6. 생성된 토큰 복사 (다시 볼 수 없으니 주의!)

### 필수 권한 확인
생성한 API Token이 다음 권한을 포함해야 합니다:
- ✅ Account - D1: Edit
- ✅ Account - Workers Scripts: Edit
- ✅ Account - Account Settings: Read

### GitHub Secret 설정
1. GitHub Repository → **Settings** → **Secrets and variables** → **Actions**
2. **New repository secret** 클릭
3. Name: `CLOUDFLARE_API_TOKEN`
4. Value: 생성한 API Token 붙여넣기
5. **Add secret** 클릭

---

## 3. GEMINI_API_KEY 설정

### API Key 발급
1. https://aistudio.google.com/app/apikey 방문
2. **Create API Key** 클릭
3. 키 복사 (AIza로 시작하는 문자열)

### GitHub Secret 설정
1. GitHub Repository → **Settings** → **Secrets and variables** → **Actions**
2. **New repository secret** 클릭
3. Name: `GEMINI_API_KEY`
4. Value: 발급받은 API Key
5. **Add secret** 클릭

---

## 4. JWT_SECRET 설정

### Secret 생성
로컬에서 안전한 랜덤 문자열 생성:
```bash
openssl rand -base64 32
```

출력 예시:
```
DtRlOC1noMuWlWTZw2e3Ob58zx1j7av5vJuv0RPz3GY=
```

### GitHub Secret 설정
1. GitHub Repository → **Settings** → **Secrets and variables** → **Actions**
2. **New repository secret** 클릭
3. Name: `JWT_SECRET`
4. Value: 생성한 랜덤 문자열
5. **Add secret** 클릭

---

## ✅ 설정 확인

### 모든 Secret이 설정되었는지 확인
GitHub Repository → **Settings** → **Secrets and variables** → **Actions**에서:
- [x] CLOUDFLARE_ACCOUNT_ID
- [x] CLOUDFLARE_API_TOKEN
- [x] GEMINI_API_KEY
- [x] JWT_SECRET
- [x] VITE_API_BASE_URL

### 로컬 테스트
로컬에서 API Token이 올바른지 테스트:
```bash
cd workers
export CLOUDFLARE_API_TOKEN="your-api-token"
export CLOUDFLARE_ACCOUNT_ID="your-account-id"
npx wrangler whoami
```

성공 응답 예시:
```
Getting User settings...
👋 You are logged in with an API Token, associated with the email '***@example.com'!
```

---

## 🚨 트러블슈팅

### 7403 에러: "account is not authorized"
**원인**: API Token 권한 부족 또는 Account ID 불일치

**해결**:
1. Cloudflare Dashboard에서 Account ID 재확인
2. API Token에 D1 Edit 권한이 있는지 확인
3. 필요시 Token 재생성하여 다시 설정

### Secret이 반영되지 않음
**해결**: Secret 변경 후 새 workflow를 트리거해야 합니다
```bash
git commit --allow-empty -m "chore: trigger workflow"
git push
```

### API Token 테스트 실패
**해결**: Token이 만료되었거나 권한이 부족한 경우 재발급
1. https://dash.cloudflare.com/profile/api-tokens
2. 기존 Token 삭제
3. 새 Token 생성
4. GitHub Secret 업데이트

### 프론트엔드가 잘못된 API로 호출함
**원인**: `VITE_API_BASE_URL` Secret 미설정으로 기본값(`blog-api.immuddelo.workers.dev`) 사용

**해결**:
- Repository Secret에 `VITE_API_BASE_URL` 추가 (예: `https://blog-api-prod.immuddelo.workers.dev`)
- 또는 사용자 정의 도메인을 사용 중이면 해당 URL로 설정

---

## 📚 참고 문서

- [Cloudflare API Tokens](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/)
- [Wrangler Authentication](https://developers.cloudflare.com/workers/wrangler/ci-cd/)
- [GitHub Actions Secrets](https://docs.github.com/en/actions/security-guides/encrypted-secrets)

---

# Part 2: Backend 서버 배포 (SSH)

Backend API + VAS (Virtual Agent Service) 스택을 원격 서버에 배포합니다.

## 아키텍처

```
GitHub Actions (ubuntu-latest)
       │
       │ SSH (port 11223)
       ▼
┌─────────────────────────────────────────────────────────┐
│  Remote Server (Fedora 43)                              │
│  suhak.nodove.com                                       │
│                                                         │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
│  │ cloudflared │───▶│    nginx    │───▶│     api     │ │
│  │  (tunnel)   │    │  (reverse)  │    │  (Node.js)  │ │
│  └─────────────┘    └─────────────┘    └──────┬──────┘ │
│                                               │        │
│                                               ▼        │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
│  │  vas-admin  │───▶│  vas-proxy  │───▶│  vas-core   │ │
│  │ (token UI)  │    │ (/auto-chat)│    │ (OpenCode)  │ │
│  └─────────────┘    └─────────────┘    └─────────────┘ │
│                                                         │
│  + embedding-server, chromadb, terminal-server          │
└─────────────────────────────────────────────────────────┘
```

## 필요한 Secrets

### SSH 접속 정보

| Secret | 값 | 설명 |
|--------|-----|------|
| `SSH_HOST` | `suhak.nodove.com` | 원격 서버 호스트 |
| `SSH_PORT` | `11223` | SSH 포트 |
| `SSH_USER` | `nodove` | SSH 사용자명 |
| `SSH_PRIVATE_KEY` | (아래 참조) | SSH 개인키 전체 내용 |
| `REMOTE_DIR` | `/home/nodove/blog-backend` | 배포 디렉토리 |
| `PUBLIC_API_BASE_URL` | `https://api.nodove.com` | 공개 API URL |
| `BACKEND_ENV_FILE` | (아래 참조) | .env 파일 전체 내용 |

---

## 1. SSH_PRIVATE_KEY 설정

### 개인키 내용 확인
```bash
cat ~/.ssh/pmx.ed25519
```

출력 예시:
```
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAA...
...
-----END OPENSSH PRIVATE KEY-----
```

### GitHub Secret 설정
1. GitHub Repository → **Settings** → **Secrets and variables** → **Actions**
2. **New repository secret** 클릭
3. Name: `SSH_PRIVATE_KEY`
4. Value: 개인키 전체 내용 붙여넣기 (BEGIN/END 포함)
5. **Add secret** 클릭

---

## 2. SSH 접속 정보 설정

| Secret Name | Value |
|-------------|-------|
| `SSH_HOST` | `suhak.nodove.com` |
| `SSH_PORT` | `11223` |
| `SSH_USER` | `nodove` |
| `REMOTE_DIR` | `/home/nodove/blog-backend` |
| `PUBLIC_API_BASE_URL` | `https://api.nodove.com` |

각각 동일한 방법으로 추가합니다.

---

## 3. BACKEND_ENV_FILE 설정

`.env` 파일 전체 내용을 Secret으로 저장합니다.

### 필수 환경변수 템플릿

```env
# ===================================
# 기본 서버 설정
# ===================================
APP_ENV=production
HOST=0.0.0.0
PORT=5080
LOG_LEVEL=info

# ===================================
# Cloudflare Tunnel (필수)
# ===================================
# Zero Trust Dashboard에서 터널 생성 후 토큰 복사
# https://one.dash.cloudflare.com/ → Access → Tunnels
CLOUDFLARE_TUNNEL_TOKEN=eyJhIjoiZjZmMTF...

# ===================================
# CORS 설정
# ===================================
ALLOWED_ORIGINS=https://noblog.nodove.com,https://blog.nodove.com,http://localhost:5173

# ===================================
# VAS (Virtual Agent Service) 설정
# ===================================
# Admin JWT Secret (랜덤 생성: openssl rand -base64 32)
ADMIN_JWT_SECRET=your-secure-random-secret-here

# Admin 계정 (자동 생성용)
ADMIN_EMAIL=admin@nodove.com
ADMIN_PASSWORD=your-admin-password

# ===================================
# Terminal Server 설정
# ===================================
ORIGIN_SECRET_KEY=your-origin-secret-key
SANDBOX_IMAGE=alpine:latest

# ===================================
# GitHub 설정 (Admin PR 생성용)
# ===================================
GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
GITHUB_REPO_OWNER=choisimo
GITHUB_REPO_NAME=blog
GIT_USER_NAME=CI Bot
GIT_USER_EMAIL=ci@nodove.com

# ===================================
# Admin 보호 설정
# ===================================
ADMIN_BEARER_TOKEN=your_secure_random_token_here

# ===================================
# AI 기능 설정 (선택사항 - VAS 사용시 불필요)
# ===================================
# Gemini API (VAS로 대체됨, 백업용)
GEMINI_API_KEY=
GEMINI_MODEL=gemini-1.5-flash

# ===================================
# Firebase 설정 (댓글 기능)
# ===================================
FIREBASE_PROJECT_ID=your-project-id
FIREBASE_SERVICE_ACCOUNT_JSON={"type":"service_account",...}
```

### GitHub Secret 설정
1. 위 템플릿을 복사하여 실제 값으로 채우기
2. GitHub Repository → **Settings** → **Secrets and variables** → **Actions**
3. **New repository secret** 클릭
4. Name: `BACKEND_ENV_FILE`
5. Value: 완성된 .env 내용 전체 붙여넣기
6. **Add secret** 클릭

---

## 4. Cloudflare Tunnel 토큰 발급

### 터널 생성 방법
1. https://one.dash.cloudflare.com/ 로그인
2. **Access** → **Tunnels** → **Create a tunnel**
3. Tunnel name: `blog-backend` (또는 원하는 이름)
4. **Save tunnel**
5. 토큰 복사 (eyJ...로 시작하는 긴 문자열)

### Public Hostname 설정
터널 설정에서 다음 hostname을 추가:

| Public hostname | Service |
|-----------------|---------|
| `api.nodove.com` | `http://nginx:80` |
| `ai-serve.nodove.com` | `http://vas-core:7012` (선택사항) |

---

## ✅ Backend Secrets 체크리스트

GitHub Repository → **Settings** → **Secrets and variables** → **Actions**에서:

- [ ] `SSH_HOST` = `suhak.nodove.com`
- [ ] `SSH_PORT` = `11223`
- [ ] `SSH_USER` = `nodove`
- [ ] `SSH_PRIVATE_KEY` = (개인키 전체 내용)
- [ ] `REMOTE_DIR` = `/home/nodove/blog-backend`
- [ ] `PUBLIC_API_BASE_URL` = `https://api.nodove.com`
- [ ] `BACKEND_ENV_FILE` = (.env 전체 내용)

---

## 🚀 첫 배포 후 추가 작업

### GitHub Copilot 인증 (VAS 사용시 필수)

배포 완료 후, 원격 서버에서 GitHub Copilot 인증을 해야 합니다:

```bash
ssh -p 11223 nodove@suhak.nodove.com
cd ~/blog-backend
docker compose -f compose.runtime.yml exec vas-core opencode auth login
```

브라우저에서 GitHub 인증 후 터미널에서 완료됩니다.

### 인증 확인
```bash
docker compose -f compose.runtime.yml exec vas-core opencode auth status
```

---

## 🚨 Backend 트러블슈팅

### SSH 연결 실패
**원인**: SSH 키 또는 호스트 설정 오류

**확인**:
```bash
# 로컬에서 테스트
ssh -p 11223 -i ~/.ssh/pmx.ed25519 nodove@suhak.nodove.com "hostname"
```

### VAS Proxy 헬스체크 실패
**원인**: GitHub Copilot 인증 미완료

**해결**: 위의 "GitHub Copilot 인증" 섹션 참조

### Cloudflare Tunnel 연결 안됨
**원인**: 토큰 오류 또는 터널 설정 문제

**확인**:
```bash
ssh -p 11223 nodove@suhak.nodove.com
cd ~/blog-backend
docker compose -f compose.runtime.yml logs cloudflared
```

### 배포 디렉토리 권한 오류
**해결**:
```bash
ssh -p 11223 nodove@suhak.nodove.com "mkdir -p ~/blog-backend && chmod 755 ~/blog-backend"
```

---

## 📚 참고 문서

- [Cloudflare Tunnels](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/)
- [Docker Compose](https://docs.docker.com/compose/)
- [GitHub Actions SSH Deploy](https://github.com/webfactory/ssh-agent)

```

### SECURITY.md

**Path:** `.github/SECURITY.md`

```markdown
# Security Policy

## 🔐 Sensitive Information

This repository follows strict security practices:

### ✅ Safe to Commit
- `wrangler.toml` - Contains only resource IDs (D1, KV, R2)
- `.dev.vars.example` - Template files with placeholder values
- Source code with environment variable references

### ❌ NEVER Commit
- `.env` - Environment variables
- `.dev.vars` - Actual development secrets
- `wrangler-account.json` - Cloudflare account information
- Service account JSON files
- API keys, tokens, passwords
- Private keys or certificates

### 🛡️ Secret Management

**Development Secrets** (Local):
- Store in `.dev.vars` (gitignored)
- Never commit actual values

**Production Secrets** (Cloudflare):
- Set via `wrangler secret put` CLI
- Or use GitHub Actions secrets for CI/CD

**GitHub Actions Secrets**:
- `CLOUDFLARE_ACCOUNT_ID`
- `CLOUDFLARE_API_TOKEN`
- `VITE_API_BASE_URL`

### 🚨 If Secrets Are Exposed

1. **Immediately rotate all exposed credentials**
   ```bash
   # Rotate Cloudflare API token
   wrangler secret put JWT_SECRET --env production
   wrangler secret put ADMIN_PASSWORD --env production
   ```

2. **Remove from Git history**
   ```bash
   git filter-branch --force --index-filter \
     "git rm --cached --ignore-unmatch PATH_TO_FILE" \
     --prune-empty --tag-name-filter cat -- --all
   ```

3. **Force push (⚠️ destructive)**
   ```bash
   git push origin --force --all
   ```

4. **Notify team and audit access logs**

## 📋 Security Checklist

Before every commit:
- [ ] No `.env` or `.dev.vars` files
- [ ] No API keys or passwords in code
- [ ] All secrets use environment variables
- [ ] `.gitignore` properly configured
- [ ] Run `git diff --cached` to review changes

## 🔍 Automated Checks

Pre-commit hook checks for:
- Common secret patterns
- Environment files
- Service account files

## 📞 Reporting Security Issues

If you discover a security vulnerability:
1. **DO NOT** open a public issue
2. Email: [security contact]
3. Include detailed description and steps to reproduce

## 🔄 Regular Security Maintenance

- [ ] Rotate secrets every 90 days
- [ ] Review access logs monthly
- [ ] Update dependencies regularly
- [ ] Audit `.gitignore` quarterly

```

---

## .github/workflows

### backend-deploy.yml

**Path:** `.github/workflows/backend-deploy.yml`

```yaml
name: Backend Build & Deploy (SSH Compose)

# =============================================================================
# Full Stack Deployment with LiteLLM AI Gateway
# =============================================================================
# Architecture:
#   cloudflared -> nginx -> api -> litellm-proxy -> LLM APIs
#
# Services deployed:
#   - api: Node.js backend (built from Dockerfile)
#   - nginx: Reverse proxy
#   - cloudflared: Cloudflare Tunnel
#   - litellm: AI Gateway for multiple LLM providers
#   - embedding-server: TEI for RAG
#   - chromadb: Vector database
#   - terminal-server: Docker PTY server
#
# Required secrets:
#   - SSH_HOST, SSH_USER, SSH_PRIVATE_KEY, SSH_PORT (optional)
#   - REMOTE_DIR: Remote deployment directory
#   - BACKEND_ENV_FILE: Full .env file contents
#   - PUBLIC_API_BASE_URL: Public API URL for health checks
# =============================================================================

on:
  push:
    paths:
      - 'backend/**'
      - '.github/workflows/backend-deploy.yml'
    branches: [ main ]
  workflow_dispatch:
    inputs:
      ref:
        description: 'Ref (branch/sha) to deploy'
        required: false
        default: ''
      skip_build:
        description: 'Skip build, only pull and restart (for config changes)'
        required: false
        default: false
        type: boolean

permissions:
  contents: read

concurrency:
  group: backend-deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      IMAGE_NAME: blog-backend
      IMAGE_TAG: ${{ github.sha }}
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
      REMOTE_DIR: ${{ secrets.REMOTE_DIR }}
      PUBLIC_API_BASE_URL: ${{ secrets.PUBLIC_API_BASE_URL }}
      PUBLIC_FRONTEND_ORIGIN: https://noblog.nodove.com

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.ref || github.ref }}

      - name: Set up Docker Buildx
        if: ${{ github.event.inputs.skip_build != 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Build backend API image (local load)
        if: ${{ github.event.inputs.skip_build != 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Build Terminal Server image
        if: ${{ github.event.inputs.skip_build != 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: ./backend/terminal-server
          file: ./backend/terminal-server/Dockerfile
          push: false
          load: true
          tags: terminal-server:${{ env.IMAGE_TAG }}

      - name: Save images artifact (gzip)
        if: ${{ github.event.inputs.skip_build != 'true' }}
        run: |
          docker save \
            "${IMAGE_NAME}:${IMAGE_TAG}" \
            "terminal-server:${IMAGE_TAG}" \
            | gzip > backend-images.tar.gz
          ls -lh backend-images.tar.gz

      - name: Start ssh-agent and add key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add remote host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p "${SSH_PORT}" -H "${SSH_HOST}" >> ~/.ssh/known_hosts

      - name: Prepare .env from secret
        run: |
          if [ -z "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "BACKEND_ENV_FILE secret is missing." >&2; exit 1;
          fi
          printf "%s" "${{ secrets.BACKEND_ENV_FILE }}" > /tmp/backend.env
          # Append additional secrets that are stored separately
          echo "" >> /tmp/backend.env
          echo "CLOUDFLARE_TUNNEL_TOKEN=${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}" >> /tmp/backend.env

      - name: Upload artifacts to remote
        run: |
          test -n "${REMOTE_DIR}" || { echo "REMOTE_DIR secret is missing" >&2; exit 1; }
          ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "mkdir -p ${REMOTE_DIR}"

          # Upload images (if built)
          if [ -f backend-images.tar.gz ]; then
            scp -P "${SSH_PORT}" backend-images.tar.gz "${SSH_USER}@${SSH_HOST}:${REMOTE_DIR}/"
          fi

          # Upload config files
          scp -P "${SSH_PORT}" backend/nginx.conf "${SSH_USER}@${SSH_HOST}:${REMOTE_DIR}/nginx.conf"
          scp -P "${SSH_PORT}" /tmp/backend.env "${SSH_USER}@${SSH_HOST}:${REMOTE_DIR}/.env"

          # Upload LiteLLM config if exists
          if [ -f backend/litellm_config.yaml ]; then
            scp -P "${SSH_PORT}" backend/litellm_config.yaml "${SSH_USER}@${SSH_HOST}:${REMOTE_DIR}/litellm_config.yaml"
          fi

      - name: Deploy full stack on remote
        env:
          SHA: ${{ github.sha }}
          SKIP_BUILD: ${{ github.event.inputs.skip_build }}
        run: |
          ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "REMOTE_DIR='${REMOTE_DIR}' SHA='${SHA}' bash -s" <<'REMOTE_EOF'
          set -euo pipefail
          DC="docker compose"
          if ! $DC version >/dev/null 2>&1; then DC="docker-compose"; fi
          cd "${REMOTE_DIR}"
          IMAGE_TAG="${SHA}"
          IMAGE_NAME="blog-backend"

          # Load images if present
          if [ -f backend-images.tar.gz ]; then
            echo "Loading images on remote..."
            gzip -dc backend-images.tar.gz | docker load
            rm -f backend-images.tar.gz
          fi

          # Generate runtime compose file with LiteLLM architecture
          cat > compose.runtime.yml <<'YML'
          # =======================================================================
          # Runtime Compose - LiteLLM AI Gateway Architecture
          # =======================================================================
          # Cloudflare Tunnel → nginx:80 → Internal Services
          #
          # Routes:
          #   /api/*       → api:5080
          #   /litellm/*   → litellm:4000
          #   /terminal/*  → terminal-server:8080
          # =======================================================================

          services:
            # Cloudflare Tunnel (connects to nginx only)
            cloudflared:
              image: cloudflare/cloudflared:latest
              command: tunnel --no-autoupdate run
              environment:
                - TUNNEL_TOKEN=${CLOUDFLARE_TUNNEL_TOKEN}
              depends_on:
                nginx:
                  condition: service_started
              networks:
                - backend
              restart: unless-stopped

            # Nginx Reverse Proxy (Single Entry Point)
            nginx:
              image: nginx:alpine
              depends_on:
                api:
                  condition: service_started
              ports:
                - "127.0.0.1:8080:80"
              expose:
                - "80"
              volumes:
                - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
              networks:
                - backend
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "wget", "-q", "--spider", "http://localhost/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 10s

            # Backend API Server
            api:
              image: blog-backend:IMAGE_TAG_PLACEHOLDER
              env_file: .env
              environment:
                - APP_ENV=production
                - HOST=0.0.0.0
                - PORT=5080
                - LITELLM_BASE_URL=http://litellm:4000
                - AI_PROVIDER=litellm
              expose:
                - "5080"
              networks:
                - backend
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "wget", "-q", "--spider", "http://localhost:5080/api/v1/healthz"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 60s

            # LiteLLM AI Gateway
            litellm:
              image: ghcr.io/berriai/litellm:main-latest
              env_file: .env
              environment:
                - LITELLM_MASTER_KEY=${LITELLM_MASTER_KEY:-sk-1234}
                - LITELLM_LOG_LEVEL=INFO
                # Disable database features - we use D1 for usage tracking
                - DISABLE_SPEND_LOGS=true
                - DATABASE_URL=
              expose:
                - "4000"
              volumes:
                - ./litellm_config.yaml:/app/config.yaml:ro
              command: ["--config", "/app/config.yaml", "--port", "4000"]
              networks:
                - backend
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "wget", "-q", "--spider", "http://localhost:4000/health"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 30s

            # TEI Embedding Server
            embedding-server:
              image: ghcr.io/huggingface/text-embeddings-inference:cpu-1.2.3
              command: --model-id sentence-transformers/all-MiniLM-L6-v2
              ports:
                - "127.0.0.1:8180:80"
              volumes:
                - tei-data:/data
              networks:
                - backend
              restart: unless-stopped

            # ChromaDB
            chromadb:
              image: chromadb/chroma:0.5.23
              environment:
                - IS_PERSISTENT=TRUE
                - PERSIST_DIRECTORY=/chroma/chroma
                - ANONYMIZED_TELEMETRY=FALSE
              ports:
                - "127.0.0.1:8100:8000"
              volumes:
                - chroma-data:/chroma/chroma
              networks:
                - backend
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "wget", "-q", "--spider", "http://localhost:8000/api/v1/heartbeat"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 60s

            # Terminal Server
            terminal-server:
              image: terminal-server:IMAGE_TAG_PLACEHOLDER
              environment:
                - ORIGIN_SECRET_KEY=${ORIGIN_SECRET_KEY:-default-secret-change-me}
                - SANDBOX_IMAGE=${SANDBOX_IMAGE:-alpine:latest}
              expose:
                - "8080"
              volumes:
                - /var/run/docker.sock:/var/run/docker.sock:ro
              networks:
                - backend
              restart: unless-stopped

          networks:
            backend:
              driver: bridge

          volumes:
            tei-data:
            chroma-data:
          YML

          # Replace image tag placeholder
          sed -i "s/IMAGE_TAG_PLACEHOLDER/${IMAGE_TAG}/g" compose.runtime.yml

          echo "Bringing up full stack..."
          $DC -f compose.runtime.yml up -d --remove-orphans

          # Force nginx to reload upstream DNS after API container is recreated
          echo "Reloading nginx to refresh upstream DNS..."
          sleep 5
          $DC -f compose.runtime.yml exec -T nginx nginx -s reload 2>/dev/null || \
            $DC -f compose.runtime.yml restart nginx

          # Wait for services via nginx (port 8080 on host)
          echo "Waiting for nginx to be ready..."
          for i in $(seq 1 30); do
            if curl -fsS http://localhost:8080/health >/dev/null 2>&1; then
              echo "nginx Health OK"
              break
            fi
            echo "nginx Retry $i/30"; sleep 2;
          done

          echo "Waiting for API health check via nginx..."
          for i in $(seq 1 60); do
            if curl -fsS http://localhost:8080/api/v1/healthz >/dev/null 2>&1; then
              echo "API Health OK"
              break
            fi
            echo "API Retry $i/60"; sleep 2;
          done

          echo "Waiting for LiteLLM health check..."
          for i in $(seq 1 30); do
            if curl -fsS http://localhost:8080/litellm/health >/dev/null 2>&1; then
              echo "LiteLLM Health OK"
              break
            fi
            echo "LiteLLM Retry $i/30"; sleep 2;
          done

          # Final status
          echo ""
          echo "=== Service Status ==="
          $DC -f compose.runtime.yml ps

          # Verify critical services are running via nginx
          if ! curl -fsS http://localhost:8080/api/v1/healthz >/dev/null 2>&1; then
            echo "FATAL: API health check failed"
            echo "--- nginx logs ---"
            $DC -f compose.runtime.yml logs --no-color nginx | tail -n 30
            echo "--- api logs ---"
            $DC -f compose.runtime.yml logs --no-color api | tail -n 100
            exit 1
          fi

          echo ""
          echo "Deployment successful!"
          REMOTE_EOF

      - name: External health check (public domain)
        if: ${{ env.PUBLIC_API_BASE_URL != '' }}
        continue-on-error: true
        run: |
          echo "Checking public health at ${PUBLIC_API_BASE_URL}/api/v1/healthz ..."
          for i in $(seq 1 30); do
            if curl -fsS "${PUBLIC_API_BASE_URL}/api/v1/healthz" >/dev/null; then
              echo "Public health OK"; exit 0;
            fi
            echo "Retry $i/30"; sleep 2;
          done
          echo "⚠️ Public health check failed at ${PUBLIC_API_BASE_URL}/api/v1/healthz"
          echo "This may indicate Cloudflare tunnel or firewall issues."
          exit 1

      - name: Verify public runtime config
        if: ${{ env.PUBLIC_API_BASE_URL != '' }}
        continue-on-error: true
        run: |
          echo "Fetching ${PUBLIC_API_BASE_URL}/api/v1/public/config"
          cfg=$(curl -fsS "${PUBLIC_API_BASE_URL}/api/v1/public/config")
          echo "$cfg"
          echo "$cfg" | grep -q '"ok":\s*true' || { echo 'Config ok=false' >&2; exit 1; }
          echo "$cfg" | grep -q "\"apiBaseUrl\":\s*\"${PUBLIC_API_BASE_URL}\"" || { echo 'apiBaseUrl mismatch' >&2; exit 1; }

      - name: Check CORS header for frontend origin
        if: ${{ env.PUBLIC_API_BASE_URL != '' }}
        continue-on-error: true
        run: |
          echo "Checking CORS for origin ${PUBLIC_FRONTEND_ORIGIN}"
          headers=$(curl -fsS -D - -o /dev/null -H "Origin: ${PUBLIC_FRONTEND_ORIGIN}" "${PUBLIC_API_BASE_URL}/api/v1/healthz")
          echo "$headers"
          printf "%s" "$headers" | awk 'tolower($0) ~ /^access-control-allow-origin:/ {print}' | grep -q "${PUBLIC_FRONTEND_ORIGIN}" || {
            echo "CORS header missing or mismatched for origin ${PUBLIC_FRONTEND_ORIGIN}" >&2; exit 1; }

      - name: Verify AI Gateway via public endpoint
        if: ${{ env.PUBLIC_API_BASE_URL != '' }}
        continue-on-error: true
        run: |
          echo "Checking AI Gateway integration via ${PUBLIC_API_BASE_URL}/api/v1/ai/health ..."
          response=$(curl -fsS "${PUBLIC_API_BASE_URL}/api/v1/ai/health" 2>&1 || echo '{"error":"endpoint not found"}')
          echo "$response"
          echo "AI Gateway public check completed (check logs above for status)"

```

### deploy-ai-check-gateway.yml

**Path:** `.github/workflows/deploy-ai-check-gateway.yml`

```yaml
name: Deploy ai-check-gateway

on:
  push:
    branches: [ main ]
    paths:
      - 'workers/ai-check-gateway/**'
      - '.github/workflows/deploy-ai-check-gateway.yml'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: workers/package-lock.json

      - name: Install Wrangler 4
        working-directory: workers
        run: npm install --save-dev wrangler@4

      - name: Deploy ai-check-gateway (production)
        working-directory: workers/ai-check-gateway
        run: npx wrangler deploy --env production

      - name: Deployment summary
        run: |
          echo "✅ ai-check-gateway deployed successfully"
          echo "🌍 Route configured in workers/ai-check-gateway/wrangler.toml"

```

### deploy-doc-converter.yml

**Path:** `.github/workflows/deploy-doc-converter.yml`

```yaml
name: Build and Deploy Doc Converter

on:
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: doc-converter/package-lock.json

      - name: Install dependencies
        run: |
          cd doc-converter
          npm ci

      - name: Build
        run: |
          cd doc-converter
          npm run build

      - name: Deploy to GitHub Pages
        if: github.ref == 'refs/heads/main'
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./doc-converter/dist
          destination_dir: doc-converter

```

### deploy-worker.yml

**Path:** `.github/workflows/deploy-worker.yml`

```yaml
name: Deploy Cloudflare Worker (db-api)

on:
  push:
    branches: [ main ]
    paths:
      - 'workers/db-api/**'
      - '.github/workflows/deploy-worker.yml'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_D1_DATABASE_ID: ${{ secrets.CLOUDFLARE_D1_DATABASE_ID }}
      CLOUDFLARE_D1_DATABASE_NAME: ${{ secrets.CLOUDFLARE_D1_DATABASE_NAME }}
      WORKER_NAME: ${{ secrets.WORKER_NAME }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: workers/package-lock.json

      - name: Install dependencies
        working-directory: workers
        run: npm ci --ignore-scripts

      - name: Generate wrangler.toml from template
        working-directory: workers/db-api
        run: |
          : "${WORKER_NAME:=db-api}"
          test -n "$CLOUDFLARE_ACCOUNT_ID" || { echo "CLOUDFLARE_ACCOUNT_ID missing" >&2; exit 1; }
          test -n "$CLOUDFLARE_D1_DATABASE_ID" || { echo "CLOUDFLARE_D1_DATABASE_ID missing" >&2; exit 1; }
          test -n "$CLOUDFLARE_D1_DATABASE_NAME" || { echo "CLOUDFLARE_D1_DATABASE_NAME missing" >&2; exit 1; }
          sed -e "s/__WORKER_NAME__/${WORKER_NAME}/g" \
              -e "s/__CLOUDFLARE_ACCOUNT_ID__/${CLOUDFLARE_ACCOUNT_ID}/g" \
              -e "s/__CLOUDFLARE_D1_DATABASE_NAME__/${CLOUDFLARE_D1_DATABASE_NAME}/g" \
              -e "s/__CLOUDFLARE_D1_DATABASE_ID__/${CLOUDFLARE_D1_DATABASE_ID}/g" \
              wrangler.toml.tpl > wrangler.toml
          echo "Generated workers/db-api/wrangler.toml:" && cat wrangler.toml

      - name: Publish Worker
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          workingDirectory: workers/db-api
          command: deploy --env production

```

### deploy-workers.yml

**Path:** `.github/workflows/deploy-workers.yml`

```yaml
name: Deploy Cloudflare Workers

on:
  push:
    branches:
      - main
    paths:
      - 'workers/**'
      - '.github/workflows/deploy-workers.yml'
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: workers/package-lock.json

      - name: Install Wrangler 4
        working-directory: workers
        run: npm install --save-dev wrangler@4

      - name: Install dependencies
        working-directory: workers
        run: npm ci --ignore-scripts

      - name: Type check
        working-directory: workers
        run: npm run typecheck

      - name: Verify Cloudflare credentials
        working-directory: workers
        run: |
          echo "Verifying Cloudflare authentication..."
          echo "Account ID: ${CLOUDFLARE_ACCOUNT_ID:0:8}***"
          npx wrangler whoami

      - name: Apply D1 migrations (production)
        working-directory: workers
        run: npx wrangler d1 migrations apply blog-db-prod --env production --remote

      - name: Set Secrets (production)
        working-directory: workers
        run: |
          echo "${{ secrets.GEMINI_API_KEY }}" | npx wrangler secret put GEMINI_API_KEY --env production
          echo "${{ secrets.JWT_SECRET }}" | npx wrangler secret put JWT_SECRET --env production
          if [ -n "${{ secrets.ASSETS_BASE_URL }}" ]; then
            echo "${{ secrets.ASSETS_BASE_URL }}" | npx wrangler secret put ASSETS_BASE_URL --env production
          fi

      - name: Deploy to Cloudflare Workers (production)
        working-directory: workers
        run: npx wrangler deploy --env production

      - name: Deployment summary
        run: |
          echo "✅ Cloudflare Workers deployed successfully"
          echo "📦 Environment: production"
          echo "🌍 Endpoint: https://blog-api-prod.immuddelo.workers.dev"
          echo "🔑 Secrets configured: GEMINI_API_KEY, JWT_SECRET"

```

### deploy.yml

**Path:** `.github/workflows/deploy.yml`

```yaml
name: Deploy to GitHub Pages

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'frontend/**'
      - 'doc-converter/**'
      - '.github/workflows/deploy.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'frontend/**'
      - 'doc-converter/**'
      - '.github/workflows/deploy.yml'

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      SITE_BASE_URL: https://noblog.nodove.com
      VITE_SITE_BASE_URL: https://noblog.nodove.com
      # Unified backend base URL (e.g., https://api.nodove.com or https://your-server:5080)
      # Configure this as a repository secret named VITE_API_BASE_URL
      VITE_API_BASE_URL: ${{ secrets.VITE_API_BASE_URL }}
      VITE_CHAT_BASE_URL: ${{ secrets.VITE_CHAT_BASE_URL }}
      VITE_CHAT_API_KEY: ${{ secrets.VITE_CHAT_API_KEY }}
      # Feature flags for frontend (configure as repository secrets)
      # Set VITE_FEATURE_FAB to 'true' to enable FAB by default
      VITE_FEATURE_FAB: ${{ secrets.VITE_FEATURE_FAB }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: |
          frontend/package-lock.json
          doc-converter/package-lock.json
        
    - name: Install dependencies (frontend)
      run: npm --prefix frontend ci
      
    - name: Generate manifests (frontend)
      run: npm --prefix frontend run generate-manifests
      
    - name: Generate SEO files (frontend)
      run: npm --prefix frontend run generate-seo
      
    - name: Auto-commit generated files
      if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
      uses: stefanzweifel/git-auto-commit-action@v5
      with:
        commit_message: "chore(ci): update manifests and SEO artifacts"
        file_pattern: |
          frontend/public/posts-manifest.json
          frontend/public/posts/posts-manifest.json
          frontend/public/posts/**/manifest.json
          frontend/public/sitemap.xml
          frontend/public/rss.xml
          frontend/public/robots.txt
      
    - name: Build (frontend)
      run: npm --prefix frontend run build

    - name: Install dependencies (doc-converter)
      run: npm --prefix doc-converter ci

    - name: Build (doc-converter)
      run: npm --prefix doc-converter run build

    - name: Copy doc-converter into frontend dist
      run: mkdir -p frontend/dist/doc-converter && cp -r doc-converter/dist/* frontend/dist/doc-converter/
      
    - name: Setup Pages
      uses: actions/configure-pages@v4
      
    - name: Upload artifact
      uses: actions/upload-pages-artifact@v3
      with:
        path: './frontend/dist'

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
```

### rag-index.yml

**Path:** `.github/workflows/rag-index.yml`

```yaml
name: RAG Indexing

on:
  workflow_dispatch: {}
  push:
    branches:
      - main
    paths:
      - 'frontend/public/posts/**'
      - 'frontend/public/posts-manifest.json'
      - 'scripts/rag/**'

jobs:
  index:
    # Self-hosted runner on the same server as Docker services
    # This allows direct access to internal services via localhost
    runs-on: self-hosted
    concurrency:
      group: rag-index-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r scripts/rag/requirements.txt

      - name: Run indexer
        env:
          # Internal localhost URLs (bound to 127.0.0.1 in docker-compose)
          TEI_URL: http://127.0.0.1:8180
          CHROMA_URL: http://127.0.0.1:8100
          # No Cloudflare Access needed - direct localhost access
          CHROMA_COLLECTION: ${{ vars.CHROMA_COLLECTION }}
          BASE_COLLECTION_NAME: ${{ vars.BASE_COLLECTION_NAME || 'blog-posts' }}
          TEI_MODEL_NAME: ${{ vars.TEI_MODEL_NAME || vars.TEI_MODEL || 'all-MiniLM-L6-v2' }}
          CHUNK_TOKENS: ${{ vars.CHUNK_TOKENS || '512' }}
          CHUNK_OVERLAP_TOKENS: ${{ vars.CHUNK_OVERLAP_TOKENS || '80' }}
          EMBED_BATCH: ${{ vars.EMBED_BATCH || '32' }}
          MAX_WORKERS: ${{ vars.MAX_WORKERS || '6' }}
          RETRIES_TOTAL: ${{ vars.RETRIES_TOTAL || '5' }}
          RETRY_BACKOFF_S: ${{ vars.RETRY_BACKOFF_S || '1.0' }}
          CHROMA_RETRIES: ${{ vars.CHROMA_RETRIES || '4' }}
          CHROMA_BACKOFF_S: ${{ vars.CHROMA_BACKOFF_S || '1.5' }}
          EMBED_TIMEOUT_S: ${{ vars.EMBED_TIMEOUT_S || '120' }}
        run: |
          python scripts/rag/index_posts.py

```

---

## .roo

### mcp.json

**Path:** `.roo/mcp.json`

```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "~ /workspace"
      ]
    },
    "sequentialthinking": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-sequential-thinking"
      ]
    },
    "playwright": {
      "command": "npx",
      "args": [
        "-y",
        "@playwright/mcp@latest",
        "--browser=",
        "--headless=",
        "--viewport-size="
      ]
    },
    "cloudflare": {
      "command": "npx",
      "args": [
        "-y",
        "@cloudflare/mcp-server-cloudflare"
      ]
    }
  }
}
```

---

## backend

### .env.example

**Path:** `backend/.env.example`

```bash
# Application (prefer root .env; this file is optional override)
APP_ENV=development
HOST=0.0.0.0
PORT=5080
TRUST_PROXY=1
LOG_LEVEL=info

# Origins and URLs
SITE_BASE_URL=https://noblog.nodove.com
API_BASE_URL=http://localhost:5080
ALLOWED_ORIGINS=https://noblog.nodove.com,http://localhost:8080,http://localhost:5173

# Rate limiting
RATE_LIMIT_MAX=60
RATE_LIMIT_WINDOW_MS=60000

# =============================================================================
# AI Provider Configuration
# =============================================================================
# Which AI provider to use: 'litellm' (recommended), 'vas', or 'gemini'
# If not set, auto-detects based on available configuration
AI_PROVIDER=litellm

# =============================================================================
# LiteLLM AI Gateway (Recommended - Single endpoint for all AI providers)
# =============================================================================
# Master key for authenticating with LiteLLM proxy
LITELLM_MASTER_KEY=sk-litellm-your-secret-key
# LiteLLM endpoint (Docker internal)
LITELLM_BASE_URL=http://litellm:4000
# Default model to use
AI_DEFAULT_MODEL=gpt-4.1

# Provider API Keys (used by LiteLLM)
# Only fill in the providers you want to use
OPENAI_API_KEY=
GOOGLE_API_KEY=
ANTHROPIC_API_KEY=

# VAS (GitHub Copilot) API endpoint
AI_SERVE_BASE_URL=http://ai-serve:7012/v1
# VAS API Key (auto-generated from vas-bootstrap)
# Usually read from file: /app/shared/auto-token.jwt
VAS_API_KEY=

# =============================================================================
# Legacy: Direct Gemini (deprecated - use LiteLLM instead)
# =============================================================================
GEMINI_API_KEY=
GEMINI_MODEL=gemini-1.5-flash

# Cloudflare D1 (for comments/analytics/translate/personas/memos)
# Get these from Cloudflare Dashboard
CF_ACCOUNT_ID=f6f11e2a4e5178d2f37476785018f761
CF_API_TOKEN=
D1_DATABASE_ID=e547f944-71a0-42b6-8af1-abc50f29df80

# Cloudflare R2 (for image storage)
# Uses same CF_ACCOUNT_ID and CF_API_TOKEN as D1
R2_BUCKET_NAME=blog
R2_ASSETS_BASE_URL=https://assets-b.nodove.com

# Firebase (deprecated - use D1 instead)
# Put the full JSON string of your service account here (escaped as a single line), or use Docker/K8s secrets.
FIREBASE_SERVICE_ACCOUNT_JSON=
FIREBASE_PROJECT_ID=

# GitHub for Admin PR creation
GITHUB_TOKEN=
GITHUB_REPO_OWNER=choisimo
GITHUB_REPO_NAME=blog
GIT_USER_NAME=CI Bot
GIT_USER_EMAIL=ci@example.com

# Admin token for protected routes (Bearer <token>)
ADMIN_BEARER_TOKEN=

# Optional: JWT auth for admin login
JWT_SECRET=
ADMIN_USERNAME=
ADMIN_PASSWORD=

```

### .env.production.example

**Path:** `backend/.env.production.example`

```bash
# ===================================
# Blog Backend Production Configuration
# ===================================
# 이 파일을 .env로 복사하고 실제 값으로 채우세요
# cp .env.production.example .env

# ===================================
# 기본 서버 설정
# ===================================
APP_ENV=production
HOST=0.0.0.0
PORT=5080

# ===================================
# CORS 설정
# ===================================
# GitHub Pages 도메인과 로컬 개발 도메인을 포함해야 합니다
# 여러 도메인은 콤마로 구분합니다
ALLOWED_ORIGINS=https://noblog.nodove.com,http://localhost:5173

# ===================================
# Rate Limiting
# ===================================
# 분당 요청 제한 (선택사항, 기본값: 100)
RATE_LIMIT_MAX=100
RATE_LIMIT_WINDOW_MS=60000

# ===================================
# GitHub 설정 (Admin PR 생성용)
# ===================================
# Personal Access Token - repo 권한 필요
# https://github.com/settings/tokens/new 에서 생성
GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# 리포지토리 정보
GITHUB_REPO_OWNER=your-github-username
GITHUB_REPO_NAME=blog

# Git 커밋 작성자 정보
GIT_USER_NAME=Your Name
GIT_USER_EMAIL=your-email@example.com

# ===================================
# Admin 보호 설정
# ===================================
# Admin 엔드포인트 보호용 Bearer Token
# 강력한 랜덤 값 생성: openssl rand -hex 32
ADMIN_BEARER_TOKEN=your_secure_random_token_here

# ===================================
# AI 기능 설정 (선택사항)
# ===================================
# Gemini API - https://makersuite.google.com/app/apikey
GEMINI_API_KEY=AIzaSy_xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
GEMINI_MODEL=gemini-1.5-flash

# ===================================
# Firebase 설정 (댓글 기능)
# ===================================
# Firebase 프로젝트 ID
FIREBASE_PROJECT_ID=your-project-id

# Firebase Service Account JSON
# Firebase Console > 프로젝트 설정 > 서비스 계정 > 새 비공개 키 생성
# JSON 전체 내용을 한 줄로 변환하여 붙여넣기
# 예: {"type":"service_account","project_id":"..."}
FIREBASE_SERVICE_ACCOUNT_JSON={"type":"service_account","project_id":"your-project","private_key_id":"...","private_key":"-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n","client_email":"...","client_id":"...","auth_uri":"...","token_uri":"...","auth_provider_x509_cert_url":"...","client_x509_cert_url":"..."}

# ===================================
# 선택적 통합 설정
# ===================================
# Vercel Deploy Hook (사용하지 않으면 비워두세요)
VERCEL_DEPLOY_HOOK_URL=

# ===================================
# 로깅 설정 (선택사항)
# ===================================
# 로그 레벨: error, warn, info, debug
LOG_LEVEL=info

```

### .env.test.example

**Path:** `backend/.env.test.example`

```bash
# =============================================================================
# Test Environment Configuration (.env.test)
# =============================================================================
# docker compose -f docker-compose.test.yml --env-file .env.test up -d --build
# =============================================================================

# -----------------------------------------------------------------------------
# Cloudflare Tunnel (Required)
# -----------------------------------------------------------------------------
# 1. https://one.dash.cloudflare.com/ 접속
# 2. Access > Tunnels > Create a tunnel
# 3. 터널 이름: blog-test
# 4. 토큰 복사
# 5. Public Hostname 설정:
#    - Subdomain: blog-test, Domain: nodove.com, Service: http://nginx-test:80
#    - (Optional) Subdomain: api-test, Domain: nodove.com, Service: http://nginx-test:80
CLOUDFLARE_TUNNEL_TOKEN_TEST=your_tunnel_token_here

# -----------------------------------------------------------------------------
# Frontend Build Args (Optional)
# -----------------------------------------------------------------------------
# API endpoint for frontend to call
# If using api-test.nodove.com:
VITE_API_BASE_URL=https://api-test.nodove.com
# Or if using same domain with /api/ prefix:
# VITE_API_BASE_URL=https://blog-test.nodove.com

# -----------------------------------------------------------------------------
# VAS Admin (Optional)
# -----------------------------------------------------------------------------
ADMIN_JWT_SECRET=test-secret-change-in-production
ADMIN_EMAIL=admin@example.com
# ADMIN_PASSWORD=  # Leave empty for auto-bootstrap mode

```

### .gitignore

**Path:** `backend/.gitignore`

```gitignore
# Environment files
.env
.env.*
!.env.example
!.env.*.example

# Secrets & credentials
*.pem
*.key
*.jwt
*.token
serviceAccount*.json
credentials*.json

# Logs
logs/
*.log
npm-debug.log*

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# Dependencies (should not be in backend, but just in case)
node_modules/

# Build output
dist/
build/

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Test artifacts
coverage/
.nyc_output/

# Docker artifacts (local)
*.tar.gz

```

### DOCKER.md

**Path:** `backend/DOCKER.md`

```markdown
# Docker Guide (Backend API)

이 문서는 백엔드 API 서버를 Docker/Docker Compose로 구동하는 방법과 운영 시 고려사항을 정리합니다.

## 이미지 빌드
프로젝트 루트에서:

```bash
docker build -t blog-backend:local backend
```

- 베이스: `node:20-alpine`
- 포트: `5080`

## 단독 컨테이너 실행 (로컬 테스트)
변경 사항을 호스트에 보존하려면 `frontend/public`을 바인드 마운트하세요.

```bash
# .env 준비
cp -n backend/.env.example backend/.env

# 임시 또는 실제 정적 경로 선택
PUBLIC_DIR=$(realpath frontend/public)
mkdir -p "$PUBLIC_DIR"

docker run --rm -it \
  --name blog-backend \
  -p 5080:5080 \
  --env-file backend/.env \
  -v "$PUBLIC_DIR:/frontend/public" \
  blog-backend:local
```

- API 확인: `http://localhost:5080/api/v1/healthz`
- 업로드 파일은 컨테이너 내 `/frontend/public/images`에 저장되며, 호스트의 `frontend/public/images`에 반영됩니다.

## docker compose (nginx 리버스 프록시 포함)
`backend/docker-compose.yml`을 사용하면 API와 nginx를 함께 구동합니다.

1) `.env` 준비

```bash
cd backend
cp -n .env.example .env
```

2) (권장) `docker-compose.override.yml`로 정적 자산 볼륨과 포트를 오버라이드

```yaml
# backend/docker-compose.override.yml
services:
  api:
    volumes:
      - ../frontend/public:/frontend/public
  nginx:
    ports:
      - "8091:80"
```

3) 실행

```bash
docker compose up --build
# http://localhost:8091/api/v1/healthz
```

### Nginx 업로드 용량
`backend/nginx.conf` 기본 설정은 `client_max_body_size 2m`입니다. 이미지 업로드가 413으로 실패하면 값을 늘리세요.

```nginx
server {
  client_max_body_size 25m; # 필요 시 확대
  ...
}
```

## 환경 변수 전달
- compose: `env_file: .env`
- docker run: `--env-file backend/.env`

운영에서는 `ADMIN_BEARER_TOKEN`을 반드시 설정하고, `ALLOWED_ORIGINS`를 제한하세요.

## 퍼시스턴스 전략
- 게시글/이미지 파일은 컨테이너 수명과 별개로 유지되어야 합니다.
- 권장: 호스트 디렉터리 `frontend/public`을 컨테이너 `/frontend/public`에 마운트.
- 대안: 외부 볼륨(예: `-v blog_public:/frontend/public`) 사용.

## 헬스체크/모니터링
- 헬스: `GET /api/v1/healthz`
- 로그: `docker compose logs -f api` 또는 `docker logs -f blog-backend`

## 보안 체크리스트
- `ADMIN_BEARER_TOKEN` 설정
- `ALLOWED_ORIGINS` 제한
- 프록시 앞단에서 HTTPS 종단
- 레이트 리밋(`RATE_LIMIT_MAX`, `RATE_LIMIT_WINDOW_MS`) 적절히 설정

## 업그레이드/배포 팁
- 이미지 태깅: `blog-backend:<git-sha>` 또는 날짜 태그
- 롤백 대비 이전 태그 보존
- 프론트 정적 자산과 동일 볼륨을 공유해 컨텐츠 일관성 유지

```

### Dockerfile

**Path:** `backend/Dockerfile`

```dockerfile
# syntax=docker/dockerfile:1
FROM node:20-alpine AS base
WORKDIR /app

# Install dependencies
COPY package.json package-lock.json* ./
RUN npm ci --omit=dev || npm install --omit=dev

# Copy source
COPY src ./src

ENV NODE_ENV=production
EXPOSE 5080
CMD ["node", "src/index.js"]

```

### README.md

**Path:** `backend/README.md`

```markdown
# Backend API Server (Blog)

블로그의 API 서버입니다. 게시글 Markdown 관리(CRUD), 통합/연도별 매니페스트 생성, 이미지 업로드/관리, 댓글, AI 기능, OG 이미지 생성 등을 제공합니다.

- 런타임: Node.js 20+
- 프레임워크: Express 4
- 포트: `5080` (기본)
- 주요 경로: `/api/v1/*`

## 🚀 빠른 시작 (Quick Start)

비개발자도 쉽게 설치할 수 있는 자동화 스크립트를 제공합니다:

```bash
# 저장소 클론 후 백엔드 디렉토리로 이동
cd backend

# 빠른 설치 스크립트 실행
bash scripts/setup.sh --pm2 --cloudflare  # Cloudflare Tunnel 사용
# 또는
bash scripts/setup.sh --systemd --nginx   # Nginx + Let's Encrypt 사용
```

자세한 연동 가이드: [PRD 문서](../docs/PRD-fe-be-integration.md)

## 콘텐츠 경로(중요)
코드는 리포지토리 루트를 기준으로 정적 자산 디렉터리를 계산합니다.

- 리포지토리 루트: `repoRoot = path.resolve(process.cwd(), '..')` (기본적으로 `backend/` 한 단계 위)
- 정적 루트: `frontend/public`
- 게시글 디렉터리: `frontend/public/posts`
- 이미지 디렉터리: `frontend/public/images`

도커 컨테이너에서 실행 시 위 경로가 컨테이너 내부에도 존재해야 합니다. 운영·개발 모두에서 변경 사항을 호스트에 보존하려면 컨테이너에 `../frontend/public -> /frontend/public` 바인드 마운트를 권장합니다. 자세한 내용은 아래 Docker 섹션 참고.

## 주요 기능
- **Posts API** (게시글 관리)
  - `GET /api/v1/posts?year=YYYY&includeDrafts=true|false`
  - `GET /api/v1/posts/:year/:slug`
  - `POST /api/v1/posts` (admin)
  - `PUT /api/v1/posts/:year/:slug` (admin)
  - `DELETE /api/v1/posts/:year/:slug` (admin)
  - `POST /api/v1/posts/regenerate-manifests` (admin)
- **Images API** (이미지 관리)
  - `POST /api/v1/images/upload` (admin, multipart form, 필드명 `files`)
  - `GET /api/v1/images?year=YYYY&slug=slug` 또는 `?dir=sub/dir`
  - `DELETE /api/v1/images/:year/:slug/:filename` (admin)
- **Comments API** (댓글)
  - `GET /api/v1/comments?postId=...`
  - `POST /api/v1/comments` {postId, author, content, website?}
- **AI API** (AI 기능)
  - `POST /api/v1/ai/summarize` {text|input, instructions?}
  - `POST /api/v1/ai/generate` {prompt, temperature?}
  - `POST /api/v1/ai/{sketch|prism|chain}` {paragraph, postTitle?}
- **OG Image** (Open Graph 이미지 생성)
  - `GET /api/v1/og?title=...&subtitle=...&theme=dark|light`
- **Admin API** (관리자 기능)
  - `POST /api/v1/admin/propose-new-version` (GitHub PR 생성)
  - `POST /api/v1/admin/archive-comments` (댓글 아카이빙)
- **공용**
  - `GET /api/v1/healthz` (헬스체크)
  - `GET /api/v1/public/config` (프론트에서 필요한 공개설정)

## 환경 변수

프로덕션용 설정 템플릿: `backend/.env.production.example`

- 기본: `.env.production.example`을 `.env`로 복사·수정 (`cp backend/.env.production.example backend/.env`)
- 선택: 로컬 전용 오버라이드가 필요하면 `backend/.env`를 추가로 둘 수 있습니다.

- 서버/네트워킹
  - `APP_ENV` (`development|staging|production`) 기본 `development`
  - `HOST` 기본 `0.0.0.0`
  - `PORT` 기본 `5080`
  - `TRUST_PROXY` 프록시 홉 수. 기본 `1`
  - `ALLOWED_ORIGINS` CORS 허용 원본(콤마 구분)
  - `API_BASE_URL`, `SITE_BASE_URL`
  - 레이트 리밋: `RATE_LIMIT_MAX`, `RATE_LIMIT_WINDOW_MS`
- 인증
  - `ADMIN_BEARER_TOKEN` 관리자 보호 라우트 토큰. 미설정 시 로컬 개발 편의를 위해 보호가 비활성화됩니다(운영에서는 반드시 설정!).
  - (선택) `JWT_SECRET`, `JWT_EXPIRES_IN`을 설정하면 `/api/v1/auth/login` 에서 JWT 발급 후 동일 토큰을 Admin 라우트 보호에 사용할 수 있습니다. 중앙 미들웨어: `src/middleware/adminAuth.js`
- 통합(옵션)
  - Gemini: `GEMINI_API_KEY`, `GEMINI_MODEL`
  - Firebase: `FIREBASE_SERVICE_ACCOUNT_JSON`, `FIREBASE_PROJECT_ID`
  - GitHub(PR 생성용): `GITHUB_TOKEN`, `GITHUB_REPO_OWNER`, `GITHUB_REPO_NAME`, `GIT_USER_NAME`, `GIT_USER_EMAIL`

## 로컬(네이티브) 실행
사전 준비: Node.js 20+, npm 10+, `frontend/public` 존재(없으면 자동 생성되지만, 리포지토리 구조를 유지하는 것이 좋습니다)

```bash
cd backend
cp -n .env.example .env
# 필요 시 ADMIN_BEARER_TOKEN 설정
npm ci
npm run dev
# http://localhost:5080/api/v1/healthz 확인
```

## Docker로 실행
### 1) docker compose (리버스 프록시 포함)
`backend/docker-compose.yml`은 API와 nginx를 올립니다.

```bash
cd backend
cp -n .env.example .env
# 호스트의 정적 자산(프론트 빌드 소스)을 컨테이너에 마운트해 변경사항을 보존
# docker-compose.override.yml 생성(권장):
cat > docker-compose.override.yml <<'YAML'
services:
  api:
    volumes:
      - ../frontend/public:/frontend/public
  nginx:
    ports:
      - "8091:80"
YAML

docker compose up --build
# nginx 프록시 경유:    http://localhost:8091/api/v1/healthz
# 백엔드에 직결(포트): http://localhost:5080/api/v1/healthz
```

주의: 기본 `nginx.conf`는 `client_max_body_size 2m`입니다. 이미지 업로드 시 413이 난다면 `25m` 등으로 늘리세요.

```nginx
# backend/nginx.conf
server {
  client_max_body_size 25m; # 필요 시 조정
  ...
}
```

### 2) 단일 docker run (에페메럴/테스트)
`frontend/public` 대신 임시 디렉터리를 마운트하여 안전하게 실험할 수 있습니다.

```bash
TMP=$(mktemp -d)
# 임시 디렉터리에 posts/images가 생성됩니다
docker run --rm -it \
  -p 5080:5080 \
  --env-file backend/.env \
  -v "$TMP:/frontend/public" \
  -w /app \
  node:20-alpine sh -lc '
    apk add --no-cache nodejs npm && \
    cd /app && \
    mkdir -p /app && \
    # 애플리케이션 이미지 사용을 권장. 예시는 이해를 위한 baseline.
    exit 0
  '
# 권장: 프로젝트 이미지로 빌드/실행
# docker build -t blog-backend:local backend
# docker run --rm -p 5080:5080 --env-file backend/.env -v "$TMP:/frontend/public" blog-backend:local
```

## 매니페스트 생성/정합성
- 게시글 작성/수정/삭제 시:
  - 연도별 `frontend/public/posts/<year>/manifest.json` 갱신
  - 통합 `frontend/public/posts-manifest.json` 및 `frontend/public/posts/posts-manifest.json` 갱신
- 프론트의 `scripts/generate-manifests.js`와 구조 호환(필드: `title`, `slug`, `date`, `tags`, `readingTime`, `coverImage`, ...)

## 엔드포인트 요약
- Health: `GET /api/v1/healthz`
- Public config: `GET /api/v1/public/config`
- Posts
  - List: `GET /api/v1/posts?year=&includeDrafts=`
  - Get: `GET /api/v1/posts/:year/:slug`
  - Create: `POST /api/v1/posts` (admin)
  - Update: `PUT /api/v1/posts/:year/:slug` (admin)
  - Delete: `DELETE /api/v1/posts/:year/:slug` (admin)
  - Regenerate manifests: `POST /api/v1/posts/regenerate-manifests` (admin)
- Images
  - Upload: `POST /api/v1/images/upload` (admin, multipart: `files=@...` 여러개 허용)
  - List: `GET /api/v1/images?year=YYYY&slug=slug` 또는 `GET /api/v1/images?dir=covers`
  - Delete: `DELETE /api/v1/images/:year/:slug/:filename` (admin)

## 보안 & 운영 팁
- Admin 보호 구조: `src/middleware/adminAuth.js`가 모든 (posts/images/admin 등) 쓰기/민감 라우트에서 재사용됩니다. 이전 개별 파일 내 inline 검사 로직은 제거되었습니다.
- JWT 유틸: `src/lib/jwt.js`에 `signJwt`, `verifyJwt`, `isAdminClaims` 제공. Auth 라우트(`/api/v1/auth/*`)는 이를 사용하여 일관성 유지.
- 운영 환경에서는 반드시 `ADMIN_BEARER_TOKEN`을 설정하여 쓰기 라우트를 보호하세요.
- CORS는 `ALLOWED_ORIGINS`에서 엄격히 제한하세요.
- 리버스 프록시(Nginx/Cloud) 앞에서는 `TRUST_PROXY`를 올바르게 설정하세요.
- 업로드 용량 제한은 프록시(Nginx)와 Express 양쪽에서 고려하세요.
- Docker로 실행 시 볼륨 마운트로 `frontend/public`을 호스트에 보존하는 구성을 권장합니다.

## 프로덕션 배포

### 옵션 1: PM2 + Cloudflare Tunnel (추천)
```bash
cd backend
bash scripts/setup.sh --pm2 --cloudflare
```

### 옵션 2: systemd + Nginx
```bash
cd backend
bash scripts/setup.sh --systemd --nginx
```

### 수동 설정
- PM2 설정: `ecosystem.config.js`
- systemd 서비스: `deploy/blog-backend.service`
- Nginx 설정: `deploy/nginx-blog-api.conf`
- Cloudflare 설정: `deploy/cloudflared-config.yml`

## GitHub Actions 연동

1. 리포지토리 Settings → Secrets → Actions
2. `VITE_API_BASE_URL` Secret 추가
3. 값: 백엔드의 공개 HTTPS URL (예: `https://api.yourdomain.com`)
4. main 브랜치 푸시 시 자동으로 프론트엔드가 빌드/배포되며 API URL이 주입됨

## 트러블슈팅
- 401 Unauthorized: `Authorization: Bearer <token>` 헤더 확인, 토큰 값 일치 여부 확인
- 413 Payload Too Large: Nginx `client_max_body_size` 증가, Express `express.json({ limit })` 조정 검토
- CORS 오류: `ALLOWED_ORIGINS`에 호출 원본 추가
- 매니페스트가 갱신되지 않음: 쓰기 연산 후 에러 로그 확인, 파일 권한/볼륨 마운트 경로 확인
- Mixed Content: `VITE_API_BASE_URL`이 HTTPS로 설정되었는지 확인
- PR 생성 실패: GitHub 토큰 권한, 리포지토리 설정 확인

## 관련 문서
- [Frontend-Backend 연동 PRD](../docs/PRD-fe-be-integration.md) - 상세한 설치 및 연동 가이드
- [아키텍처 문서](../docs/ARCHITECTURE.md) - 전체 시스템 구조

```

### docker-compose.test.yml

**Path:** `backend/docker-compose.test.yml`

```yaml
# =============================================================================
# Docker Compose - Test Environment (blog-test.nodove.com)
# =============================================================================
# Frontend-only test deployment that connects to production backend
#
# Architecture:
#   Cloudflare Tunnel → Nginx → Frontend
#   Frontend → api.nodove.com (production backend via Cloudflare Tunnel)
#
# Services:
#   - cloudflared-test: Cloudflare Tunnel for blog-test.nodove.com
#   - nginx-test: Reverse proxy
#   - frontend-test: Frontend SPA
#
# Backend:
#   Uses production backend at https://api.nodove.com
#   - Backend API: https://api.nodove.com/api/*
#   - AI Chat API: https://api.nodove.com/ai/*
#   - VAS Core: https://api.nodove.com/vas/*
#
# Setup:
#   1. Create a tunnel in Cloudflare Zero Trust for blog-test.nodove.com
#   2. Save tunnel token to .env.test as CLOUDFLARE_TUNNEL_TOKEN_TEST
#   3. docker compose -f docker-compose.test.yml --env-file .env.test up -d --build
#
# URL: https://blog-test.nodove.com
# Backend: https://api.nodove.com
# =============================================================================

services:
  # ---------------------------------------------------------------------------
  # Cloudflare Tunnel (Public Entry Point)
  # ---------------------------------------------------------------------------
  cloudflared:
    image: cloudflare/cloudflared:latest
    command: tunnel --no-autoupdate run --token ${CLOUDFLARE_TUNNEL_TOKEN_TEST}
    depends_on:
      - nginx
    networks:
      - test-network
    restart: unless-stopped

  # ---------------------------------------------------------------------------
  # Nginx Reverse Proxy
  # ---------------------------------------------------------------------------
  nginx:
    image: nginx:alpine
    depends_on:
      - frontend
    expose:
      - "80"
    volumes:
      - ./nginx-test.conf:/etc/nginx/conf.d/default.conf:ro
    networks:
      - test-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost/"]
      interval: 30s
      timeout: 10s
      retries: 3

  # ---------------------------------------------------------------------------
  # Frontend (Static SPA) - Connects to api.nodove.com
  # ---------------------------------------------------------------------------
  frontend:
    build:
      context: ../frontend
      dockerfile: Dockerfile
      args:
        - VITE_API_BASE_URL=https://api.nodove.com
        - VITE_SITE_BASE_URL=https://blog-test.nodove.com
    expose:
      - "80"
    networks:
      - test-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost/"]
      interval: 30s
      timeout: 10s
      retries: 3

# =============================================================================
# Networks
# =============================================================================
networks:
  test-network:
    driver: bridge

```

### docker-compose.yml

**Path:** `backend/docker-compose.yml`

```yaml
# =============================================================================
# Docker Compose - Full Stack with Cloudflare Tunnel + LiteLLM AI Gateway
# =============================================================================
#
# Architecture (Single Entry Point + LiteLLM Gateway):
#
#   ┌─────────────────────────────────────────────────────────────────────────┐
#   │                         Internet                                        │
#   │                            │                                            │
#   │                            ▼                                            │
#   │                   Cloudflare Tunnel                                     │
#   │                            │                                            │
#   │                            ▼                                            │
#   │  ┌──────────────────────────────────────────────────────────────────┐  │
#   │  │                    nginx:80 (Single Entry)                       │  │
#   │  │  /api/*      → api:5080                                          │  │
#   │  │  /ai/*       → litellm:4000  (NEW: LiteLLM Gateway)              │  │
#   │  │  /vas/*      → vas-core:7012                                     │  │
#   │  │  /vas-admin/* → vas-admin:7080                                   │  │
#   │  │  /terminal/* → terminal-server:8080                              │  │
#   │  └──────────────────────────────────────────────────────────────────┘  │
#   │                                                                         │
#   │  ┌─────────────────────────────────────────────────────────────────┐   │
#   │  │              LiteLLM AI Gateway (port 4000)                     │   │
#   │  │  - OpenAI-compatible API for ALL providers                      │   │
#   │  │  - Automatic fallback: gpt-4 → gemini → claude                  │   │
#   │  │  - Load balancing, rate limiting, cost tracking                 │   │
#   │  │  - Routes to: vas-core (GitHub Copilot), OpenAI, Gemini, etc.   │   │
#   │  └─────────────────────────────────────────────────────────────────┘   │
#   │                                                                         │
#   │  Internal Services (Docker bridge network only):                        │
#   │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │
#   │  │    api      │ │  vas-core   │ │   litellm   │ │  vas-admin  │       │
#   │  │   :5080     │ │   :7012     │ │   :4000     │ │   :7080     │       │
#   │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘       │
#   │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐                       │
#   │  │  terminal   │ │  embedding  │ │  chromadb   │                       │
#   │  │   :8080     │ │    :80      │ │   :8000     │                       │
#   │  └─────────────┘ └─────────────┘ └─────────────┘                       │
#   └─────────────────────────────────────────────────────────────────────────┘
#
# Public URL Routes (via api.nodove.com):
#   https://api.nodove.com/api/*       → Backend API
#   https://api.nodove.com/ai/*        → LiteLLM Gateway (OpenAI-compatible)
#   https://api.nodove.com/vas/*       → VAS Core (direct, for auth)
#   https://api.nodove.com/vas-admin/* → VAS Admin UI
#   https://api.nodove.com/terminal/*  → Terminal WebSocket
#
# Localhost ports (for self-hosted runner / debugging):
#   127.0.0.1:4000 → litellm:4000        (LiteLLM Gateway)
#   127.0.0.1:8180 → embedding-server:80 (TEI)
#   127.0.0.1:8100 → chromadb:8000       (Vector DB)
#   127.0.0.1:7012 → vas-core:7012       (OpenCode API for auth)
#
# Setup:
#   1. Cloudflare Zero Trust에서 터널 생성
#   2. 터널 Public Hostname 설정: api.nodove.com → http://nginx:80
#   3. 터널 토큰을 .env 파일에 CLOUDFLARE_TUNNEL_TOKEN으로 저장
#   4. API 키 설정 (.env):
#      - LITELLM_MASTER_KEY=sk-your-master-key
#      - OPENAI_API_KEY=sk-... (optional)
#      - GOOGLE_API_KEY=... (optional)
#      - ANTHROPIC_API_KEY=... (optional)
#   5. docker compose up -d
#   6. GitHub Copilot 인증 (호스트에서):
#      npm install -g opencode@latest
#      OPENCODE_API_URL=http://127.0.0.1:7012 opencode auth login
#      docker compose restart vas-core litellm
# =============================================================================

services:
  # ---------------------------------------------------------------------------
  # Cloudflare Tunnel (connects to nginx only)
  # ---------------------------------------------------------------------------
  cloudflared:
    image: cloudflare/cloudflared:latest
    command: tunnel --no-autoupdate run
    environment:
      - TUNNEL_TOKEN=${CLOUDFLARE_TUNNEL_TOKEN}
    depends_on:
      nginx:
        condition: service_healthy
    networks:
      - backend
    restart: unless-stopped

  # ---------------------------------------------------------------------------
  # Nginx Reverse Proxy (Single Entry Point)
  # ---------------------------------------------------------------------------
  # All external traffic comes through here.
  # Routes to internal services based on URL path.
  # ---------------------------------------------------------------------------
  nginx:
    image: nginx:alpine
    depends_on:
      api:
        condition: service_healthy
      vas-proxy:
        condition: service_healthy
    expose:
      - "80"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
    networks:
      - backend
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # ---------------------------------------------------------------------------
  # Backend API Server
  # ---------------------------------------------------------------------------
  api:
    build: .
    env_file:
      - path: .env
        required: false
    environment:
      - APP_ENV=${APP_ENV:-production}
      - HOST=0.0.0.0
      - PORT=5080
      # LiteLLM Gateway (OpenAI-compatible endpoint)
      - LITELLM_BASE_URL=http://litellm:4000
      - LITELLM_API_KEY=${LITELLM_MASTER_KEY:-sk-litellm-master-key}
      # Legacy VAS endpoints (for GitHub Copilot auth)
      - VAS_CORE_URL=http://vas-core:7012
      # Default model settings
      - AI_DEFAULT_MODEL=gpt-4.1
    expose:
      - "5080"
    networks:
      - backend
    depends_on:
      litellm:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "node -e \"const http=require('http'); http.get('http://localhost:5080/api/v1/healthz', (r)=>process.exit(r.statusCode===200?0:1)).on('error',()=>process.exit(1))\""]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s

  # ---------------------------------------------------------------------------
  # TEI Embedding Server (Internal + localhost for self-hosted runner)
  # ---------------------------------------------------------------------------
  embedding-server:
    image: ghcr.io/huggingface/text-embeddings-inference:cpu-1.2.3
    command: --model-id sentence-transformers/all-MiniLM-L6-v2
    ports:
      - "127.0.0.1:8180:80"
    volumes:
      - tei-data:/data
    networks:
      - backend
    restart: unless-stopped

  # ---------------------------------------------------------------------------
  # ChromaDB Vector Database (Internal + localhost for self-hosted runner)
  # ---------------------------------------------------------------------------
  chromadb:
    image: chromadb/chroma:0.5.23
    environment:
      - IS_PERSISTENT=TRUE
      - PERSIST_DIRECTORY=/chroma/chroma
      - ANONYMIZED_TELEMETRY=FALSE
    ports:
      - "127.0.0.1:8100:8000"
    volumes:
      - chroma-data:/chroma/chroma
    networks:
      - backend
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8000/api/v1/heartbeat"]
      interval: 30s
      timeout: 10s
      retries: 3

  # ---------------------------------------------------------------------------
  # Terminal Server (WebSocket PTY)
  # ---------------------------------------------------------------------------
  terminal-server:
    build:
      context: ./terminal-server
    environment:
      - ORIGIN_SECRET_KEY=${ORIGIN_SECRET_KEY:-default-secret-change-me}
      - SANDBOX_IMAGE=${SANDBOX_IMAGE:-alpine:latest}
    expose:
      - "8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - backend
    restart: unless-stopped

  # ===========================================================================
  # LiteLLM AI Gateway (Unified LLM Endpoint)
  # ===========================================================================
  # Single OpenAI-compatible endpoint for ALL LLM providers.
  # No more provider-specific code in the backend!
  # ---------------------------------------------------------------------------
  litellm:
    image: ghcr.io/berriai/litellm:main-latest
    restart: unless-stopped
    ports:
      - "127.0.0.1:4000:4000"
    expose:
      - "4000"
    environment:
      # Master API key for authentication
      LITELLM_MASTER_KEY: ${LITELLM_MASTER_KEY:-sk-litellm-master-key}
      # Provider API Keys
      VAS_API_KEY: ${VAS_API_KEY:-file:///app/shared/auto-token.jwt}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-}
      GOOGLE_API_KEY: ${GOOGLE_API_KEY:-}
      ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY:-}
      # Logging
      LITELLM_LOG: INFO
    command:
      - --config
      - /app/config.yaml
      - --port
      - "4000"
      - --host
      - "0.0.0.0"
    volumes:
      - ./litellm_config.yaml:/app/config.yaml:ro
      - vas-shared:/app/shared:ro
    networks:
      - backend
    depends_on:
      ai-engine:
        condition: service_healthy
      vas-bootstrap:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:4000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s
    security_opt:
      - no-new-privileges:true

  # ===========================================================================
  # AI Engine (GitHub Copilot Authentication)
  # ===========================================================================
  # Unified name: ai-engine (was: vas-core, opencode, opencode-serve)
  # This service handles GitHub Copilot authentication only.
  # All AI calls go through LiteLLM gateway.
  # ---------------------------------------------------------------------------
  ai-engine:
    build:
      context: ./opencode-serve
      dockerfile: ai-serve.Dockerfile
    image: ai-engine:latest
    restart: unless-stopped
    ports:
      - "127.0.0.1:7012:7012"
    expose:
      - "7012"
    environment:
      NODE_ENV: production
      OPENCODE_HOST: 0.0.0.0
      OPENCODE_PORT: 7012
    command:
      - /app/node_modules/.bin/opencode
      - serve
      - --hostname
      - 0.0.0.0
      - --port
      - "7012"
    volumes:
      - vas-data:/home/node/.local/share/opencode
      - vas-logs:/var/log/opencode
      - ./opencode-config:/home/node/.config/opencode
    networks:
      backend:
        # Aliases for backward compatibility with legacy service names
        aliases:
          - vas-core      # Legacy name
          - opencode      # Legacy name
          - ai-engine     # New unified name
    healthcheck:
      test: ["CMD-SHELL", "node -e \"const http=require('http'); http.get('http://localhost:7012/app', ()=>process.exit(0)).on('error', ()=>process.exit(1));\" "]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    security_opt:
      - no-new-privileges:true

  # ---------------------------------------------------------------------------
  # AI Bootstrap (Auto JWT Token Generation)
  # ---------------------------------------------------------------------------
  vas-bootstrap:
    image: curlimages/curl:latest
    restart: "no"
    user: "0:0"
    entrypoint: ["/bin/sh", "/app/bootstrap-token.sh"]
    environment:
      ADMIN_URL: http://ai-admin:7080
      TOKEN_FILE: /app/shared/auto-token.jwt
      MAX_RETRIES: "60"
      RETRY_INTERVAL: "2"
    volumes:
      - ./opencode-serve/bootstrap-token.sh:/app/bootstrap-token.sh:ro
      - vas-shared:/app/shared
    networks:
      - backend
    depends_on:
      ai-admin:
        condition: service_started

  # ---------------------------------------------------------------------------
  # VAS Proxy (DEPRECATED - replaced by LiteLLM)
  # ---------------------------------------------------------------------------
  # Kept for backward compatibility. LiteLLM now handles all routing.
  # Can be removed once migration is complete.
  # ---------------------------------------------------------------------------
  vas-proxy:
    image: node:20-alpine
    restart: unless-stopped
    profiles:
      - legacy  # Only starts with: docker compose --profile legacy up
    command: ["node", "/app/auto-chat-proxy.js"]
    environment:
      OPENCODE_BASE: http://ai-engine:7012
      PROXY_PORT: 7016
      DEFAULT_PROVIDER: github-copilot
      DEFAULT_MODEL: gpt-4.1
      DEFAULT_SESSION_TITLE: Auto Session
      OPENCODE_BEARER_TOKEN_FILE: /app/shared/auto-token.jwt
      TOKEN_FILE_POLL_INTERVAL: "3000"
      TOKEN_FILE_MAX_WAIT: "180000"
      MESSAGE_TIMEOUT: "120000"
    expose:
      - "7016"
    volumes:
      - ./opencode-serve/auto-chat-proxy.js:/app/auto-chat-proxy.js:ro
      - vas-shared:/app/shared:ro
    networks:
      - backend
    depends_on:
      ai-engine:
        condition: service_healthy
      vas-bootstrap:
        condition: service_completed_successfully
    security_opt:
      - no-new-privileges:true
    healthcheck:
      test: ["CMD-SHELL", "node -e \"const http=require('http'); http.get('http://localhost:7016/health', (r)=>process.exit(r.statusCode===200?0:1)).on('error',()=>process.exit(1))\""]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s

  # ---------------------------------------------------------------------------
  # AI Admin (Token Management UI)
  # ---------------------------------------------------------------------------
  ai-admin:
    build:
      context: ./opencode-serve/go-proxy-admin
      dockerfile: Dockerfile
    image: ai-admin:latest
    restart: unless-stopped
    expose:
      - "7080"
    environment:
      OPENCODE_BASE: http://ai-engine:7012
      ADMIN_JWT_SECRET: ${ADMIN_JWT_SECRET:-auto-generated-secret-change-in-production}
      ADMIN_PORT: 7080
      ADMIN_DB_PATH: /app/data/vas-admin.db
      ADMIN_EMAIL: ${ADMIN_EMAIL:-admin@example.com}
      ADMIN_PASSWORD: ${ADMIN_PASSWORD:-}
      AUTO_BOOTSTRAP: "true"
    volumes:
      - vas-admin-data:/app/data
    networks:
      backend:
        aliases:
          - vas-admin    # Legacy name
          - ai-admin     # New unified name
    depends_on:
      ai-engine:
        condition: service_healthy
    security_opt:
      - no-new-privileges:true

# =============================================================================
# Networks
# =============================================================================
networks:
  backend:
    driver: bridge

# =============================================================================
# Volumes
# =============================================================================
volumes:
  tei-data:
    driver: local
  chroma-data:
    driver: local
  vas-data:
    driver: local
  vas-logs:
    driver: local
  vas-admin-data:
    driver: local
  vas-shared:
    driver: local

```

### ecosystem.config.js

**Path:** `backend/ecosystem.config.js`

```javascript
/**
 * PM2 Configuration for Blog Backend
 * Usage:
 *   pm2 start ecosystem.config.js --env production
 *   pm2 reload ecosystem.config.js --env production
 *   pm2 stop blog-backend
 *   pm2 logs blog-backend
 */

module.exports = {
  apps: [
    {
      name: 'blog-backend',
      script: './src/index.js',
      cwd: '/home/ubuntu/workspace/blog/backend',
      
      // Process management
      instances: 1,  // Single instance (can increase for clustering)
      exec_mode: 'fork',  // Use 'cluster' for multiple instances
      autorestart: true,
      watch: false,  // Disable in production
      max_memory_restart: '500M',
      
      // Logging
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      error_file: './logs/error.log',
      out_file: './logs/out.log',
      merge_logs: true,
      
      // Environment variables
      env: {
        NODE_ENV: 'development',
        // Development-specific vars can go here
      },
      env_production: {
        NODE_ENV: 'production',
        // Production env vars are loaded from .env file
        // PM2 will automatically load .env file in the cwd
      },
      
      // Advanced options
      min_uptime: '10s',  // Minimum uptime to consider app started
      listen_timeout: 3000,  // Time to wait for app to listen
      kill_timeout: 5000,  // Time to wait before forcefully killing
      
      // Graceful shutdown
      shutdown_with_message: true,
      wait_ready: false,
      
      // Node.js flags
      node_args: '--max-old-space-size=256',
      
      // Restart delay
      restart_delay: 4000,
      
      // Auto-restart cron pattern (optional)
      // cron_restart: '0 2 * * *',  // Daily restart at 2 AM
    }
  ],

  // Deploy configuration (optional)
  deploy: {
    production: {
      user: 'ubuntu',
      host: 'localhost',
      ref: 'origin/main',
      repo: 'https://github.com/your-username/blog.git',
      path: '/home/ubuntu/workspace/blog',
      'post-deploy': 'cd backend && npm ci && pm2 reload ecosystem.config.js --env production',
      'pre-deploy-local': '',
      env: {
        NODE_ENV: 'production'
      }
    }
  }
};

```

### litellm_config.yaml

**Path:** `backend/litellm_config.yaml`

```yaml
# =============================================================================
# LiteLLM Proxy Configuration
# =============================================================================
#
# LiteLLM provides a unified OpenAI-compatible API for all LLM providers.
# All backend services call this single endpoint instead of provider-specific APIs.
#
# Architecture:
#   Backend API -> LiteLLM Proxy (port 4000) -> Any LLM Provider
#
# Benefits:
#   - Single endpoint for all providers (OpenAI-compatible)
#   - Automatic fallback between providers
#   - Load balancing and rate limiting
#   - Cost tracking and budget management
#   - Unified logging and monitoring
#
# Usage:
#   curl http://litellm:4000/v1/chat/completions \
#     -H "Authorization: Bearer sk-litellm-master-key" \
#     -d '{"model": "gpt-4", "messages": [...]}'
#
# =============================================================================

# -----------------------------------------------------------------------------
# Model List - All available models across providers
# -----------------------------------------------------------------------------
model_list:
  # ---------------------------------------------------------------------------
  # Primary Models (Default aliases that map to fastest available)
  # ---------------------------------------------------------------------------
  # These aliases are used by the backend API - they map to Gemini for speed/cost
  - model_name: gpt-4.1
    litellm_params:
      model: gemini/gemini-1.5-flash
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "Default model - Maps to Gemini 1.5 Flash"
      
  - model_name: gpt-4o
    litellm_params:
      model: gemini/gemini-1.5-pro
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "High capability model - Maps to Gemini 1.5 Pro"

  # ---------------------------------------------------------------------------
  # OpenAI Direct (Optional - when you have your own API key)
  # ---------------------------------------------------------------------------
  - model_name: openai/gpt-4o
    litellm_params:
      model: gpt-4o
      api_key: os.environ/OPENAI_API_KEY
    model_info:
      description: "OpenAI GPT-4o Direct"

  - model_name: openai/gpt-4-turbo
    litellm_params:
      model: gpt-4-turbo
      api_key: os.environ/OPENAI_API_KEY
    model_info:
      description: "OpenAI GPT-4 Turbo Direct"

  - model_name: openai/gpt-3.5-turbo
    litellm_params:
      model: gpt-3.5-turbo
      api_key: os.environ/OPENAI_API_KEY
    model_info:
      description: "OpenAI GPT-3.5 Turbo Direct"

  # ---------------------------------------------------------------------------
  # Google Gemini - Fallback Provider
  # ---------------------------------------------------------------------------
  - model_name: gemini-1.5-flash
    litellm_params:
      model: gemini/gemini-1.5-flash
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "Google Gemini 1.5 Flash (fast, cheap)"

  - model_name: gemini-1.5-pro
    litellm_params:
      model: gemini/gemini-1.5-pro
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "Google Gemini 1.5 Pro"

  - model_name: gemini-2.0-flash
    litellm_params:
      model: gemini/gemini-2.0-flash-exp
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "Google Gemini 2.0 Flash Experimental"

  # ---------------------------------------------------------------------------
  # Anthropic Claude (Optional)
  # ---------------------------------------------------------------------------
  - model_name: claude-3.5-sonnet
    litellm_params:
      model: claude-3-5-sonnet-20241022
      api_key: os.environ/ANTHROPIC_API_KEY
    model_info:
      description: "Anthropic Claude 3.5 Sonnet"

  - model_name: claude-3-opus
    litellm_params:
      model: claude-3-opus-20240229
      api_key: os.environ/ANTHROPIC_API_KEY
    model_info:
      description: "Anthropic Claude 3 Opus"

  - model_name: claude-3-haiku
    litellm_params:
      model: claude-3-haiku-20240307
      api_key: os.environ/ANTHROPIC_API_KEY
    model_info:
      description: "Anthropic Claude 3 Haiku (fast)"

  # ---------------------------------------------------------------------------
  # Local LLM (Ollama) - For development/testing
  # ---------------------------------------------------------------------------
  - model_name: local/llama3
    litellm_params:
      model: ollama/llama3
      api_base: http://host.docker.internal:11434
    model_info:
      description: "Local Llama 3 via Ollama"

  - model_name: local/codellama
    litellm_params:
      model: ollama/codellama
      api_base: http://host.docker.internal:11434
    model_info:
      description: "Local CodeLlama via Ollama"

  # ---------------------------------------------------------------------------
  # Agent-Optimized Models (Function Calling Support)
  # ---------------------------------------------------------------------------
  # These models are specifically optimized for agent use with tool calling
  
  - model_name: agent/gpt-4o
    litellm_params:
      model: gpt-4o
      api_key: os.environ/OPENAI_API_KEY
    model_info:
      description: "GPT-4o optimized for agent/function calling"
      supports_function_calling: true
      supports_parallel_function_calling: true

  - model_name: agent/claude-3.5-sonnet
    litellm_params:
      model: claude-3-5-sonnet-20241022
      api_key: os.environ/ANTHROPIC_API_KEY
    model_info:
      description: "Claude 3.5 Sonnet for agent/tool use"
      supports_function_calling: true

  - model_name: agent/gemini-1.5-pro
    litellm_params:
      model: gemini/gemini-1.5-pro
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "Gemini 1.5 Pro for agent/function calling"
      supports_function_calling: true

  - model_name: agent/gemini-1.5-flash
    litellm_params:
      model: gemini/gemini-1.5-flash
      api_key: os.environ/GOOGLE_API_KEY
    model_info:
      description: "Gemini 1.5 Flash for fast agent responses"
      supports_function_calling: true

# -----------------------------------------------------------------------------
# Router Settings - Fallback and Load Balancing
# -----------------------------------------------------------------------------
router_settings:
  # Routing strategy: simple, least-busy, latency-based-routing, cost-based-routing
  routing_strategy: latency-based-routing
  
  # Number of retries before failing
  num_retries: 3
  
  # Timeout for each request (seconds)
  timeout: 120
  
  # Fallback configuration
  # If gpt-4.1 fails, try gemini alternatives
  fallbacks:
    - gpt-4.1: ["gemini-1.5-pro", "claude-3-haiku"]
    - gpt-4o: ["gemini-2.0-flash", "claude-3.5-sonnet"]

  # Context window fallbacks (for long contexts)
  context_window_fallbacks:
    - gpt-4.1: ["gemini-1.5-pro"]  # Gemini has 1M context

  # Allowed failures before marking model as failed
  allowed_fails: 3
  
  # Cooldown time after failures (seconds)
  cooldown_time: 60

# -----------------------------------------------------------------------------
# LiteLLM General Settings
# -----------------------------------------------------------------------------
litellm_settings:
  # Enable/disable request/response logging
  set_verbose: false
  
  # Drop unmapped params (for compatibility)
  drop_params: true
  
  # Request timeout (seconds)
  request_timeout: 120
  
  # Enable caching (Redis required for production)
  cache: false
  # cache_params:
  #   type: redis
  #   host: redis
  #   port: 6379
  
  # Success callbacks for monitoring
  success_callback: []
  
  # Failure callbacks for alerting
  failure_callback: []
  
  # Function Calling / Tool Use Settings
  # Enable parallel function calling where supported
  supports_function_calling: true
  
  # Allow tool_choice parameter
  supports_tool_choice: true

# -----------------------------------------------------------------------------
# General Settings
# -----------------------------------------------------------------------------
general_settings:
  # Master API key for all requests
  master_key: os.environ/LITELLM_MASTER_KEY
  
  # Disable database - we don't need internal usage tracking
  # Our own D1 database handles usage logging via backend API
  database_connection_pool_limit: 0
  disable_spend_logs: true
  
  # Enable Prometheus metrics at /metrics
  # alerting:
  #   - prometheus

```

### package.json

**Path:** `backend/package.json`

```json
{
  "name": "blog-backend",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "engines": {
    "node": ">=20.0.0"
  },
  "scripts": {
    "dev": "node --watch src/index.js",
    "start": "node src/index.js"
  },
  "dependencies": {
    "@blog/shared": "file:../shared",
    "@octokit/rest": "^20.1.1",
    "cors": "^2.8.5",
    "dotenv": "^16.6.1",
    "express": "^4.19.2",
    "express-rate-limit": "^7.4.0",
    "firebase-admin": "^12.5.0",
    "fs-extra": "^11.2.0",
    "gray-matter": "^4.0.3",
    "helmet": "^7.2.0",
    "jsonwebtoken": "^9.0.2",
    "moment": "^2.30.1",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "sharp": "^0.33.5",
    "slugify": "^1.6.6",
    "zod": "^3.23.8"
  }
}

```

---

## backend/deploy

### cloudflared-config.yml

**Path:** `backend/deploy/cloudflared-config.yml`

```yaml
# =============================================================================
# Cloudflare Tunnel 설정 가이드 (Docker + Token 방식)
# =============================================================================
#
# 이 파일은 참고용입니다. 토큰 방식에서는 Cloudflare 대시보드에서 설정합니다.
#
# Architecture:
#   Internet → api.nodove.com → Cloudflare Tunnel → cloudflared (Docker)
#       → nginx (Docker network) → api (Docker network)
#
#   Internet → ai-serve.nodove.com → Cloudflare Tunnel → cloudflared (Docker)
#       → ai-serve (Docker network, port 4096)
#
# Internal services (localhost only, no tunnel):
#   - TEI:      127.0.0.1:8180
#   - ChromaDB: 127.0.0.1:8100
#   - Terminal: 127.0.0.1:8280
#   - AI Serve: 127.0.0.1:4096 (also exposed via tunnel)
#
# =============================================================================
# 설정 방법
# =============================================================================
#
# 1. Cloudflare Zero Trust 대시보드 접속:
#    https://one.dash.cloudflare.com/
#
# 2. Networks → Tunnels → Create a tunnel
#
# 3. Tunnel type: Cloudflared 선택
#
# 4. Tunnel 이름 입력: blog-api
#
# 5. Install and run a connector 단계에서:
#    - Docker 탭 선택
#    - 표시된 토큰 복사 (TUNNEL_TOKEN=... 부분)
#
# 6. 토큰을 .env 파일에 저장:
#    echo "CLOUDFLARE_TUNNEL_TOKEN=<복사한-토큰>" >> backend/.env
#
# 7. Public Hostnames 설정:
#
#    [Hostname 1 - API Server]
#    - Domain: api.nodove.com
#    - Service Type: HTTP
#    - URL: nginx:80
#    (Docker 네트워크 내부에서 nginx 서비스 이름으로 접근)
#
#    [Hostname 2 - AI Serve (LLM Gateway)]
#    - Domain: ai-serve.nodove.com
#    - Service Type: HTTP
#    - URL: ai-serve:4096
#    (Docker 네트워크 내부에서 ai-serve 서비스로 접근)
#
# 8. Docker Compose 실행:
#    cd backend && docker compose up -d
#
# =============================================================================
# Ingress 규칙 (Cloudflare 대시보드에서 설정)
# =============================================================================
#
# [Rule 1]
# Public Hostname: api.nodove.com
# Service: http://nginx:80
#
# [Rule 2]
# Public Hostname: ai-serve.nodove.com
# Service: http://ai-serve:4096
#
# 추가 설정 (Optional):
#   - No TLS Verify: Enabled (내부 HTTP 통신)
#   - HTTP Host Header: (각 도메인에 맞게 설정)
#
# =============================================================================

```

---

## backend/scripts

### generate-env-from-config.js

**Path:** `backend/scripts/generate-env-from-config.js`

```javascript
#!/usr/bin/env node
/**
 * Generate .env file from current config
 * Usage: node scripts/generate-env-from-config.js [output-path]
 */

import { config } from '../src/config.js';
import fs from 'node:fs/promises';
import path from 'node:path';

const CONFIG_SCHEMA = {
  app: {
    name: 'Application',
    vars: [
      { key: 'APP_ENV', value: () => config.appEnv },
      { key: 'HOST', value: () => config.host },
      { key: 'PORT', value: () => config.port },
      { key: 'TRUST_PROXY', value: () => config.trustProxy },
      { key: 'LOG_LEVEL', value: () => config.logLevel },
      { key: 'RATE_LIMIT_MAX', value: () => config.rateLimit.max },
      { key: 'RATE_LIMIT_WINDOW_MS', value: () => config.rateLimit.windowMs },
    ],
  },
  urls: {
    name: 'URLs & CORS',
    vars: [
      { key: 'SITE_BASE_URL', value: () => config.siteBaseUrl },
      { key: 'API_BASE_URL', value: () => config.apiBaseUrl },
      { key: 'ALLOWED_ORIGINS', value: () => config.allowedOrigins.join(',') },
    ],
  },
  ai: {
    name: 'AI Services (VAS)',
    vars: [
      { key: 'AI_SERVE_BASE_URL', value: () => config.aiServe.baseUrl },
      { key: 'VAS_CORE_URL', value: () => config.aiServe.vasCoreUrl },
      { key: 'AI_SERVE_DEFAULT_PROVIDER', value: () => config.aiServe.defaultProvider },
      { key: 'AI_SERVE_DEFAULT_MODEL', value: () => config.aiServe.defaultModel },
      { key: 'GEMINI_API_KEY', value: () => config.gemini.apiKey, secret: true },
      { key: 'GEMINI_MODEL', value: () => config.gemini.model },
      { key: 'OPENROUTER_API_KEY', value: () => config.openrouter.apiKey, secret: true },
    ],
  },
  cloudflare: {
    name: 'Cloudflare',
    vars: [
      { key: 'CF_ACCOUNT_ID', value: () => process.env.CF_ACCOUNT_ID },
      { key: 'CF_API_TOKEN', value: () => process.env.CF_API_TOKEN, secret: true },
      { key: 'D1_DATABASE_ID', value: () => process.env.D1_DATABASE_ID },
      { key: 'R2_BUCKET_NAME', value: () => process.env.R2_BUCKET_NAME || 'blog' },
      { key: 'R2_ASSETS_BASE_URL', value: () => process.env.R2_ASSETS_BASE_URL },
    ],
  },
  github: {
    name: 'GitHub',
    vars: [
      { key: 'GITHUB_TOKEN', value: () => config.github.token, secret: true },
      { key: 'GITHUB_REPO_OWNER', value: () => config.github.owner },
      { key: 'GITHUB_REPO_NAME', value: () => config.github.repo },
      { key: 'GIT_USER_NAME', value: () => config.github.gitUserName },
      { key: 'GIT_USER_EMAIL', value: () => config.github.gitUserEmail },
    ],
  },
  firebase: {
    name: 'Firebase',
    vars: [
      { key: 'FIREBASE_PROJECT_ID', value: () => config.firebase.projectId },
      { key: 'FIREBASE_SERVICE_ACCOUNT_JSON', value: () => config.firebase.serviceAccountJson, secret: true },
    ],
  },
  auth: {
    name: 'Authentication',
    vars: [
      { key: 'ADMIN_BEARER_TOKEN', value: () => config.admin.bearerToken, secret: true },
      { key: 'JWT_SECRET', value: () => config.auth.jwtSecret, secret: true },
      { key: 'ADMIN_USERNAME', value: () => config.admin.username },
      { key: 'ADMIN_PASSWORD', value: () => config.admin.password, secret: true },
    ],
  },
  rag: {
    name: 'RAG Services',
    vars: [
      { key: 'TEI_URL', value: () => config.rag.teiUrl },
      { key: 'CHROMA_URL', value: () => config.rag.chromaUrl },
      { key: 'CHROMA_COLLECTION', value: () => config.rag.chromaCollection },
    ],
  },
};

function generateEnvContent(includeSecrets = false) {
  const lines = [
    '# Auto-generated environment configuration',
    `# Generated at: ${new Date().toISOString()}`,
    '#',
    '# Usage: Copy this file to .env and fill in the values',
    '',
  ];

  for (const [, category] of Object.entries(CONFIG_SCHEMA)) {
    lines.push(`# === ${category.name} ===`);
    
    for (const v of category.vars) {
      try {
        const val = v.value() || '';
        if (v.secret && !includeSecrets) {
          lines.push(`# ${v.key}=<secret>`);
        } else {
          lines.push(`${v.key}=${val}`);
        }
      } catch {
        lines.push(`# ${v.key}=<error>`);
      }
    }
    lines.push('');
  }

  return lines.join('\n');
}

function generateDockerComposeEnv(includeSecrets = false) {
  const lines = ['    environment:'];

  for (const [, category] of Object.entries(CONFIG_SCHEMA)) {
    for (const v of category.vars) {
      try {
        const val = v.value() || '';
        if (v.secret && !includeSecrets) {
          lines.push(`      # - ${v.key}=\${${v.key}}`);
        } else if (val) {
          lines.push(`      - ${v.key}=${val}`);
        }
      } catch {
        // skip
      }
    }
  }

  return lines.join('\n');
}

function generateWranglerVars(includeSecrets = false) {
  const varsLines = ['[vars]'];
  const secretsLines = ['', '# Secrets (set via CLI):', '# wrangler secret put <KEY>'];

  for (const [, category] of Object.entries(CONFIG_SCHEMA)) {
    for (const v of category.vars) {
      try {
        const val = v.value() || '';
        if (v.secret) {
          secretsLines.push(`# wrangler secret put ${v.key}`);
        } else if (val) {
          varsLines.push(`${v.key} = "${val}"`);
        }
      } catch {
        // skip
      }
    }
  }

  return [...varsLines, ...secretsLines].join('\n');
}

async function main() {
  const args = process.argv.slice(2);
  const format = args.find(a => ['--env', '--docker', '--wrangler'].includes(a)) || '--env';
  const outputPath = args.find(a => !a.startsWith('-'));
  const includeSecrets = args.includes('--include-secrets');

  let content;
  let defaultFilename;

  switch (format) {
    case '--docker':
      content = generateDockerComposeEnv(includeSecrets);
      defaultFilename = 'docker-env.yml';
      break;
    case '--wrangler':
      content = generateWranglerVars(includeSecrets);
      defaultFilename = 'wrangler-vars.toml';
      break;
    default:
      content = generateEnvContent(includeSecrets);
      defaultFilename = '.env.generated';
  }

  if (outputPath) {
    const fullPath = path.resolve(process.cwd(), outputPath);
    await fs.writeFile(fullPath, content, 'utf8');
    console.log(`Written to: ${fullPath}`);
  } else {
    console.log(content);
  }
}

main().catch(console.error);

```

### setup.sh

**Path:** `backend/scripts/setup.sh`

```bash
#!/bin/bash

# ===================================
# Blog Backend Quick Setup Script
# ===================================
# This script helps set up the blog backend on Ubuntu
# Usage: bash setup.sh [--pm2|--systemd] [--cloudflare|--nginx]

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Default values
SERVICE_MANAGER="pm2"  # or "systemd"
PROXY_METHOD="cloudflare"  # or "nginx"
WORKING_DIR=$(pwd)
NODE_VERSION="20"

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --pm2)
            SERVICE_MANAGER="pm2"
            shift
            ;;
        --systemd)
            SERVICE_MANAGER="systemd"
            shift
            ;;
        --cloudflare)
            PROXY_METHOD="cloudflare"
            shift
            ;;
        --nginx)
            PROXY_METHOD="nginx"
            shift
            ;;
        --help)
            echo "Usage: $0 [--pm2|--systemd] [--cloudflare|--nginx]"
            echo "  --pm2         Use PM2 for process management (default)"
            echo "  --systemd     Use systemd for process management"
            echo "  --cloudflare  Use Cloudflare Tunnel for HTTPS (default)"
            echo "  --nginx       Use Nginx + Let's Encrypt for HTTPS"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

echo -e "${GREEN}====================================${NC}"
echo -e "${GREEN}Blog Backend Setup Script${NC}"
echo -e "${GREEN}====================================${NC}"
echo "Service Manager: $SERVICE_MANAGER"
echo "Proxy Method: $PROXY_METHOD"
echo ""

# Function to check if command exists
command_exists() {
    command -v "$1" &> /dev/null
}

# Function to prompt for input
prompt_input() {
    local prompt_text="$1"
    local var_name="$2"
    local default_value="$3"
    
    if [ -n "$default_value" ]; then
        read -p "$prompt_text [$default_value]: " input_value
        eval "$var_name=\${input_value:-$default_value}"
    else
        read -p "$prompt_text: " input_value
        while [ -z "$input_value" ]; do
            echo -e "${RED}This field is required${NC}"
            read -p "$prompt_text: " input_value
        done
        eval "$var_name=\$input_value"
    fi
}

# Function to generate random token
generate_token() {
    openssl rand -hex 32
}

# Step 1: Check Node.js installation
echo -e "${YELLOW}Step 1: Checking Node.js installation...${NC}"
if command_exists node; then
    NODE_INSTALLED_VERSION=$(node -v | sed 's/v//')
    echo "Node.js version $NODE_INSTALLED_VERSION is installed"
    
    # Check if version is >= 20
    REQUIRED_VERSION="20.0.0"
    if [ "$(printf '%s\n' "$REQUIRED_VERSION" "$NODE_INSTALLED_VERSION" | sort -V | head -n1)" != "$REQUIRED_VERSION" ]; then
        echo -e "${RED}Node.js version 20 or higher is required${NC}"
        echo "Would you like to install Node.js 20? (y/n)"
        read -r install_node
        if [ "$install_node" = "y" ]; then
            curl -fsSL https://deb.nodesource.com/setup_${NODE_VERSION}.x | sudo -E bash -
            sudo apt-get install -y nodejs
        else
            exit 1
        fi
    fi
else
    echo -e "${YELLOW}Node.js is not installed. Installing Node.js ${NODE_VERSION}...${NC}"
    curl -fsSL https://deb.nodesource.com/setup_${NODE_VERSION}.x | sudo -E bash -
    sudo apt-get install -y nodejs
fi

# Step 2: Install dependencies
echo -e "${YELLOW}Step 2: Installing backend dependencies...${NC}"
if [ ! -f "package.json" ]; then
    echo -e "${RED}Error: package.json not found. Please run this script from the backend directory${NC}"
    exit 1
fi
npm install

# Step 3: Create .env file
echo -e "${YELLOW}Step 3: Setting up environment configuration...${NC}"
if [ -f ".env" ]; then
    echo -e "${YELLOW}Warning: .env file already exists${NC}"
    echo "Would you like to backup and create a new one? (y/n)"
    read -r backup_env
    if [ "$backup_env" = "y" ]; then
        cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
        echo "Existing .env backed up"
    else
        echo "Keeping existing .env file"
        # Skip to next step
    fi
fi

if [ ! -f ".env" ] || [ "$backup_env" = "y" ]; then
    echo "Creating .env file..."
    
    # Collect required information
    prompt_input "GitHub username (repo owner)" GITHUB_OWNER
    prompt_input "GitHub repository name" GITHUB_REPO "blog"
    prompt_input "GitHub Personal Access Token (with repo permissions)" GITHUB_TOKEN
    prompt_input "Git commit author name" GIT_USER_NAME
    prompt_input "Git commit author email" GIT_USER_EMAIL
    prompt_input "Frontend domain (GitHub Pages URL)" FRONTEND_DOMAIN "https://noblog.nodove.com"
    
    # Generate admin token
    ADMIN_TOKEN=$(generate_token)
    echo "Generated Admin Bearer Token: $ADMIN_TOKEN"
    
    # Optional configurations
    echo ""
    echo "Optional configurations (press Enter to skip):"
    prompt_input "Gemini API Key" GEMINI_API_KEY ""
    prompt_input "Firebase Project ID" FIREBASE_PROJECT_ID ""
    
    # Create .env file
    cat > .env << EOF
# Generated by setup.sh on $(date)

# Server Configuration
APP_ENV=production
HOST=0.0.0.0
PORT=5080

# CORS
ALLOWED_ORIGINS=${FRONTEND_DOMAIN},http://localhost:5173

# GitHub Configuration
GITHUB_TOKEN=${GITHUB_TOKEN}
GITHUB_REPO_OWNER=${GITHUB_OWNER}
GITHUB_REPO_NAME=${GITHUB_REPO}
GIT_USER_NAME=${GIT_USER_NAME}
GIT_USER_EMAIL=${GIT_USER_EMAIL}

# Admin Protection
ADMIN_BEARER_TOKEN=${ADMIN_TOKEN}

# Optional Services
GEMINI_API_KEY=${GEMINI_API_KEY}
GEMINI_MODEL=gemini-1.5-flash
FIREBASE_PROJECT_ID=${FIREBASE_PROJECT_ID}
FIREBASE_SERVICE_ACCOUNT_JSON=

# Rate Limiting
RATE_LIMIT_MAX=100
RATE_LIMIT_WINDOW_MS=60000

# Logging
LOG_LEVEL=info
EOF
    
    echo -e "${GREEN}.env file created successfully${NC}"
    echo ""
    echo -e "${YELLOW}Important: Save your Admin Bearer Token:${NC}"
    echo "$ADMIN_TOKEN"
    echo ""
fi

# Step 4: Setup process manager
echo -e "${YELLOW}Step 4: Setting up process manager ($SERVICE_MANAGER)...${NC}"

if [ "$SERVICE_MANAGER" = "pm2" ]; then
    # Install PM2 globally if not installed
    if ! command_exists pm2; then
        echo "Installing PM2..."
        sudo npm install -g pm2
    fi
    
    # Start the application
    echo "Starting application with PM2..."
    pm2 start ecosystem.config.js --env production
    
    # Setup PM2 startup script
    pm2 startup systemd -u $USER --hp $HOME
    pm2 save
    
    echo -e "${GREEN}PM2 setup complete${NC}"
    echo "Useful PM2 commands:"
    echo "  pm2 status          - Check status"
    echo "  pm2 logs blog-backend - View logs"
    echo "  pm2 restart blog-backend - Restart service"
    
elif [ "$SERVICE_MANAGER" = "systemd" ]; then
    # Copy systemd service file
    echo "Setting up systemd service..."
    
    # Update paths in service file
    sed "s|/home/ubuntu|$HOME|g" deploy/blog-backend.service > /tmp/blog-backend.service
    
    sudo cp /tmp/blog-backend.service /etc/systemd/system/
    sudo systemctl daemon-reload
    sudo systemctl enable blog-backend
    sudo systemctl start blog-backend
    
    echo -e "${GREEN}Systemd setup complete${NC}"
    echo "Useful systemd commands:"
    echo "  sudo systemctl status blog-backend  - Check status"
    echo "  sudo journalctl -u blog-backend -f  - View logs"
    echo "  sudo systemctl restart blog-backend - Restart service"
fi

# Step 5: Test backend
echo -e "${YELLOW}Step 5: Testing backend...${NC}"
sleep 3  # Wait for service to start
if curl -s http://localhost:5080/api/v1/healthz | grep -q "ok"; then
    echo -e "${GREEN}✓ Backend is running successfully${NC}"
else
    echo -e "${RED}✗ Backend health check failed${NC}"
    echo "Check logs for errors:"
    if [ "$SERVICE_MANAGER" = "pm2" ]; then
        pm2 logs blog-backend --lines 20
    else
        sudo journalctl -u blog-backend -n 20
    fi
fi

# Step 6: Setup HTTPS proxy
echo -e "${YELLOW}Step 6: Setting up HTTPS proxy ($PROXY_METHOD)...${NC}"

if [ "$PROXY_METHOD" = "cloudflare" ]; then
    echo ""
    echo -e "${YELLOW}Cloudflare Tunnel Setup Instructions:${NC}"
    echo "1. Install cloudflared (if not installed):"
    echo "   curl -fsSL https://pkg.cloudflare.com/install.sh | sudo bash"
    echo "   sudo apt-get install -y cloudflared"
    echo ""
    echo "2. Authenticate with Cloudflare:"
    echo "   cloudflared tunnel login"
    echo ""
    echo "3. Create tunnel:"
    echo "   cloudflared tunnel create blog-api"
    echo ""
    echo "4. Route your domain:"
    echo "   cloudflared tunnel route dns blog-api api.yourdomain.com"
    echo ""
    echo "5. Copy the config file:"
    echo "   sudo cp deploy/cloudflared-config.yml /etc/cloudflared/config.yml"
    echo "   # Edit the file to add your tunnel UUID"
    echo ""
    echo "6. Start the tunnel service:"
    echo "   sudo systemctl enable --now cloudflared"
    echo ""
    
elif [ "$PROXY_METHOD" = "nginx" ]; then
    # Check if Nginx is installed
    if ! command_exists nginx; then
        echo "Installing Nginx..."
        sudo apt-get update
        sudo apt-get install -y nginx
    fi
    
    prompt_input "Enter your API domain (e.g., api.yourdomain.com)" API_DOMAIN
    
    # Copy and update Nginx config
    sed "s|api.yourdomain.com|$API_DOMAIN|g" deploy/nginx-blog-api.conf > /tmp/blog-api
    sudo cp /tmp/blog-api /etc/nginx/sites-available/blog-api
    sudo ln -sf /etc/nginx/sites-available/blog-api /etc/nginx/sites-enabled/blog-api
    
    # Test and reload Nginx
    sudo nginx -t
    sudo systemctl reload nginx
    
    echo ""
    echo -e "${YELLOW}Setting up SSL with Let's Encrypt...${NC}"
    echo "Installing Certbot..."
    sudo apt-get install -y certbot python3-certbot-nginx
    
    echo "Obtaining SSL certificate..."
    sudo certbot --nginx -d $API_DOMAIN --redirect --non-interactive --agree-tos -m $GIT_USER_EMAIL
    
    echo -e "${GREEN}Nginx and SSL setup complete${NC}"
fi

# Step 7: Final instructions
echo ""
echo -e "${GREEN}====================================${NC}"
echo -e "${GREEN}Setup Complete!${NC}"
echo -e "${GREEN}====================================${NC}"
echo ""
echo "Next steps:"
echo "1. Add VITE_API_BASE_URL to GitHub repository secrets:"
echo "   - Go to: https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}/settings/secrets/actions"
echo "   - Add new secret: VITE_API_BASE_URL"
if [ "$PROXY_METHOD" = "nginx" ]; then
    echo "   - Value: https://${API_DOMAIN}"
else
    echo "   - Value: https://api.yourdomain.com (your Cloudflare tunnel domain)"
fi
echo ""
echo "2. Trigger a GitHub Pages deployment:"
echo "   - Push to main branch or manually trigger the workflow"
echo ""
echo "3. Test the integration:"
echo "   - Visit your GitHub Pages site"
echo "   - Check browser console for API calls"
echo "   - Try posting a comment"
echo ""
echo -e "${YELLOW}Important information saved:${NC}"
echo "- Environment config: .env"
echo "- Admin Bearer Token: $ADMIN_TOKEN"
if [ "$SERVICE_MANAGER" = "pm2" ]; then
    echo "- PM2 config: ecosystem.config.js"
else
    echo "- Systemd service: /etc/systemd/system/blog-backend.service"
fi
echo ""
echo -e "${GREEN}Your backend is now running!${NC}"

```

---

## backend/src

### config.js

**Path:** `backend/src/config.js`

```javascript
import dotenv from 'dotenv';
import { z } from 'zod';
import path from 'node:path';

// Load env: prefer root .env, then backend/.env overrides
const repoRoot = path.resolve(process.cwd(), '..');
dotenv.config({ path: path.join(repoRoot, '.env') });
dotenv.config({ path: path.resolve(process.cwd(), '.env'), override: true });

const schema = z.object({
  APP_ENV: z
    .enum(['development', 'staging', 'production', 'test'])
    .default('development'),
  HOST: z.string().default('0.0.0.0'),
  PORT: z.coerce.number().int().positive().default(5080),
  TRUST_PROXY: z.coerce.number().int().nonnegative().default(1),
  LOG_LEVEL: z
    .enum(['fatal', 'error', 'warn', 'info', 'debug', 'trace'])
    .default('info'),

  SITE_BASE_URL: z.string().url().default('https://noblog.nodove.com'),
  API_BASE_URL: z.string().default('http://localhost:5080'),
  ALLOWED_ORIGINS: z.string().default('http://localhost:5173'),

  RATE_LIMIT_MAX: z.coerce.number().int().positive().default(60),
  RATE_LIMIT_WINDOW_MS: z.coerce.number().int().positive().default(60_000),

  // ==========================================================================
  // AI Gateway (LiteLLM) - Primary AI endpoint
  // ==========================================================================
  LITELLM_BASE_URL: z.string().default('http://litellm:4000'),
  LITELLM_API_KEY: z.string().default('sk-litellm-master-key'),
  AI_DEFAULT_MODEL: z.string().default('gpt-4.1'),

  // AI Engine (VAS Core) - For GitHub Copilot authentication only
  AI_ENGINE_URL: z.string().default('http://ai-engine:7012'),

  // Legacy: Gemini direct access (deprecated - use LiteLLM instead)
  GEMINI_API_KEY: z.string().optional(),
  GEMINI_MODEL: z.string().default('gemini-1.5-flash'),
  OPENROUTER_API_KEY: z.string().optional(),

  // ==========================================================================
  // Cloudflare D1 (Primary database for all data)
  // ==========================================================================
  CF_ACCOUNT_ID: z.string().optional(),
  CF_API_TOKEN: z.string().optional(),
  D1_DATABASE_ID: z.string().optional(),

  // Cloudflare R2 (for image storage)
  R2_BUCKET_NAME: z.string().default('blog'),
  R2_ASSETS_BASE_URL: z.string().default('https://assets-b.nodove.com'),

  // ==========================================================================
  // Firebase (DEPRECATED - Use D1 instead)
  // ==========================================================================
  // These are kept for backward compatibility during migration.
  // Remove after confirming all data is migrated to D1.
  FIREBASE_SERVICE_ACCOUNT_JSON: z.string().optional(),
  FIREBASE_PROJECT_ID: z.string().optional(),

  GITHUB_TOKEN: z.string().optional(),
  GITHUB_REPO_OWNER: z.string().optional(),
  GITHUB_REPO_NAME: z.string().optional(),
  GIT_USER_NAME: z.string().optional(),
  GIT_USER_EMAIL: z.string().optional(),

  ADMIN_BEARER_TOKEN: z.string().optional(),
  JWT_SECRET: z.string().optional(),
  ADMIN_USERNAME: z.string().optional(),
  ADMIN_PASSWORD: z.string().optional(),
  VERCEL_DEPLOY_HOOK_URL: z.string().optional(),

  // ==========================================================================
  // RAG Services
  // ==========================================================================
  TEI_URL: z.string().default('http://embedding-server:80'),
  CHROMA_URL: z.string().default('http://chromadb:8000'),
  CHROMA_COLLECTION: z.string().default('blog-posts-all-MiniLM-L6-v2'),
});

const raw = schema.parse(process.env);

const allowedOrigins = raw.ALLOWED_ORIGINS.split(',')
  .map(s => s.trim())
  .filter(Boolean);

const publicDir = path.join(repoRoot, 'frontend', 'public');
const postsDir = path.join(publicDir, 'posts');
const imagesDir = path.join(publicDir, 'images');

export const config = {
  appEnv: raw.APP_ENV,
  host: raw.HOST,
  port: raw.PORT,
  trustProxy: raw.TRUST_PROXY,
  logLevel: raw.LOG_LEVEL,

  siteBaseUrl: raw.SITE_BASE_URL,
  apiBaseUrl: raw.API_BASE_URL,
  allowedOrigins,

  rateLimit: {
    max: raw.RATE_LIMIT_MAX,
    windowMs: raw.RATE_LIMIT_WINDOW_MS,
  },

  // ==========================================================================
  // AI Gateway (LiteLLM) - Primary AI endpoint
  // ==========================================================================
  ai: {
    // LiteLLM Gateway (OpenAI-compatible)
    gateway: {
      baseUrl: raw.LITELLM_BASE_URL,
      apiKey: raw.LITELLM_API_KEY,
      defaultModel: raw.AI_DEFAULT_MODEL,
    },
    // AI Engine (for GitHub Copilot auth only)
    engine: {
      url: raw.AI_ENGINE_URL,
    },
  },

  // Legacy: Gemini direct (deprecated - use ai.gateway instead)
  gemini: {
    apiKey: raw.GEMINI_API_KEY,
    model: raw.GEMINI_MODEL,
  },

  openrouter: {
    apiKey: raw.OPENROUTER_API_KEY,
  },

  // ==========================================================================
  // Firebase (DEPRECATED - kept for migration reference)
  // ==========================================================================
  firebase: {
    serviceAccountJson: raw.FIREBASE_SERVICE_ACCOUNT_JSON,
    projectId: raw.FIREBASE_PROJECT_ID,
    _deprecated: true,
  },

  github: {
    token: raw.GITHUB_TOKEN,
    owner: raw.GITHUB_REPO_OWNER,
    repo: raw.GITHUB_REPO_NAME,
    gitUserName: raw.GIT_USER_NAME,
    gitUserEmail: raw.GIT_USER_EMAIL,
  },

  admin: {
    bearerToken: raw.ADMIN_BEARER_TOKEN,
    username: raw.ADMIN_USERNAME,
    password: raw.ADMIN_PASSWORD,
  },

  auth: {
    jwtSecret: raw.JWT_SECRET,
    jwtExpiresIn: '12h',
  },

  content: {
    repoRoot,
    publicDir,
    postsDir,
    imagesDir,
  },

  integrations: {
    vercelDeployHookUrl: raw.VERCEL_DEPLOY_HOOK_URL,
  },

  rag: {
    teiUrl: raw.TEI_URL,
    chromaUrl: raw.CHROMA_URL,
    chromaCollection: raw.CHROMA_COLLECTION,
  },
};

export function publicRuntimeConfig() {
  return {
    siteBaseUrl: config.siteBaseUrl,
    apiBaseUrl: config.apiBaseUrl,
    env: config.appEnv,
    features: {
      aiInline: true,
    },
  };
}

```

### index.js

**Path:** `backend/src/index.js`

```javascript
import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import morgan from 'morgan';
import rateLimit from 'express-rate-limit';
import { config, publicRuntimeConfig } from './config.js';

import aiRouter from './routes/ai.js';
import commentsRouter from './routes/comments.js';
import analyticsRouter from './routes/analytics.js';
import chatRouter from './routes/chat.js';
import translateRouter from './routes/translate.js';
import userContentRouter from './routes/userContent.js';
import ogRouter from './routes/og.js';
import adminRouter from './routes/admin.js';
import postsRouter from './routes/posts.js';
import imagesRouter from './routes/images.js';
import authRouter from './routes/auth.js';
import ragRouter from './routes/rag.js';
import configRouter from './routes/config.js';
import workersRouter from './routes/workers.js';
import aiAdminRouter from './routes/aiAdmin.js';
import agentRouter from './routes/agent.js';

const app = express();

// trust proxy (for correct IP in rate-limit, etc.)
app.set('trust proxy', config.trustProxy);

// security headers
app.use(
  helmet({
    crossOriginResourcePolicy: { policy: 'cross-origin' },
  })
);

// CORS
const corsOptions = {
  origin(origin, callback) {
    if (!origin) return callback(null, true);
    const ok = config.allowedOrigins.some(o => o === origin);
    return callback(ok ? null : new Error('Not allowed by CORS'), ok);
  },
  credentials: true,
};
app.use(cors(corsOptions));

// logging
app.use(morgan('combined'));

// parsers
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: false }));

// basic rate limit (can be overridden per route if needed)
const limiter = rateLimit({
  windowMs: config.rateLimit.windowMs,
  max: config.rateLimit.max,
  standardHeaders: true,
  legacyHeaders: false,
});
app.use(limiter);

// health & public config
app.get('/api/v1/healthz', (req, res) => {
  res.json({ ok: true, env: config.appEnv, uptime: process.uptime() });
});
app.get('/api/v1/public/config', (req, res) => {
  res.json({ ok: true, data: publicRuntimeConfig() });
});

// routes
app.use('/api/v1/ai', aiRouter);
app.use('/api/v1/comments', commentsRouter);
app.use('/api/v1/analytics', analyticsRouter);
app.use('/api/v1/chat', chatRouter);
app.use('/api/v1/translate', translateRouter);
app.use('/api', userContentRouter);  // /api/personas, /api/memos
app.use('/api/v1/og', ogRouter);
app.use('/api/v1/admin', adminRouter);
app.use('/api/v1/posts', postsRouter);
app.use('/api/v1/images', imagesRouter);
app.use('/api/v1/auth', authRouter);
app.use('/api/v1/rag', ragRouter);
app.use('/api/v1/admin/config', configRouter);
app.use('/api/v1/admin/workers', workersRouter);
app.use('/api/v1/admin/ai', aiAdminRouter);
app.use('/api/v1/agent', agentRouter);

// not found
app.use((req, res) => {
  res.status(404).json({ ok: false, error: 'Not Found' });
});

// error handler

app.use((err, req, res, next) => {
  const status = err.status || 500;
  res.status(status).json({ ok: false, error: err.message || 'Server Error' });
});

const port = config.port;
const host = config.host;
app.listen(port, host, () => {
  console.log(`[api] listening on http://${host}:${port}`);
});

```

---

## backend/src/lib

### ai-serve.js

**Path:** `backend/src/lib/ai-serve.js`

```javascript
/**
 * Virtual Agent Service (VAS) Client
 *
 * All LLM calls are routed through the VAS stack:
 *   - vas-core (port 7012): Core OpenCode engine (3 replicas)
 *   - vas-proxy (port 7016): Simplified /auto-chat endpoint (3 replicas)
 *   - vas-admin (port 7080): Token management
 *   - nginx-lb: Load balancer for vas-core and vas-proxy
 *
 * Architecture:
 *   Backend API -> nginx-lb:7016 -> vas-proxy (1-3) -> vas-core (1-3) -> LLM Provider
 *
 * Features:
 *   - Request timeout with AbortController
 *   - Health check before critical operations
 *   - Automatic retry with exponential backoff
 *   - Circuit breaker pattern for fault tolerance
 *
 * Usage:
 *   const vas = new VASClient();
 *   const response = await vas.chat([{ role: 'user', content: 'Hello!' }]);
 *   // or
 *   const text = await vas.generate('Summarize this text...');
 */

import { config } from '../config.js';

/**
 * Structured logger for VAS Client
 * Provides consistent log format with context
 */
const logger = {
  _format(level, context, message, data = {}) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      service: 'vas-client',
      ...context,
      message,
      ...data,
    };
    return JSON.stringify(logEntry);
  },

  info(context, message, data) {
    console.log(this._format('info', context, message, data));
  },

  warn(context, message, data) {
    console.warn(this._format('warn', context, message, data));
  },

  error(context, message, data) {
    console.error(this._format('error', context, message, data));
  },

  debug(context, message, data) {
    if (process.env.DEBUG_VAS === 'true') {
      console.debug(this._format('debug', context, message, data));
    }
  },
};

// Default configuration - points to nginx-lb (load balancer)
const AI_SERVE_BASE_URL = process.env.AI_SERVE_BASE_URL || 'http://nginx-lb:7016';
const VAS_CORE_URL = process.env.VAS_CORE_URL || 'http://nginx-lb:7012';
const AI_SERVE_DEFAULT_PROVIDER = process.env.AI_SERVE_DEFAULT_PROVIDER || 'github-copilot';
const AI_SERVE_DEFAULT_MODEL = process.env.AI_SERVE_DEFAULT_MODEL || 'gpt-4.1';

// Timeout settings (in milliseconds)
const DEFAULT_TIMEOUT = 120000; // 2 minutes for normal requests
const LONG_TIMEOUT = 300000; // 5 minutes for long operations (translation, vision)
const HEALTH_CHECK_TIMEOUT = 5000; // 5 seconds for health checks

// Circuit breaker settings
const CIRCUIT_BREAKER_THRESHOLD = 5; // failures before opening circuit
const CIRCUIT_BREAKER_RESET_TIME = 30000; // 30 seconds before trying again

/**
 * Fetch with timeout support using AbortController
 * @param {string} url - Request URL
 * @param {object} options - Fetch options
 * @param {number} timeout - Timeout in milliseconds
 * @returns {Promise<Response>}
 */
async function fetchWithTimeout(url, options = {}, timeout = DEFAULT_TIMEOUT) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    });
    return response;
  } catch (error) {
    if (error.name === 'AbortError') {
      throw new Error(`Request timeout after ${timeout}ms: ${url}`);
    }
    throw error;
  } finally {
    clearTimeout(timeoutId);
  }
}

/**
 * Virtual Agent Service (VAS) API Client
 */
export class VASClient {
  constructor(options = {}) {
    // vas-proxy URL for simplified chat (via load balancer)
    this.baseUrl = options.baseUrl || AI_SERVE_BASE_URL;
    // Direct vas-core URL for advanced operations (via load balancer)
    this.vasCoreUrl = options.vasCoreUrl || VAS_CORE_URL;
    this.defaultProvider = options.provider || AI_SERVE_DEFAULT_PROVIDER;
    this.defaultModel = options.model || AI_SERVE_DEFAULT_MODEL;

    // Circuit breaker state
    this._circuitState = {
      failures: 0,
      lastFailure: 0,
      isOpen: false,
    };

    // Health check cache
    this._healthCache = {
      lastCheck: 0,
      isHealthy: false,
      cacheDuration: 10000, // 10 seconds
    };
  }

  /**
   * Check if circuit breaker is open
   * @returns {boolean}
   */
  _isCircuitOpen() {
    if (!this._circuitState.isOpen) return false;

    // Check if enough time has passed to try again
    const now = Date.now();
    if (now - this._circuitState.lastFailure > CIRCUIT_BREAKER_RESET_TIME) {
      this._circuitState.isOpen = false;
      this._circuitState.failures = 0;
      return false;
    }

    return true;
  }

  /**
   * Record a failure for circuit breaker
   */
  _recordFailure() {
    this._circuitState.failures++;
    this._circuitState.lastFailure = Date.now();

    if (this._circuitState.failures >= CIRCUIT_BREAKER_THRESHOLD) {
      this._circuitState.isOpen = true;
      logger.warn(
        { operation: 'circuit_breaker' },
        'Circuit breaker opened due to repeated failures',
        { failures: this._circuitState.failures, threshold: CIRCUIT_BREAKER_THRESHOLD }
      );
    }
  }

  /**
   * Record a success, reset circuit breaker
   */
  _recordSuccess() {
    this._circuitState.failures = 0;
    this._circuitState.isOpen = false;
  }

  /**
   * Simple text generation via vas-proxy
   * @param {string} prompt - The prompt text
   * @param {object} options - Options (provider, model, timeout)
   * @returns {Promise<string>} Generated text
   */
  async generate(prompt, options = {}) {
    const requestId = `gen-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const startTime = Date.now();

    if (this._isCircuitOpen()) {
      logger.warn(
        { operation: 'generate', requestId },
        'Request blocked by circuit breaker'
      );
      throw new Error('AI service temporarily unavailable (circuit breaker open)');
    }

    const provider = options.provider || this.defaultProvider;
    const model = options.model || this.defaultModel;
    const timeout = options.timeout || DEFAULT_TIMEOUT;

    logger.debug(
      { operation: 'generate', requestId },
      'Starting generation request',
      { provider, model, promptLength: prompt?.length, timeout }
    );

    try {
      const response = await fetchWithTimeout(
        `${this.baseUrl}/auto-chat`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: prompt,
            providerID: provider,
            modelID: model,
            title: `backend-generate-${Date.now()}`,
          }),
        },
        timeout
      );

      if (!response.ok) {
        const error = await response.text().catch(() => '');
        throw new Error(`AI generation failed: ${response.status} ${error}`);
      }

      const data = await response.json();
      const duration = Date.now() - startTime;

      this._recordSuccess();

      logger.info(
        { operation: 'generate', requestId },
        'Generation completed successfully',
        { provider, model, duration, responseLength: data.response?.text?.length || 0 }
      );

      return data.response?.text || '';
    } catch (error) {
      const duration = Date.now() - startTime;
      this._recordFailure();

      logger.error(
        { operation: 'generate', requestId },
        'Generation failed',
        {
          provider,
          model,
          duration,
          error: error.message,
          circuitState: this.getCircuitState(),
        }
      );

      throw error;
    }
  }

  /**
   * Chat completion with message history via vas-proxy
   * @param {Array<{role: string, content: string}>} messages - Chat messages
   * @param {object} options - Options (provider, model, timeout)
   * @returns {Promise<{content: string, model: string, provider: string}>}
   */
  async chat(messages, options = {}) {
    const requestId = `chat-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const startTime = Date.now();

    if (this._isCircuitOpen()) {
      logger.warn(
        { operation: 'chat', requestId },
        'Request blocked by circuit breaker'
      );
      throw new Error('AI service temporarily unavailable (circuit breaker open)');
    }

    const provider = options.provider || this.defaultProvider;
    const model = options.model || this.defaultModel;
    const timeout = options.timeout || DEFAULT_TIMEOUT;

    logger.debug(
      { operation: 'chat', requestId },
      'Starting chat request',
      { provider, model, messageCount: messages?.length, timeout }
    );

    // For chat with history, format messages into a single prompt
    // vas-proxy creates a new session per request
    let prompt;
    if (messages.length === 1) {
      prompt = messages[0].content;
    } else {
      // Format conversation history
      const formatted = messages.map((m) => {
        const role = m.role === 'assistant' ? 'Assistant' : 'User';
        return `${role}: ${m.content}`;
      }).join('\n\n');
      prompt = formatted;
    }

    try {
      const response = await fetchWithTimeout(
        `${this.baseUrl}/auto-chat`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: prompt,
            providerID: provider,
            modelID: model,
            title: `backend-chat-${Date.now()}`,
          }),
        },
        timeout
      );

      if (!response.ok) {
        const error = await response.text().catch(() => '');
        throw new Error(`AI chat failed: ${response.status} ${error}`);
      }

      const data = await response.json();
      const duration = Date.now() - startTime;

      this._recordSuccess();

      logger.info(
        { operation: 'chat', requestId },
        'Chat completed successfully',
        {
          provider,
          model,
          duration,
          sessionId: data.sessionId,
          responseLength: data.response?.text?.length || 0,
        }
      );

      return {
        content: data.response?.text || '',
        model,
        provider,
        sessionId: data.sessionId,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      this._recordFailure();

      logger.error(
        { operation: 'chat', requestId },
        'Chat failed',
        {
          provider,
          model,
          duration,
          messageCount: messages?.length,
          error: error.message,
          circuitState: this.getCircuitState(),
        }
      );

      throw error;
    }
  }

  /**
   * Vision analysis with image
   * @param {string} imageBase64 - Base64 encoded image
   * @param {string} mimeType - Image MIME type
   * @param {string} prompt - Analysis prompt
   * @param {object} options - Options
   * @returns {Promise<string>} Analysis result
   */
  async vision(imageBase64, mimeType, prompt, options = {}) {
    const requestId = `vision-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

    logger.info(
      { operation: 'vision', requestId },
      'Starting vision analysis',
      { mimeType, imageSize: imageBase64?.length, promptLength: prompt?.length }
    );

    // Include image as data URL in the message
    const imageDataUrl = `data:${mimeType};base64,${imageBase64}`;
    const fullPrompt = `[Image: ${imageDataUrl}]\n\n${prompt}`;

    // Use vision-capable model with longer timeout
    return this.generate(fullPrompt, {
      ...options,
      model: options.model || 'gpt-4o',
      timeout: options.timeout || LONG_TIMEOUT,
    });
  }

  /**
   * Health check - checks vas-proxy health (with caching)
   * @param {boolean} force - Force fresh check, ignore cache
   * @returns {Promise<{ok: boolean, status: object}>}
   */
  async health(force = false) {
    const now = Date.now();

    // Return cached result if still valid
    if (!force && now - this._healthCache.lastCheck < this._healthCache.cacheDuration) {
      return {
        ok: this._healthCache.isHealthy,
        cached: true,
        status: this._healthCache.status,
      };
    }

    try {
      const response = await fetchWithTimeout(
        `${this.baseUrl}/health`,
        {},
        HEALTH_CHECK_TIMEOUT
      );

      if (!response.ok) {
        this._healthCache.isHealthy = false;
        this._healthCache.lastCheck = now;
        return { ok: false, error: `Status ${response.status}` };
      }

      const data = await response.json();
      const isHealthy = data.status === 'ok' && data.tokenReady;

      this._healthCache.isHealthy = isHealthy;
      this._healthCache.lastCheck = now;
      this._healthCache.status = data;

      return {
        ok: isHealthy,
        status: data,
      };
    } catch (err) {
      this._healthCache.isHealthy = false;
      this._healthCache.lastCheck = now;

      logger.warn(
        { operation: 'health' },
        'Health check failed',
        { error: err.message }
      );

      return { ok: false, error: err.message };
    }
  }

  /**
   * Status check - gets detailed status from vas-proxy
   * @returns {Promise<{ok: boolean, status: object}>}
   */
  async status() {
    try {
      const response = await fetchWithTimeout(
        `${this.baseUrl}/status`,
        {},
        HEALTH_CHECK_TIMEOUT
      );

      if (!response.ok) {
        return { ok: false, error: `Status ${response.status}` };
      }

      const data = await response.json();
      return { ok: true, status: data };
    } catch (err) {
      return { ok: false, error: err.message };
    }
  }

  /**
   * Load balancer status - check nginx-lb health
   * @returns {Promise<{ok: boolean, status: object}>}
   */
  async lbStatus() {
    try {
      const response = await fetchWithTimeout(
        `${this.baseUrl}/lb-status`,
        {},
        HEALTH_CHECK_TIMEOUT
      );

      if (!response.ok) {
        return { ok: false, error: `Status ${response.status}` };
      }

      const data = await response.json();
      return { ok: true, status: data };
    } catch (err) {
      return { ok: false, error: err.message };
    }
  }

  /**
   * Get available providers from vas-core directly
   * @returns {Promise<{providers: Array}>}
   */
  async providers() {
    const response = await fetchWithTimeout(
      `${this.vasCoreUrl}/config/providers`,
      {},
      HEALTH_CHECK_TIMEOUT
    );

    if (!response.ok) {
      throw new Error(`Failed to get providers: ${response.status}`);
    }

    return response.json();
  }

  /**
   * Get circuit breaker state (for monitoring)
   * @returns {object}
   */
  getCircuitState() {
    return {
      isOpen: this._circuitState.isOpen,
      failures: this._circuitState.failures,
      lastFailure: this._circuitState.lastFailure,
      threshold: CIRCUIT_BREAKER_THRESHOLD,
      resetTime: CIRCUIT_BREAKER_RESET_TIME,
    };
  }
}

// Legacy alias for backward compatibility
export const AIServeClient = VASClient;

// Singleton instance
let _client = null;

/**
 * Get the default VAS client instance
 * @returns {VASClient}
 */
export function getVASClient() {
  if (!_client) {
    _client = new VASClient();
  }
  return _client;
}

// Legacy alias for backward compatibility
export const getAIServeClient = getVASClient;

/**
 * Legacy compatibility: generateContent function
 * Drop-in replacement for the old Gemini generateContent
 *
 * @param {string} prompt - The prompt text
 * @param {object} options - Options (temperature is noted but not directly used)
 * @returns {Promise<string>} Generated text
 */
export async function generateContent(prompt, options = {}) {
  const client = getVASClient();
  return client.generate(prompt, options);
}

/**
 * Legacy compatibility: tryParseJson function
 * Attempts to parse JSON from AI response text
 */
export function tryParseJson(text) {
  if (!text) return null;
  try {
    return JSON.parse(text);
  } catch {
    // empty
  }
  const fence = text.match(/```json\s*([\s\S]*?)```/i);
  if (fence && fence[1]) {
    try {
      return JSON.parse(fence[1]);
    } catch {
      // empty
    }
  }
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start >= 0 && end > start) {
    const maybe = text.slice(start, end + 1);
    try {
      return JSON.parse(maybe);
    } catch {
      // empty
    }
  }
  return null;
}

export default VASClient;

```

### ai-service.js

**Path:** `backend/src/lib/ai-service.js`

```javascript
/**
 * Unified AI Service
 *
 * Provider-agnostic AI interface that supports multiple backends:
 *   - LiteLLM (OpenAI-compatible gateway) - Recommended
 *   - VAS (GitHub Copilot) - Legacy
 *   - Gemini (Direct API) - Legacy
 *
 * Architecture:
 *   Route -> AIService -> Provider Client -> External API
 *
 * Configuration priority:
 *   1. AI_PROVIDER env var ('litellm', 'vas', 'gemini')
 *   2. Default: 'litellm' if LITELLM_BASE_URL is set, otherwise 'vas'
 *
 * Usage:
 *   import { aiService } from './lib/ai-service.js';
 *
 *   // Simple generation
 *   const text = await aiService.generate('Summarize this text...');
 *
 *   // Chat with messages
 *   const response = await aiService.chat([
 *     { role: 'system', content: 'You are a helpful assistant.' },
 *     { role: 'user', content: 'Hello!' }
 *   ]);
 *
 *   // Structured task (sketch, prism, chain)
 *   const result = await aiService.task('sketch', { paragraph: '...' });
 */

import { config } from '../config.js';
import { getLiteLLMClient, tryParseJson as litellmTryParse } from './litellm-client.js';
import { getVASClient, tryParseJson as vasTryParse } from './ai-serve.js';
import { generateContent as geminiGenerate, tryParseJson as geminiTryParse } from './gemini.js';
import { logAIUsage } from './ai-usage-logger.js';

// ============================================================================
// Configuration
// ============================================================================

/**
 * Determine the active AI provider based on environment
 */
function getActiveProvider() {
  const explicit = process.env.AI_PROVIDER?.toLowerCase();
  
  if (explicit) {
    if (['litellm', 'vas', 'gemini', 'openai'].includes(explicit)) {
      return explicit === 'openai' ? 'litellm' : explicit;
    }
    console.warn(`[AIService] Unknown AI_PROVIDER "${explicit}", using default`);
  }
  
  // Auto-detect based on available configuration
  if (config.ai?.gateway?.baseUrl || process.env.LITELLM_BASE_URL) {
    return 'litellm';
  }
  
  if (process.env.AI_SERVE_BASE_URL || process.env.VAS_CORE_URL) {
    return 'vas';
  }
  
  if (config.gemini?.apiKey) {
    return 'gemini';
  }
  
  return 'litellm'; // Default
}

// ============================================================================
// Logger
// ============================================================================

const logger = {
  _format(level, context, message, data = {}) {
    return JSON.stringify({
      timestamp: new Date().toISOString(),
      level,
      service: 'ai-service',
      ...context,
      message,
      ...data,
    });
  },
  info(ctx, msg, data) { console.log(this._format('info', ctx, msg, data)); },
  warn(ctx, msg, data) { console.warn(this._format('warn', ctx, msg, data)); },
  error(ctx, msg, data) { console.error(this._format('error', ctx, msg, data)); },
  debug(ctx, msg, data) {
    if (process.env.DEBUG_AI === 'true') {
      console.debug(this._format('debug', ctx, msg, data));
    }
  },
};

// ============================================================================
// Unified AI Service Class
// ============================================================================

export class AIService {
  constructor() {
    this.provider = getActiveProvider();
    this._client = null;
    
    logger.info(
      { operation: 'init' },
      `AIService initialized with provider: ${this.provider}`
    );
  }

  /**
   * Get or create the appropriate client
   */
  _getClient() {
    if (this._client) return this._client;
    
    switch (this.provider) {
      case 'litellm':
        this._client = getLiteLLMClient();
        break;
      case 'vas':
        this._client = getVASClient();
        break;
      case 'gemini':
        // Gemini uses direct function, no client object
        this._client = null;
        break;
      default:
        throw new Error(`Unknown AI provider: ${this.provider}`);
    }
    
    return this._client;
  }

  /**
   * Generate text from a prompt
   *
   * @param {string} prompt - The prompt text
   * @param {object} options - { temperature, model, systemPrompt, timeout }
   * @returns {Promise<string>} Generated text
   */
  async generate(prompt, options = {}) {
    const requestId = `gen-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const startTime = Date.now();

    logger.debug(
      { operation: 'generate', requestId, provider: this.provider },
      'Starting generation',
      { promptLength: prompt?.length }
    );

    try {
      let result;

      switch (this.provider) {
        case 'litellm': {
          const client = this._getClient();
          result = await client.generate(prompt, {
            temperature: options.temperature,
            model: options.model,
            systemPrompt: options.systemPrompt,
            timeout: options.timeout,
          });
          break;
        }

        case 'vas': {
          const client = this._getClient();
          // VAS doesn't support system prompt directly, prepend to prompt
          const fullPrompt = options.systemPrompt
            ? `${options.systemPrompt}\n\n${prompt}`
            : prompt;
          result = await client.generate(fullPrompt, {
            model: options.model,
            timeout: options.timeout,
          });
          break;
        }

        case 'gemini': {
          const fullPrompt = options.systemPrompt
            ? `${options.systemPrompt}\n\n${prompt}`
            : prompt;
          result = await geminiGenerate(fullPrompt, {
            temperature: options.temperature ?? 0.2,
          });
          break;
        }

        default:
          throw new Error(`Unsupported provider: ${this.provider}`);
      }

      const duration = Date.now() - startTime;
      logger.info(
        { operation: 'generate', requestId, provider: this.provider },
        'Generation completed',
        { duration, resultLength: result?.length }
      );

      // Log usage asynchronously (fire and forget)
      logAIUsage({
        modelName: options.model || this._getDefaultModel(),
        requestType: 'completion',
        promptTokens: this._estimateTokens(prompt),
        completionTokens: this._estimateTokens(result),
        latencyMs: duration,
        status: 'success',
        metadata: { requestId, provider: this.provider },
      }).catch(() => {}); // Silently ignore logging errors

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      logger.error(
        { operation: 'generate', requestId, provider: this.provider },
        'Generation failed',
        { duration, error: error.message }
      );

      // Log failed request
      logAIUsage({
        modelName: options.model || this._getDefaultModel(),
        requestType: 'completion',
        promptTokens: this._estimateTokens(prompt),
        latencyMs: duration,
        status: 'error',
        errorMessage: error.message,
        metadata: { requestId, provider: this.provider },
      }).catch(() => {});

      throw error;
    }
  }

  /**
   * Chat completion with message history
   *
   * @param {Array<{role: string, content: string}>} messages
   * @param {object} options - { temperature, model, timeout }
   * @returns {Promise<{content: string, model: string, provider: string}>}
   */
  async chat(messages, options = {}) {
    const requestId = `chat-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const startTime = Date.now();

    logger.debug(
      { operation: 'chat', requestId, provider: this.provider },
      'Starting chat',
      { messageCount: messages?.length }
    );

    try {
      let result;

      switch (this.provider) {
        case 'litellm': {
          const client = this._getClient();
          try {
            const response = await client.chat(messages, {
              temperature: options.temperature,
              model: options.model,
              timeout: options.timeout,
            });
            result = {
              content: response.content,
              model: response.model,
              provider: 'litellm',
              usage: response.usage,
            };
          } catch (litellmError) {
            // Fallback to Gemini if LiteLLM fails and Gemini is configured
            if (config.gemini?.apiKey) {
              logger.warn(
                { operation: 'chat', requestId },
                'LiteLLM failed, falling back to Gemini',
                { error: litellmError.message }
              );
              const formattedMessages = messages.map(m => {
                if (m.role === 'system') return `System: ${m.content}`;
                if (m.role === 'assistant') return `Assistant: ${m.content}`;
                return `User: ${m.content}`;
              }).join('\n\n');
              const response = await geminiGenerate(formattedMessages, {
                temperature: options.temperature ?? 0.2,
              });
              result = {
                content: response,
                model: config.gemini?.model || 'gemini-1.5-flash',
                provider: 'gemini-fallback',
              };
            } else {
              throw litellmError;
            }
          }
          break;
        }

        case 'vas': {
          const client = this._getClient();
          const response = await client.chat(messages, {
            model: options.model,
            timeout: options.timeout,
          });
          result = {
            content: response.content,
            model: response.model,
            provider: 'vas',
          };
          break;
        }

        case 'gemini': {
          // Gemini: format messages into a single prompt
          const formattedMessages = messages.map(m => {
            if (m.role === 'system') return `System: ${m.content}`;
            if (m.role === 'assistant') return `Assistant: ${m.content}`;
            return `User: ${m.content}`;
          }).join('\n\n');

          const response = await geminiGenerate(formattedMessages, {
            temperature: options.temperature ?? 0.2,
          });

          result = {
            content: response,
            model: config.gemini?.model || 'gemini-1.5-flash',
            provider: 'gemini',
          };
          break;
        }

        default:
          throw new Error(`Unsupported provider: ${this.provider}`);
      }

      const duration = Date.now() - startTime;
      logger.info(
        { operation: 'chat', requestId, provider: this.provider },
        'Chat completed',
        { duration, resultLength: result?.content?.length }
      );

      // Log usage asynchronously with actual token counts if available
      logAIUsage({
        modelName: result.model || options.model || this._getDefaultModel(),
        requestType: 'chat',
        promptTokens: result.usage?.prompt_tokens || this._estimateTokens(JSON.stringify(messages)),
        completionTokens: result.usage?.completion_tokens || this._estimateTokens(result.content),
        latencyMs: duration,
        status: 'success',
        metadata: { requestId, provider: this.provider },
      }).catch(() => {});

      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      logger.error(
        { operation: 'chat', requestId, provider: this.provider },
        'Chat failed',
        { duration, error: error.message }
      );

      // Log failed request
      logAIUsage({
        modelName: options.model || this._getDefaultModel(),
        requestType: 'chat',
        promptTokens: this._estimateTokens(JSON.stringify(messages)),
        latencyMs: duration,
        status: 'error',
        errorMessage: error.message,
        metadata: { requestId, provider: this.provider },
      }).catch(() => {});

      throw error;
    }
  }

  /**
   * Vision analysis with image
   *
   * @param {string} imageData - Base64 encoded image or URL
   * @param {string} prompt - Analysis prompt
   * @param {object} options - { mimeType, model, timeout }
   * @returns {Promise<string>} Analysis result
   */
  async vision(imageData, prompt, options = {}) {
    const mimeType = options.mimeType || 'image/jpeg';

    switch (this.provider) {
      case 'litellm': {
        const client = this._getClient();
        // Construct image URL
        const imageUrl = imageData.startsWith('data:')
          ? imageData
          : imageData.startsWith('http')
          ? imageData
          : `data:${mimeType};base64,${imageData}`;

        return client.vision(imageUrl, prompt, {
          model: options.model || 'gpt-4o',
          timeout: options.timeout,
        });
      }

      case 'vas': {
        const client = this._getClient();
        return client.vision(imageData, mimeType, prompt, {
          model: options.model,
          timeout: options.timeout,
        });
      }

      case 'gemini': {
        // Gemini vision requires specific API
        throw new Error('Vision not supported for Gemini in this implementation');
      }

      default:
        throw new Error(`Vision not supported for provider: ${this.provider}`);
    }
  }

  /**
   * Streaming generation
   *
   * @param {string} prompt - The prompt text
   * @param {object} options
   * @yields {string} Text chunks
   */
  async *stream(prompt, options = {}) {
    if (this.provider !== 'litellm') {
      // For non-LiteLLM providers, generate full text and chunk it
      const text = await this.generate(prompt, options);
      const chunkSize = 80;
      for (let i = 0; i < text.length; i += chunkSize) {
        yield text.slice(i, Math.min(i + chunkSize, text.length));
        await new Promise(r => setTimeout(r, 25));
      }
      return;
    }

    const client = this._getClient();
    const messages = options.systemPrompt
      ? [
          { role: 'system', content: options.systemPrompt },
          { role: 'user', content: prompt },
        ]
      : [{ role: 'user', content: prompt }];

    yield* client.stream(messages, {
      temperature: options.temperature,
      model: options.model,
      timeout: options.timeout,
    });
  }

  /**
   * Embeddings generation
   *
   * @param {string|string[]} input
   * @param {object} options
   * @returns {Promise<number[][]>}
   */
  async embeddings(input, options = {}) {
    if (this.provider !== 'litellm') {
      throw new Error(`Embeddings not supported for provider: ${this.provider}`);
    }

    const client = this._getClient();
    return client.embeddings(input, options);
  }

  /**
   * Execute a structured AI task (sketch, prism, chain, summary)
   *
   * @param {string} mode - Task mode
   * @param {object} payload - Task-specific payload
   * @param {object} options - { temperature }
   * @returns {Promise<object>} Parsed result
   */
  async task(mode, payload, options = {}) {
    const prompts = this._buildTaskPrompt(mode, payload);
    const temperature = options.temperature ?? this._getTaskTemperature(mode);

    try {
      const text = await this.generate(prompts.user, {
        systemPrompt: prompts.system,
        temperature,
      });

      const json = this.tryParseJson(text);
      if (json && typeof json === 'object') {
        return { ok: true, data: json };
      }

      // Fallback data
      return { ok: true, data: this._getFallbackData(mode, payload) };
    } catch (error) {
      logger.warn(
        { operation: 'task', mode },
        'Task generation failed, using fallback',
        { error: error.message }
      );
      return { ok: true, data: this._getFallbackData(mode, payload) };
    }
  }

  /**
   * Build prompt for structured task
   */
  _buildTaskPrompt(mode, payload) {
    const { paragraph, postTitle, persona, content, prompt: userPrompt } = payload;
    const truncated = this._safeTruncate(paragraph || content || '', 1600);
    const titleTrunc = this._safeTruncate(postTitle || '', 120);

    switch (mode) {
      case 'sketch':
        return {
          system: 'You are a helpful writing companion. Return STRICT JSON only.',
          user: [
            '{"mood":"string","bullets":["string", "string", "..."]}',
            '',
            `Persona: ${persona || 'default'}`,
            `Post: ${titleTrunc}`,
            'Paragraph:',
            truncated,
            '',
            'Task: Capture the emotional sketch. Select a concise mood (e.g., curious, excited, skeptical) and 3-6 short bullets in the original language.',
          ].join('\n'),
        };

      case 'prism':
        return {
          system: 'Return STRICT JSON only for idea facets.',
          user: [
            '{"facets":[{"title":"string","points":["string","string"]}]}',
            `Post: ${titleTrunc}`,
            'Paragraph:',
            truncated,
            '',
            'Task: Provide 2-3 facets (titles) with 2-4 concise points each, in the original language.',
          ].join('\n'),
        };

      case 'chain':
        return {
          system: 'Return STRICT JSON only for follow-up questions.',
          user: [
            '{"questions":[{"q":"string","why":"string"}]}',
            `Post: ${titleTrunc}`,
            'Paragraph:',
            truncated,
            '',
            'Task: Generate 3-5 short follow-up questions and a brief why for each, in the original language.',
          ].join('\n'),
        };

      case 'summary':
        return {
          system: userPrompt || 'You are a helpful assistant that summarizes text concisely.',
          user: `Summarize the following content in Korean, concise but faithful to key points.\n\n${truncated}`,
        };

      default:
        return {
          system: 'You are a helpful assistant.',
          user: truncated,
        };
    }
  }

  /**
   * Get fallback data for task mode
   */
  _getFallbackData(mode, payload) {
    const paragraph = payload.paragraph || payload.content || '';

    switch (mode) {
      case 'sketch': {
        const sentences = paragraph
          .replace(/\n+/g, ' ')
          .split(/[.!?]\s+/)
          .map(s => s.trim())
          .filter(Boolean);
        return {
          mood: 'curious',
          bullets: sentences.slice(0, 4).map(s =>
            s.length > 140 ? `${s.slice(0, 138)}…` : s
          ),
        };
      }

      case 'prism':
        return {
          facets: [
            { title: '핵심 요점', points: [this._safeTruncate(paragraph, 140)] },
            { title: '생각해볼 점', points: ['관점 A', '관점 B'] },
          ],
        };

      case 'chain':
        return {
          questions: [
            { q: '무엇이 핵심 주장인가?', why: '핵심을 명료화' },
            { q: '어떤 가정이 있는가?', why: '숨은 전제 확인' },
            { q: '적용 예시는?', why: '구체화' },
          ],
        };

      case 'summary':
        return { summary: this._safeTruncate(paragraph, 200) };

      default:
        return { text: paragraph };
    }
  }

  /**
   * Get temperature for task mode
   */
  _getTaskTemperature(mode) {
    const temps = {
      sketch: 0.3,
      prism: 0.2,
      chain: 0.2,
      summary: 0.2,
    };
    return temps[mode] ?? 0.2;
  }

  /**
   * Safely truncate string
   */
  _safeTruncate(s, n) {
    if (!s) return s;
    return s.length > n ? `${s.slice(0, n)}\n…(truncated)` : s;
  }

  /**
   * Try to parse JSON from AI response
   */
  tryParseJson(text) {
    // Use provider-specific parser or generic one
    switch (this.provider) {
      case 'litellm':
        return litellmTryParse(text);
      case 'vas':
        return vasTryParse(text);
      case 'gemini':
        return geminiTryParse(text);
      default:
        return this._genericTryParseJson(text);
    }
  }

  _genericTryParseJson(text) {
    if (!text) return null;

    try {
      return JSON.parse(text);
    } catch { /* continue */ }

    const fence = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
    if (fence?.[1]) {
      try {
        return JSON.parse(fence[1].trim());
      } catch { /* continue */ }
    }

    const start = text.indexOf('{');
    const end = text.lastIndexOf('}');
    if (start >= 0 && end > start) {
      try {
        return JSON.parse(text.slice(start, end + 1));
      } catch { /* continue */ }
    }

    return null;
  }

  /**
   * Estimate token count from text (rough approximation: ~4 chars per token)
   */
  _estimateTokens(text) {
    if (!text) return 0;
    return Math.ceil(text.length / 4);
  }

  /**
   * Get default model name based on provider
   */
  _getDefaultModel() {
    switch (this.provider) {
      case 'litellm':
        return config.ai?.gateway?.defaultModel || 'gpt-4o-mini';
      case 'vas':
        return process.env.AI_SERVE_DEFAULT_MODEL || 'gpt-4o';
      case 'gemini':
        return config.gemini?.model || 'gemini-1.5-flash';
      default:
        return 'unknown';
    }
  }

  /**
   * Health check
   */
  async health(force = false) {
    switch (this.provider) {
      case 'litellm': {
        const client = this._getClient();
        return client.health(force);
      }

      case 'vas': {
        const client = this._getClient();
        return client.health(force);
      }

      case 'gemini': {
        // Gemini: simple check if API key exists
        return {
          ok: !!config.gemini?.apiKey,
          provider: 'gemini',
          status: config.gemini?.apiKey ? 'configured' : 'missing_key',
        };
      }

      default:
        return { ok: false, error: `Unknown provider: ${this.provider}` };
    }
  }

  /**
   * Get current provider info
   */
  getProviderInfo() {
    return {
      provider: this.provider,
      config: {
        litellm: {
          baseUrl: config.ai?.gateway?.baseUrl,
          model: config.ai?.gateway?.defaultModel,
        },
        vas: {
          baseUrl: process.env.AI_SERVE_BASE_URL,
          model: process.env.AI_SERVE_DEFAULT_MODEL,
        },
        gemini: {
          model: config.gemini?.model,
          hasKey: !!config.gemini?.apiKey,
        },
      },
    };
  }
}

// ============================================================================
// Singleton & Exports
// ============================================================================

let _service = null;

/**
 * Get the singleton AIService instance
 */
export function getAIService() {
  if (!_service) {
    _service = new AIService();
  }
  return _service;
}

/**
 * Create AIService with specific provider (for testing)
 */
export function createAIService(provider) {
  process.env.AI_PROVIDER = provider;
  _service = null;
  return getAIService();
}

// Default singleton instance
export const aiService = getAIService();

// Legacy compatibility exports
export { tryParseJson } from './litellm-client.js';

export default AIService;

```

### ai-usage-logger.js

**Path:** `backend/src/lib/ai-usage-logger.js`

```javascript
/**
 * AI Usage Logger
 * 
 * Logs AI usage to D1 database for monitoring and analytics.
 * Works asynchronously to not block AI responses.
 */

import { execute, queryOne, isD1Configured } from './d1.js';

/**
 * Log an AI usage event to the database
 * Runs asynchronously and silently fails to not impact AI performance
 */
export async function logAIUsage(data) {
  // Skip if D1 not configured
  if (!isD1Configured()) {
    return;
  }

  try {
    const {
      modelName,
      routeName,
      requestType = 'chat',
      promptTokens = 0,
      completionTokens = 0,
      latencyMs,
      status = 'success',
      errorMessage,
      userId,
      metadata,
    } = data;

    // Lookup model ID by name
    let modelId = null;
    if (modelName) {
      const model = await queryOne(
        'SELECT id, input_cost_per_1k, output_cost_per_1k FROM ai_models WHERE model_name = ?',
        modelName
      );
      if (model) {
        modelId = model.id;
      }
    }

    // Lookup route ID by name
    let routeId = null;
    if (routeName) {
      const route = await queryOne(
        'SELECT id FROM ai_routes WHERE name = ?',
        routeName
      );
      if (route) {
        routeId = route.id;
      }
    }

    // Calculate estimated cost
    let estimatedCost = 0;
    if (modelId) {
      const model = await queryOne(
        'SELECT input_cost_per_1k, output_cost_per_1k FROM ai_models WHERE id = ?',
        modelId
      );
      if (model) {
        estimatedCost =
          ((promptTokens || 0) * (model.input_cost_per_1k || 0)) / 1000 +
          ((completionTokens || 0) * (model.output_cost_per_1k || 0)) / 1000;
      }
    }

    const totalTokens = (promptTokens || 0) + (completionTokens || 0);
    const id = `usage_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

    await execute(
      `INSERT INTO ai_usage_logs (
        id, model_id, route_id, request_type,
        prompt_tokens, completion_tokens, total_tokens,
        estimated_cost, latency_ms, status, error_message, user_id, metadata
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      id,
      modelId,
      routeId,
      requestType,
      promptTokens,
      completionTokens,
      totalTokens,
      estimatedCost,
      latencyMs || null,
      status,
      errorMessage || null,
      userId || null,
      metadata ? JSON.stringify(metadata) : null
    );

    // Update daily aggregation
    const today = new Date().toISOString().split('T')[0];
    if (modelId) {
      // Try to update existing record
      const result = await execute(
        `UPDATE ai_usage_daily SET
          total_requests = total_requests + 1,
          total_prompt_tokens = total_prompt_tokens + ?,
          total_completion_tokens = total_completion_tokens + ?,
          total_tokens = total_tokens + ?,
          total_cost = total_cost + ?,
          success_count = success_count + ?,
          error_count = error_count + ?,
          avg_latency_ms = (avg_latency_ms * (total_requests - 1) + ?) / total_requests
        WHERE date = ? AND model_id = ?`,
        promptTokens,
        completionTokens,
        totalTokens,
        estimatedCost,
        status === 'success' ? 1 : 0,
        status === 'error' ? 1 : 0,
        latencyMs || 0,
        today,
        modelId
      );

      // Insert if doesn't exist
      if (result.changes === 0) {
        await execute(
          `INSERT INTO ai_usage_daily (
            date, model_id, total_requests,
            total_prompt_tokens, total_completion_tokens, total_tokens,
            total_cost, success_count, error_count, avg_latency_ms
          ) VALUES (?, ?, 1, ?, ?, ?, ?, ?, ?, ?)`,
          today,
          modelId,
          promptTokens,
          completionTokens,
          totalTokens,
          estimatedCost,
          status === 'success' ? 1 : 0,
          status === 'error' ? 1 : 0,
          latencyMs || 0
        );
      }
    }
  } catch (err) {
    // Silently fail - logging should not impact AI performance
    console.warn('[AIUsage] Failed to log usage:', err.message);
  }
}

/**
 * Create a usage logger middleware/wrapper for AI clients
 */
export function createUsageLogger(defaultRouteName) {
  return async function logUsage(data) {
    await logAIUsage({
      routeName: defaultRouteName,
      ...data,
    });
  };
}

```

### d1.js

**Path:** `backend/src/lib/d1.js`

```javascript
/**
 * Cloudflare D1 HTTP API Client
 *
 * Uses Cloudflare's REST API to access D1 databases.
 * Requires: CF_ACCOUNT_ID, CF_API_TOKEN, D1_DATABASE_ID
 *
 * API: POST https://api.cloudflare.com/client/v4/accounts/{account_id}/d1/database/{database_id}/query
 */

import { config } from '../config.js';

// Get credentials from environment
const getCredentials = () => {
  const accountId = process.env.CF_ACCOUNT_ID;
  const apiToken = process.env.CF_API_TOKEN;
  const databaseId = process.env.D1_DATABASE_ID;

  if (!accountId || !apiToken || !databaseId) {
    throw new Error(
      'D1 credentials not configured. Set CF_ACCOUNT_ID, CF_API_TOKEN, D1_DATABASE_ID'
    );
  }

  return { accountId, apiToken, databaseId };
};

/**
 * Execute a SQL query against D1
 * @param {string} sql - SQL query
 * @param {...any} params - Query parameters
 * @returns {Promise<{results: any[], meta: any}>}
 */
export async function query(sql, ...params) {
  const { accountId, apiToken, databaseId } = getCredentials();

  const url = `https://api.cloudflare.com/client/v4/accounts/${accountId}/d1/database/${databaseId}/query`;

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${apiToken}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      sql,
      params: params.length > 0 ? params : undefined,
    }),
  });

  if (!response.ok) {
    const text = await response.text();
    throw new Error(`D1 API error (${response.status}): ${text}`);
  }

  const data = await response.json();

  if (!data.success) {
    const errorMsg = data.errors?.map((e) => e.message).join(', ') || 'Unknown error';
    throw new Error(`D1 query failed: ${errorMsg}`);
  }

  // D1 API returns array of results (one per statement)
  const result = data.result?.[0];
  return {
    results: result?.results || [],
    meta: result?.meta || {},
  };
}

/**
 * Query and return all rows
 * @param {string} sql
 * @param {...any} params
 * @returns {Promise<any[]>}
 */
export async function queryAll(sql, ...params) {
  const { results } = await query(sql, ...params);
  return results;
}

/**
 * Query and return first row
 * @param {string} sql
 * @param {...any} params
 * @returns {Promise<any|null>}
 */
export async function queryOne(sql, ...params) {
  const { results } = await query(sql, ...params);
  return results[0] || null;
}

/**
 * Execute a statement (INSERT, UPDATE, DELETE)
 * @param {string} sql
 * @param {...any} params
 * @returns {Promise<{changes: number, lastRowId: number}>}
 */
export async function execute(sql, ...params) {
  const { meta } = await query(sql, ...params);
  return {
    changes: meta.changes || 0,
    lastRowId: meta.last_row_id || 0,
  };
}

/**
 * Check if D1 is configured and available
 * @returns {boolean}
 */
export function isD1Configured() {
  try {
    getCredentials();
    return true;
  } catch {
    return false;
  }
}

/**
 * Test D1 connection
 * @returns {Promise<boolean>}
 */
export async function testConnection() {
  try {
    await queryOne('SELECT 1 as test');
    return true;
  } catch (err) {
    console.error('D1 connection test failed:', err.message);
    return false;
  }
}

```

### firebase.js

**Path:** `backend/src/lib/firebase.js`

```javascript
/**
 * @deprecated Firebase has been replaced by Cloudflare D1
 * 
 * This file is kept for reference only. All Firebase functionality
 * has been migrated to D1. Use the d1.js client instead:
 * 
 *   import { queryAll, execute } from './d1.js';
 * 
 * Migration completed:
 * - Comments: Now stored in D1 `comments` table
 * - Settings: Now stored in D1 `settings` table
 * - Analytics: Now stored in D1 `post_analytics` table
 * 
 * To fully remove Firebase:
 * 1. Delete this file (firebase.js)
 * 2. Remove firebase-admin from package.json
 * 3. Remove FIREBASE_* environment variables
 * 4. Delete workers/scripts/migrate-firestore-to-d1.ts
 * 
 * @see workers/migrations/ for D1 schema definitions
 */

// Throw error if anyone tries to use this deprecated module
export function getDb() {
  throw new Error(
    'Firebase is deprecated. Use Cloudflare D1 instead.\n' +
    'Import from: import { queryAll, execute } from "./d1.js"'
  );
}

export const FieldValue = null;
export const Timestamp = null;

```

### gemini.js

**Path:** `backend/src/lib/gemini.js`

```javascript
import { config } from '../config.js';

export async function generateContent(prompt, { temperature = 0.2 } = {}) {
  const apiKey = config.gemini.apiKey;
  const model = config.gemini.model || 'gemini-1.5-flash';
  if (!apiKey) {
    const err = new Error('Server not configured: GEMINI_API_KEY missing');
    err.status = 500;
    throw err;
  }
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(apiKey)}`;
  const body = {
    contents: [
      {
        role: 'user',
        parts: [{ text: String(prompt || '') }],
      },
    ],
    generationConfig: { temperature },
  };
  const resp = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });
  if (!resp.ok) {
    const details = await resp.text().catch(() => '');
    const err = new Error(
      `Gemini API error(${resp.status}) ${details.slice(0, 400)}`
    );
    err.status = 502;
    throw err;
  }
  const data = await resp.json();
  const summary = (data?.candidates?.[0]?.content?.parts || [])
    .map(p => (p && typeof p === 'object' && 'text' in p ? p.text : ''))
    .filter(Boolean)
    .join('\n');
  return summary;
}

export function tryParseJson(text) {
  if (!text) return null;
  try {
    return JSON.parse(text);
  } catch {}
  const fence = text.match(/```json\s*([\s\S]*?)```/i);
  if (fence && fence[1]) {
    try {
      return JSON.parse(fence[1]);
    } catch {}
  }
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start >= 0 && end > start) {
    const maybe = text.slice(start, end + 1);
    try {
      return JSON.parse(maybe);
    } catch {}
  }
  return null;
}

```

### jwt.js

**Path:** `backend/src/lib/jwt.js`

```javascript
import jwt from 'jsonwebtoken';
import { config } from '../config.js';

export function signJwt(payload, opts = {}) {
  const secret = config.auth.jwtSecret;
  if (!secret) throw Object.assign(new Error('JWT not configured'), { status: 500 });
  return jwt.sign(payload, secret, { expiresIn: config.auth.jwtExpiresIn, ...opts });
}

export function verifyJwt(token) {
  const secret = config.auth.jwtSecret;
  if (!secret) throw Object.assign(new Error('JWT not configured'), { status: 500 });
  return jwt.verify(token, secret);
}

export function isAdminClaims(claims) {
  if (!claims || typeof claims !== 'object') return false;
  return claims.role === 'admin' || claims.sub === 'admin';
}

```

### litellm-client.js

**Path:** `backend/src/lib/litellm-client.js`

```javascript
/**
 * LiteLLM Client - Unified AI Gateway
 *
 * OpenAI-compatible client that routes through LiteLLM proxy.
 * LiteLLM handles all provider switching, fallbacks, and load balancing.
 *
 * Architecture:
 *   Backend API -> LiteLLM (port 4000) -> Any LLM Provider
 *
 * Benefits:
 *   - Single endpoint, single API format (OpenAI-compatible)
 *   - No more provider-specific if/else branches
 *   - Automatic fallback: gpt-4 → gemini → claude
 *   - Load balancing and rate limiting built-in
 *   - Cost tracking and budget management
 *
 * Usage:
 *   const client = getLiteLLMClient();
 *   const response = await client.chat([{ role: 'user', content: 'Hello!' }]);
 *   // or with streaming
 *   for await (const chunk of client.stream([{ role: 'user', content: 'Hello!' }])) {
 *     process.stdout.write(chunk);
 *   }
 */

/**
 * Structured logger for LiteLLM Client
 */
const logger = {
  _format(level, context, message, data = {}) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      service: 'litellm-client',
      ...context,
      message,
      ...data,
    };
    return JSON.stringify(logEntry);
  },

  info(context, message, data) {
    console.log(this._format('info', context, message, data));
  },

  warn(context, message, data) {
    console.warn(this._format('warn', context, message, data));
  },

  error(context, message, data) {
    console.error(this._format('error', context, message, data));
  },

  debug(context, message, data) {
    if (process.env.DEBUG_LITELLM === 'true') {
      console.debug(this._format('debug', context, message, data));
    }
  },
};

// Configuration from environment
const LITELLM_BASE_URL = process.env.LITELLM_BASE_URL || 'http://litellm:4000';
const LITELLM_API_KEY = process.env.LITELLM_API_KEY || 'sk-litellm-master-key';
const DEFAULT_MODEL = process.env.AI_DEFAULT_MODEL || 'gpt-4.1';

// Timeout settings
const DEFAULT_TIMEOUT = 120000; // 2 minutes
const LONG_TIMEOUT = 300000; // 5 minutes for vision/translation
const HEALTH_CHECK_TIMEOUT = 5000; // 5 seconds

// Circuit breaker settings
const CIRCUIT_BREAKER_THRESHOLD = 5;
const CIRCUIT_BREAKER_RESET_TIME = 30000;

/**
 * Fetch with timeout using AbortController
 */
async function fetchWithTimeout(url, options = {}, timeout = DEFAULT_TIMEOUT) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    });
    return response;
  } catch (error) {
    if (error.name === 'AbortError') {
      throw new Error(`Request timeout after ${timeout}ms: ${url}`);
    }
    throw error;
  } finally {
    clearTimeout(timeoutId);
  }
}

/**
 * LiteLLM API Client (OpenAI-compatible)
 */
export class LiteLLMClient {
  constructor(options = {}) {
    this.baseUrl = options.baseUrl || LITELLM_BASE_URL;
    this.apiKey = options.apiKey || LITELLM_API_KEY;
    this.defaultModel = options.model || DEFAULT_MODEL;

    // Circuit breaker state
    this._circuitState = {
      failures: 0,
      lastFailure: 0,
      isOpen: false,
    };

    // Health check cache
    this._healthCache = {
      lastCheck: 0,
      isHealthy: false,
      cacheDuration: 10000,
    };
  }

  /**
   * Get default headers for API requests
   */
  _getHeaders() {
    return {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${this.apiKey}`,
    };
  }

  /**
   * Check if circuit breaker is open
   */
  _isCircuitOpen() {
    if (!this._circuitState.isOpen) return false;

    const now = Date.now();
    if (now - this._circuitState.lastFailure > CIRCUIT_BREAKER_RESET_TIME) {
      this._circuitState.isOpen = false;
      this._circuitState.failures = 0;
      return false;
    }
    return true;
  }

  _recordFailure() {
    this._circuitState.failures++;
    this._circuitState.lastFailure = Date.now();

    if (this._circuitState.failures >= CIRCUIT_BREAKER_THRESHOLD) {
      this._circuitState.isOpen = true;
      logger.warn(
        { operation: 'circuit_breaker' },
        'Circuit breaker opened',
        { failures: this._circuitState.failures }
      );
    }
  }

  _recordSuccess() {
    this._circuitState.failures = 0;
    this._circuitState.isOpen = false;
  }

  /**
   * Chat completion - OpenAI-compatible format
   * @param {Array<{role: string, content: string}>} messages
   * @param {object} options - { model, temperature, max_tokens, ... }
   * @returns {Promise<{content: string, model: string, usage: object}>}
   */
  async chat(messages, options = {}) {
    const requestId = `chat-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const startTime = Date.now();

    if (this._isCircuitOpen()) {
      logger.warn({ operation: 'chat', requestId }, 'Request blocked by circuit breaker');
      throw new Error('AI service temporarily unavailable (circuit breaker open)');
    }

    const model = options.model || this.defaultModel;
    const timeout = options.timeout || DEFAULT_TIMEOUT;

    logger.debug(
      { operation: 'chat', requestId },
      'Starting chat request',
      { model, messageCount: messages?.length }
    );

    try {
      const response = await fetchWithTimeout(
        `${this.baseUrl}/v1/chat/completions`,
        {
          method: 'POST',
          headers: this._getHeaders(),
          body: JSON.stringify({
            model,
            messages,
            temperature: options.temperature ?? 0.7,
            max_tokens: options.max_tokens,
            ...options,
          }),
        },
        timeout
      );

      if (!response.ok) {
        const error = await response.text().catch(() => '');
        throw new Error(`LiteLLM chat failed: ${response.status} ${error}`);
      }

      const data = await response.json();
      const duration = Date.now() - startTime;

      this._recordSuccess();

      logger.info(
        { operation: 'chat', requestId },
        'Chat completed',
        {
          model: data.model,
          duration,
          usage: data.usage,
        }
      );

      return {
        content: data.choices?.[0]?.message?.content || '',
        model: data.model,
        usage: data.usage,
        finishReason: data.choices?.[0]?.finish_reason,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      this._recordFailure();

      logger.error(
        { operation: 'chat', requestId },
        'Chat failed',
        { model, duration, error: error.message }
      );

      throw error;
    }
  }

  /**
   * Simple text generation (convenience wrapper)
   * @param {string} prompt
   * @param {object} options
   * @returns {Promise<string>}
   */
  async generate(prompt, options = {}) {
    const messages = [{ role: 'user', content: prompt }];

    if (options.systemPrompt) {
      messages.unshift({ role: 'system', content: options.systemPrompt });
    }

    const response = await this.chat(messages, options);
    return response.content;
  }

  /**
   * Streaming chat completion
   * @param {Array<{role: string, content: string}>} messages
   * @param {object} options
   * @yields {string} Content chunks
   */
  async *stream(messages, options = {}) {
    const requestId = `stream-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

    if (this._isCircuitOpen()) {
      throw new Error('AI service temporarily unavailable (circuit breaker open)');
    }

    const model = options.model || this.defaultModel;

    logger.debug({ operation: 'stream', requestId }, 'Starting stream', { model });

    const response = await fetchWithTimeout(
      `${this.baseUrl}/v1/chat/completions`,
      {
        method: 'POST',
        headers: this._getHeaders(),
        body: JSON.stringify({
          model,
          messages,
          stream: true,
          temperature: options.temperature ?? 0.7,
          max_tokens: options.max_tokens,
          ...options,
        }),
      },
      options.timeout || DEFAULT_TIMEOUT
    );

    if (!response.ok) {
      const error = await response.text().catch(() => '');
      this._recordFailure();
      throw new Error(`LiteLLM stream failed: ${response.status} ${error}`);
    }

    this._recordSuccess();

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data === '[DONE]') return;

            try {
              const parsed = JSON.parse(data);
              const content = parsed.choices?.[0]?.delta?.content;
              if (content) yield content;
            } catch {
              // Skip invalid JSON
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }

  /**
   * Vision analysis with image
   * @param {string} imageUrl - URL or base64 data URL
   * @param {string} prompt
   * @param {object} options
   * @returns {Promise<string>}
   */
  async vision(imageUrl, prompt, options = {}) {
    const messages = [
      {
        role: 'user',
        content: [
          { type: 'text', text: prompt },
          {
            type: 'image_url',
            image_url: { url: imageUrl },
          },
        ],
      },
    ];

    // Use vision-capable model
    const response = await this.chat(messages, {
      model: options.model || 'gpt-4o',
      timeout: options.timeout || LONG_TIMEOUT,
      ...options,
    });

    return response.content;
  }

  /**
   * Embeddings generation
   * @param {string|string[]} input
   * @param {object} options
   * @returns {Promise<number[][]>}
   */
  async embeddings(input, options = {}) {
    const response = await fetchWithTimeout(
      `${this.baseUrl}/v1/embeddings`,
      {
        method: 'POST',
        headers: this._getHeaders(),
        body: JSON.stringify({
          model: options.model || 'text-embedding-ada-002',
          input: Array.isArray(input) ? input : [input],
        }),
      },
      options.timeout || DEFAULT_TIMEOUT
    );

    if (!response.ok) {
      throw new Error(`LiteLLM embeddings failed: ${response.status}`);
    }

    const data = await response.json();
    return data.data.map((d) => d.embedding);
  }

  /**
   * Health check
   * @param {boolean} force
   * @returns {Promise<{ok: boolean, status: object}>}
   */
  async health(force = false) {
    const now = Date.now();

    if (!force && now - this._healthCache.lastCheck < this._healthCache.cacheDuration) {
      return {
        ok: this._healthCache.isHealthy,
        cached: true,
        status: this._healthCache.status,
      };
    }

    try {
      const response = await fetchWithTimeout(
        `${this.baseUrl}/health`,
        { headers: this._getHeaders() },
        HEALTH_CHECK_TIMEOUT
      );

      const isHealthy = response.ok;
      const status = response.ok ? await response.json().catch(() => ({})) : {};

      this._healthCache.isHealthy = isHealthy;
      this._healthCache.lastCheck = now;
      this._healthCache.status = status;

      return { ok: isHealthy, status };
    } catch (err) {
      this._healthCache.isHealthy = false;
      this._healthCache.lastCheck = now;

      logger.warn({ operation: 'health' }, 'Health check failed', { error: err.message });
      return { ok: false, error: err.message };
    }
  }

  /**
   * List available models
   * @returns {Promise<Array>}
   */
  async models() {
    const response = await fetchWithTimeout(
      `${this.baseUrl}/v1/models`,
      { headers: this._getHeaders() },
      HEALTH_CHECK_TIMEOUT
    );

    if (!response.ok) {
      throw new Error(`Failed to list models: ${response.status}`);
    }

    const data = await response.json();
    return data.data;
  }

  /**
   * Get circuit breaker state
   */
  getCircuitState() {
    return {
      isOpen: this._circuitState.isOpen,
      failures: this._circuitState.failures,
      lastFailure: this._circuitState.lastFailure,
      threshold: CIRCUIT_BREAKER_THRESHOLD,
      resetTime: CIRCUIT_BREAKER_RESET_TIME,
    };
  }
}

// Singleton instance
let _client = null;

/**
 * Get the default LiteLLM client instance
 */
export function getLiteLLMClient() {
  if (!_client) {
    _client = new LiteLLMClient();
  }
  return _client;
}

/**
 * Legacy compatibility: generateContent (drop-in replacement)
 */
export async function generateContent(prompt, options = {}) {
  const client = getLiteLLMClient();
  return client.generate(prompt, options);
}

/**
 * Legacy compatibility: tryParseJson
 */
export function tryParseJson(text) {
  if (!text) return null;

  // Try direct parse
  try {
    return JSON.parse(text);
  } catch {
    // continue
  }

  // Try code fence
  const fence = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fence?.[1]) {
    try {
      return JSON.parse(fence[1].trim());
    } catch {
      // continue
    }
  }

  // Try substring
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start >= 0 && end > start) {
    try {
      return JSON.parse(text.slice(start, end + 1));
    } catch {
      // continue
    }
  }

  return null;
}

export default LiteLLMClient;

```

### markdown.js

**Path:** `backend/src/lib/markdown.js`

```javascript
// Utilities for building and parsing markdown with frontmatter
// Keep logic minimal & deterministic to mirror existing inline implementation
import matter from 'gray-matter';

export function buildFrontmatterMarkdown(frontmatter, body) {
  const fm = frontmatter || {};
  const serialized = Object.entries(fm)
    .map(([k, v]) => {
      if (Array.isArray(v)) {
        return `${k}: [${v.map(x => JSON.stringify(x)).join(', ')}]`;
      }
      return `${k}: ${JSON.stringify(v)}`;
    })
    .join('\n');
  return `---\n${serialized}\n---\n\n${body || ''}\n`;
}

export function parseMarkdown(raw) {
  const { data: frontmatter, content } = matter(raw);
  return { frontmatter, content, raw };
}

```

### r2.js

**Path:** `backend/src/lib/r2.js`

```javascript
/**
 * Cloudflare R2 HTTP API Client
 *
 * Uses Cloudflare's REST API to access R2 storage.
 * Requires: CF_ACCOUNT_ID, CF_API_TOKEN, R2_BUCKET_NAME
 *
 * API: https://api.cloudflare.com/client/v4/accounts/{account_id}/r2/buckets/{bucket_name}/objects/{key}
 */

// Get credentials from environment
const getCredentials = () => {
  const accountId = process.env.CF_ACCOUNT_ID;
  const apiToken = process.env.CF_API_TOKEN;
  const bucketName = process.env.R2_BUCKET_NAME || 'blog';
  const assetsBaseUrl = process.env.R2_ASSETS_BASE_URL || 'https://assets-b.nodove.com';

  if (!accountId || !apiToken) {
    throw new Error('R2 credentials not configured. Set CF_ACCOUNT_ID, CF_API_TOKEN');
  }

  return { accountId, apiToken, bucketName, assetsBaseUrl };
};

/**
 * Check if R2 is configured
 * @returns {boolean}
 */
export function isR2Configured() {
  try {
    getCredentials();
    return true;
  } catch {
    return false;
  }
}

/**
 * Upload a file to R2
 * @param {string} key - Object key (path in bucket)
 * @param {Buffer|ArrayBuffer|Uint8Array} data - File data
 * @param {object} options - Upload options
 * @returns {Promise<{key: string, url: string, size: number}>}
 */
export async function upload(key, data, options = {}) {
  const { accountId, apiToken, bucketName, assetsBaseUrl } = getCredentials();

  const url = `https://api.cloudflare.com/client/v4/accounts/${accountId}/r2/buckets/${bucketName}/objects/${encodeURIComponent(key)}`;

  const headers = {
    Authorization: `Bearer ${apiToken}`,
  };

  if (options.contentType) {
    headers['Content-Type'] = options.contentType;
  }

  const response = await fetch(url, {
    method: 'PUT',
    headers,
    body: data,
  });

  if (!response.ok) {
    const text = await response.text();
    throw new Error(`R2 upload failed (${response.status}): ${text}`);
  }

  const size = data.byteLength || data.length || 0;
  const publicUrl = `${assetsBaseUrl.replace(/\/$/, '')}/${key}`;

  return {
    key,
    url: publicUrl,
    size,
    contentType: options.contentType || 'application/octet-stream',
  };
}

/**
 * Delete an object from R2
 * @param {string} key - Object key
 * @returns {Promise<{deleted: boolean}>}
 */
export async function deleteObject(key) {
  const { accountId, apiToken, bucketName } = getCredentials();

  const url = `https://api.cloudflare.com/client/v4/accounts/${accountId}/r2/buckets/${bucketName}/objects/${encodeURIComponent(key)}`;

  const response = await fetch(url, {
    method: 'DELETE',
    headers: {
      Authorization: `Bearer ${apiToken}`,
    },
  });

  if (!response.ok && response.status !== 404) {
    const text = await response.text();
    throw new Error(`R2 delete failed (${response.status}): ${text}`);
  }

  return { deleted: true };
}

/**
 * Get object metadata from R2
 * @param {string} key - Object key
 * @returns {Promise<object|null>}
 */
export async function head(key) {
  const { accountId, apiToken, bucketName } = getCredentials();

  const url = `https://api.cloudflare.com/client/v4/accounts/${accountId}/r2/buckets/${bucketName}/objects/${encodeURIComponent(key)}`;

  const response = await fetch(url, {
    method: 'HEAD',
    headers: {
      Authorization: `Bearer ${apiToken}`,
    },
  });

  if (response.status === 404) {
    return null;
  }

  if (!response.ok) {
    const text = await response.text();
    throw new Error(`R2 head failed (${response.status}): ${text}`);
  }

  return {
    key,
    size: parseInt(response.headers.get('content-length') || '0', 10),
    contentType: response.headers.get('content-type'),
    etag: response.headers.get('etag'),
  };
}

/**
 * Generate a unique key for uploads
 * @param {string} filename - Original filename
 * @param {string} prefix - Key prefix (e.g., 'ai-chat', 'posts')
 * @returns {string}
 */
export function generateKey(filename, prefix = 'uploads') {
  const sanitized = filename.replace(/[^a-zA-Z0-9._-]/g, '-');
  const timestamp = Date.now();
  const year = new Date().getFullYear();
  return `${prefix}/${year}/${timestamp}-${sanitized}`;
}

```

---

## backend/src/lib/agent

### coordinator.js

**Path:** `backend/src/lib/agent/coordinator.js`

```javascript
/**
 * Agent Coordinator - AI Agent Orchestration Layer
 * 
 * Core orchestration engine that manages:
 *   - Multi-turn conversations with context
 *   - Tool selection and execution (function calling)
 *   - Memory management (session/persistent/vector)
 *   - Task decomposition and planning
 * 
 * Architecture:
 *   Request -> Coordinator -> Tool Selection -> Tool Execution -> Response
 *                   ↓                                    ↑
 *              Memory Store <─────────────────────────────┘
 * 
 * Usage:
 *   const coordinator = getAgentCoordinator();
 *   const response = await coordinator.run({
 *     sessionId: 'user-123',
 *     messages: [{ role: 'user', content: 'Search my blog for AI articles' }],
 *   });
 */

import { getLiteLLMClient } from '../litellm-client.js';
import { getToolRegistry } from './tools/index.js';
import { getSessionMemory } from './memory/session.js';
import { getPersistentMemory } from './memory/persistent.js';
import { getVectorMemory } from './memory/vector.js';
import { SYSTEM_PROMPTS, buildSystemPrompt } from './prompts/system.js';

// ============================================================================
// Configuration
// ============================================================================

const DEFAULT_MODEL = process.env.AGENT_MODEL || 'gpt-4.1';
const MAX_TOOL_ITERATIONS = 10;
const MAX_CONTEXT_MESSAGES = 20;
const TOOL_TIMEOUT = 30000;

// ============================================================================
// Logger
// ============================================================================

const logger = {
  _format(level, context, message, data = {}) {
    return JSON.stringify({
      timestamp: new Date().toISOString(),
      level,
      service: 'agent-coordinator',
      ...context,
      message,
      ...data,
    });
  },
  info(ctx, msg, data) { console.log(this._format('info', ctx, msg, data)); },
  warn(ctx, msg, data) { console.warn(this._format('warn', ctx, msg, data)); },
  error(ctx, msg, data) { console.error(this._format('error', ctx, msg, data)); },
  debug(ctx, msg, data) {
    if (process.env.DEBUG_AGENT === 'true') {
      console.debug(this._format('debug', ctx, msg, data));
    }
  },
};

// ============================================================================
// Agent Coordinator Class
// ============================================================================

export class AgentCoordinator {
  constructor(options = {}) {
    this.llmClient = options.llmClient || getLiteLLMClient();
    this.toolRegistry = options.toolRegistry || getToolRegistry();
    this.sessionMemory = options.sessionMemory || getSessionMemory();
    this.persistentMemory = options.persistentMemory || getPersistentMemory();
    this.vectorMemory = options.vectorMemory || getVectorMemory();
    
    this.defaultModel = options.model || DEFAULT_MODEL;
    this.maxIterations = options.maxIterations || MAX_TOOL_ITERATIONS;
    
    logger.info({ operation: 'init' }, 'AgentCoordinator initialized', {
      model: this.defaultModel,
      toolCount: this.toolRegistry.getToolCount(),
    });
  }

  /**
   * Run the agent with a conversation
   * 
   * @param {object} params
   * @param {string} params.sessionId - Unique session identifier
   * @param {Array} params.messages - Conversation messages
   * @param {string} [params.mode] - Agent mode (default, research, coding, blog)
   * @param {object} [params.context] - Additional context (user info, etc.)
   * @param {object} [params.options] - LLM options (temperature, model)
   * @returns {Promise<{content: string, toolCalls: Array, usage: object}>}
   */
  async run(params) {
    const {
      sessionId,
      messages,
      mode = 'default',
      context = {},
      options = {},
    } = params;

    const runId = `run-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const startTime = Date.now();

    logger.info(
      { operation: 'run', runId, sessionId },
      'Starting agent run',
      { mode, messageCount: messages?.length }
    );

    try {
      // 1. Load session memory and history
      const sessionHistory = await this.sessionMemory.getHistory(sessionId, MAX_CONTEXT_MESSAGES);
      
      // 2. Build context-aware system prompt
      const systemPrompt = await this._buildContextualSystemPrompt(mode, context, sessionId);
      
      // 3. Prepare messages with history
      const fullMessages = this._prepareMessages(systemPrompt, sessionHistory, messages);
      
      // 4. Get relevant memories from vector store
      const relevantMemories = await this._retrieveRelevantMemories(messages, sessionId);
      if (relevantMemories.length > 0) {
        fullMessages.splice(1, 0, {
          role: 'system',
          content: `Relevant context from memory:\n${relevantMemories.map(m => `- ${m.content}`).join('\n')}`,
        });
      }

      // 5. Run agent loop with tools
      const result = await this._runAgentLoop(fullMessages, {
        ...options,
        model: options.model || this.defaultModel,
        runId,
      });

      // 6. Save to session memory
      await this.sessionMemory.addMessages(sessionId, [
        ...messages,
        { role: 'assistant', content: result.content },
      ]);

      // 7. Extract and save important information to persistent memory
      await this._extractAndSaveMemories(result.content, messages, sessionId);

      const duration = Date.now() - startTime;
      logger.info(
        { operation: 'run', runId, sessionId },
        'Agent run completed',
        { duration, toolCalls: result.toolCalls?.length || 0 }
      );

      return {
        ...result,
        sessionId,
        runId,
        duration,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      logger.error(
        { operation: 'run', runId, sessionId },
        'Agent run failed',
        { duration, error: error.message }
      );
      throw error;
    }
  }

  /**
   * Run agent loop with tool execution
   */
  async _runAgentLoop(messages, options) {
    const { runId, model } = options;
    const toolCalls = [];
    let currentMessages = [...messages];
    let iterations = 0;

    while (iterations < this.maxIterations) {
      iterations++;

      logger.debug(
        { operation: 'loop', runId },
        `Agent iteration ${iterations}`,
        { messageCount: currentMessages.length }
      );

      // Call LLM with function calling
      const response = await this._callLLMWithTools(currentMessages, {
        model,
        temperature: options.temperature ?? 0.7,
      });

      // Check if LLM wants to call tools
      if (response.toolCalls && response.toolCalls.length > 0) {
        logger.info(
          { operation: 'tool_call', runId },
          'LLM requested tool calls',
          { tools: response.toolCalls.map(t => t.function.name) }
        );

        // Execute tools
        const toolResults = await this._executeTools(response.toolCalls, runId);
        toolCalls.push(...response.toolCalls.map((tc, i) => ({
          ...tc,
          result: toolResults[i],
        })));

        // Add assistant message with tool calls
        currentMessages.push({
          role: 'assistant',
          content: response.content || null,
          tool_calls: response.toolCalls,
        });

        // Add tool results
        for (let i = 0; i < response.toolCalls.length; i++) {
          currentMessages.push({
            role: 'tool',
            tool_call_id: response.toolCalls[i].id,
            content: JSON.stringify(toolResults[i]),
          });
        }

        // Continue loop to let LLM process tool results
        continue;
      }

      // No more tool calls, return final response
      return {
        content: response.content,
        toolCalls,
        usage: response.usage,
        model: response.model,
        iterations,
      };
    }

    // Max iterations reached
    logger.warn(
      { operation: 'loop', runId },
      'Max iterations reached',
      { iterations: this.maxIterations }
    );

    return {
      content: 'I apologize, but I was unable to complete the task within the allowed iterations. Please try breaking down your request into smaller steps.',
      toolCalls,
      iterations,
      maxIterationsReached: true,
    };
  }

  /**
   * Call LLM with function calling support
   */
  async _callLLMWithTools(messages, options) {
    const tools = this.toolRegistry.getToolDefinitions();
    
    try {
      const response = await fetch(`${this.llmClient.baseUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.llmClient.apiKey}`,
        },
        body: JSON.stringify({
          model: options.model || this.defaultModel,
          messages,
          tools: tools.length > 0 ? tools : undefined,
          tool_choice: tools.length > 0 ? 'auto' : undefined,
          temperature: options.temperature ?? 0.7,
        }),
      });

      if (!response.ok) {
        const error = await response.text().catch(() => '');
        throw new Error(`LLM call failed: ${response.status} ${error}`);
      }

      const data = await response.json();
      const choice = data.choices?.[0];

      return {
        content: choice?.message?.content || '',
        toolCalls: choice?.message?.tool_calls,
        usage: data.usage,
        model: data.model,
        finishReason: choice?.finish_reason,
      };
    } catch (error) {
      logger.error({ operation: 'llm_call' }, 'LLM call failed', { error: error.message });
      throw error;
    }
  }

  /**
   * Execute tool calls
   */
  async _executeTools(toolCalls, runId) {
    const results = [];

    for (const toolCall of toolCalls) {
      const { name, arguments: argsStr } = toolCall.function;
      const toolId = toolCall.id;

      logger.debug(
        { operation: 'tool_exec', runId, toolId },
        `Executing tool: ${name}`
      );

      try {
        const args = JSON.parse(argsStr || '{}');
        const tool = this.toolRegistry.getTool(name);

        if (!tool) {
          results.push({ error: `Tool not found: ${name}` });
          continue;
        }

        // Execute with timeout
        const result = await Promise.race([
          tool.execute(args),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Tool execution timeout')), TOOL_TIMEOUT)
          ),
        ]);

        results.push(result);

        logger.info(
          { operation: 'tool_exec', runId, toolId },
          `Tool ${name} completed`,
          { resultType: typeof result }
        );
      } catch (error) {
        logger.error(
          { operation: 'tool_exec', runId, toolId },
          `Tool ${name} failed`,
          { error: error.message }
        );
        results.push({ error: error.message });
      }
    }

    return results;
  }

  /**
   * Build contextual system prompt
   */
  async _buildContextualSystemPrompt(mode, context, sessionId) {
    // Get user preferences from persistent memory
    const userPrefs = await this.persistentMemory.getUserPreferences(sessionId);
    
    return buildSystemPrompt({
      mode,
      ...context,
      userPreferences: userPrefs,
      customInstructions: context.customInstructions,
    });
  }

  /**
   * Prepare messages with history
   */
  _prepareMessages(systemPrompt, history, newMessages) {
    const messages = [{ role: 'system', content: systemPrompt }];
    
    // Add history (limited)
    if (history && history.length > 0) {
      messages.push(...history.slice(-MAX_CONTEXT_MESSAGES));
    }
    
    // Add new messages
    messages.push(...newMessages);
    
    return messages;
  }

  /**
   * Retrieve relevant memories from vector store
   */
  async _retrieveRelevantMemories(messages, sessionId) {
    try {
      const lastUserMessage = [...messages].reverse().find(m => m.role === 'user');
      if (!lastUserMessage) return [];

      return await this.vectorMemory.search(lastUserMessage.content, {
        sessionId,
        limit: 5,
        minScore: 0.7,
      });
    } catch (error) {
      logger.warn(
        { operation: 'memory_retrieval' },
        'Failed to retrieve memories',
        { error: error.message }
      );
      return [];
    }
  }

  /**
   * Extract and save important information to memories
   */
  async _extractAndSaveMemories(response, messages, sessionId) {
    try {
      // Simple extraction: save user intents and assistant responses
      const lastUserMessage = [...messages].reverse().find(m => m.role === 'user');
      
      if (lastUserMessage && response) {
        // Save to vector memory for semantic search
        await this.vectorMemory.add({
          content: `User: ${lastUserMessage.content}\nAssistant: ${response.slice(0, 500)}`,
          sessionId,
          timestamp: new Date().toISOString(),
          type: 'conversation',
        });
      }
    } catch (error) {
      logger.warn(
        { operation: 'memory_save' },
        'Failed to save memories',
        { error: error.message }
      );
    }
  }

  /**
   * Stream agent response
   * 
   * @param {object} params - Same as run()
   * @yields {object} Stream events: { type: 'text'|'tool_start'|'tool_end'|'done', data: any }
   */
  async *stream(params) {
    const {
      sessionId,
      messages,
      mode = 'default',
      context = {},
      options = {},
    } = params;

    const runId = `stream-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

    logger.info({ operation: 'stream', runId, sessionId }, 'Starting agent stream');

    // Load context
    const sessionHistory = await this.sessionMemory.getHistory(sessionId, MAX_CONTEXT_MESSAGES);
    const systemPrompt = await this._buildContextualSystemPrompt(mode, context, sessionId);
    const fullMessages = this._prepareMessages(systemPrompt, sessionHistory, messages);

    // Get relevant memories
    const relevantMemories = await this._retrieveRelevantMemories(messages, sessionId);
    if (relevantMemories.length > 0) {
      fullMessages.splice(1, 0, {
        role: 'system',
        content: `Relevant context:\n${relevantMemories.map(m => `- ${m.content}`).join('\n')}`,
      });
    }

    const tools = this.toolRegistry.getToolDefinitions();
    let currentMessages = [...fullMessages];
    let iterations = 0;
    const toolCalls = [];

    while (iterations < this.maxIterations) {
      iterations++;

      // Stream from LLM
      const response = await fetch(`${this.llmClient.baseUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.llmClient.apiKey}`,
        },
        body: JSON.stringify({
          model: options.model || this.defaultModel,
          messages: currentMessages,
          tools: tools.length > 0 ? tools : undefined,
          tool_choice: tools.length > 0 ? 'auto' : undefined,
          temperature: options.temperature ?? 0.7,
          stream: true,
        }),
      });

      if (!response.ok) {
        throw new Error(`LLM stream failed: ${response.status}`);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      let accumulatedContent = '';
      let accumulatedToolCalls = [];

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data === '[DONE]') continue;

            try {
              const parsed = JSON.parse(data);
              const delta = parsed.choices?.[0]?.delta;

              if (delta?.content) {
                accumulatedContent += delta.content;
                yield { type: 'text', data: delta.content };
              }

              if (delta?.tool_calls) {
                for (const tc of delta.tool_calls) {
                  if (tc.index !== undefined) {
                    if (!accumulatedToolCalls[tc.index]) {
                      accumulatedToolCalls[tc.index] = {
                        id: tc.id || '',
                        type: 'function',
                        function: { name: '', arguments: '' },
                      };
                    }
                    if (tc.id) accumulatedToolCalls[tc.index].id = tc.id;
                    if (tc.function?.name) accumulatedToolCalls[tc.index].function.name += tc.function.name;
                    if (tc.function?.arguments) accumulatedToolCalls[tc.index].function.arguments += tc.function.arguments;
                  }
                }
              }
            } catch {
              // Skip invalid JSON
            }
          }
        }
      }

      reader.releaseLock();

      // Handle tool calls
      if (accumulatedToolCalls.length > 0) {
        for (const tc of accumulatedToolCalls) {
          yield { type: 'tool_start', data: { name: tc.function.name, id: tc.id } };

          try {
            const args = JSON.parse(tc.function.arguments || '{}');
            const tool = this.toolRegistry.getTool(tc.function.name);
            const result = tool ? await tool.execute(args) : { error: 'Tool not found' };

            toolCalls.push({ ...tc, result });
            yield { type: 'tool_end', data: { name: tc.function.name, result } };

            currentMessages.push({
              role: 'assistant',
              content: accumulatedContent || null,
              tool_calls: accumulatedToolCalls,
            });
            currentMessages.push({
              role: 'tool',
              tool_call_id: tc.id,
              content: JSON.stringify(result),
            });
          } catch (error) {
            yield { type: 'tool_error', data: { name: tc.function.name, error: error.message } };
          }
        }
        continue; // Continue loop to process tool results
      }

      // No tool calls, done
      yield { type: 'done', data: { content: accumulatedContent, toolCalls } };

      // Save to memory
      await this.sessionMemory.addMessages(sessionId, [
        ...messages,
        { role: 'assistant', content: accumulatedContent },
      ]);

      return;
    }

    yield { type: 'error', data: { message: 'Max iterations reached' } };
  }

  /**
   * Get session info
   */
  async getSession(sessionId) {
    const history = await this.sessionMemory.getHistory(sessionId);
    const metadata = await this.sessionMemory.getMetadata(sessionId);
    return { sessionId, history, metadata };
  }

  /**
   * Clear session
   */
  async clearSession(sessionId) {
    await this.sessionMemory.clear(sessionId);
    logger.info({ operation: 'clear_session' }, 'Session cleared', { sessionId });
  }

  /**
   * Extract memories from conversation messages
   * This is a simplified implementation - in production, you'd want to use
   * the LLM to intelligently extract facts and preferences
   */
  async extractMemories(messages) {
    const memories = [];
    
    for (const msg of messages) {
      if (msg.role === 'user' && msg.content) {
        // Simple extraction - look for key patterns
        const content = msg.content;
        
        // Extract preferences (e.g., "I prefer...", "I like...")
        const preferencePatterns = [
          /I (?:prefer|like|love|enjoy|want)\s+(.+?)(?:\.|$)/gi,
          /my (?:favorite|preferred)\s+(?:is|are)\s+(.+?)(?:\.|$)/gi,
        ];
        
        for (const pattern of preferencePatterns) {
          let match;
          while ((match = pattern.exec(content)) !== null) {
            memories.push({
              type: 'preference',
              content: match[0].trim(),
              extractedAt: new Date().toISOString(),
            });
          }
        }
        
        // Extract facts (e.g., "I am...", "I work...")
        const factPatterns = [
          /I (?:am|work|live|have)\s+(.+?)(?:\.|$)/gi,
          /my (?:name|job|work|company)\s+(?:is|are)\s+(.+?)(?:\.|$)/gi,
        ];
        
        for (const pattern of factPatterns) {
          let match;
          while ((match = pattern.exec(content)) !== null) {
            memories.push({
              type: 'fact',
              content: match[0].trim(),
              extractedAt: new Date().toISOString(),
            });
          }
        }
      }
    }
    
    return memories;
  }

  /**
   * Search memories semantically
   */
  async searchMemories(query, options = {}) {
    const { userId, limit = 10, sessionId } = options;
    
    try {
      const results = await this.vectorMemory.search(query, {
        sessionId: sessionId || userId,
        limit,
        minScore: 0.5,
      });
      
      return results.map(r => ({
        content: r.content,
        score: r.score,
        metadata: r.metadata,
      }));
    } catch (error) {
      logger.warn(
        { operation: 'search_memories' },
        'Failed to search memories',
        { error: error.message }
      );
      return [];
    }
  }

  /**
   * Health check
   */
  async health() {
    const llmHealth = await this.llmClient.health();
    const toolCount = this.toolRegistry.getToolCount();

    return {
      ok: llmHealth.ok,
      llm: llmHealth,
      tools: {
        count: toolCount,
        names: this.toolRegistry.getToolNames(),
      },
    };
  }
}

// ============================================================================
// Singleton & Exports
// ============================================================================

let _coordinator = null;

/**
 * Get the singleton AgentCoordinator instance
 */
export function getAgentCoordinator() {
  if (!_coordinator) {
    _coordinator = new AgentCoordinator();
  }
  return _coordinator;
}

/**
 * Create AgentCoordinator with custom options
 */
export function createAgentCoordinator(options) {
  return new AgentCoordinator(options);
}

export default AgentCoordinator;

```

---

## backend/src/lib/agent/memory

### persistent.js

**Path:** `backend/src/lib/agent/memory/persistent.js`

```javascript
/**
 * Persistent Memory - D1-backed long-term storage
 * 
 * Provides persistent storage for user preferences, important facts,
 * and long-term conversation summaries using Cloudflare D1.
 */

import { query, execute, isD1Configured } from '../../d1.js';

// Configuration
const TABLE_NAME = 'agent_memories';
const PREFERENCES_TABLE = 'agent_user_preferences';

/**
 * Persistent Memory Store
 */
class PersistentMemoryStore {
  constructor(options = {}) {
    this._d1Available = null;
  }

  /**
   * Check if D1 is available
   */
  async _isD1Available() {
    if (this._d1Available !== null) {
      return this._d1Available;
    }
    
    try {
      this._d1Available = isD1Configured();
      return this._d1Available;
    } catch (error) {
      this._d1Available = false;
      return false;
    }
  }

  /**
   * Save a memory
   * @param {object} memory
   * @param {string} memory.sessionId
   * @param {string} memory.type - 'fact', 'preference', 'summary', 'note'
   * @param {string} memory.content
   * @param {object} [memory.metadata]
   */
  async save(memory) {
    try {
      const isAvailable = await this._isD1Available();
      if (!isAvailable) {
        console.warn('[PersistentMemory] D1 not available, using fallback');
        return this._fallbackSave(memory);
      }

      const id = `mem-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      
      await execute(
        `INSERT INTO ${TABLE_NAME} (id, session_id, type, content, metadata, created_at)
         VALUES (?, ?, ?, ?, ?, datetime('now'))`,
        id,
        memory.sessionId,
        memory.type || 'note',
        memory.content,
        JSON.stringify(memory.metadata || {}),
      );

      return { id, ...memory };
    } catch (error) {
      console.error('[PersistentMemory] Save failed:', error.message);
      return this._fallbackSave(memory);
    }
  }

  /**
   * Get memories for a session
   * @param {string} sessionId
   * @param {object} options
   */
  async getMemories(sessionId, options = {}) {
    try {
      const isAvailable = await this._isD1Available();
      if (!isAvailable) {
        return this._fallbackGet(sessionId, options);
      }

      const { type, limit = 50 } = options;
      
      let sql = `SELECT * FROM ${TABLE_NAME} WHERE session_id = ?`;
      const params = [sessionId];

      if (type) {
        sql += ` AND type = ?`;
        params.push(type);
      }

      sql += ` ORDER BY created_at DESC LIMIT ?`;
      params.push(limit);

      const result = await query(sql, ...params);
      
      return (result.results || []).map(row => ({
        id: row.id,
        sessionId: row.session_id,
        type: row.type,
        content: row.content,
        metadata: JSON.parse(row.metadata || '{}'),
        createdAt: row.created_at,
      }));
    } catch (error) {
      console.error('[PersistentMemory] Get failed:', error.message);
      return this._fallbackGet(sessionId, options);
    }
  }

  /**
   * Search memories by content
   * @param {string} searchQuery
   * @param {object} options
   */
  async search(searchQuery, options = {}) {
    try {
      const isAvailable = await this._isD1Available();
      if (!isAvailable) {
        return [];
      }

      const { sessionId, limit = 20 } = options;
      
      let sql = `SELECT * FROM ${TABLE_NAME} WHERE content LIKE ?`;
      const params = [`%${searchQuery}%`];

      if (sessionId) {
        sql += ` AND session_id = ?`;
        params.push(sessionId);
      }

      sql += ` ORDER BY created_at DESC LIMIT ?`;
      params.push(limit);

      const result = await query(sql, ...params);
      
      return (result.results || []).map(row => ({
        id: row.id,
        sessionId: row.session_id,
        type: row.type,
        content: row.content,
        metadata: JSON.parse(row.metadata || '{}'),
        createdAt: row.created_at,
      }));
    } catch (error) {
      console.error('[PersistentMemory] Search failed:', error.message);
      return [];
    }
  }

  /**
   * Delete a memory
   * @param {string} id
   */
  async delete(id) {
    try {
      const isAvailable = await this._isD1Available();
      if (!isAvailable) return;

      await execute(`DELETE FROM ${TABLE_NAME} WHERE id = ?`, id);
    } catch (error) {
      console.error('[PersistentMemory] Delete failed:', error.message);
    }
  }

  /**
   * Get user preferences
   * @param {string} sessionId
   */
  async getUserPreferences(sessionId) {
    try {
      const isAvailable = await this._isD1Available();
      if (!isAvailable) {
        return this._fallbackPreferences.get(sessionId) || {};
      }

      const result = await query(
        `SELECT * FROM ${PREFERENCES_TABLE} WHERE session_id = ?`,
        sessionId
      );

      if (result.results?.length > 0) {
        return JSON.parse(result.results[0].preferences || '{}');
      }
      return {};
    } catch (error) {
      console.error('[PersistentMemory] Get preferences failed:', error.message);
      return {};
    }
  }

  /**
   * Save user preferences
   * @param {string} sessionId
   * @param {object} preferences
   */
  async saveUserPreferences(sessionId, preferences) {
    try {
      const isAvailable = await this._isD1Available();
      if (!isAvailable) {
        this._fallbackPreferences.set(sessionId, preferences);
        return;
      }

      await execute(
        `INSERT INTO ${PREFERENCES_TABLE} (session_id, preferences, updated_at)
         VALUES (?, ?, datetime('now'))
         ON CONFLICT(session_id) DO UPDATE SET
         preferences = excluded.preferences,
         updated_at = datetime('now')`,
        sessionId,
        JSON.stringify(preferences)
      );
    } catch (error) {
      console.error('[PersistentMemory] Save preferences failed:', error.message);
      this._fallbackPreferences.set(sessionId, preferences);
    }
  }

  /**
   * Clear all memories for a session
   * @param {string} sessionId
   */
  async clearSession(sessionId) {
    try {
      const isAvailable = await this._isD1Available();
      if (!isAvailable) {
        this._fallbackMemories.delete(sessionId);
        this._fallbackPreferences.delete(sessionId);
        return;
      }

      await execute(`DELETE FROM ${TABLE_NAME} WHERE session_id = ?`, sessionId);
      await execute(`DELETE FROM ${PREFERENCES_TABLE} WHERE session_id = ?`, sessionId);
    } catch (error) {
      console.error('[PersistentMemory] Clear failed:', error.message);
    }
  }

  // ============================================================================
  // Fallback in-memory storage (when D1 is unavailable)
  // ============================================================================

  _fallbackMemories = new Map();
  _fallbackPreferences = new Map();

  _fallbackSave(memory) {
    const id = `mem-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const sessionMemories = this._fallbackMemories.get(memory.sessionId) || [];
    sessionMemories.push({ id, ...memory, createdAt: new Date().toISOString() });
    this._fallbackMemories.set(memory.sessionId, sessionMemories);
    return { id, ...memory };
  }

  _fallbackGet(sessionId, options = {}) {
    const memories = this._fallbackMemories.get(sessionId) || [];
    let filtered = [...memories];
    
    if (options.type) {
      filtered = filtered.filter(m => m.type === options.type);
    }
    
    return filtered.slice(0, options.limit || 50).reverse();
  }
}

// ============================================================================
// Singleton & Exports
// ============================================================================

let _store = null;

/**
 * Get the singleton PersistentMemoryStore instance
 */
export function getPersistentMemory() {
  if (!_store) {
    _store = new PersistentMemoryStore();
  }
  return _store;
}

/**
 * Create a new PersistentMemoryStore instance
 */
export function createPersistentMemory(options) {
  return new PersistentMemoryStore(options);
}

export default PersistentMemoryStore;

```

### session.js

**Path:** `backend/src/lib/agent/memory/session.js`

```javascript
/**
 * Session Memory - In-memory session storage
 * 
 * Provides fast, ephemeral storage for conversation history within a session.
 * Data is lost on server restart. For persistent storage, use persistent.js.
 */

// Configuration
const MAX_HISTORY_LENGTH = parseInt(process.env.MAX_SESSION_HISTORY || '100', 10);
const SESSION_TTL = parseInt(process.env.SESSION_TTL || '3600000', 10); // 1 hour default

/**
 * Session Memory Store
 */
class SessionMemoryStore {
  constructor() {
    /** @type {Map<string, {messages: Array, metadata: object, lastAccess: number}>} */
    this.sessions = new Map();
    
    // Cleanup old sessions periodically
    this._cleanupInterval = setInterval(() => this._cleanup(), 60000);
  }

  /**
   * Get conversation history for a session
   * @param {string} sessionId
   * @param {number} [limit] - Maximum messages to return
   * @returns {Promise<Array>}
   */
  async getHistory(sessionId, limit) {
    const session = this.sessions.get(sessionId);
    if (!session) return [];

    session.lastAccess = Date.now();
    const messages = session.messages;

    if (limit && messages.length > limit) {
      return messages.slice(-limit);
    }
    return [...messages];
  }

  /**
   * Add messages to session history
   * @param {string} sessionId
   * @param {Array} messages
   */
  async addMessages(sessionId, messages) {
    let session = this.sessions.get(sessionId);
    
    if (!session) {
      session = {
        messages: [],
        metadata: { createdAt: new Date().toISOString() },
        lastAccess: Date.now(),
      };
      this.sessions.set(sessionId, session);
    }

    session.messages.push(...messages);
    session.lastAccess = Date.now();

    // Trim if exceeds max length
    if (session.messages.length > MAX_HISTORY_LENGTH) {
      session.messages = session.messages.slice(-MAX_HISTORY_LENGTH);
    }
  }

  /**
   * Get session metadata
   * @param {string} sessionId
   * @returns {Promise<object>}
   */
  async getMetadata(sessionId) {
    const session = this.sessions.get(sessionId);
    if (!session) return {};
    
    return {
      ...session.metadata,
      messageCount: session.messages.length,
      lastAccess: new Date(session.lastAccess).toISOString(),
    };
  }

  /**
   * Update session metadata
   * @param {string} sessionId
   * @param {object} metadata
   */
  async updateMetadata(sessionId, metadata) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.metadata = { ...session.metadata, ...metadata };
      session.lastAccess = Date.now();
    }
  }

  /**
   * Clear a session
   * @param {string} sessionId
   */
  async clear(sessionId) {
    this.sessions.delete(sessionId);
  }

  /**
   * Check if session exists
   * @param {string} sessionId
   * @returns {boolean}
   */
  exists(sessionId) {
    return this.sessions.has(sessionId);
  }

  /**
   * Get all session IDs
   * @returns {string[]}
   */
  getAllSessionIds() {
    return Array.from(this.sessions.keys());
  }

  /**
   * Get session count
   * @returns {number}
   */
  getSessionCount() {
    return this.sessions.size;
  }

  /**
   * Cleanup expired sessions
   */
  _cleanup() {
    const now = Date.now();
    const expiredSessions = [];

    for (const [sessionId, session] of this.sessions) {
      if (now - session.lastAccess > SESSION_TTL) {
        expiredSessions.push(sessionId);
      }
    }

    for (const sessionId of expiredSessions) {
      this.sessions.delete(sessionId);
    }

    if (expiredSessions.length > 0) {
      console.log(`[SessionMemory] Cleaned up ${expiredSessions.length} expired sessions`);
    }
  }

  /**
   * Export session for persistence
   * @param {string} sessionId
   * @returns {object|null}
   */
  export(sessionId) {
    const session = this.sessions.get(sessionId);
    if (!session) return null;

    return {
      sessionId,
      messages: [...session.messages],
      metadata: { ...session.metadata },
      exportedAt: new Date().toISOString(),
    };
  }

  /**
   * Import session from persistence
   * @param {object} data
   */
  import(data) {
    if (!data.sessionId) return;

    this.sessions.set(data.sessionId, {
      messages: data.messages || [],
      metadata: data.metadata || {},
      lastAccess: Date.now(),
    });
  }

  /**
   * Destroy the store
   */
  destroy() {
    clearInterval(this._cleanupInterval);
    this.sessions.clear();
  }
}

// ============================================================================
// Singleton & Exports
// ============================================================================

let _store = null;

/**
 * Get the singleton SessionMemoryStore instance
 */
export function getSessionMemory() {
  if (!_store) {
    _store = new SessionMemoryStore();
  }
  return _store;
}

/**
 * Create a new SessionMemoryStore instance
 */
export function createSessionMemory() {
  return new SessionMemoryStore();
}

export default SessionMemoryStore;

```

### vector.js

**Path:** `backend/src/lib/agent/memory/vector.js`

```javascript
/**
 * Vector Memory - ChromaDB-backed semantic memory
 * 
 * Provides semantic search over conversation history and memories
 * using vector embeddings stored in ChromaDB.
 */

// Configuration
const CHROMA_URL = process.env.CHROMA_URL || 'http://chromadb:8000';
const TEI_URL = process.env.TEI_URL || 'http://embedding-server:80';
const COLLECTION_NAME = 'agent_memories';

/**
 * Generate embeddings using TEI server
 */
async function generateEmbeddings(text) {
  try {
    const response = await fetch(`${TEI_URL}/embed`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ inputs: text }),
    });

    if (!response.ok) {
      throw new Error(`TEI embedding failed: ${response.status}`);
    }

    const embeddings = await response.json();
    return Array.isArray(embeddings[0]) ? embeddings[0] : embeddings;
  } catch (error) {
    console.error('[VectorMemory] Embedding generation failed:', error.message);
    return null;
  }
}

/**
 * Vector Memory Store
 */
class VectorMemoryStore {
  constructor() {
    this._initialized = false;
    this._fallbackStore = new Map();
  }

  /**
   * Initialize ChromaDB collection
   */
  async _ensureCollection() {
    if (this._initialized) return true;

    try {
      // Check if collection exists
      const response = await fetch(`${CHROMA_URL}/api/v1/collections/${COLLECTION_NAME}`);
      
      if (!response.ok && response.status === 404) {
        // Create collection
        const createResponse = await fetch(`${CHROMA_URL}/api/v1/collections`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: COLLECTION_NAME,
            metadata: { description: 'Agent conversation memories' },
          }),
        });

        if (!createResponse.ok) {
          throw new Error(`Failed to create collection: ${createResponse.status}`);
        }
      }

      this._initialized = true;
      return true;
    } catch (error) {
      console.warn('[VectorMemory] ChromaDB initialization failed:', error.message);
      return false;
    }
  }

  /**
   * Add a memory to vector store
   * @param {object} memory
   * @param {string} memory.content - Text content to embed
   * @param {string} memory.sessionId - Session identifier
   * @param {string} [memory.type] - Memory type
   * @param {object} [memory.metadata] - Additional metadata
   */
  async add(memory) {
    const { content, sessionId, type = 'conversation', metadata = {} } = memory;

    if (!content) {
      console.warn('[VectorMemory] Empty content, skipping');
      return null;
    }

    try {
      const isReady = await this._ensureCollection();
      if (!isReady) {
        return this._fallbackAdd(memory);
      }

      // Generate embedding
      const embedding = await generateEmbeddings(content);
      if (!embedding) {
        return this._fallbackAdd(memory);
      }

      const id = `vmem-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

      // Add to ChromaDB
      const response = await fetch(`${CHROMA_URL}/api/v1/collections/${COLLECTION_NAME}/add`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ids: [id],
          embeddings: [embedding],
          documents: [content],
          metadatas: [{
            sessionId,
            type,
            timestamp: new Date().toISOString(),
            ...metadata,
          }],
        }),
      });

      if (!response.ok) {
        throw new Error(`ChromaDB add failed: ${response.status}`);
      }

      return { id, content, sessionId, type };
    } catch (error) {
      console.error('[VectorMemory] Add failed:', error.message);
      return this._fallbackAdd(memory);
    }
  }

  /**
   * Search for similar memories
   * @param {string} query - Search query
   * @param {object} options
   * @param {string} [options.sessionId] - Filter by session
   * @param {number} [options.limit] - Max results
   * @param {number} [options.minScore] - Minimum similarity score
   */
  async search(query, options = {}) {
    const { sessionId, limit = 5, minScore = 0.5 } = options;

    if (!query) return [];

    try {
      const isReady = await this._ensureCollection();
      if (!isReady) {
        return this._fallbackSearch(query, options);
      }

      // Generate query embedding
      const queryEmbedding = await generateEmbeddings(query);
      if (!queryEmbedding) {
        return this._fallbackSearch(query, options);
      }

      // Build where filter
      const where = sessionId ? { sessionId } : undefined;

      // Query ChromaDB
      const response = await fetch(`${CHROMA_URL}/api/v1/collections/${COLLECTION_NAME}/query`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query_embeddings: [queryEmbedding],
          n_results: limit,
          where,
          include: ['documents', 'metadatas', 'distances'],
        }),
      });

      if (!response.ok) {
        throw new Error(`ChromaDB query failed: ${response.status}`);
      }

      const data = await response.json();
      
      // Format results
      const results = [];
      const documents = data.documents?.[0] || [];
      const metadatas = data.metadatas?.[0] || [];
      const distances = data.distances?.[0] || [];

      for (let i = 0; i < documents.length; i++) {
        const score = 1 - (distances[i] || 0);
        if (score >= minScore) {
          results.push({
            content: documents[i],
            metadata: metadatas[i] || {},
            score,
          });
        }
      }

      return results;
    } catch (error) {
      console.error('[VectorMemory] Search failed:', error.message);
      return this._fallbackSearch(query, options);
    }
  }

  /**
   * Delete memories by session
   * @param {string} sessionId
   */
  async deleteBySession(sessionId) {
    try {
      const isReady = await this._ensureCollection();
      if (!isReady) {
        this._fallbackStore.delete(sessionId);
        return;
      }

      await fetch(`${CHROMA_URL}/api/v1/collections/${COLLECTION_NAME}/delete`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          where: { sessionId },
        }),
      });

      this._fallbackStore.delete(sessionId);
    } catch (error) {
      console.error('[VectorMemory] Delete failed:', error.message);
    }
  }

  /**
   * Get collection stats
   */
  async getStats() {
    try {
      const response = await fetch(`${CHROMA_URL}/api/v1/collections/${COLLECTION_NAME}`);
      if (!response.ok) {
        return { count: 0, available: false };
      }

      const data = await response.json();
      return {
        count: data.count || 0,
        available: true,
        name: COLLECTION_NAME,
      };
    } catch (error) {
      return { count: 0, available: false, error: error.message };
    }
  }

  // ============================================================================
  // Fallback in-memory storage (when ChromaDB is unavailable)
  // ============================================================================

  _fallbackAdd(memory) {
    const id = `vmem-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const sessionMemories = this._fallbackStore.get(memory.sessionId) || [];
    sessionMemories.push({
      id,
      content: memory.content,
      type: memory.type || 'conversation',
      timestamp: new Date().toISOString(),
      metadata: memory.metadata || {},
    });
    this._fallbackStore.set(memory.sessionId, sessionMemories);
    return { id, ...memory };
  }

  _fallbackSearch(query, options = {}) {
    const { sessionId, limit = 5 } = options;
    const queryLower = query.toLowerCase();
    const results = [];

    const sessions = sessionId ? [sessionId] : Array.from(this._fallbackStore.keys());

    for (const sid of sessions) {
      const memories = this._fallbackStore.get(sid) || [];
      for (const memory of memories) {
        if (memory.content.toLowerCase().includes(queryLower)) {
          results.push({
            content: memory.content,
            metadata: { ...memory.metadata, sessionId: sid },
            score: 0.8, // Simple text match
          });
        }
      }
    }

    return results.slice(0, limit);
  }
}

// ============================================================================
// Singleton & Exports
// ============================================================================

let _store = null;

/**
 * Get the singleton VectorMemoryStore instance
 */
export function getVectorMemory() {
  if (!_store) {
    _store = new VectorMemoryStore();
  }
  return _store;
}

/**
 * Create a new VectorMemoryStore instance
 */
export function createVectorMemory() {
  return new VectorMemoryStore();
}

export default VectorMemoryStore;

```

---

## backend/src/lib/agent/prompts

### system.js

**Path:** `backend/src/lib/agent/prompts/system.js`

```javascript
/**
 * System Prompts for Agent Coordinator
 * 
 * Defines different personas and behaviors for the AI agent
 * based on context and user needs.
 */

// ============================================================================
// Base System Prompt Components
// ============================================================================

const CORE_IDENTITY = `You are a helpful AI assistant for a personal tech blog called "nodove blog". 
You have access to various tools to help answer questions, search for information, and assist with tasks.`;

const MEMORY_CONTEXT = `
## Memory Context
You have access to user memories and past conversations. Use this context to:
- Personalize responses based on known preferences
- Reference relevant past discussions when appropriate
- Build on previously shared information
- Maintain consistency across conversations`;

const TOOL_USAGE_GUIDELINES = `
## Tool Usage Guidelines
1. **RAG Search**: Use for questions about blog content, technical articles, or documented knowledge
2. **Web Search**: Use for current events, external information, or topics not in the blog
3. **Blog Operations**: Use when the user wants to create, edit, or manage blog content
4. **Code Execution**: Use for running code snippets, calculations, or demonstrations
5. **MCP Tools**: Use for file system access, advanced integrations, or external services

Always explain what tools you're using and why. Be transparent about your capabilities.`;

const RESPONSE_STYLE = `
## Response Style
- Be concise but thorough
- Use markdown formatting for readability
- Include code blocks with syntax highlighting when relevant
- Provide sources and references when available
- Ask clarifying questions when the request is ambiguous`;

// ============================================================================
// Mode-Specific Prompts
// ============================================================================

/**
 * Default conversational mode
 */
const DEFAULT_MODE = `${CORE_IDENTITY}

You are in **general conversation mode**. Help the user with any questions or tasks they have.
${MEMORY_CONTEXT}
${TOOL_USAGE_GUIDELINES}
${RESPONSE_STYLE}

## Behavior
- Be friendly and approachable
- Offer to help with follow-up questions
- Suggest related topics when appropriate
- Remember context from earlier in the conversation`;

/**
 * Research mode - for in-depth information gathering
 */
const RESEARCH_MODE = `${CORE_IDENTITY}

You are in **research mode**. Your goal is to provide comprehensive, well-researched answers.
${MEMORY_CONTEXT}
${TOOL_USAGE_GUIDELINES}

## Research Behavior
- Use multiple tools to gather information
- Cross-reference sources for accuracy
- Cite your sources clearly
- Organize information hierarchically
- Highlight key findings and conclusions
- Note any limitations or uncertainties

## Response Format
Structure your research findings as:
1. **Summary**: Brief overview of findings
2. **Details**: In-depth information organized by topic
3. **Sources**: List of sources used
4. **Further Reading**: Suggestions for deeper exploration`;

/**
 * Coding assistant mode
 */
const CODING_MODE = `${CORE_IDENTITY}

You are in **coding assistant mode**. Help the user with programming tasks.
${MEMORY_CONTEXT}
${TOOL_USAGE_GUIDELINES}

## Coding Behavior
- Write clean, well-documented code
- Follow best practices and conventions
- Explain your code with inline comments
- Suggest tests and error handling
- Consider edge cases and performance
- Use appropriate design patterns

## Code Style
- Use consistent naming conventions
- Keep functions small and focused
- Add meaningful variable names
- Include type annotations where appropriate
- Format code for readability

## Languages & Frameworks
You're proficient in:
- JavaScript/TypeScript, Python, Go, Rust
- React, Vue, Node.js, Express
- SQL, MongoDB, Redis
- Docker, Kubernetes, CI/CD
- And many more...`;

/**
 * Blog management mode
 */
const BLOG_MODE = `${CORE_IDENTITY}

You are in **blog management mode**. Help the user create and manage blog content.
${MEMORY_CONTEXT}
${TOOL_USAGE_GUIDELINES}

## Blog Writing Guidelines
- Write engaging, informative content
- Use clear headings and structure
- Include code examples when relevant
- Add appropriate metadata (tags, categories)
- Optimize for SEO while maintaining readability
- Match the blog's existing tone and style

## Content Types
1. **Technical Tutorials**: Step-by-step guides with code examples
2. **Concept Explanations**: Deep dives into technical concepts
3. **Project Showcases**: Demonstrations of completed projects
4. **Opinion Pieces**: Thoughts on tech trends and practices
5. **Quick Tips**: Short, actionable advice

## Post Structure
- **Title**: Clear, descriptive, SEO-friendly
- **Introduction**: Hook the reader, state the problem
- **Body**: Organized sections with clear progression
- **Code Examples**: Working, tested code snippets
- **Conclusion**: Summary and call to action
- **Metadata**: Tags, category, description`;

/**
 * Article Q&A mode - for answering questions about specific blog posts
 */
const ARTICLE_QA_MODE = `${CORE_IDENTITY}

You are in **article Q&A mode**. Answer questions about a specific blog article.
${MEMORY_CONTEXT}

## Article Context
The user is reading a specific blog article and has questions about it.
Use RAG search to find relevant context from the article content.

## Q&A Behavior
- Focus answers on the article content
- Quote relevant sections when helpful
- Explain technical concepts mentioned in the article
- Suggest related articles for further reading
- Offer to clarify any confusing parts

## Response Style
- Reference specific parts of the article
- Use the article's terminology consistently
- Provide additional context when needed
- Keep answers focused and relevant`;

/**
 * Terminal assistant mode - for system administration tasks
 */
const TERMINAL_MODE = `${CORE_IDENTITY}

You are in **terminal assistant mode**. Help the user with system administration and command-line tasks.
${MEMORY_CONTEXT}
${TOOL_USAGE_GUIDELINES}

## Terminal Behavior
- Provide safe, tested commands
- Explain what each command does
- Warn about potentially dangerous operations
- Suggest alternatives when appropriate
- Use proper quoting and escaping

## Safety Guidelines
- Never suggest commands that could cause data loss without warning
- Always explain the impact of destructive operations
- Recommend backup steps before major changes
- Use \`--dry-run\` flags when available
- Prefer reversible operations

## Common Tasks
- File and directory management
- Process monitoring and control
- Network diagnostics
- Package management
- Git operations
- Docker management
- System monitoring`;

// ============================================================================
// Dynamic Prompt Builder
// ============================================================================

/**
 * Build a complete system prompt based on mode and context
 * @param {object} options
 * @param {string} [options.mode] - Agent mode (default, research, coding, blog, article, terminal)
 * @param {string} [options.articleSlug] - Article slug for article Q&A mode
 * @param {string} [options.articleContent] - Article content for context
 * @param {Array} [options.memories] - Relevant user memories
 * @param {object} [options.userPreferences] - User preferences
 * @param {string} [options.customInstructions] - Additional instructions
 */
export function buildSystemPrompt(options = {}) {
  const {
    mode = 'default',
    articleSlug,
    articleContent,
    memories = [],
    userPreferences = {},
    customInstructions,
  } = options;

  // Select base prompt by mode
  let basePrompt;
  switch (mode) {
    case 'research':
      basePrompt = RESEARCH_MODE;
      break;
    case 'coding':
      basePrompt = CODING_MODE;
      break;
    case 'blog':
      basePrompt = BLOG_MODE;
      break;
    case 'article':
      basePrompt = ARTICLE_QA_MODE;
      break;
    case 'terminal':
      basePrompt = TERMINAL_MODE;
      break;
    default:
      basePrompt = DEFAULT_MODE;
  }

  const parts = [basePrompt];

  // Add article context if in article mode
  if (mode === 'article' && articleSlug) {
    parts.push(`\n## Current Article\nSlug: ${articleSlug}`);
    if (articleContent) {
      // Truncate if too long
      const truncated = articleContent.length > 2000
        ? articleContent.slice(0, 2000) + '...[truncated]'
        : articleContent;
      parts.push(`\nContent Summary:\n${truncated}`);
    }
  }

  // Add user memories
  if (memories.length > 0) {
    const memoryText = memories
      .map(m => `- ${m.category || m.type}: ${m.content}`)
      .join('\n');
    parts.push(`\n## Relevant User Context\n${memoryText}`);
  }

  // Add user preferences
  if (Object.keys(userPreferences).length > 0) {
    const prefText = Object.entries(userPreferences)
      .map(([k, v]) => `- ${k}: ${v}`)
      .join('\n');
    parts.push(`\n## User Preferences\n${prefText}`);
  }

  // Add custom instructions
  if (customInstructions) {
    parts.push(`\n## Additional Instructions\n${customInstructions}`);
  }

  // Add current timestamp
  parts.push(`\n## Current Time\n${new Date().toISOString()}`);

  return parts.join('\n');
}

// ============================================================================
// Preset Prompts
// ============================================================================

export const SYSTEM_PROMPTS = {
  default: DEFAULT_MODE,
  research: RESEARCH_MODE,
  coding: CODING_MODE,
  blog: BLOG_MODE,
  article: ARTICLE_QA_MODE,
  terminal: TERMINAL_MODE,
};

// ============================================================================
// Tool-Specific Prompts
// ============================================================================

/**
 * Prompt for RAG context injection
 */
export const RAG_CONTEXT_PROMPT = `
## Retrieved Context
The following information was retrieved from the knowledge base and may be relevant to the user's question:

{context}

Use this context to inform your response. If the context doesn't contain relevant information, 
you may use your general knowledge or other tools to answer.`;

/**
 * Prompt for web search context
 */
export const WEB_SEARCH_CONTEXT_PROMPT = `
## Web Search Results
The following information was found from web search:

{results}

Use these results to inform your response. Cite sources when appropriate.`;

/**
 * Prompt for code execution results
 */
export const CODE_EXECUTION_PROMPT = `
## Code Execution Results
The code was executed with the following results:

**Language**: {language}
**Status**: {status}
**Output**:
\`\`\`
{output}
\`\`\`
{error}

Explain the results and offer suggestions if there were errors.`;

// ============================================================================
// Memory Extraction Prompt
// ============================================================================

/**
 * Prompt for extracting memorable facts from conversations
 */
export const MEMORY_EXTRACTION_PROMPT = `
Analyze the following conversation and extract any memorable facts, preferences, or information about the user.

## Conversation
{conversation}

## Instructions
Extract information in the following categories:
1. **Personal facts**: Name, occupation, location, etc.
2. **Preferences**: Likes, dislikes, preferred tools/languages, etc.
3. **Technical context**: Projects they're working on, technologies they use
4. **Goals**: What they're trying to achieve
5. **Important decisions**: Significant choices they've mentioned

Return a JSON array of extracted memories:
[
  {
    "category": "personal|preference|technical|goal|decision",
    "content": "The extracted fact or preference",
    "importance": 0.0-1.0  // How important is this to remember?
  }
]

Only extract clear, factual information. Do not make assumptions or inferences.
If no memorable information is found, return an empty array: []`;

// ============================================================================
// Summary Generation Prompt
// ============================================================================

/**
 * Prompt for generating conversation summaries
 */
export const CONVERSATION_SUMMARY_PROMPT = `
Summarize the following conversation in a concise paragraph.
Focus on the main topics discussed, decisions made, and any action items.

## Conversation
{conversation}

## Instructions
- Keep the summary under 200 words
- Highlight key topics and conclusions
- Note any unresolved questions
- Mention important technical details
- Use neutral, factual language

Return only the summary text, no additional formatting.`;

/**
 * Prompt for generating session titles
 */
export const SESSION_TITLE_PROMPT = `
Generate a short, descriptive title for this conversation (max 50 characters).
The title should capture the main topic or purpose of the discussion.

## Conversation Summary
{summary}

## First Message
{firstMessage}

Return only the title text, no quotes or additional formatting.`;

// ============================================================================
// Exports
// ============================================================================

export default {
  buildSystemPrompt,
  SYSTEM_PROMPTS,
  RAG_CONTEXT_PROMPT,
  WEB_SEARCH_CONTEXT_PROMPT,
  CODE_EXECUTION_PROMPT,
  MEMORY_EXTRACTION_PROMPT,
  CONVERSATION_SUMMARY_PROMPT,
  SESSION_TITLE_PROMPT,
};

```

---

## backend/src/lib/agent/tools

### blog-ops.js

**Path:** `backend/src/lib/agent/tools/blog-ops.js`

```javascript
/**
 * Blog Operations Tool - CRUD operations for blog content
 * 
 * Provides tools for creating, reading, updating, and managing blog posts,
 * memos, and other content.
 */

import { config } from '../../../config.js';

// Configuration
const API_BASE_URL = process.env.INTERNAL_API_URL || 'http://localhost:5080';

/**
 * Make authenticated API request
 */
async function apiRequest(endpoint, options = {}) {
  const url = `${API_BASE_URL}${endpoint}`;
  
  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

  if (!response.ok) {
    const error = await response.text().catch(() => '');
    throw new Error(`API request failed: ${response.status} ${error}`);
  }

  return response.json();
}

/**
 * Create Blog Operations Tool
 */
export function createBlogOpsTool() {
  return {
    name: 'blog_operations',
    description: 'Perform operations on blog content including searching posts, getting post details, creating memos, and managing content.',
    parameters: {
      type: 'object',
      properties: {
        operation: {
          type: 'string',
          description: 'The operation to perform',
          enum: [
            'list_posts',
            'get_post',
            'search_posts',
            'list_categories',
            'list_tags',
            'create_memo',
            'list_memos',
            'get_stats',
          ],
        },
        // For get_post
        slug: {
          type: 'string',
          description: 'Post slug (for get_post operation)',
        },
        // For search_posts and list_posts
        query: {
          type: 'string',
          description: 'Search query (for search_posts operation)',
        },
        category: {
          type: 'string',
          description: 'Filter by category',
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Filter by tags',
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results',
          default: 10,
        },
        offset: {
          type: 'number',
          description: 'Pagination offset',
          default: 0,
        },
        // For create_memo
        content: {
          type: 'string',
          description: 'Memo content (for create_memo operation)',
        },
        title: {
          type: 'string',
          description: 'Memo title (for create_memo operation)',
        },
      },
      required: ['operation'],
    },

    async execute(args) {
      const { operation, slug, query, category, tags, limit, offset, content, title } = args;

      console.log(`[BlogOps] Executing operation: ${operation}`);

      try {
        switch (operation) {
          case 'list_posts': {
            const params = new URLSearchParams();
            if (category) params.append('category', category);
            if (tags?.length) tags.forEach(t => params.append('tag', t));
            if (limit) params.append('limit', limit.toString());
            if (offset) params.append('offset', offset.toString());

            const result = await apiRequest(`/api/v1/posts?${params}`);
            return {
              success: true,
              operation,
              count: result.data?.length || 0,
              posts: (result.data || []).map(p => ({
                title: p.title,
                slug: p.slug,
                category: p.category,
                date: p.date,
                excerpt: p.excerpt?.slice(0, 150),
              })),
            };
          }

          case 'get_post': {
            if (!slug) {
              return { success: false, error: 'slug is required for get_post' };
            }
            const result = await apiRequest(`/api/v1/posts/${slug}`);
            return {
              success: true,
              operation,
              post: {
                title: result.data?.title,
                slug: result.data?.slug,
                content: result.data?.content?.slice(0, 2000),
                category: result.data?.category,
                tags: result.data?.tags,
                date: result.data?.date,
              },
            };
          }

          case 'search_posts': {
            if (!query) {
              return { success: false, error: 'query is required for search_posts' };
            }
            const params = new URLSearchParams({ q: query });
            if (limit) params.append('limit', limit.toString());

            const result = await apiRequest(`/api/v1/posts/search?${params}`);
            return {
              success: true,
              operation,
              query,
              count: result.data?.length || 0,
              posts: (result.data || []).map(p => ({
                title: p.title,
                slug: p.slug,
                excerpt: p.excerpt?.slice(0, 150),
                score: p.score,
              })),
            };
          }

          case 'list_categories': {
            const result = await apiRequest('/api/v1/categories');
            return {
              success: true,
              operation,
              categories: result.data || [],
            };
          }

          case 'list_tags': {
            const result = await apiRequest('/api/v1/tags');
            return {
              success: true,
              operation,
              tags: result.data || [],
            };
          }

          case 'create_memo': {
            if (!content) {
              return { success: false, error: 'content is required for create_memo' };
            }
            const result = await apiRequest('/api/v1/memos', {
              method: 'POST',
              body: JSON.stringify({
                title: title || 'Untitled Memo',
                content,
                type: 'ai_generated',
              }),
            });
            return {
              success: true,
              operation,
              memo: {
                id: result.data?.id,
                title: result.data?.title,
              },
            };
          }

          case 'list_memos': {
            const params = new URLSearchParams();
            if (limit) params.append('limit', limit.toString());
            if (offset) params.append('offset', offset.toString());

            const result = await apiRequest(`/api/v1/memos?${params}`);
            return {
              success: true,
              operation,
              count: result.data?.length || 0,
              memos: (result.data || []).map(m => ({
                id: m.id,
                title: m.title,
                excerpt: m.content?.slice(0, 100),
                createdAt: m.createdAt,
              })),
            };
          }

          case 'get_stats': {
            const result = await apiRequest('/api/v1/stats');
            return {
              success: true,
              operation,
              stats: result.data,
            };
          }

          default:
            return {
              success: false,
              error: `Unknown operation: ${operation}`,
            };
        }
      } catch (error) {
        console.error(`[BlogOps] Operation failed: ${error.message}`);
        return {
          success: false,
          operation,
          error: error.message,
        };
      }
    },
  };
}

export default createBlogOpsTool;

```

### code-execution.js

**Path:** `backend/src/lib/agent/tools/code-execution.js`

```javascript
/**
 * Code Execution Tool - Safe code execution in sandbox
 * 
 * Provides secure code execution capabilities using the terminal server
 * sandbox environment. Supports multiple languages.
 */

// Configuration
const TERMINAL_SERVER_URL = process.env.TERMINAL_SERVER_URL || 'http://terminal-server:8080';
const EXECUTION_TIMEOUT = parseInt(process.env.CODE_EXEC_TIMEOUT || '30000', 10);

/**
 * Execute code in sandbox
 */
async function executeInSandbox(code, language) {
  const response = await fetch(`${TERMINAL_SERVER_URL}/execute`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      code,
      language,
      timeout: EXECUTION_TIMEOUT,
    }),
  });

  if (!response.ok) {
    const error = await response.text().catch(() => '');
    throw new Error(`Execution failed: ${response.status} ${error}`);
  }

  return response.json();
}

/**
 * Execute JavaScript code (using Node.js vm module locally)
 */
async function executeJavaScript(code) {
  try {
    // Try sandbox first
    return await executeInSandbox(code, 'javascript');
  } catch {
    // Fallback to basic evaluation (limited)
    const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
    
    // Create a sandboxed context
    const sandbox = {
      console: {
        log: (...args) => output.push(args.map(String).join(' ')),
        error: (...args) => output.push(`[Error] ${args.map(String).join(' ')}`),
      },
      Math,
      Date,
      JSON,
      Array,
      Object,
      String,
      Number,
      Boolean,
      parseInt,
      parseFloat,
      isNaN,
      isFinite,
    };

    const output = [];
    
    try {
      const fn = new AsyncFunction(...Object.keys(sandbox), code);
      const result = await fn(...Object.values(sandbox));
      
      return {
        success: true,
        output: output.join('\n'),
        result: result !== undefined ? String(result) : undefined,
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        output: output.join('\n'),
      };
    }
  }
}

/**
 * Execute Python code
 */
async function executePython(code) {
  return executeInSandbox(code, 'python');
}

/**
 * Execute shell commands
 */
async function executeShell(code) {
  return executeInSandbox(code, 'bash');
}

/**
 * Create Code Execution Tool
 */
export function createCodeExecutionTool() {
  return {
    name: 'code_execution',
    description: 'Execute code in a sandboxed environment. Supports JavaScript, Python, and shell commands. Use for calculations, data processing, or testing code snippets.',
    parameters: {
      type: 'object',
      properties: {
        code: {
          type: 'string',
          description: 'The code to execute',
        },
        language: {
          type: 'string',
          description: 'Programming language',
          enum: ['javascript', 'python', 'bash'],
          default: 'javascript',
        },
      },
      required: ['code'],
    },

    async execute(args) {
      const { code, language = 'javascript' } = args;

      if (!code) {
        return { success: false, error: 'code is required' };
      }

      console.log(`[CodeExec] Executing ${language} code (${code.length} chars)`);

      try {
        let result;

        switch (language) {
          case 'javascript':
            result = await executeJavaScript(code);
            break;
          case 'python':
            result = await executePython(code);
            break;
          case 'bash':
            result = await executeShell(code);
            break;
          default:
            return {
              success: false,
              error: `Unsupported language: ${language}`,
            };
        }

        console.log(`[CodeExec] Execution completed: ${result.success ? 'success' : 'failed'}`);

        return {
          success: result.success !== false,
          language,
          output: result.output?.slice(0, 2000),
          result: result.result?.slice?.(0, 1000) || result.result,
          error: result.error,
        };
      } catch (error) {
        console.error(`[CodeExec] Failed: ${error.message}`);
        return {
          success: false,
          language,
          error: error.message,
        };
      }
    },
  };
}

export default createCodeExecutionTool;

```

### index.js

**Path:** `backend/src/lib/agent/tools/index.js`

```javascript
/**
 * Tool Registry - Central registry for all available tools
 * 
 * Manages tool definitions and execution for the Agent Coordinator.
 * Tools are defined in OpenAI function calling format.
 * 
 * Usage:
 *   const registry = getToolRegistry();
 *   registry.register(myTool);
 *   const tools = registry.getToolDefinitions();
 */

import { createRAGSearchTool } from './rag-search.js';
import { createBlogOpsTool } from './blog-ops.js';
import { createMCPClientTool } from './mcp-client.js';
import { createWebSearchTool } from './web-search.js';
import { createCodeExecutionTool } from './code-execution.js';

// ============================================================================
// Tool Interface
// ============================================================================

/**
 * Tool Definition Interface
 * @typedef {object} Tool
 * @property {string} name - Unique tool identifier
 * @property {string} description - Human-readable description
 * @property {object} parameters - JSON Schema for parameters
 * @property {function} execute - Async function to execute the tool
 */

// ============================================================================
// Tool Registry Class
// ============================================================================

export class ToolRegistry {
  constructor() {
    /** @type {Map<string, Tool>} */
    this.tools = new Map();
    this._initialized = false;
  }

  /**
   * Initialize with default tools
   */
  async initialize() {
    if (this._initialized) return;

    // Register built-in tools
    const builtInTools = [
      createRAGSearchTool(),
      createBlogOpsTool(),
      createWebSearchTool(),
      createCodeExecutionTool(),
    ];

    for (const tool of builtInTools) {
      if (tool) {
        this.register(tool);
      }
    }

    // Try to initialize MCP tools (optional)
    try {
      const mcpTool = await createMCPClientTool();
      if (mcpTool) {
        this.register(mcpTool);
      }
    } catch (error) {
      console.warn('[ToolRegistry] MCP tool initialization failed:', error.message);
    }

    this._initialized = true;
    console.log(`[ToolRegistry] Initialized with ${this.tools.size} tools`);
  }

  /**
   * Register a tool
   * @param {Tool} tool
   */
  register(tool) {
    if (!tool.name || !tool.execute) {
      throw new Error('Tool must have name and execute function');
    }

    this.tools.set(tool.name, tool);
    console.log(`[ToolRegistry] Registered tool: ${tool.name}`);
  }

  /**
   * Unregister a tool
   * @param {string} name
   */
  unregister(name) {
    this.tools.delete(name);
  }

  /**
   * Get a tool by name
   * @param {string} name
   * @returns {Tool|undefined}
   */
  getTool(name) {
    return this.tools.get(name);
  }

  /**
   * Get all tool names
   * @returns {string[]}
   */
  getToolNames() {
    return Array.from(this.tools.keys());
  }

  /**
   * Get tool count
   * @returns {number}
   */
  getToolCount() {
    return this.tools.size;
  }

  /**
   * Get tool definitions in OpenAI format
   * @returns {Array<{type: 'function', function: object}>}
   */
  getToolDefinitions() {
    const definitions = [];

    for (const tool of this.tools.values()) {
      definitions.push({
        type: 'function',
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.parameters || {
            type: 'object',
            properties: {},
            required: [],
          },
        },
      });
    }

    return definitions;
  }

  /**
   * Execute a tool by name
   * @param {string} name
   * @param {object} args
   * @returns {Promise<any>}
   */
  async execute(name, args) {
    const tool = this.tools.get(name);
    if (!tool) {
      throw new Error(`Tool not found: ${name}`);
    }
    return tool.execute(args);
  }
}

// ============================================================================
// Singleton & Exports
// ============================================================================

let _registry = null;

/**
 * Get the singleton ToolRegistry instance
 */
export function getToolRegistry() {
  if (!_registry) {
    _registry = new ToolRegistry();
    // Initialize asynchronously
    _registry.initialize().catch(err => {
      console.error('[ToolRegistry] Initialization error:', err);
    });
  }
  return _registry;
}

/**
 * Create a new ToolRegistry instance
 */
export function createToolRegistry() {
  return new ToolRegistry();
}

export default ToolRegistry;

```

### mcp-client.js

**Path:** `backend/src/lib/agent/tools/mcp-client.js`

```javascript
/**
 * MCP Client Tool - Model Context Protocol Integration
 * 
 * Connects to MCP servers to access external tools and resources.
 * Supports filesystem, web search, and custom MCP servers.
 */

import { spawn } from 'child_process';

// Configuration
const MCP_CONFIG_PATH = process.env.MCP_CONFIG_PATH || '/.roo/mcp.json';

// MCP Server definitions
const MCP_SERVERS = {
  filesystem: {
    command: 'npx',
    args: ['-y', '@modelcontextprotocol/server-filesystem', process.env.WORKSPACE_PATH || '/workspace'],
  },
  // Add more MCP servers as needed
};

/**
 * MCP Client class for communicating with MCP servers
 */
class MCPClient {
  constructor(serverConfig) {
    this.config = serverConfig;
    this.process = null;
    this.pendingRequests = new Map();
    this.requestId = 0;
    this.ready = false;
  }

  /**
   * Start the MCP server process
   */
  async start() {
    return new Promise((resolve, reject) => {
      try {
        this.process = spawn(this.config.command, this.config.args, {
          stdio: ['pipe', 'pipe', 'pipe'],
          env: { ...process.env, ...this.config.env },
        });

        let buffer = '';

        this.process.stdout.on('data', (data) => {
          buffer += data.toString();
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.trim()) {
              try {
                const message = JSON.parse(line);
                this._handleMessage(message);
              } catch (e) {
                // Not JSON, ignore
              }
            }
          }
        });

        this.process.stderr.on('data', (data) => {
          console.error(`[MCP] stderr: ${data}`);
        });

        this.process.on('close', (code) => {
          this.ready = false;
          console.log(`[MCP] Process exited with code ${code}`);
        });

        // Send initialize request
        this._send({
          jsonrpc: '2.0',
          id: this._nextId(),
          method: 'initialize',
          params: {
            protocolVersion: '2024-11-05',
            capabilities: {},
            clientInfo: {
              name: 'blog-agent',
              version: '1.0.0',
            },
          },
        });

        // Wait for initialization
        setTimeout(() => {
          this.ready = true;
          resolve();
        }, 1000);

      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Stop the MCP server process
   */
  stop() {
    if (this.process) {
      this.process.kill();
      this.process = null;
    }
    this.ready = false;
  }

  /**
   * Send a message to the MCP server
   */
  _send(message) {
    if (this.process && this.process.stdin.writable) {
      this.process.stdin.write(JSON.stringify(message) + '\n');
    }
  }

  /**
   * Get next request ID
   */
  _nextId() {
    return ++this.requestId;
  }

  /**
   * Handle incoming message from MCP server
   */
  _handleMessage(message) {
    if (message.id && this.pendingRequests.has(message.id)) {
      const { resolve, reject } = this.pendingRequests.get(message.id);
      this.pendingRequests.delete(message.id);

      if (message.error) {
        reject(new Error(message.error.message));
      } else {
        resolve(message.result);
      }
    }
  }

  /**
   * Call an MCP tool
   */
  async callTool(name, args) {
    return new Promise((resolve, reject) => {
      const id = this._nextId();
      this.pendingRequests.set(id, { resolve, reject });

      const timeout = setTimeout(() => {
        this.pendingRequests.delete(id);
        reject(new Error('MCP tool call timeout'));
      }, 30000);

      this._send({
        jsonrpc: '2.0',
        id,
        method: 'tools/call',
        params: { name, arguments: args },
      });

      // Clear timeout on resolution
      this.pendingRequests.get(id).timeout = timeout;
    });
  }

  /**
   * List available tools
   */
  async listTools() {
    return new Promise((resolve, reject) => {
      const id = this._nextId();
      this.pendingRequests.set(id, { resolve, reject });

      this._send({
        jsonrpc: '2.0',
        id,
        method: 'tools/list',
        params: {},
      });
    });
  }

  /**
   * Read a resource
   */
  async readResource(uri) {
    return new Promise((resolve, reject) => {
      const id = this._nextId();
      this.pendingRequests.set(id, { resolve, reject });

      this._send({
        jsonrpc: '2.0',
        id,
        method: 'resources/read',
        params: { uri },
      });
    });
  }
}

// Global MCP clients
const mcpClients = new Map();

/**
 * Get or create an MCP client
 */
async function getMCPClient(serverName) {
  if (mcpClients.has(serverName)) {
    const client = mcpClients.get(serverName);
    if (client.ready) return client;
  }

  const config = MCP_SERVERS[serverName];
  if (!config) {
    throw new Error(`Unknown MCP server: ${serverName}`);
  }

  const client = new MCPClient(config);
  await client.start();
  mcpClients.set(serverName, client);
  return client;
}

/**
 * Create MCP Client Tool
 */
export async function createMCPClientTool() {
  // Check if MCP is enabled
  if (process.env.DISABLE_MCP === 'true') {
    console.log('[MCP] MCP is disabled');
    return null;
  }

  return {
    name: 'mcp_tools',
    description: 'Access external tools and resources via Model Context Protocol (MCP). Can read files, search the web, and interact with various services.',
    parameters: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          description: 'The MCP action to perform',
          enum: ['read_file', 'list_files', 'search_files', 'call_tool'],
        },
        server: {
          type: 'string',
          description: 'The MCP server to use',
          enum: ['filesystem'],
          default: 'filesystem',
        },
        // For file operations
        path: {
          type: 'string',
          description: 'File or directory path',
        },
        pattern: {
          type: 'string',
          description: 'Search pattern (glob or regex)',
        },
        // For call_tool
        tool: {
          type: 'string',
          description: 'Tool name to call',
        },
        args: {
          type: 'object',
          description: 'Arguments for the tool',
        },
      },
      required: ['action'],
    },

    async execute(params) {
      const { action, server = 'filesystem', path, pattern, tool, args } = params;

      console.log(`[MCP] Executing action: ${action} on server: ${server}`);

      try {
        const client = await getMCPClient(server);

        switch (action) {
          case 'read_file': {
            if (!path) {
              return { success: false, error: 'path is required' };
            }
            const result = await client.readResource(`file://${path}`);
            return {
              success: true,
              action,
              path,
              content: result.contents?.[0]?.text?.slice(0, 5000),
            };
          }

          case 'list_files': {
            if (!path) {
              return { success: false, error: 'path is required' };
            }
            const result = await client.callTool('list_directory', { path });
            return {
              success: true,
              action,
              path,
              files: result.content?.map(c => c.text),
            };
          }

          case 'search_files': {
            if (!pattern) {
              return { success: false, error: 'pattern is required' };
            }
            const result = await client.callTool('search_files', {
              path: path || '.',
              pattern,
            });
            return {
              success: true,
              action,
              pattern,
              matches: result.content?.map(c => c.text),
            };
          }

          case 'call_tool': {
            if (!tool) {
              return { success: false, error: 'tool is required' };
            }
            const result = await client.callTool(tool, args || {});
            return {
              success: true,
              action,
              tool,
              result: result.content,
            };
          }

          default:
            return {
              success: false,
              error: `Unknown action: ${action}`,
            };
        }
      } catch (error) {
        console.error(`[MCP] Action failed: ${error.message}`);
        return {
          success: false,
          action,
          error: error.message,
        };
      }
    },
  };
}

/**
 * Cleanup MCP clients on exit
 */
process.on('exit', () => {
  for (const client of mcpClients.values()) {
    client.stop();
  }
});

export default createMCPClientTool;

```

### rag-search.js

**Path:** `backend/src/lib/agent/tools/rag-search.js`

```javascript
/**
 * RAG Search Tool - Semantic search over blog content
 * 
 * Provides semantic search capabilities using ChromaDB and TEI embeddings.
 * Searches blog posts, memos, and other indexed content.
 */

// Configuration
const CHROMA_URL = process.env.CHROMA_URL || 'http://chromadb:8000';
const TEI_URL = process.env.TEI_URL || 'http://embedding-server:80';
const DEFAULT_COLLECTION = 'blog_posts';
const DEFAULT_LIMIT = 5;

/**
 * Generate embeddings using TEI server
 */
async function generateEmbeddings(text) {
  try {
    const response = await fetch(`${TEI_URL}/embed`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ inputs: text }),
    });

    if (!response.ok) {
      throw new Error(`TEI embedding failed: ${response.status}`);
    }

    const embeddings = await response.json();
    return Array.isArray(embeddings[0]) ? embeddings[0] : embeddings;
  } catch (error) {
    console.error('[RAGSearch] Embedding generation failed:', error.message);
    throw error;
  }
}

/**
 * Search ChromaDB collection
 */
async function searchChromaDB(query, options = {}) {
  const {
    collection = DEFAULT_COLLECTION,
    limit = DEFAULT_LIMIT,
    where = {},
  } = options;

  try {
    // Generate query embedding
    const queryEmbedding = await generateEmbeddings(query);

    // Query ChromaDB
    const response = await fetch(`${CHROMA_URL}/api/v1/collections/${collection}/query`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query_embeddings: [queryEmbedding],
        n_results: limit,
        where: Object.keys(where).length > 0 ? where : undefined,
        include: ['documents', 'metadatas', 'distances'],
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`ChromaDB query failed: ${response.status} ${error}`);
    }

    const data = await response.json();
    
    // Format results
    const results = [];
    const documents = data.documents?.[0] || [];
    const metadatas = data.metadatas?.[0] || [];
    const distances = data.distances?.[0] || [];

    for (let i = 0; i < documents.length; i++) {
      results.push({
        content: documents[i],
        metadata: metadatas[i] || {},
        score: 1 - (distances[i] || 0), // Convert distance to similarity score
      });
    }

    return results;
  } catch (error) {
    console.error('[RAGSearch] ChromaDB search failed:', error.message);
    throw error;
  }
}

/**
 * Create RAG Search Tool
 */
export function createRAGSearchTool() {
  return {
    name: 'rag_search',
    description: 'Search blog posts and content using semantic search. Use this to find relevant articles, posts, or information from the blog.',
    parameters: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'The search query to find relevant content',
        },
        collection: {
          type: 'string',
          description: 'The collection to search (default: blog_posts)',
          enum: ['blog_posts', 'memos', 'comments'],
          default: 'blog_posts',
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results to return (default: 5)',
          default: 5,
        },
        category: {
          type: 'string',
          description: 'Filter by category (optional)',
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Filter by tags (optional)',
        },
      },
      required: ['query'],
    },

    async execute(args) {
      const { query, collection, limit, category, tags } = args;

      console.log(`[RAGSearch] Searching for: "${query}"`);

      try {
        // Build filter
        const where = {};
        if (category) {
          where.category = category;
        }
        if (tags && tags.length > 0) {
          where.tags = { $in: tags };
        }

        // Perform search
        const results = await searchChromaDB(query, {
          collection: collection || DEFAULT_COLLECTION,
          limit: limit || DEFAULT_LIMIT,
          where,
        });

        console.log(`[RAGSearch] Found ${results.length} results`);

        return {
          success: true,
          query,
          count: results.length,
          results: results.map(r => ({
            content: r.content?.slice(0, 500) + (r.content?.length > 500 ? '...' : ''),
            title: r.metadata?.title,
            slug: r.metadata?.slug,
            category: r.metadata?.category,
            tags: r.metadata?.tags,
            score: r.score?.toFixed(3),
          })),
        };
      } catch (error) {
        console.error('[RAGSearch] Search failed:', error.message);
        return {
          success: false,
          error: error.message,
          query,
        };
      }
    },
  };
}

/**
 * Direct search function for use outside of agent
 */
export async function ragSearch(query, options = {}) {
  return searchChromaDB(query, options);
}

export default createRAGSearchTool;

```

### web-search.js

**Path:** `backend/src/lib/agent/tools/web-search.js`

```javascript
/**
 * Web Search Tool - Search the web for information
 * 
 * Provides web search capabilities using various search APIs.
 * Supports DuckDuckGo, Brave Search, and custom search endpoints.
 */

// Configuration
const SEARCH_API_URL = process.env.SEARCH_API_URL || 'https://api.duckduckgo.com/';
const BRAVE_API_KEY = process.env.BRAVE_SEARCH_API_KEY;
const SERPER_API_KEY = process.env.SERPER_API_KEY;

/**
 * Search using DuckDuckGo Instant Answer API (free, no key needed)
 */
async function searchDuckDuckGo(query) {
  const params = new URLSearchParams({
    q: query,
    format: 'json',
    no_html: '1',
    skip_disambig: '1',
  });

  const response = await fetch(`${SEARCH_API_URL}?${params}`);
  if (!response.ok) {
    throw new Error(`DuckDuckGo search failed: ${response.status}`);
  }

  const data = await response.json();
  
  const results = [];
  
  // Abstract (main answer)
  if (data.Abstract) {
    results.push({
      title: data.Heading || 'Summary',
      snippet: data.Abstract,
      url: data.AbstractURL,
      source: data.AbstractSource,
    });
  }

  // Related topics
  if (data.RelatedTopics) {
    for (const topic of data.RelatedTopics.slice(0, 5)) {
      if (topic.Text) {
        results.push({
          title: topic.Text.split(' - ')[0],
          snippet: topic.Text,
          url: topic.FirstURL,
        });
      }
    }
  }

  return results;
}

/**
 * Search using Brave Search API (requires API key)
 */
async function searchBrave(query, options = {}) {
  if (!BRAVE_API_KEY) {
    throw new Error('BRAVE_SEARCH_API_KEY not configured');
  }

  const params = new URLSearchParams({
    q: query,
    count: options.limit || 5,
  });

  const response = await fetch(`https://api.search.brave.com/res/v1/web/search?${params}`, {
    headers: {
      'Accept': 'application/json',
      'X-Subscription-Token': BRAVE_API_KEY,
    },
  });

  if (!response.ok) {
    throw new Error(`Brave search failed: ${response.status}`);
  }

  const data = await response.json();
  
  return (data.web?.results || []).map(r => ({
    title: r.title,
    snippet: r.description,
    url: r.url,
  }));
}

/**
 * Search using Serper API (Google search, requires API key)
 */
async function searchSerper(query, options = {}) {
  if (!SERPER_API_KEY) {
    throw new Error('SERPER_API_KEY not configured');
  }

  const response = await fetch('https://google.serper.dev/search', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-API-KEY': SERPER_API_KEY,
    },
    body: JSON.stringify({
      q: query,
      num: options.limit || 5,
    }),
  });

  if (!response.ok) {
    throw new Error(`Serper search failed: ${response.status}`);
  }

  const data = await response.json();
  
  return (data.organic || []).map(r => ({
    title: r.title,
    snippet: r.snippet,
    url: r.link,
  }));
}

/**
 * Fetch and summarize a web page
 */
async function fetchWebPage(url) {
  try {
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; BlogAgent/1.0)',
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch: ${response.status}`);
    }

    const html = await response.text();
    
    // Simple HTML to text conversion
    const text = html
      .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
      .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
      .replace(/<[^>]+>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

    return text.slice(0, 5000);
  } catch (error) {
    return `Failed to fetch page: ${error.message}`;
  }
}

/**
 * Create Web Search Tool
 */
export function createWebSearchTool() {
  return {
    name: 'web_search',
    description: 'Search the web for current information, news, documentation, or any topic. Can also fetch and summarize web pages.',
    parameters: {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          description: 'The action to perform',
          enum: ['search', 'fetch_page'],
        },
        query: {
          type: 'string',
          description: 'Search query (for search action)',
        },
        url: {
          type: 'string',
          description: 'URL to fetch (for fetch_page action)',
        },
        engine: {
          type: 'string',
          description: 'Search engine to use',
          enum: ['duckduckgo', 'brave', 'serper'],
          default: 'duckduckgo',
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results',
          default: 5,
        },
      },
      required: ['action'],
    },

    async execute(args) {
      const { action, query, url, engine = 'duckduckgo', limit = 5 } = args;

      console.log(`[WebSearch] Action: ${action}, Query: ${query || url}`);

      try {
        switch (action) {
          case 'search': {
            if (!query) {
              return { success: false, error: 'query is required for search' };
            }

            let results;
            switch (engine) {
              case 'brave':
                results = await searchBrave(query, { limit });
                break;
              case 'serper':
                results = await searchSerper(query, { limit });
                break;
              case 'duckduckgo':
              default:
                results = await searchDuckDuckGo(query);
            }

            return {
              success: true,
              action,
              query,
              engine,
              count: results.length,
              results,
            };
          }

          case 'fetch_page': {
            if (!url) {
              return { success: false, error: 'url is required for fetch_page' };
            }

            const content = await fetchWebPage(url);
            return {
              success: true,
              action,
              url,
              content,
            };
          }

          default:
            return {
              success: false,
              error: `Unknown action: ${action}`,
            };
        }
      } catch (error) {
        console.error(`[WebSearch] Failed: ${error.message}`);
        return {
          success: false,
          action,
          error: error.message,
        };
      }
    },
  };
}

export default createWebSearchTool;

```

---

## backend/src/middleware

### adminAuth.js

**Path:** `backend/src/middleware/adminAuth.js`

```javascript
import { config } from '../config.js';
import { verifyJwt, isAdminClaims } from '../lib/jwt.js';

/**
 * Admin 보호 미들웨어.
 * - ADMIN_BEARER_TOKEN 또는 JWT_SECRET 둘 중 하나라도 설정되어 있으면 보호 활성화
 * - 둘 다 없으면(로컬 편의) 패스스루
 */
export function requireAdmin(req, res, next) {
  const protectionEnabled = !!(config.admin.bearerToken || config.auth?.jwtSecret);
  if (!protectionEnabled) return next();

  const auth = req.headers['authorization'] || '';
  const token = auth.replace(/^Bearer\s+/i, '').trim();
  if (!token) return res.status(401).json({ ok: false, error: 'Unauthorized' });

  // Static bearer token 우선
  if (config.admin.bearerToken && token === config.admin.bearerToken) return next();

  // JWT 어드민 검사
  if (config.auth?.jwtSecret) {
    try {
      const claims = verifyJwt(token);
      if (isAdminClaims(claims)) return next();
    } catch {}
  }

  return res.status(401).json({ ok: false, error: 'Unauthorized' });
}

export default requireAdmin;

```

---

## backend/src/routes

### admin.js

**Path:** `backend/src/routes/admin.js`

```javascript
import { Router } from 'express';
import { Octokit } from '@octokit/rest';
import { config } from '../config.js';
import { queryAll, execute, isD1Configured } from '../lib/d1.js';
import requireAdmin from '../middleware/adminAuth.js'; // centralized admin auth middleware
import { buildFrontmatterMarkdown } from '../lib/markdown.js';

const router = Router();


router.post('/propose-new-version', requireAdmin, async (req, res, next) => {
  try {
    const { original, markdown, sourcePage } = req.body || {};
    if (!markdown || typeof markdown !== 'string') {
      return res.status(400).json({ ok: false, error: 'markdown is required' });
    }

    const owner = config.github.owner;
    const repo = config.github.repo;
    const token = config.github.token;
    if (!owner || !repo || !token) {
      return res.status(500).json({
        ok: false,
        error: 'Server not configured for GitHub (owner/repo/token missing)',
      });
    }

    const octokit = new Octokit({ auth: token });

    // get repo default branch
    const repoInfo = await octokit.rest.repos.get({ owner, repo });
    const baseBranch = repoInfo.data.default_branch || 'main';

    // base ref
    const baseRef = await octokit.rest.git.getRef({
      owner,
      repo,
      ref: `heads/${baseBranch}`,
    });
    const baseSha = baseRef.data.object.sha;

    // branch name
    const stamp = new Date()
      .toISOString()
      .replace(/[-:T.Z]/g, '')
      .slice(0, 12);
    const slug = (original?.slug || 'post').toString();
    const year = (original?.year || new Date().getFullYear()).toString();
    const branch = `propose/${year}-${slug}-${stamp}`;

    // create branch
    await octokit.rest.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branch}`,
      sha: baseSha,
    });

    // destination path
    let origPath = (original?.path || `/posts/${year}/${slug}.md`).toString();
    if (!origPath.startsWith('/')) origPath = `/${origPath}`;
    // Propose into a new file to avoid overwriting
    const proposedName = origPath.replace(/\.md$/i, `-rev-${stamp}.md`);
    const destPath = `frontend/public${proposedName}`.replace(/^\/+/, '');

    // commit file content
    const contentBase64 = Buffer.from(markdown, 'utf-8').toString('base64');
    const message = `propose: ${year}/${slug} (${stamp})\n\nsource: ${sourcePage || ''}`;

    await octokit.rest.repos.createOrUpdateFileContents({
      owner,
      repo,
      path: destPath,
      message,
      content: contentBase64,
      branch,
      committer:
        config.github.gitUserName && config.github.gitUserEmail
          ? {
              name: config.github.gitUserName,
              email: config.github.gitUserEmail,
            }
          : undefined,
      author:
        config.github.gitUserName && config.github.gitUserEmail
          ? {
              name: config.github.gitUserName,
              email: config.github.gitUserEmail,
            }
          : undefined,
    });

    // create PR
    const prTitle = `Propose new version: ${year}/${slug}`;
    const prBody = [
      sourcePage ? `Source: ${sourcePage}` : '',
      original?.url ? `Original: ${original.url}` : '',
    ]
      .filter(Boolean)
      .join('\n');

    const pr = await octokit.rest.pulls.create({
      owner,
      repo,
      title: prTitle,
      head: branch,
      base: baseBranch,
      body: prBody,
    });

    return res.json({ ok: true, data: { prUrl: pr.data.html_url } });
  } catch (err) {
    return next(err);
  }
});

// Archive old comments into versioned JSON files in the repo and mark them as archived
// Query param: dryRun=1 to simulate without committing or updating D1
// Now uses Cloudflare D1 instead of Firebase Firestore
router.post('/archive-comments', requireAdmin, async (req, res, next) => {
  try {
    // Check if D1 is configured
    if (!isD1Configured()) {
      return res.status(500).json({
        ok: false,
        error: 'D1 database not configured. Set CF_ACCOUNT_ID, CF_API_TOKEN, D1_DATABASE_ID',
      });
    }

    const dryRun = String(req.query.dryRun || '').trim() === '1';
    const cutoffDays = 90;
    const cutoffDate = new Date(Date.now() - cutoffDays * 24 * 60 * 60 * 1000);
    const cutoffIso = cutoffDate.toISOString();

    // Query comments from D1 that are not archived and older than cutoff
    const comments = await queryAll(
      `SELECT id, post_id, author, content, website, parent_id, created_at
       FROM comments 
       WHERE (archived = 0 OR archived IS NULL) 
       AND created_at <= ?
       ORDER BY post_id, created_at ASC`,
      cutoffIso
    );

    if (comments.length === 0) {
      return res.json({ 
        ok: true, 
        data: { archivedPosts: [], totalComments: 0, message: 'No comments to archive' } 
      });
    }

    // Group comments by post_id
    const groups = new Map();
    for (const comment of comments) {
      const pid = String(comment.post_id);
      if (!groups.has(pid)) groups.set(pid, []);
      groups.get(pid).push(comment);
    }

    const owner = config.github.owner;
    const repo = config.github.repo;
    const token = config.github.token;
    if (!owner || !repo || !token) {
      return res.status(500).json({
        ok: false,
        error: 'Server not configured for GitHub (owner/repo/token missing)',
      });
    }

    const octokit = new Octokit({ auth: token });
    // Ensure we use default branch
    const repoInfo = await octokit.rest.repos.get({ owner, repo });
    const baseBranch = repoInfo.data.default_branch || 'main';

    const results = [];
    let total = 0;

    for (const [postId, items] of groups.entries()) {
      const formattedComments = items.map((c) => ({
        id: c.id,
        postId: c.post_id,
        author: c.author,
        content: c.content,
        website: c.website || null,
        parentId: c.parent_id || null,
        createdAt: c.created_at,
      }));

      total += formattedComments.length;
      const path = `frontend/src/data/comments/${postId}.json`;
      const contentStr = `${JSON.stringify({ comments: formattedComments }, null, 2)}\n`;

      if (!dryRun) {
        // get existing sha if any
        let sha;
        try {
          const existing = await octokit.rest.repos.getContent({ owner, repo, path, ref: baseBranch });
          if (!Array.isArray(existing.data)) sha = existing.data.sha;
        } catch (_) {
          // not found OK
        }

        await octokit.rest.repos.createOrUpdateFileContents({
          owner,
          repo,
          path,
          message: `chore(archive): comments for ${postId} (${formattedComments.length})`,
          content: Buffer.from(contentStr, 'utf8').toString('base64'),
          branch: baseBranch,
          committer:
            config.github.gitUserName && config.github.gitUserEmail
              ? { name: config.github.gitUserName, email: config.github.gitUserEmail }
              : undefined,
          author:
            config.github.gitUserName && config.github.gitUserEmail
              ? { name: config.github.gitUserName, email: config.github.gitUserEmail }
              : undefined,
          sha,
        });

        // Mark archived in D1
        const ids = items.map(c => c.id);
        const placeholders = ids.map(() => '?').join(',');
        await execute(
          `UPDATE comments SET archived = 1, updated_at = datetime('now') WHERE id IN (${placeholders})`,
          ...ids
        );
      }

      results.push({ postId, count: formattedComments.length, path, committed: !dryRun });
    }

    // Optional deploy hook (compat)
    const hook = config.integrations?.vercelDeployHookUrl;
    if (hook && !dryRun) {
      try {
        await fetch(hook, { method: 'POST' });
      } catch (_) {}
    }

    return res.json({ ok: true, data: { archivedPosts: results, totalComments: total } });
  } catch (err) {
    return next(err);
  }
});

// Create a new post by opening a PR that adds the markdown file under frontend/public/posts/:year/:slug.md
router.post('/create-post-pr', requireAdmin, async (req, res, next) => {
  try {
    const { title, slug: slugRaw, year: yearRaw, content, frontmatter, draft } = req.body || {};

    const owner = config.github.owner;
    const repo = config.github.repo;
    const token = config.github.token;
    if (!owner || !repo || !token) {
      return res.status(500).json({ ok: false, error: 'Server not configured for GitHub (owner/repo/token missing)' });
    }

    const year = String(yearRaw || new Date().getFullYear());
    if (!/^\d{4}$/.test(year)) {
      return res.status(400).json({ ok: false, error: 'year must be YYYY' });
    }

    const baseTitle = String(title || slugRaw || 'New Post');
    const normalizedSlug = (baseTitle || 'post')
      .toString()
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9\-\s_]/g, '')
      .replace(/[\s_]+/g, '-')
      .replace(/^-+|-+$/g, '');

    const filename = `${normalizedSlug || 'post'}.md`;

    const fm = {
      title: baseTitle,
      date: new Date().toISOString(),
      tags: [],
      category: 'General',
      published: draft ? false : true,
      ...(frontmatter && typeof frontmatter === 'object' ? frontmatter : {}),
    };
    const body = typeof content === 'string' ? content : '';
    const markdown = buildFrontmatterMarkdown(fm, body);

    const octokit = new Octokit({ auth: token });

    // Get default branch
    const repoInfo = await octokit.rest.repos.get({ owner, repo });
    const baseBranch = repoInfo.data.default_branch || 'main';

    // Base ref SHA
    const baseRef = await octokit.rest.git.getRef({ owner, repo, ref: `heads/${baseBranch}` });
    const baseSha = baseRef.data.object.sha;

    // Branch name
    const stamp = new Date().toISOString().replace(/[-:T.Z]/g, '').slice(0, 12);
    const branch = `post/${year}-${normalizedSlug}-${stamp}`;

    await octokit.rest.git.createRef({ owner, repo, ref: `refs/heads/${branch}`, sha: baseSha });

    // Destination path in repo
    const destPath = `frontend/public/posts/${year}/${filename}`;

    // Commit file
    await octokit.rest.repos.createOrUpdateFileContents({
      owner,
      repo,
      path: destPath,
      message: `feat(post): add ${year}/${filename}`,
      content: Buffer.from(markdown, 'utf8').toString('base64'),
      branch,
      committer:
        config.github.gitUserName && config.github.gitUserEmail
          ? { name: config.github.gitUserName, email: config.github.gitUserEmail }
          : undefined,
      author:
        config.github.gitUserName && config.github.gitUserEmail
          ? { name: config.github.gitUserName, email: config.github.gitUserEmail }
          : undefined,
    });

    // Optionally run manifest generation file updates inside PR by touching a file
    // (CI will generate manifests automatically on PR)

    // Create PR
    const prTitle = `Add new post: ${baseTitle} (${year}/${normalizedSlug})`;
    const prBody = `This PR adds a new post file at ${destPath}.\n\n- Title: ${baseTitle}\n- Year: ${year}\n- Slug: ${normalizedSlug}\n- Published: ${fm.published !== false}`;

    const pr = await octokit.rest.pulls.create({
      owner,
      repo,
      title: prTitle,
      head: branch,
      base: baseBranch,
      body: prBody,
    });

    return res.status(201).json({ ok: true, data: { prUrl: pr.data.html_url, branch, path: destPath } });
  } catch (err) {
    return next(err);
  }
});

export default router;

```

### agent.js

**Path:** `backend/src/routes/agent.js`

```javascript
/**
 * Agent Routes
 * 
 * AI Agent Orchestration Layer API endpoints
 * Provides access to the Agent Coordinator for multi-turn conversations,
 * tool execution, and memory-enhanced interactions.
 * 
 * Endpoints:
 * - POST /api/v1/agent/run - Run agent with message (non-streaming)
 * - POST /api/v1/agent/stream - Run agent with streaming response
 * - GET /api/v1/agent/session/:sessionId - Get session details
 * - DELETE /api/v1/agent/session/:sessionId - Clear session
 * - GET /api/v1/agent/sessions - List all sessions for a user
 * - GET /api/v1/agent/health - Agent health check
 * - GET /api/v1/agent/tools - List available tools
 */

import express from 'express';
import { AgentCoordinator, createAgentCoordinator, getAgentCoordinator } from '../lib/agent/coordinator.js';
import { buildSystemPrompt, SYSTEM_PROMPTS } from '../lib/agent/prompts/system.js';
import { getSessionMemory } from '../lib/agent/memory/session.js';

const router = express.Router();

/**
 * Get or create the singleton agent coordinator
 */
function getCoordinator() {
  return getAgentCoordinator();
}

// ============================================================================
// RUN ENDPOINTS
// ============================================================================

/**
 * POST /run - Run agent with message (non-streaming)
 * 
 * Request Body:
 * {
 *   message: string,              // User message
 *   sessionId?: string,           // Session ID (auto-generated if not provided)
 *   mode?: string,                // Agent mode: default, research, coding, blog, article, terminal
 *   articleSlug?: string,         // Article slug (for article mode)
 *   tools?: string[],             // Enabled tools (default: all)
 *   model?: string,               // Model override
 *   temperature?: number,         // Temperature override
 *   maxIterations?: number,       // Max tool iterations
 *   userId?: string,              // User ID for memory
 * }
 * 
 * Response:
 * {
 *   ok: true,
 *   data: {
 *     response: string,
 *     sessionId: string,
 *     toolsUsed: string[],
 *     memoryUpdated: boolean,
 *     model: string,
 *     tokens: { prompt, completion, total }
 *   }
 * }
 */
router.post('/run', async (req, res) => {
  try {
    const {
      message,
      sessionId,
      mode = 'default',
      articleSlug,
      tools,
      model,
      temperature,
      maxIterations,
      userId = 'default-user',
    } = req.body;

    if (!message || typeof message !== 'string') {
      return res.status(400).json({
        ok: false,
        error: { message: 'message is required', code: 'INVALID_REQUEST' },
      });
    }

    const coordinator = getCoordinator();

    // Run agent
    const result = await coordinator.run({
      sessionId,
      messages: [{ role: 'user', content: message }],
      mode,
      context: {
        articleSlug,
        userId,
      },
      options: {
        model,
        temperature,
        maxIterations,
      },
    });

    res.json({
      ok: true,
      data: {
        response: result.content,
        sessionId: result.sessionId || sessionId,
        toolsUsed: result.toolCalls?.map(tc => tc.function?.name) || [],
        memoryUpdated: true,
        model: result.model,
        tokens: result.usage,
      },
    });
  } catch (err) {
    console.error('Agent run error:', err);
    res.status(500).json({
      ok: false,
      error: { message: err.message, code: 'INTERNAL_ERROR' },
    });
  }
});

/**
 * POST /stream - Run agent with streaming response
 * 
 * Request Body: Same as /run
 * 
 * Response: Server-Sent Events stream
 * - event: open - Connection established
 * - event: token - Token chunk
 * - event: tool_start - Tool execution started
 * - event: tool_end - Tool execution completed
 * - event: done - Stream completed
 * - event: error - Error occurred
 */
router.post('/stream', async (req, res) => {
  // Set SSE headers
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache, no-transform',
    'Connection': 'keep-alive',
    'X-Accel-Buffering': 'no',
  });

  const send = (event, data) => {
    try {
      if (event) res.write(`event: ${event}\n`);
      if (data !== undefined) {
        const payload = typeof data === 'string' ? data : JSON.stringify(data);
        res.write(`data: ${payload}\n`);
      }
      res.write('\n');
    } catch (e) {
      // Ignore write errors (client disconnected)
    }
  };

  let closed = false;
  const onClose = () => {
    closed = true;
    clearInterval(ping);
    try {
      res.end();
    } catch (e) {}
  };

  req.on('close', onClose);
  req.on('error', onClose);

  // Keep-alive ping
  const ping = setInterval(() => {
    if (!closed) send('ping', {});
  }, 25000);

  try {
    const {
      message,
      sessionId,
      mode = 'default',
      articleSlug,
      tools,
      model,
      temperature,
      maxIterations,
      userId = 'default-user',
    } = req.body;

    if (!message || typeof message !== 'string') {
      send('error', { message: 'message is required', code: 'INVALID_REQUEST' });
      return onClose();
    }

    send('open', { type: 'open' });

    const coordinator = getCoordinator();

    // Stream agent response
    try {
      for await (const event of coordinator.stream({
        sessionId,
        messages: [{ role: 'user', content: message }],
        mode,
        context: {
          articleSlug,
          userId,
        },
        options: {
          model,
          temperature,
          maxIterations,
        },
      })) {
        if (closed) break;

        switch (event.type) {
          case 'text':
            send('token', { token: event.data });
            break;
          case 'tool_start':
            send('tool_start', { tool: event.data.name, id: event.data.id });
            break;
          case 'tool_end':
            send('tool_end', { tool: event.data.name, result: summarizeToolResult(event.data.result) });
            break;
          case 'tool_error':
            send('tool_error', { tool: event.data.name, error: event.data.error });
            break;
          case 'done':
            send('done', {
              type: 'done',
              sessionId,
              toolsUsed: event.data.toolCalls?.map(tc => tc.function?.name) || [],
              content: event.data.content,
            });
            break;
          case 'error':
            send('error', { message: event.data.message });
            break;
        }
      }
    } catch (streamError) {
      send('error', { message: streamError.message, code: 'STREAM_ERROR' });
    }

    onClose();
  } catch (err) {
    console.error('Agent stream error:', err);
    send('error', { message: err.message, code: 'INTERNAL_ERROR' });
    onClose();
  }
});

/**
 * Summarize tool result for streaming (avoid sending too much data)
 */
function summarizeToolResult(result) {
  if (!result) return null;
  if (typeof result === 'string') {
    return result.length > 500 ? result.slice(0, 500) + '...' : result;
  }
  if (Array.isArray(result)) {
    return { count: result.length, preview: result.slice(0, 3) };
  }
  if (typeof result === 'object') {
    const str = JSON.stringify(result);
    if (str.length > 500) {
      return { summary: 'Object with keys: ' + Object.keys(result).join(', ') };
    }
    return result;
  }
  return result;
}

// ============================================================================
// SESSION MANAGEMENT ENDPOINTS
// ============================================================================

/**
 * GET /session/:sessionId - Get session details
 */
router.get('/session/:sessionId', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const coordinator = getCoordinator();

    const session = await coordinator.getSession(sessionId);
    if (!session || !session.history || session.history.length === 0) {
      return res.status(404).json({
        ok: false,
        error: { message: 'Session not found', code: 'NOT_FOUND' },
      });
    }

    res.json({
      ok: true,
      data: {
        sessionId,
        messageCount: session.history?.length || 0,
        metadata: session.metadata,
        // Include last few messages for context
        recentMessages: (session.history || []).slice(-10).map(m => ({
          role: m.role,
          content: typeof m.content === 'string' 
            ? m.content.slice(0, 200) + (m.content.length > 200 ? '...' : '')
            : '[complex content]',
          timestamp: m.timestamp,
        })),
      },
    });
  } catch (err) {
    console.error('Get session error:', err);
    res.status(500).json({
      ok: false,
      error: { message: err.message, code: 'INTERNAL_ERROR' },
    });
  }
});

/**
 * DELETE /session/:sessionId - Clear session
 */
router.delete('/session/:sessionId', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const coordinator = getCoordinator();

    await coordinator.clearSession(sessionId);

    res.json({
      ok: true,
      data: { deleted: true, sessionId },
    });
  } catch (err) {
    console.error('Delete session error:', err);
    res.status(500).json({
      ok: false,
      error: { message: err.message, code: 'INTERNAL_ERROR' },
    });
  }
});

/**
 * GET /sessions - List all sessions (with pagination)
 */
router.get('/sessions', async (req, res) => {
  try {
    const { userId = 'default-user', limit = 20, offset = 0 } = req.query;
    const sessionMemory = getSessionMemory();

    // Note: In-memory store may not support full listing,
    // this would need persistent store for proper implementation
    const sessions = await sessionMemory.listSessions?.({
      userId,
      limit: parseInt(limit, 10),
      offset: parseInt(offset, 10),
    }) || [];

    res.json({
      ok: true,
      data: {
        sessions: sessions || [],
        total: sessions?.length || 0,
      },
    });
  } catch (err) {
    console.error('List sessions error:', err);
    res.status(500).json({
      ok: false,
      error: { message: err.message, code: 'INTERNAL_ERROR' },
    });
  }
});

// ============================================================================
// UTILITY ENDPOINTS
// ============================================================================

/**
 * GET /health - Agent health check
 */
router.get('/health', async (req, res) => {
  try {
    const coordinator = getCoordinator();
    const health = await coordinator.health();

    res.json({
      ok: health.ok,
      data: {
        status: health.ok ? 'healthy' : 'degraded',
        llm: health.llm,
        tools: health.tools,
        uptime: process.uptime(),
        timestamp: new Date().toISOString(),
      },
    });
  } catch (err) {
    console.error('Agent health error:', err);
    res.status(500).json({
      ok: false,
      data: {
        status: 'error',
        error: err.message,
        timestamp: new Date().toISOString(),
      },
    });
  }
});

/**
 * GET /tools - List available tools
 */
router.get('/tools', async (req, res) => {
  try {
    const coordinator = getCoordinator();
    const health = await coordinator.health();
    const toolNames = health.tools?.names || [];

    res.json({
      ok: true,
      data: {
        tools: toolNames.map(name => ({
          name,
          enabled: true,
        })),
        total: toolNames.length,
      },
    });
  } catch (err) {
    console.error('List tools error:', err);
    res.status(500).json({
      ok: false,
      error: { message: err.message, code: 'INTERNAL_ERROR' },
    });
  }
});

/**
 * GET /modes - List available agent modes
 */
router.get('/modes', (req, res) => {
  res.json({
    ok: true,
    data: {
      modes: [
        { id: 'default', name: 'General', description: 'General conversation and assistance' },
        { id: 'research', name: 'Research', description: 'In-depth information gathering' },
        { id: 'coding', name: 'Coding', description: 'Programming assistance' },
        { id: 'blog', name: 'Blog', description: 'Blog content management' },
        { id: 'article', name: 'Article Q&A', description: 'Questions about specific articles' },
        { id: 'terminal', name: 'Terminal', description: 'System administration tasks' },
      ],
    },
  });
});

// ============================================================================
// MEMORY ENDPOINTS
// ============================================================================

/**
 * POST /memory/extract - Extract memories from conversation
 */
router.post('/memory/extract', async (req, res) => {
  try {
    const { sessionId, messages } = req.body;

    if (!messages || !Array.isArray(messages)) {
      return res.status(400).json({
        ok: false,
        error: { message: 'messages array is required', code: 'INVALID_REQUEST' },
      });
    }

    const coordinator = getCoordinator();
    const memories = await coordinator.extractMemories(messages);

    res.json({
      ok: true,
      data: {
        memories: memories || [],
        count: memories?.length || 0,
      },
    });
  } catch (err) {
    console.error('Memory extract error:', err);
    res.status(500).json({
      ok: false,
      error: { message: err.message, code: 'INTERNAL_ERROR' },
    });
  }
});

/**
 * POST /memory/search - Search memories semantically
 */
router.post('/memory/search', async (req, res) => {
  try {
    const { query, userId = 'default-user', limit = 10 } = req.body;

    if (!query || typeof query !== 'string') {
      return res.status(400).json({
        ok: false,
        error: { message: 'query is required', code: 'INVALID_REQUEST' },
      });
    }

    const coordinator = getCoordinator();
    const results = await coordinator.searchMemories(query, { userId, limit });

    res.json({
      ok: true,
      data: {
        results: results || [],
        count: results?.length || 0,
      },
    });
  } catch (err) {
    console.error('Memory search error:', err);
    res.status(500).json({
      ok: false,
      error: { message: err.message, code: 'INTERNAL_ERROR' },
    });
  }
});

export default router;

```

### ai.js

**Path:** `backend/src/routes/ai.js`

```javascript
import { Router } from 'express';
import { aiService, tryParseJson } from '../lib/ai-service.js';
import { getLiteLLMClient } from '../lib/litellm-client.js';
import { config } from '../config.js';

const router = Router();

// ============================================================================
// Model List Endpoint - Get available AI models from LiteLLM
// GET /api/v1/ai/models
// ============================================================================

router.get('/models', async (req, res) => {
  try {
    const client = getLiteLLMClient();
    const models = await client.models();
    
    // Get default model from config
    const defaultModel = config.ai?.gateway?.defaultModel || 
                        process.env.AI_DEFAULT_MODEL || 
                        'gemini-1.5-flash';
    
    // Transform models to a cleaner format with categories
    const categorizedModels = categorizeModels(models, defaultModel);
    
    res.json({
      ok: true,
      data: {
        models: categorizedModels,
        default: defaultModel,
        provider: 'litellm',
      },
    });
  } catch (err) {
    console.error('Failed to fetch models:', err.message);
    
    // Return fallback models if LiteLLM is unavailable
    res.json({
      ok: true,
      data: {
        models: getFallbackModels(),
        default: process.env.AI_DEFAULT_MODEL || 'gemini-1.5-flash',
        provider: 'fallback',
        warning: 'Using fallback model list - LiteLLM may be unavailable',
      },
    });
  }
});

/**
 * Categorize models by provider for better UI organization
 */
function categorizeModels(models, defaultModel) {
  const result = [];
  
  for (const model of models) {
    const id = model.id;
    const info = getModelInfo(id);
    
    result.push({
      id,
      name: info.name,
      provider: info.provider,
      description: info.description,
      isDefault: id === defaultModel,
      capabilities: info.capabilities,
    });
  }
  
  // Sort: default first, then by provider
  return result.sort((a, b) => {
    if (a.isDefault) return -1;
    if (b.isDefault) return 1;
    return a.provider.localeCompare(b.provider);
  });
}

/**
 * Get human-readable model info
 */
function getModelInfo(modelId) {
  const modelMap = {
    // Google Gemini
    'gemini-1.5-flash': { 
      name: 'Gemini 1.5 Flash', 
      provider: 'Google', 
      description: 'Fast and efficient',
      capabilities: ['chat', 'vision'],
    },
    'gemini-1.5-pro': { 
      name: 'Gemini 1.5 Pro', 
      provider: 'Google', 
      description: 'Most capable Gemini',
      capabilities: ['chat', 'vision', 'long-context'],
    },
    'gemini-2.0-flash': { 
      name: 'Gemini 2.0 Flash', 
      provider: 'Google', 
      description: 'Latest experimental',
      capabilities: ['chat', 'vision'],
    },
    // OpenAI
    'gpt-4o': { 
      name: 'GPT-4o', 
      provider: 'OpenAI', 
      description: 'Most capable GPT-4',
      capabilities: ['chat', 'vision'],
    },
    'gpt-4o-mini': { 
      name: 'GPT-4o Mini', 
      provider: 'OpenAI', 
      description: 'Fast and affordable',
      capabilities: ['chat', 'vision'],
    },
    'gpt-4-turbo': { 
      name: 'GPT-4 Turbo', 
      provider: 'OpenAI', 
      description: 'High performance',
      capabilities: ['chat', 'vision'],
    },
    'gpt-3.5-turbo': { 
      name: 'GPT-3.5 Turbo', 
      provider: 'OpenAI', 
      description: 'Legacy fast model',
      capabilities: ['chat'],
    },
    // Anthropic
    'claude-3.5-sonnet': { 
      name: 'Claude 3.5 Sonnet', 
      provider: 'Anthropic', 
      description: 'Best for coding',
      capabilities: ['chat', 'vision'],
    },
    'claude-3-haiku': { 
      name: 'Claude 3 Haiku', 
      provider: 'Anthropic', 
      description: 'Fast responses',
      capabilities: ['chat'],
    },
    // Local
    'local': { 
      name: 'Local (Ollama)', 
      provider: 'Local', 
      description: 'Llama 3.2 via Ollama',
      capabilities: ['chat'],
    },
    'local/llama3': { 
      name: 'Llama 3.2', 
      provider: 'Local', 
      description: 'Via Ollama',
      capabilities: ['chat'],
    },
    'local/codellama': { 
      name: 'CodeLlama', 
      provider: 'Local', 
      description: 'Code-optimized',
      capabilities: ['chat', 'code'],
    },
    // Aliases
    'gpt-4.1': { 
      name: 'GPT-4.1 (Alias)', 
      provider: 'Alias', 
      description: 'Maps to Gemini Flash',
      capabilities: ['chat'],
    },
  };
  
  return modelMap[modelId] || {
    name: modelId,
    provider: 'Unknown',
    description: '',
    capabilities: ['chat'],
  };
}

/**
 * Fallback models when LiteLLM is unavailable
 */
function getFallbackModels() {
  return [
    { id: 'gemini-1.5-flash', name: 'Gemini 1.5 Flash', provider: 'Google', isDefault: true },
    { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro', provider: 'Google' },
    { id: 'gpt-4o', name: 'GPT-4o', provider: 'OpenAI' },
    { id: 'gpt-4o-mini', name: 'GPT-4o Mini', provider: 'OpenAI' },
    { id: 'claude-3.5-sonnet', name: 'Claude 3.5 Sonnet', provider: 'Anthropic' },
  ];
}

// ============================================================================
// Auto-Chat Endpoint (replaces ai-call-gateway proxy target)
// POST /api/v1/ai/auto-chat
// ============================================================================

router.post('/auto-chat', async (req, res, next) => {
  try {
    const { messages, temperature, maxTokens, model } = req.body || {};

    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return res.status(400).json({
        ok: false,
        error: { message: 'messages array is required', code: 'INVALID_REQUEST' },
      });
    }

    // Use unified AI service for chat with optional model selection
    const result = await aiService.chat(messages, {
      temperature,
      maxTokens,
      model, // Pass selected model to AI service
    });

    return res.json({
      ok: true,
      data: {
        content: result.content,
        model: result.model,
        provider: result.provider,
      },
    });
  } catch (err) {
    console.error('auto-chat error:', err);
    return next(err);
  }
});

// GET /api/v1/ai/health - Health check
router.get('/health', async (req, res) => {
  const healthResult = await aiService.health();
  const providerInfo = aiService.getProviderInfo();

  res.json({
    ok: true,
    data: {
      status: healthResult.ok ? 'healthy' : 'degraded',
      provider: providerInfo.provider,
      health: healthResult,
      // Legacy fallback status
      hasGeminiKey: !!config.gemini.apiKey,
      hasOpenRouterKey: !!config.openrouter.apiKey,
      timestamp: new Date().toISOString(),
    },
  });
});

// GET /api/v1/ai/status - Status check
router.get('/status', async (req, res) => {
  const providerInfo = aiService.getProviderInfo();
  const healthResult = await aiService.health();

  res.json({
    ok: true,
    data: {
      status: healthResult.ok ? 'ok' : 'degraded',
      provider: providerInfo.provider,
      model: providerInfo.config[providerInfo.provider]?.model || config.aiServe?.defaultModel,
      aiService: {
        provider: providerInfo.provider,
        config: providerInfo.config,
      },
      features: {
        chat: true,
        vision: true,
        summarize: true,
        generate: true,
        stream: true,
        embeddings: providerInfo.provider === 'litellm',
      },
      uptime: process.uptime(),
      timestamp: new Date().toISOString(),
    },
  });
});

// ============================================================================
// Vision Analysis Endpoint (replaces ai-vision-gateway)
// POST /api/v1/ai/vision/analyze
// ============================================================================

const DEFAULT_VISION_PROMPT = `이 이미지를 분석해주세요. 다음 내용을 간결하게 설명해주세요:
1. 이미지에 보이는 주요 요소들
2. 전체적인 분위기나 맥락
3. 텍스트가 있다면 해당 내용

한국어로 2-3문장으로 간결하게 요약해주세요.`;

/**
 * Fetch image from URL and convert to base64
 */
async function fetchImageAsBase64(imageUrl) {
  const response = await fetch(imageUrl);
  if (!response.ok) {
    throw new Error(`Failed to fetch image: ${response.status}`);
  }

  const contentType = response.headers.get('content-type') || 'image/jpeg';
  const arrayBuffer = await response.arrayBuffer();
  const base64 = Buffer.from(arrayBuffer).toString('base64');

  return { base64, mimeType: contentType };
}

router.post('/vision/analyze', async (req, res, next) => {
  try {
    const { imageUrl, imageBase64, mimeType: inputMimeType, prompt, provider: preferredProvider } = req.body || {};

    let base64Data;
    let mimeType;

    // Get image data from either base64 or URL
    if (imageBase64) {
      base64Data = imageBase64;
      mimeType = inputMimeType || 'image/jpeg';
    } else if (imageUrl) {
      try {
        const fetched = await fetchImageAsBase64(imageUrl);
        base64Data = fetched.base64;
        mimeType = fetched.mimeType;
      } catch (err) {
        return res.status(400).json({
          ok: false,
          error: { message: err.message || 'Failed to fetch image', code: 'IMAGE_FETCH_ERROR' },
        });
      }
    } else {
      return res.status(400).json({
        ok: false,
        error: { message: 'imageUrl or imageBase64 required', code: 'INVALID_REQUEST' },
      });
    }

    const analysisPrompt = prompt || DEFAULT_VISION_PROMPT;

    // Use unified AI service for vision analysis
    try {
      const description = await aiService.vision(base64Data, analysisPrompt, {
        mimeType,
        model: 'gpt-4o', // Vision-capable model
      });

      return res.json({
        ok: true,
        data: {
          description,
          provider: aiService.provider,
        },
      });
    } catch (err) {
      console.error('Vision analysis failed:', err.message);
      return res.status(502).json({
        ok: false,
        error: {
          message: err.message || 'Vision analysis failed',
          code: 'VISION_ERROR',
        },
      });
    }
  } catch (err) {
    console.error('vision/analyze error:', err);
    return next(err);
  }
});

// GET /api/v1/ai/vision/health - Vision health check
router.get('/vision/health', async (req, res) => {
  const healthResult = await aiService.health();
  const providerInfo = aiService.getProviderInfo();

  res.json({
    ok: true,
    data: {
      status: healthResult.ok ? 'ok' : 'degraded',
      provider: providerInfo.provider,
      providers: {
        [providerInfo.provider]: healthResult.ok,
        // Legacy fallback
        gemini: !!config.gemini.apiKey,
        openrouter: !!config.openrouter.apiKey,
      },
      timestamp: new Date().toISOString(),
    },
  });
});

// ============================================================================
// Existing Endpoints (summarize, sketch, prism, chain, generate)
// ============================================================================

router.post('/summarize', async (req, res, next) => {
  try {
    const { text, input, instructions } = req.body || {};
    const contentText = text || input;
    if (!contentText) {
      return res.status(400).json({ ok: false, error: 'Missing text' });
    }

    const result = await aiService.task('summary', {
      content: contentText,
      prompt: instructions,
    }, { temperature: 0.2 });

    return res.json({ ok: true, data: { summary: result.data?.summary || result.data?.text || contentText.slice(0, 200) } });
  } catch (err) {
    return next(err);
  }
});

router.post('/sketch', async (req, res, next) => {
  try {
    const { paragraph, postTitle, persona } = req.body || {};
    if (!paragraph || typeof paragraph !== 'string')
      return res
        .status(400)
        .json({ ok: false, error: 'paragraph is required' });

    const result = await aiService.task('sketch', {
      paragraph,
      postTitle,
      persona,
    });

    if (result.ok && result.data) {
      return res.json({
        ok: true,
        data: {
          mood: result.data.mood,
          bullets: (result.data.bullets || []).slice(0, 10),
        },
      });
    }

    throw new Error('Invalid response');
  } catch (err) {
    return next(err);
  }
});

router.post('/prism', async (req, res, next) => {
  try {
    const { paragraph, postTitle } = req.body || {};
    if (!paragraph || typeof paragraph !== 'string')
      return res
        .status(400)
        .json({ ok: false, error: 'paragraph is required' });

    const result = await aiService.task('prism', {
      paragraph,
      postTitle,
    });

    if (result.ok && result.data) {
      return res.json({
        ok: true,
        data: { facets: (result.data.facets || []).slice(0, 4) },
      });
    }

    throw new Error('Invalid response');
  } catch (err) {
    return next(err);
  }
});

router.post('/chain', async (req, res, next) => {
  try {
    const { paragraph, postTitle } = req.body || {};
    if (!paragraph || typeof paragraph !== 'string')
      return res
        .status(400)
        .json({ ok: false, error: 'paragraph is required' });

    const result = await aiService.task('chain', {
      paragraph,
      postTitle,
    });

    if (result.ok && result.data) {
      return res.json({
        ok: true,
        data: { questions: (result.data.questions || []).slice(0, 6) },
      });
    }

    throw new Error('Invalid response');
  } catch (err) {
    return next(err);
  }
});

// ============================================================================
// Raw Generate Endpoints
// ============================================================================

// Raw generate endpoint for AI Memo and other generic prompts
// Request: { prompt: string, temperature?: number }
// Response: { ok: true, data: { text: string } }
router.post('/generate', async (req, res, next) => {
  try {
    const { prompt, temperature } = req.body || {};
    if (!prompt || typeof prompt !== 'string') {
      return res.status(400).json({ ok: false, error: 'prompt is required' });
    }
    const text = await aiService.generate(String(prompt), {
      temperature: typeof temperature === 'number' ? temperature : 0.2,
    });
    return res.json({ ok: true, data: { text } });
  } catch (err) {
    return next(err);
  }
});

// SSE streaming endpoint. Accepts GET with query `prompt` (or `q`) and optional `temperature`.
// Streams the generated text in small chunks as 'token' events and completes with 'done'.
router.get('/generate/stream', async (req, res, next) => {
  try {
    const q = (req.query.prompt || req.query.q || req.query.text || '').toString();
    const t = Number(req.query.temperature);
    const temperature = Number.isFinite(t) ? t : 0.2;

    if (!q) {
      res.writeHead(400, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache, no-transform',
        Connection: 'keep-alive',
        'X-Accel-Buffering': 'no',
      });
      res.write(`event: error\n`);
      res.write(`data: ${JSON.stringify({ message: 'prompt is required' })}\n\n`);
      return res.end();
    }

    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache, no-transform',
      Connection: 'keep-alive',
      'X-Accel-Buffering': 'no',
    });

    const send = (event, data) => {
      if (event) res.write(`event: ${event}\n`);
      if (data !== undefined) {
        const payload = typeof data === 'string' ? data : JSON.stringify(data);
        // split by newlines to avoid very long lines
        const lines = String(payload).split(/\n/);
        for (const line of lines) {
          res.write(`data: ${line}\n`);
        }
      }
      res.write(`\n`);
    };

    send('open', { type: 'open' });

    let closed = false;
    const onClose = () => {
      closed = true;
      clearInterval(ping);
      try {
        res.end();
      } catch {}
    };
    req.on('close', onClose);

    const ping = setInterval(() => {
      try {
        send('ping', {});
      } catch {
        onClose();
      }
    }, 25000);

    // Use streaming from AIService
    try {
      for await (const chunk of aiService.stream(String(q), { temperature })) {
        if (closed) break;
        send('token', { token: chunk });
      }
      if (!closed) {
        send('done', { type: 'done' });
      }
      return onClose();
    } catch (err) {
      send('error', { message: err?.message || 'generation failed' });
      return onClose();
    }
  } catch (err) {
    return next(err);
  }
});

export default router;

```

### aiAdmin.js

**Path:** `backend/src/routes/aiAdmin.js`

```javascript
/**
 * AI Admin API Routes
 *
 * Admin endpoints for managing AI providers, models, routes, and usage.
 * All endpoints require admin authentication.
 *
 * Base path: /api/v1/admin/ai
 */

import { Router } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { queryAll, queryOne, execute, isD1Configured } from '../lib/d1.js';
import requireAdmin from '../middleware/adminAuth.js';
import { getLiteLLMClient } from '../lib/litellm-client.js';

const router = Router();

// Apply admin auth to all routes
router.use(requireAdmin);

// ============================================================================
// Helpers
// ============================================================================

const generateId = (prefix) => `${prefix}_${uuidv4().split('-')[0]}`;

const parseJsonField = (field) => {
  if (!field) return null;
  if (typeof field === 'object') return field;
  try {
    return JSON.parse(field);
  } catch {
    return null;
  }
};

// Check D1 middleware
const checkD1 = (req, res, next) => {
  if (!isD1Configured()) {
    return res.status(500).json({
      ok: false,
      error: 'D1 database not configured. Set CF_ACCOUNT_ID, CF_API_TOKEN, D1_DATABASE_ID',
    });
  }
  next();
};

router.use(checkD1);

// ============================================================================
// Providers CRUD
// ============================================================================

/**
 * GET /providers - List all providers
 */
router.get('/providers', async (req, res, next) => {
  try {
    const providers = await queryAll(`
      SELECT 
        p.*,
        (SELECT COUNT(*) FROM ai_models WHERE provider_id = p.id) as model_count,
        (SELECT COUNT(*) FROM ai_models WHERE provider_id = p.id AND is_enabled = 1) as enabled_model_count
      FROM ai_providers p
      ORDER BY p.display_name
    `);

    const formatted = providers.map((p) => ({
      id: p.id,
      name: p.name,
      displayName: p.display_name,
      apiBaseUrl: p.api_base_url,
      apiKeyEnv: p.api_key_env,
      isEnabled: !!p.is_enabled,
      healthStatus: p.health_status,
      lastHealthCheck: p.last_health_check,
      modelCount: p.model_count,
      enabledModelCount: p.enabled_model_count,
      createdAt: p.created_at,
      updatedAt: p.updated_at,
    }));

    res.json({ ok: true, data: { providers: formatted } });
  } catch (err) {
    next(err);
  }
});

/**
 * GET /providers/:id - Get single provider
 */
router.get('/providers/:id', async (req, res, next) => {
  try {
    const provider = await queryOne(
      'SELECT * FROM ai_providers WHERE id = ?',
      req.params.id
    );

    if (!provider) {
      return res.status(404).json({ ok: false, error: 'Provider not found' });
    }

    res.json({
      ok: true,
      data: {
        id: provider.id,
        name: provider.name,
        displayName: provider.display_name,
        apiBaseUrl: provider.api_base_url,
        apiKeyEnv: provider.api_key_env,
        isEnabled: !!provider.is_enabled,
        healthStatus: provider.health_status,
        lastHealthCheck: provider.last_health_check,
        createdAt: provider.created_at,
        updatedAt: provider.updated_at,
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * POST /providers - Create provider
 */
router.post('/providers', async (req, res, next) => {
  try {
    const { name, displayName, apiBaseUrl, apiKeyEnv } = req.body;

    if (!name || !displayName) {
      return res.status(400).json({
        ok: false,
        error: 'name and displayName are required',
      });
    }

    // Check for duplicate name
    const existing = await queryOne(
      'SELECT id FROM ai_providers WHERE name = ?',
      name
    );
    if (existing) {
      return res.status(409).json({
        ok: false,
        error: `Provider with name "${name}" already exists`,
      });
    }

    const id = generateId('prov');
    await execute(
      `INSERT INTO ai_providers (id, name, display_name, api_base_url, api_key_env)
       VALUES (?, ?, ?, ?, ?)`,
      id,
      name,
      displayName,
      apiBaseUrl || null,
      apiKeyEnv || null
    );

    const provider = await queryOne('SELECT * FROM ai_providers WHERE id = ?', id);

    res.status(201).json({
      ok: true,
      data: {
        id: provider.id,
        name: provider.name,
        displayName: provider.display_name,
        apiBaseUrl: provider.api_base_url,
        apiKeyEnv: provider.api_key_env,
        isEnabled: !!provider.is_enabled,
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * PUT /providers/:id - Update provider
 */
router.put('/providers/:id', async (req, res, next) => {
  try {
    const { displayName, apiBaseUrl, apiKeyEnv, isEnabled } = req.body;

    const existing = await queryOne(
      'SELECT * FROM ai_providers WHERE id = ?',
      req.params.id
    );
    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Provider not found' });
    }

    await execute(
      `UPDATE ai_providers 
       SET display_name = ?, api_base_url = ?, api_key_env = ?, is_enabled = ?, updated_at = datetime('now')
       WHERE id = ?`,
      displayName ?? existing.display_name,
      apiBaseUrl !== undefined ? apiBaseUrl : existing.api_base_url,
      apiKeyEnv !== undefined ? apiKeyEnv : existing.api_key_env,
      isEnabled !== undefined ? (isEnabled ? 1 : 0) : existing.is_enabled,
      req.params.id
    );

    const provider = await queryOne(
      'SELECT * FROM ai_providers WHERE id = ?',
      req.params.id
    );

    res.json({
      ok: true,
      data: {
        id: provider.id,
        name: provider.name,
        displayName: provider.display_name,
        apiBaseUrl: provider.api_base_url,
        apiKeyEnv: provider.api_key_env,
        isEnabled: !!provider.is_enabled,
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * DELETE /providers/:id - Delete provider
 */
router.delete('/providers/:id', async (req, res, next) => {
  try {
    const existing = await queryOne(
      'SELECT * FROM ai_providers WHERE id = ?',
      req.params.id
    );
    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Provider not found' });
    }

    // Check if has models
    const modelCount = await queryOne(
      'SELECT COUNT(*) as count FROM ai_models WHERE provider_id = ?',
      req.params.id
    );
    if (modelCount?.count > 0) {
      return res.status(400).json({
        ok: false,
        error: `Cannot delete provider with ${modelCount.count} models. Delete models first.`,
      });
    }

    await execute('DELETE FROM ai_providers WHERE id = ?', req.params.id);

    res.json({ ok: true, data: { deleted: req.params.id } });
  } catch (err) {
    next(err);
  }
});

/**
 * POST /providers/:id/health - Check provider health
 */
router.post('/providers/:id/health', async (req, res, next) => {
  try {
    const provider = await queryOne(
      'SELECT * FROM ai_providers WHERE id = ?',
      req.params.id
    );
    if (!provider) {
      return res.status(404).json({ ok: false, error: 'Provider not found' });
    }

    // Get first enabled model for this provider
    const model = await queryOne(
      'SELECT * FROM ai_models WHERE provider_id = ? AND is_enabled = 1 LIMIT 1',
      req.params.id
    );

    let healthStatus = 'unknown';
    let latencyMs = null;
    let error = null;

    if (model) {
      try {
        const client = getLiteLLMClient();
        const start = Date.now();
        await client.chat(
          [{ role: 'user', content: 'Hello' }],
          { model: model.model_name, timeout: 10000 }
        );
        latencyMs = Date.now() - start;
        healthStatus = 'healthy';
      } catch (err) {
        healthStatus = 'down';
        error = err.message;
      }
    }

    // Update provider health status
    await execute(
      `UPDATE ai_providers 
       SET health_status = ?, last_health_check = datetime('now'), updated_at = datetime('now')
       WHERE id = ?`,
      healthStatus,
      req.params.id
    );

    res.json({
      ok: true,
      data: {
        providerId: req.params.id,
        status: healthStatus,
        latencyMs,
        error,
        checkedAt: new Date().toISOString(),
      },
    });
  } catch (err) {
    next(err);
  }
});

// ============================================================================
// Models CRUD
// ============================================================================

/**
 * GET /models - List all models
 */
router.get('/models', async (req, res, next) => {
  try {
    const { providerId, enabled } = req.query;

    let sql = `
      SELECT 
        m.*,
        p.name as provider_name,
        p.display_name as provider_display_name,
        p.is_enabled as provider_enabled
      FROM ai_models m
      JOIN ai_providers p ON m.provider_id = p.id
      WHERE 1=1
    `;
    const params = [];

    if (providerId) {
      sql += ' AND m.provider_id = ?';
      params.push(providerId);
    }
    if (enabled !== undefined) {
      sql += ' AND m.is_enabled = ?';
      params.push(enabled === 'true' || enabled === '1' ? 1 : 0);
    }

    sql += ' ORDER BY m.priority DESC, m.display_name';

    const models = await queryAll(sql, ...params);

    const formatted = models.map((m) => ({
      id: m.id,
      modelName: m.model_name,
      displayName: m.display_name,
      litellmModel: m.litellm_model,
      description: m.description,
      provider: {
        id: m.provider_id,
        name: m.provider_name,
        displayName: m.provider_display_name,
        isEnabled: !!m.provider_enabled,
      },
      contextWindow: m.context_window,
      maxTokens: m.max_tokens,
      cost: {
        inputPer1k: m.input_cost_per_1k,
        outputPer1k: m.output_cost_per_1k,
      },
      capabilities: {
        vision: !!m.supports_vision,
        streaming: !!m.supports_streaming,
        functionCalling: !!m.supports_function_calling,
      },
      isEnabled: !!m.is_enabled,
      priority: m.priority,
      createdAt: m.created_at,
      updatedAt: m.updated_at,
    }));

    res.json({ ok: true, data: { models: formatted } });
  } catch (err) {
    next(err);
  }
});

/**
 * GET /models/:id - Get single model
 */
router.get('/models/:id', async (req, res, next) => {
  try {
    const model = await queryOne(
      `SELECT m.*, p.name as provider_name, p.display_name as provider_display_name
       FROM ai_models m
       JOIN ai_providers p ON m.provider_id = p.id
       WHERE m.id = ?`,
      req.params.id
    );

    if (!model) {
      return res.status(404).json({ ok: false, error: 'Model not found' });
    }

    res.json({
      ok: true,
      data: {
        id: model.id,
        modelName: model.model_name,
        displayName: model.display_name,
        litellmModel: model.litellm_model,
        description: model.description,
        provider: {
          id: model.provider_id,
          name: model.provider_name,
          displayName: model.provider_display_name,
        },
        contextWindow: model.context_window,
        maxTokens: model.max_tokens,
        cost: {
          inputPer1k: model.input_cost_per_1k,
          outputPer1k: model.output_cost_per_1k,
        },
        capabilities: {
          vision: !!model.supports_vision,
          streaming: !!model.supports_streaming,
          functionCalling: !!model.supports_function_calling,
        },
        isEnabled: !!model.is_enabled,
        priority: model.priority,
        createdAt: model.created_at,
        updatedAt: model.updated_at,
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * POST /models - Create model
 */
router.post('/models', async (req, res, next) => {
  try {
    const {
      modelName,
      displayName,
      providerId,
      litellmModel,
      description,
      contextWindow,
      maxTokens,
      inputCostPer1k,
      outputCostPer1k,
      supportsVision,
      supportsStreaming,
      supportsFunctionCalling,
      priority,
    } = req.body;

    if (!modelName || !displayName || !providerId || !litellmModel) {
      return res.status(400).json({
        ok: false,
        error: 'modelName, displayName, providerId, and litellmModel are required',
      });
    }

    // Check provider exists
    const provider = await queryOne(
      'SELECT id FROM ai_providers WHERE id = ?',
      providerId
    );
    if (!provider) {
      return res.status(400).json({
        ok: false,
        error: `Provider "${providerId}" not found`,
      });
    }

    // Check for duplicate model name
    const existing = await queryOne(
      'SELECT id FROM ai_models WHERE model_name = ?',
      modelName
    );
    if (existing) {
      return res.status(409).json({
        ok: false,
        error: `Model with name "${modelName}" already exists`,
      });
    }

    const id = generateId('model');
    await execute(
      `INSERT INTO ai_models (
        id, provider_id, model_name, display_name, litellm_model, description,
        context_window, max_tokens, input_cost_per_1k, output_cost_per_1k,
        supports_vision, supports_streaming, supports_function_calling, priority
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      id,
      providerId,
      modelName,
      displayName,
      litellmModel,
      description || null,
      contextWindow || null,
      maxTokens || null,
      inputCostPer1k || null,
      outputCostPer1k || null,
      supportsVision ? 1 : 0,
      supportsStreaming !== false ? 1 : 0,
      supportsFunctionCalling ? 1 : 0,
      priority || 0
    );

    const model = await queryOne('SELECT * FROM ai_models WHERE id = ?', id);

    res.status(201).json({
      ok: true,
      data: {
        id: model.id,
        modelName: model.model_name,
        displayName: model.display_name,
        litellmModel: model.litellm_model,
        providerId: model.provider_id,
        isEnabled: !!model.is_enabled,
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * PUT /models/:id - Update model
 */
router.put('/models/:id', async (req, res, next) => {
  try {
    const {
      displayName,
      litellmModel,
      description,
      contextWindow,
      maxTokens,
      inputCostPer1k,
      outputCostPer1k,
      supportsVision,
      supportsStreaming,
      supportsFunctionCalling,
      isEnabled,
      priority,
    } = req.body;

    const existing = await queryOne(
      'SELECT * FROM ai_models WHERE id = ?',
      req.params.id
    );
    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Model not found' });
    }

    await execute(
      `UPDATE ai_models SET
        display_name = ?,
        litellm_model = ?,
        description = ?,
        context_window = ?,
        max_tokens = ?,
        input_cost_per_1k = ?,
        output_cost_per_1k = ?,
        supports_vision = ?,
        supports_streaming = ?,
        supports_function_calling = ?,
        is_enabled = ?,
        priority = ?,
        updated_at = datetime('now')
      WHERE id = ?`,
      displayName ?? existing.display_name,
      litellmModel ?? existing.litellm_model,
      description !== undefined ? description : existing.description,
      contextWindow !== undefined ? contextWindow : existing.context_window,
      maxTokens !== undefined ? maxTokens : existing.max_tokens,
      inputCostPer1k !== undefined ? inputCostPer1k : existing.input_cost_per_1k,
      outputCostPer1k !== undefined ? outputCostPer1k : existing.output_cost_per_1k,
      supportsVision !== undefined ? (supportsVision ? 1 : 0) : existing.supports_vision,
      supportsStreaming !== undefined ? (supportsStreaming ? 1 : 0) : existing.supports_streaming,
      supportsFunctionCalling !== undefined ? (supportsFunctionCalling ? 1 : 0) : existing.supports_function_calling,
      isEnabled !== undefined ? (isEnabled ? 1 : 0) : existing.is_enabled,
      priority !== undefined ? priority : existing.priority,
      req.params.id
    );

    const model = await queryOne('SELECT * FROM ai_models WHERE id = ?', req.params.id);

    res.json({
      ok: true,
      data: {
        id: model.id,
        modelName: model.model_name,
        displayName: model.display_name,
        isEnabled: !!model.is_enabled,
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * DELETE /models/:id - Delete model
 */
router.delete('/models/:id', async (req, res, next) => {
  try {
    const existing = await queryOne(
      'SELECT * FROM ai_models WHERE id = ?',
      req.params.id
    );
    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Model not found' });
    }

    // Check if used in routes
    const routeUsage = await queryOne(
      `SELECT COUNT(*) as count FROM ai_routes 
       WHERE primary_model_id = ? 
         OR fallback_model_ids LIKE ?
         OR context_window_fallback_ids LIKE ?`,
      req.params.id,
      `%${req.params.id}%`,
      `%${req.params.id}%`
    );
    if (routeUsage?.count > 0) {
      return res.status(400).json({
        ok: false,
        error: 'Cannot delete model used in routing rules. Update routes first.',
      });
    }

    await execute('DELETE FROM ai_models WHERE id = ?', req.params.id);

    res.json({ ok: true, data: { deleted: req.params.id } });
  } catch (err) {
    next(err);
  }
});

/**
 * POST /models/:id/test - Test model
 */
router.post('/models/:id/test', async (req, res, next) => {
  try {
    const model = await queryOne(
      'SELECT * FROM ai_models WHERE id = ?',
      req.params.id
    );
    if (!model) {
      return res.status(404).json({ ok: false, error: 'Model not found' });
    }

    const { prompt } = req.body;
    const testPrompt = prompt || 'Say "Hello" in one word.';

    try {
      const client = getLiteLLMClient();
      const start = Date.now();
      const response = await client.chat(
        [{ role: 'user', content: testPrompt }],
        { model: model.model_name, timeout: 30000 }
      );
      const latencyMs = Date.now() - start;

      res.json({
        ok: true,
        data: {
          success: true,
          modelId: model.id,
          modelName: model.model_name,
          latencyMs,
          response: response.content?.slice(0, 500),
          usage: response.usage,
        },
      });
    } catch (err) {
      res.json({
        ok: true,
        data: {
          success: false,
          modelId: model.id,
          modelName: model.model_name,
          error: err.message,
        },
      });
    }
  } catch (err) {
    next(err);
  }
});

// ============================================================================
// Routes CRUD
// ============================================================================

/**
 * GET /routes - List all routes
 */
router.get('/routes', async (req, res, next) => {
  try {
    const routes = await queryAll(`
      SELECT 
        r.*,
        m.model_name as primary_model_name,
        m.display_name as primary_model_display_name
      FROM ai_routes r
      LEFT JOIN ai_models m ON r.primary_model_id = m.id
      ORDER BY r.is_default DESC, r.name
    `);

    const formatted = routes.map((r) => ({
      id: r.id,
      name: r.name,
      description: r.description,
      routingStrategy: r.routing_strategy,
      primaryModel: r.primary_model_id
        ? {
            id: r.primary_model_id,
            modelName: r.primary_model_name,
            displayName: r.primary_model_display_name,
          }
        : null,
      fallbackModelIds: parseJsonField(r.fallback_model_ids) || [],
      contextWindowFallbackIds: parseJsonField(r.context_window_fallback_ids) || [],
      numRetries: r.num_retries,
      timeoutSeconds: r.timeout_seconds,
      isDefault: !!r.is_default,
      isEnabled: !!r.is_enabled,
      createdAt: r.created_at,
      updatedAt: r.updated_at,
    }));

    res.json({ ok: true, data: { routes: formatted } });
  } catch (err) {
    next(err);
  }
});

/**
 * GET /routes/:id - Get single route
 */
router.get('/routes/:id', async (req, res, next) => {
  try {
    const route = await queryOne(
      `SELECT r.*, m.model_name as primary_model_name, m.display_name as primary_model_display_name
       FROM ai_routes r
       LEFT JOIN ai_models m ON r.primary_model_id = m.id
       WHERE r.id = ?`,
      req.params.id
    );

    if (!route) {
      return res.status(404).json({ ok: false, error: 'Route not found' });
    }

    res.json({
      ok: true,
      data: {
        id: route.id,
        name: route.name,
        description: route.description,
        routingStrategy: route.routing_strategy,
        primaryModel: route.primary_model_id
          ? {
              id: route.primary_model_id,
              modelName: route.primary_model_name,
              displayName: route.primary_model_display_name,
            }
          : null,
        fallbackModelIds: parseJsonField(route.fallback_model_ids) || [],
        contextWindowFallbackIds: parseJsonField(route.context_window_fallback_ids) || [],
        numRetries: route.num_retries,
        timeoutSeconds: route.timeout_seconds,
        isDefault: !!route.is_default,
        isEnabled: !!route.is_enabled,
        createdAt: route.created_at,
        updatedAt: route.updated_at,
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * POST /routes - Create route
 */
router.post('/routes', async (req, res, next) => {
  try {
    const {
      name,
      description,
      routingStrategy,
      primaryModelId,
      fallbackModelIds,
      contextWindowFallbackIds,
      numRetries,
      timeoutSeconds,
      isDefault,
    } = req.body;

    if (!name) {
      return res.status(400).json({
        ok: false,
        error: 'name is required',
      });
    }

    // Check for duplicate name
    const existing = await queryOne(
      'SELECT id FROM ai_routes WHERE name = ?',
      name
    );
    if (existing) {
      return res.status(409).json({
        ok: false,
        error: `Route with name "${name}" already exists`,
      });
    }

    // If setting as default, unset other defaults
    if (isDefault) {
      await execute('UPDATE ai_routes SET is_default = 0');
    }

    const id = generateId('route');
    await execute(
      `INSERT INTO ai_routes (
        id, name, description, routing_strategy, primary_model_id,
        fallback_model_ids, context_window_fallback_ids,
        num_retries, timeout_seconds, is_default
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      id,
      name,
      description || null,
      routingStrategy || 'latency-based-routing',
      primaryModelId || null,
      fallbackModelIds ? JSON.stringify(fallbackModelIds) : null,
      contextWindowFallbackIds ? JSON.stringify(contextWindowFallbackIds) : null,
      numRetries || 3,
      timeoutSeconds || 120,
      isDefault ? 1 : 0
    );

    const route = await queryOne('SELECT * FROM ai_routes WHERE id = ?', id);

    res.status(201).json({
      ok: true,
      data: {
        id: route.id,
        name: route.name,
        isDefault: !!route.is_default,
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * PUT /routes/:id - Update route
 */
router.put('/routes/:id', async (req, res, next) => {
  try {
    const {
      name,
      description,
      routingStrategy,
      primaryModelId,
      fallbackModelIds,
      contextWindowFallbackIds,
      numRetries,
      timeoutSeconds,
      isDefault,
      isEnabled,
    } = req.body;

    const existing = await queryOne(
      'SELECT * FROM ai_routes WHERE id = ?',
      req.params.id
    );
    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Route not found' });
    }

    // If setting as default, unset other defaults
    if (isDefault && !existing.is_default) {
      await execute('UPDATE ai_routes SET is_default = 0 WHERE id != ?', req.params.id);
    }

    await execute(
      `UPDATE ai_routes SET
        name = ?,
        description = ?,
        routing_strategy = ?,
        primary_model_id = ?,
        fallback_model_ids = ?,
        context_window_fallback_ids = ?,
        num_retries = ?,
        timeout_seconds = ?,
        is_default = ?,
        is_enabled = ?,
        updated_at = datetime('now')
      WHERE id = ?`,
      name ?? existing.name,
      description !== undefined ? description : existing.description,
      routingStrategy ?? existing.routing_strategy,
      primaryModelId !== undefined ? primaryModelId : existing.primary_model_id,
      fallbackModelIds !== undefined ? JSON.stringify(fallbackModelIds) : existing.fallback_model_ids,
      contextWindowFallbackIds !== undefined ? JSON.stringify(contextWindowFallbackIds) : existing.context_window_fallback_ids,
      numRetries ?? existing.num_retries,
      timeoutSeconds ?? existing.timeout_seconds,
      isDefault !== undefined ? (isDefault ? 1 : 0) : existing.is_default,
      isEnabled !== undefined ? (isEnabled ? 1 : 0) : existing.is_enabled,
      req.params.id
    );

    const route = await queryOne('SELECT * FROM ai_routes WHERE id = ?', req.params.id);

    res.json({
      ok: true,
      data: {
        id: route.id,
        name: route.name,
        isDefault: !!route.is_default,
        isEnabled: !!route.is_enabled,
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * DELETE /routes/:id - Delete route
 */
router.delete('/routes/:id', async (req, res, next) => {
  try {
    const existing = await queryOne(
      'SELECT * FROM ai_routes WHERE id = ?',
      req.params.id
    );
    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Route not found' });
    }

    if (existing.is_default) {
      return res.status(400).json({
        ok: false,
        error: 'Cannot delete the default route. Set another route as default first.',
      });
    }

    await execute('DELETE FROM ai_routes WHERE id = ?', req.params.id);

    res.json({ ok: true, data: { deleted: req.params.id } });
  } catch (err) {
    next(err);
  }
});

// ============================================================================
// Usage & Monitoring
// ============================================================================

/**
 * GET /usage - Get usage statistics
 */
router.get('/usage', async (req, res, next) => {
  try {
    const { startDate, endDate, modelId, groupBy } = req.query;

    // Default to last 7 days
    const end = endDate || new Date().toISOString().split('T')[0];
    const start = startDate || new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

    // Summary
    let summaryQuery = `
      SELECT 
        COUNT(*) as total_requests,
        COALESCE(SUM(total_tokens), 0) as total_tokens,
        COALESCE(SUM(estimated_cost), 0) as total_cost,
        COALESCE(AVG(latency_ms), 0) as avg_latency_ms,
        SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END) as success_count,
        SUM(CASE WHEN status = 'error' THEN 1 ELSE 0 END) as error_count
      FROM ai_usage_logs
      WHERE date(created_at) >= ? AND date(created_at) <= ?
    `;
    const summaryParams = [start, end];

    if (modelId) {
      summaryQuery += ' AND model_id = ?';
      summaryParams.push(modelId);
    }

    const summaryResult = await queryOne(summaryQuery, ...summaryParams);

    // Breakdown
    let breakdownQuery;
    let breakdownParams = [start, end];

    if (groupBy === 'model') {
      breakdownQuery = `
        SELECT 
          u.model_id,
          m.model_name,
          m.display_name,
          COUNT(*) as requests,
          COALESCE(SUM(u.total_tokens), 0) as tokens,
          COALESCE(SUM(u.estimated_cost), 0) as cost,
          COALESCE(AVG(u.latency_ms), 0) as avg_latency_ms
        FROM ai_usage_logs u
        LEFT JOIN ai_models m ON u.model_id = m.id
        WHERE date(u.created_at) >= ? AND date(u.created_at) <= ?
        GROUP BY u.model_id
        ORDER BY requests DESC
      `;
    } else {
      // Default: group by day
      breakdownQuery = `
        SELECT 
          date(created_at) as date,
          COUNT(*) as requests,
          COALESCE(SUM(total_tokens), 0) as tokens,
          COALESCE(SUM(estimated_cost), 0) as cost,
          COALESCE(AVG(latency_ms), 0) as avg_latency_ms
        FROM ai_usage_logs
        WHERE date(created_at) >= ? AND date(created_at) <= ?
      `;
      if (modelId) {
        breakdownQuery += ' AND model_id = ?';
        breakdownParams.push(modelId);
      }
      breakdownQuery += ' GROUP BY date(created_at) ORDER BY date ASC';
    }

    const breakdownResult = await queryAll(breakdownQuery, ...breakdownParams);

    res.json({
      ok: true,
      data: {
        period: { start, end },
        summary: {
          totalRequests: summaryResult?.total_requests || 0,
          totalTokens: summaryResult?.total_tokens || 0,
          totalCost: Math.round((summaryResult?.total_cost || 0) * 10000) / 10000,
          avgLatencyMs: Math.round(summaryResult?.avg_latency_ms || 0),
          successCount: summaryResult?.success_count || 0,
          errorCount: summaryResult?.error_count || 0,
        },
        breakdown: breakdownResult.map((r) => ({
          ...(r.date ? { date: r.date } : {}),
          ...(r.model_id
            ? {
                model: {
                  id: r.model_id,
                  modelName: r.model_name,
                  displayName: r.display_name,
                },
              }
            : {}),
          requests: r.requests,
          tokens: r.tokens,
          cost: Math.round((r.cost || 0) * 10000) / 10000,
          avgLatencyMs: Math.round(r.avg_latency_ms || 0),
        })),
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * POST /usage/log - Log a usage event (internal use)
 */
router.post('/usage/log', async (req, res, next) => {
  try {
    const {
      modelId,
      routeId,
      requestType,
      promptTokens,
      completionTokens,
      latencyMs,
      status,
      errorMessage,
      userId,
      metadata,
    } = req.body;

    const totalTokens = (promptTokens || 0) + (completionTokens || 0);

    // Calculate estimated cost
    let estimatedCost = 0;
    if (modelId) {
      const model = await queryOne(
        'SELECT input_cost_per_1k, output_cost_per_1k FROM ai_models WHERE id = ?',
        modelId
      );
      if (model) {
        estimatedCost =
          ((promptTokens || 0) * (model.input_cost_per_1k || 0)) / 1000 +
          ((completionTokens || 0) * (model.output_cost_per_1k || 0)) / 1000;
      }
    }

    const id = generateId('usage');
    await execute(
      `INSERT INTO ai_usage_logs (
        id, model_id, route_id, request_type,
        prompt_tokens, completion_tokens, total_tokens,
        estimated_cost, latency_ms, status, error_message, user_id, metadata
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      id,
      modelId || null,
      routeId || null,
      requestType || 'chat',
      promptTokens || 0,
      completionTokens || 0,
      totalTokens,
      estimatedCost,
      latencyMs || null,
      status || 'success',
      errorMessage || null,
      userId || null,
      metadata ? JSON.stringify(metadata) : null
    );

    res.status(201).json({ ok: true, data: { id } });
  } catch (err) {
    next(err);
  }
});

// ============================================================================
// LiteLLM Config Sync
// ============================================================================

/**
 * POST /reload - Sync database config to LiteLLM
 * This generates a config object that could be used to update LiteLLM
 */
router.post('/reload', async (req, res, next) => {
  try {
    // Get all enabled models
    const models = await queryAll(`
      SELECT m.*, p.name as provider_name, p.api_base_url, p.api_key_env
      FROM ai_models m
      JOIN ai_providers p ON m.provider_id = p.id
      WHERE m.is_enabled = 1 AND p.is_enabled = 1
      ORDER BY m.priority DESC
    `);

    // Get default route
    const defaultRoute = await queryOne(
      'SELECT * FROM ai_routes WHERE is_default = 1 AND is_enabled = 1'
    );

    // Build LiteLLM config
    const modelList = models.map((m) => ({
      model_name: m.model_name,
      litellm_params: {
        model: m.litellm_model,
        ...(m.api_base_url ? { api_base: m.api_base_url } : {}),
        ...(m.api_key_env ? { api_key: `os.environ/${m.api_key_env}` } : {}),
      },
      model_info: {
        description: m.description,
        context_window: m.context_window,
        max_tokens: m.max_tokens,
        input_cost_per_token: m.input_cost_per_1k ? m.input_cost_per_1k / 1000 : undefined,
        output_cost_per_token: m.output_cost_per_1k ? m.output_cost_per_1k / 1000 : undefined,
        supports_vision: !!m.supports_vision,
        supports_streaming: !!m.supports_streaming,
        supports_function_calling: !!m.supports_function_calling,
      },
    }));

    // Build fallbacks from default route
    let fallbacks = [];
    if (defaultRoute) {
      const primaryModel = await queryOne(
        'SELECT model_name FROM ai_models WHERE id = ?',
        defaultRoute.primary_model_id
      );
      const fallbackIds = parseJsonField(defaultRoute.fallback_model_ids) || [];
      
      if (primaryModel && fallbackIds.length > 0) {
        const fallbackModels = await queryAll(
          `SELECT model_name FROM ai_models WHERE id IN (${fallbackIds.map(() => '?').join(',')})`,
          ...fallbackIds
        );
        fallbacks.push({
          [primaryModel.model_name]: fallbackModels.map((m) => m.model_name),
        });
      }
    }

    const litellmConfig = {
      model_list: modelList,
      router_settings: {
        routing_strategy: defaultRoute?.routing_strategy || 'latency-based-routing',
        num_retries: defaultRoute?.num_retries || 3,
        timeout: defaultRoute?.timeout_seconds || 120,
        fallbacks,
      },
    };

    // Note: Actually updating LiteLLM requires calling its /config/update endpoint
    // For now, we just return the config that would be applied

    res.json({
      ok: true,
      data: {
        config: litellmConfig,
        modelCount: models.length,
        message: 'Config generated. Use LiteLLM /config/update API to apply.',
      },
    });
  } catch (err) {
    next(err);
  }
});

/**
 * GET /config/export - Export current config as YAML-compatible JSON
 */
router.get('/config/export', async (req, res, next) => {
  try {
    const providers = await queryAll('SELECT * FROM ai_providers');
    const models = await queryAll('SELECT * FROM ai_models');
    const routes = await queryAll('SELECT * FROM ai_routes');

    res.json({
      ok: true,
      data: {
        exportedAt: new Date().toISOString(),
        providers: providers.map((p) => ({
          id: p.id,
          name: p.name,
          displayName: p.display_name,
          apiBaseUrl: p.api_base_url,
          apiKeyEnv: p.api_key_env,
          isEnabled: !!p.is_enabled,
        })),
        models: models.map((m) => ({
          id: m.id,
          providerId: m.provider_id,
          modelName: m.model_name,
          displayName: m.display_name,
          litellmModel: m.litellm_model,
          description: m.description,
          contextWindow: m.context_window,
          maxTokens: m.max_tokens,
          inputCostPer1k: m.input_cost_per_1k,
          outputCostPer1k: m.output_cost_per_1k,
          supportsVision: !!m.supports_vision,
          supportsStreaming: !!m.supports_streaming,
          supportsFunctionCalling: !!m.supports_function_calling,
          isEnabled: !!m.is_enabled,
          priority: m.priority,
        })),
        routes: routes.map((r) => ({
          id: r.id,
          name: r.name,
          description: r.description,
          routingStrategy: r.routing_strategy,
          primaryModelId: r.primary_model_id,
          fallbackModelIds: parseJsonField(r.fallback_model_ids),
          contextWindowFallbackIds: parseJsonField(r.context_window_fallback_ids),
          numRetries: r.num_retries,
          timeoutSeconds: r.timeout_seconds,
          isDefault: !!r.is_default,
          isEnabled: !!r.is_enabled,
        })),
      },
    });
  } catch (err) {
    next(err);
  }
});

export default router;

```

### analytics.js

**Path:** `backend/src/routes/analytics.js`

```javascript
import { Router } from 'express';
import { queryAll, queryOne, execute, isD1Configured } from '../lib/d1.js';

const router = Router();

// Middleware to check D1 configuration
const requireD1 = (req, res, next) => {
  if (!isD1Configured()) {
    return res.status(503).json({
      ok: false,
      error: 'Analytics service not configured (D1 credentials missing)',
    });
  }
  next();
};

/**
 * POST /api/v1/analytics/view
 * Record a view for a post
 */
router.post('/view', requireD1, async (req, res, next) => {
  try {
    const { year, slug } = req.body || {};

    if (!year || !slug) {
      return res.status(400).json({ ok: false, error: 'year and slug are required' });
    }

    const today = new Date().toISOString().split('T')[0];

    // Upsert daily view count
    await execute(
      `INSERT INTO post_views (post_slug, year, view_date, view_count)
       VALUES (?, ?, ?, 1)
       ON CONFLICT(post_slug, year, view_date)
       DO UPDATE SET view_count = view_count + 1, updated_at = datetime('now')`,
      slug,
      year,
      today
    );

    // Update aggregated stats
    const existingStats = await queryOne(
      `SELECT * FROM post_stats WHERE post_slug = ? AND year = ?`,
      slug,
      year
    );

    if (existingStats) {
      await execute(
        `UPDATE post_stats
         SET total_views = total_views + 1,
             last_viewed_at = datetime('now'),
             updated_at = datetime('now')
         WHERE post_slug = ? AND year = ?`,
        slug,
        year
      );
    } else {
      await execute(
        `INSERT INTO post_stats (post_slug, year, total_views, last_viewed_at)
         VALUES (?, ?, 1, datetime('now'))`,
        slug,
        year
      );
    }

    return res.json({ ok: true, data: { recorded: true } });
  } catch (err) {
    console.error('Failed to record view:', err);
    return next(err);
  }
});

/**
 * GET /api/v1/analytics/stats/:year/:slug
 * Get stats for a specific post
 */
router.get('/stats/:year/:slug', requireD1, async (req, res, next) => {
  try {
    const { year, slug } = req.params;

    const stats = await queryOne(
      `SELECT * FROM post_stats WHERE post_slug = ? AND year = ?`,
      slug,
      year
    );

    return res.json({
      ok: true,
      data: {
        stats: stats || { total_views: 0, views_7d: 0, views_30d: 0 },
      },
    });
  } catch (err) {
    console.error('Failed to get stats:', err);
    return next(err);
  }
});

/**
 * GET /api/v1/analytics/editor-picks
 * Get active editor picks
 */
router.get('/editor-picks', requireD1, async (req, res, next) => {
  try {
    const limit = parseInt(req.query.limit) || 3;

    const picks = await queryAll(
      `SELECT * FROM editor_picks
       WHERE is_active = 1
         AND (expires_at IS NULL OR expires_at > datetime('now'))
       ORDER BY rank ASC
       LIMIT ?`,
      limit
    );

    return res.json({ ok: true, data: { picks } });
  } catch (err) {
    console.error('Failed to get editor picks:', err);
    return next(err);
  }
});

/**
 * GET /api/v1/analytics/trending
 * Get trending posts based on recent views
 */
router.get('/trending', requireD1, async (req, res, next) => {
  try {
    const limit = parseInt(req.query.limit) || 5;
    const days = parseInt(req.query.days) || 7;

    const sinceDate = new Date();
    sinceDate.setDate(sinceDate.getDate() - days);
    const sinceDateStr = sinceDate.toISOString().split('T')[0];

    const trending = await queryAll(
      `SELECT
         pv.post_slug,
         pv.year,
         SUM(pv.view_count) as recent_views,
         COALESCE(ps.total_views, 0) as total_views
       FROM post_views pv
       LEFT JOIN post_stats ps ON pv.post_slug = ps.post_slug AND pv.year = ps.year
       WHERE pv.view_date >= ?
       GROUP BY pv.post_slug, pv.year
       ORDER BY recent_views DESC
       LIMIT ?`,
      sinceDateStr,
      limit
    );

    return res.json({ ok: true, data: { trending } });
  } catch (err) {
    console.error('Failed to get trending:', err);
    return next(err);
  }
});

/**
 * POST /api/v1/analytics/refresh-stats
 * Refresh 7d and 30d view counts (admin/cron)
 */
router.post('/refresh-stats', requireD1, async (req, res, next) => {
  try {
    const now = new Date();
    const date7d = new Date(now);
    date7d.setDate(date7d.getDate() - 7);
    const date30d = new Date(now);
    date30d.setDate(date30d.getDate() - 30);

    const date7dStr = date7d.toISOString().split('T')[0];
    const date30dStr = date30d.toISOString().split('T')[0];

    const allPosts = await queryAll(
      `SELECT DISTINCT post_slug, year FROM post_stats`
    );

    for (const post of allPosts) {
      const views7d = await queryOne(
        `SELECT COALESCE(SUM(view_count), 0) as cnt
         FROM post_views
         WHERE post_slug = ? AND year = ? AND view_date >= ?`,
        post.post_slug,
        post.year,
        date7dStr
      );

      const views30d = await queryOne(
        `SELECT COALESCE(SUM(view_count), 0) as cnt
         FROM post_views
         WHERE post_slug = ? AND year = ? AND view_date >= ?`,
        post.post_slug,
        post.year,
        date30dStr
      );

      await execute(
        `UPDATE post_stats
         SET views_7d = ?, views_30d = ?, updated_at = datetime('now')
         WHERE post_slug = ? AND year = ?`,
        views7d?.cnt || 0,
        views30d?.cnt || 0,
        post.post_slug,
        post.year
      );
    }

    return res.json({ ok: true, data: { refreshed: allPosts.length } });
  } catch (err) {
    console.error('Failed to refresh stats:', err);
    return next(err);
  }
});

export default router;

```

### auth.js

**Path:** `backend/src/routes/auth.js`

```javascript
import { Router } from 'express';
import { signJwt, verifyJwt } from '../lib/jwt.js';
import { config } from '../config.js';

const router = Router();


router.post('/login', async (req, res) => {
  const { username, password } = req.body || {};
  if (!username || !password) {
    return res.status(400).json({ ok: false, error: 'username and password required' });
  }

  const u = config.admin.username;
  const p = config.admin.password;
  if (!u || !p) {
    return res.status(500).json({ ok: false, error: 'server missing ADMIN_USERNAME/ADMIN_PASSWORD' });
  }

  if (String(username) !== String(u) || String(password) !== String(p)) {
    return res.status(401).json({ ok: false, error: 'invalid credentials' });
  }

  const token = signJwt({ sub: 'admin', role: 'admin', username: u });
  return res.json({ ok: true, data: { token } });
});

router.get('/me', async (req, res) => {
  try {
    const auth = req.headers['authorization'] || '';
    const token = auth.replace(/^Bearer\s+/i, '').trim();
    if (!token) return res.status(401).json({ ok: false, error: 'Unauthorized' });
    const claims = verifyJwt(token);
    return res.json({ ok: true, data: { claims } });
  } catch (err) {
    return res.status(401).json({ ok: false, error: 'Unauthorized' });
  }
});

export default router;

```

### chat.js

**Path:** `backend/src/routes/chat.js`

```javascript
import { Router } from 'express';
import { getVASClient, generateContent, tryParseJson } from '../lib/ai-serve.js';

const router = Router();

// In-memory session storage (for simplicity - use Redis in production)
const sessions = new Map();

/**
 * Helper: Create a new session
 */
function createSession(title = '') {
  const sessionId = `sess-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  sessions.set(sessionId, {
    id: sessionId,
    title: title || `Session ${sessionId.slice(-6)}`,
    messages: [],
    createdAt: new Date().toISOString(),
  });
  return sessionId;
}

/**
 * Helper: Get session
 */
function getSession(sessionId) {
  return sessions.get(sessionId);
}

/**
 * Helper: Validate task mode
 */
const VALID_TASK_MODES = ['sketch', 'prism', 'chain', 'catalyst', 'summary', 'custom'];
function isValidTaskMode(mode) {
  return VALID_TASK_MODES.includes(mode);
}

/**
 * Helper: Build prompt for task
 */
function buildTaskPrompt(mode, payload) {
  const { paragraph, content, postTitle, persona, prompt } = payload;
  const text = paragraph || content || prompt || '';
  const title = postTitle || '';

  switch (mode) {
    case 'sketch':
      return {
        prompt: [
          'You are a helpful writing companion. Return STRICT JSON only matching the schema.',
          '{"mood":"string","bullets":["string", "string", "..."]}',
          '',
          `Persona: ${persona || 'default'}`,
          `Post: ${title.slice(0, 120)}`,
          'Paragraph:',
          text.slice(0, 1600),
          '',
          'Task: Capture the emotional sketch. Select a concise mood (e.g., curious, excited, skeptical) and 3-6 short bullets in the original language of the text.',
        ].join('\n'),
        temperature: 0.3,
      };

    case 'prism':
      return {
        prompt: [
          'Return STRICT JSON only for idea facets.',
          '{"facets":[{"title":"string","points":["string","string"]}]}',
          `Post: ${title.slice(0, 120)}`,
          'Paragraph:',
          text.slice(0, 1600),
          '',
          'Task: Provide 2-3 facets (titles) with 2-4 concise points each, in the original language.',
        ].join('\n'),
        temperature: 0.2,
      };

    case 'chain':
      return {
        prompt: [
          'Return STRICT JSON only for tail questions.',
          '{"questions":[{"q":"string","why":"string"}]}',
          `Post: ${title.slice(0, 120)}`,
          'Paragraph:',
          text.slice(0, 1600),
          '',
          'Task: Generate 3-5 short follow-up questions and a brief why for each, in the original language.',
        ].join('\n'),
        temperature: 0.2,
      };

    case 'summary':
      return {
        prompt: `Summarize the following content in Korean, concise but faithful to key points.\n\n${text}`,
        temperature: 0.2,
      };

    case 'catalyst':
      return {
        prompt: [
          'Return STRICT JSON for catalyst suggestions.',
          '{"suggestions":[{"idea":"string","reason":"string"}]}',
          `Post: ${title.slice(0, 120)}`,
          'Content:',
          text.slice(0, 1600),
          '',
          'Task: Provide 2-4 creative suggestions or alternative perspectives, in the original language.',
        ].join('\n'),
        temperature: 0.4,
      };

    case 'custom':
    default:
      return {
        prompt: text,
        temperature: 0.2,
      };
  }
}

/**
 * Helper: Get fallback data for task
 */
function getFallbackData(mode, payload) {
  const text = payload.paragraph || payload.content || payload.prompt || '';
  const sentences = text
    .replace(/\n+/g, ' ')
    .split(/[.!?]\s+/)
    .map((s) => s.trim())
    .filter(Boolean);

  switch (mode) {
    case 'sketch':
      return {
        mood: 'curious',
        bullets: sentences.slice(0, 4).map((s) => (s.length > 140 ? `${s.slice(0, 138)}...` : s)),
      };
    case 'prism':
      return {
        facets: [
          { title: '핵심 요점', points: [text.slice(0, 140)] },
          { title: '생각해볼 점', points: ['관점 A', '관점 B'] },
        ],
      };
    case 'chain':
      return {
        questions: [
          { q: '무엇이 핵심 주장인가?', why: '핵심을 명료화' },
          { q: '어떤 가정이 있는가?', why: '숨은 전제 확인' },
          { q: '적용 예시는?', why: '구체화' },
        ],
      };
    case 'summary':
      return { summary: text.slice(0, 300) + (text.length > 300 ? '...' : '') };
    case 'catalyst':
      return {
        suggestions: [
          { idea: '다른 관점에서 접근', reason: '새로운 시각 제공' },
        ],
      };
    default:
      return { text: 'Unable to process request' };
  }
}

/**
 * POST /api/v1/chat/session
 * Create new chat session
 */
router.post('/session', async (req, res, next) => {
  try {
    const { title } = req.body || {};
    const sessionId = createSession(title);
    
    return res.json({
      ok: true,
      data: { sessionID: sessionId, id: sessionId },
    });
  } catch (err) {
    return next(err);
  }
});

/**
 * POST /api/v1/chat/session/:sessionId/message
 * Send chat message (SSE streaming)
 */
router.post('/session/:sessionId/message', async (req, res, next) => {
  try {
    const { sessionId } = req.params;
    const { parts, context, model } = req.body || {};

    // Get or create session
    let session = getSession(sessionId);
    if (!session) {
      const newId = createSession();
      session = getSession(newId);
    }

    // Extract text from parts
    let userMessage = '';
    if (Array.isArray(parts)) {
      userMessage = parts
        .filter((p) => p.type === 'text')
        .map((p) => p.text)
        .join('\n');
    } else if (typeof parts === 'string') {
      userMessage = parts;
    }

    if (!userMessage.trim()) {
      return res.status(400).json({ ok: false, error: 'No message content' });
    }

    // Add context if available
    const pageContext = context?.page;
    if (pageContext?.url || pageContext?.title) {
      userMessage = `[Context: ${pageContext.title || ''} - ${pageContext.url || ''}]\n\n${userMessage}`;
    }

    // Store message
    session.messages.push({ role: 'user', content: userMessage });

    // Set up SSE
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache, no-transform',
      Connection: 'keep-alive',
      'X-Accel-Buffering': 'no',
    });

    const send = (data) => {
      const payload = typeof data === 'string' ? data : JSON.stringify(data);
      res.write(`data: ${payload}\n\n`);
    };

    let closed = false;
    req.on('close', () => {
      closed = true;
    });

    try {
      // Generate response via VAS with optional model selection
      const client = getVASClient();
      const result = await client.chat(session.messages, { model });

      if (closed) return;

      // Stream the response
      const text = result.content || '';
      
      // Send text in chunks
      const chunkSize = 50;
      for (let i = 0; i < text.length; i += chunkSize) {
        if (closed) break;
        const chunk = text.slice(i, i + chunkSize);
        send({ type: 'text', text: chunk });
        await new Promise((r) => setTimeout(r, 20));
      }

      // Store assistant response
      session.messages.push({ role: 'assistant', content: text });

      // Send done event
      send({ type: 'done' });
    } catch (err) {
      console.error('Chat streaming error:', err);
      send({ type: 'error', error: err.message || 'Chat failed' });
    }

    res.end();
  } catch (err) {
    return next(err);
  }
});

/**
 * POST /api/v1/chat/session/:sessionId/task
 * Execute inline AI task (sketch, prism, chain, etc.)
 */
router.post('/session/:sessionId/task', async (req, res, next) => {
  try {
    const { mode, payload, context, prompt: legacyPrompt } = req.body || {};

    // Validate mode
    const taskMode = isValidTaskMode(mode) ? mode : 'custom';
    const taskPayload = payload || {};

    // Legacy compatibility
    if (legacyPrompt && legacyPrompt.trim() && taskMode === 'custom') {
      taskPayload.prompt = legacyPrompt;
    }

    // Validate content
    const content = taskPayload.paragraph || taskPayload.content || taskPayload.prompt || '';
    if (!content.trim()) {
      return res.status(400).json({ ok: false, error: 'No content provided for task' });
    }

    try {
      // Build prompt
      const { prompt, temperature } = buildTaskPrompt(taskMode, taskPayload);

      // Execute via VAS
      const text = await generateContent(prompt, { temperature });

      // Parse response based on mode
      let data;
      if (taskMode === 'custom' || taskMode === 'summary') {
        data = taskMode === 'summary' ? { summary: text } : { text };
      } else {
        const json = tryParseJson(text);
        if (json) {
          data = json;
        } else {
          throw new Error('Invalid JSON response');
        }
      }

      return res.json({
        ok: true,
        data,
        mode: taskMode,
        source: 'vas',
      });
    } catch (err) {
      console.warn('Task execution failed, returning fallback:', err.message);
      const fallbackData = getFallbackData(taskMode, taskPayload);
      return res.json({
        ok: true,
        data: fallbackData,
        mode: taskMode,
        source: 'fallback',
        _fallback: true,
      });
    }
  } catch (err) {
    return next(err);
  }
});

/**
 * POST /api/v1/chat/aggregate
 * Aggregate multiple session summaries
 */
router.post('/aggregate', async (req, res, next) => {
  try {
    const { prompt } = req.body || {};

    if (!prompt || typeof prompt !== 'string' || !prompt.trim()) {
      return res.status(400).json({ ok: false, error: 'prompt is required' });
    }

    const systemPrompt = [
      '다음 입력에는 여러 대화 세션의 요약과 사용자의 통합 질문이 함께 포함되어 있습니다.',
      '먼저 세션 요약들을 충분히 이해한 뒤, 사용자의 요청에 따라 전체를 한 번에 통합하여 답변해 주세요.',
      '- 공통된 핵심 아이디어',
      '- 서로 다른 관점이나 긴장 지점',
      '- 다음 액션/실천 아이디어',
      '를 중심으로 한국어로 정리해 주세요.',
      '',
      '---',
      '',
      prompt.trim(),
    ].join('\n');

    const text = await generateContent(systemPrompt, { temperature: 0.2 });
    return res.json({ ok: true, data: { text } });
  } catch (err) {
    return next(err);
  }
});

export default router;

```

### comments.js

**Path:** `backend/src/routes/comments.js`

```javascript
import { Router } from 'express';
import { queryAll, queryOne, execute, isD1Configured } from '../lib/d1.js';
import crypto from 'crypto';

const router = Router();

// In-memory listener registry (single-process only) for SSE
const listenersByPost = new Map();
function addListener(postId, send) {
  const key = String(postId);
  let set = listenersByPost.get(key);
  if (!set) {
    set = new Set();
    listenersByPost.set(key, set);
  }
  set.add(send);
  return () => {
    try {
      set.delete(send);
      if (set.size === 0) listenersByPost.delete(key);
    } catch {}
  };
}
function broadcast(postId, payload) {
  const key = String(postId);
  const set = listenersByPost.get(key);
  if (!set || set.size === 0) return;
  for (const send of Array.from(set)) {
    try {
      send(payload);
    } catch {
      try {
        set.delete(send);
      } catch {}
    }
  }
}

// Middleware to check D1 configuration
const requireD1 = (req, res, next) => {
  if (!isD1Configured()) {
    return res.status(503).json({
      ok: false,
      error: 'Comments service not configured (D1 credentials missing)',
    });
  }
  next();
};

/**
 * GET /comments?postId=xxx - Get comments for a post
 */
router.get('/', requireD1, async (req, res, next) => {
  try {
    const postId = req.query.postId;
    if (!postId)
      return res.status(400).json({ ok: false, error: 'postId is required' });

    const items = await queryAll(
      `SELECT id, post_id, author, content, email, status, created_at, updated_at
       FROM comments
       WHERE post_id = ? AND status = 'visible'
       ORDER BY created_at ASC`,
      String(postId).trim().slice(0, 256)
    );

    // Map to frontend expected format
    const comments = items.map((d) => ({
      id: d.id,
      postId: d.post_id,
      author: d.author,
      content: d.content,
      website: null, // D1 schema uses email, not website
      parentId: null,
      createdAt: d.created_at,
    }));

    return res.json({ ok: true, data: { comments } });
  } catch (err) {
    return next(err);
  }
});

/**
 * POST /comments - Create new comment
 */
router.post('/', requireD1, async (req, res, next) => {
  try {
    const { postId, author, content, email, website } = req.body || {};

    if (!postId || typeof postId !== 'string')
      return res.status(400).json({ ok: false, error: 'postId is required' });
    if (!author || typeof author !== 'string')
      return res.status(400).json({ ok: false, error: 'author is required' });
    if (!content || typeof content !== 'string')
      return res.status(400).json({ ok: false, error: 'content is required' });

    // Basic validation
    if (author.length > 64 || content.length > 5000) {
      return res.status(400).json({ ok: false, error: 'Author or content too long' });
    }

    const normalizedPostId = String(postId).trim().slice(0, 256);
    const commentId = `comment-${crypto.randomUUID()}`;
    const now = new Date().toISOString();

    await execute(
      `INSERT INTO comments(id, post_id, author, email, content, status, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      commentId,
      normalizedPostId,
      author.trim().slice(0, 64),
      email ? email.trim().slice(0, 256) : null,
      content.trim().slice(0, 5000),
      'visible',
      now,
      now
    );

    // Best-effort realtime push to connected SSE clients
    try {
      const item = {
        id: commentId,
        postId: normalizedPostId,
        author: author.trim().slice(0, 64),
        content: content.trim().slice(0, 5000),
        website: website || null,
        parentId: null,
        createdAt: now,
      };
      broadcast(normalizedPostId, { type: 'append', items: [item] });
    } catch {}

    return res.json({ ok: true, data: { id: commentId } });
  } catch (err) {
    return next(err);
  }
});

/**
 * SSE stream for live comments per post
 */
router.get('/stream', requireD1, async (req, res, next) => {
  try {
    const postId = req.query.postId;
    if (!postId) {
      res.writeHead(400, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache, no-transform',
        Connection: 'keep-alive',
        'X-Accel-Buffering': 'no',
      });
      res.write(`data: ${JSON.stringify({ type: 'error', message: 'postId is required' })}\n\n`);
      return res.end();
    }

    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache, no-transform',
      Connection: 'keep-alive',
      'X-Accel-Buffering': 'no',
    });

    const send = (data) => {
      const s = typeof data === 'string' ? data : JSON.stringify(data);
      const lines = String(s).split(/\n/);
      for (const line of lines) {
        res.write(`data: ${line}\n`);
      }
      res.write(`\n`);
    };

    // Register listener for instant broadcasts
    const unsubscribe = addListener(String(postId), send);
    send({ type: 'open' });

    let closed = false;
    const onClose = () => {
      closed = true;
      clearInterval(ping);
      try {
        if (typeof unsubscribe === 'function') unsubscribe();
      } catch {}
      try {
        res.end();
      } catch {}
    };
    req.on('close', onClose);

    // Heartbeat
    const ping = setInterval(() => {
      try {
        send({ type: 'ping' });
      } catch {
        onClose();
      }
    }, 25000);

    // Poll D1 for new entries after connection time
    let lastTs = Date.now();

    const poll = async () => {
      if (closed) return;
      try {
        const items = await queryAll(
          `SELECT id, post_id, author, content, email, status, created_at
           FROM comments
           WHERE post_id = ? AND status = 'visible'
           ORDER BY created_at ASC`,
          String(postId).trim().slice(0, 256)
        );

        const newItems = [];
        let maxTs = lastTs;

        for (const d of items) {
          const ts = d.created_at ? Date.parse(d.created_at) : 0;
          if (ts > lastTs) {
            maxTs = Math.max(maxTs, ts);
            newItems.push({
              id: d.id,
              postId: d.post_id,
              author: d.author,
              content: d.content,
              website: null,
              parentId: null,
              createdAt: d.created_at,
            });
          }
        }

        if (newItems.length > 0) {
          newItems.sort((a, b) =>
            a.createdAt && b.createdAt ? Date.parse(a.createdAt) - Date.parse(b.createdAt) : 0
          );
          send({ type: 'append', items: newItems });
          lastTs = maxTs;
        }
      } catch (e) {
        send({ type: 'error', message: e?.message || 'poll failed' });
      } finally {
        setTimeout(poll, 5000);
      }
    };

    poll();
  } catch (err) {
    return next(err);
  }
});

/**
 * DELETE /comments/:id - Delete comment (admin only)
 */
router.delete('/:id', requireD1, async (req, res, next) => {
  try {
    const id = req.params.id;

    // TODO: Add admin auth middleware

    const existing = await queryOne('SELECT id FROM comments WHERE id = ?', id);
    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Comment not found' });
    }

    // Soft delete by setting status to 'hidden'
    await execute(
      "UPDATE comments SET status = 'hidden', updated_at = ? WHERE id = ?",
      new Date().toISOString(),
      id
    );

    return res.json({ ok: true, data: { deleted: true } });
  } catch (err) {
    return next(err);
  }
});

export default router;

```

### config.js

**Path:** `backend/src/routes/config.js`

```javascript
import { Router } from 'express';
import { config } from '../config.js';
import requireAdmin from '../middleware/adminAuth.js';
import fs from 'node:fs/promises';
import path from 'node:path';

const router = Router();

const CONFIG_CATEGORIES = [
  {
    id: 'app',
    name: 'Application',
    description: '서버 기본 설정',
    variables: [
      { key: 'APP_ENV', type: 'select', options: ['development', 'staging', 'production', 'test'], description: '실행 환경' },
      { key: 'HOST', type: 'text', default: '0.0.0.0', description: '서버 호스트' },
      { key: 'PORT', type: 'number', default: '5080', description: '서버 포트' },
      { key: 'LOG_LEVEL', type: 'select', options: ['fatal', 'error', 'warn', 'info', 'debug', 'trace'], description: '로그 레벨' },
      { key: 'TRUST_PROXY', type: 'number', default: '1', description: 'Proxy 신뢰 레벨' },
      { key: 'RATE_LIMIT_MAX', type: 'number', default: '60', description: '분당 최대 요청 수' },
      { key: 'RATE_LIMIT_WINDOW_MS', type: 'number', default: '60000', description: 'Rate limit 윈도우 (ms)' },
    ],
  },
  {
    id: 'cors',
    name: 'CORS & URLs',
    description: 'CORS 허용 도메인 및 URL 설정',
    variables: [
      { key: 'ALLOWED_ORIGINS', type: 'textarea', delimiter: ',', description: 'CORS 허용 도메인 (쉼표 구분)' },
      { key: 'API_BASE_URL', type: 'url', description: 'API 기본 URL' },
      { key: 'SITE_BASE_URL', type: 'url', description: '사이트 기본 URL' },
    ],
  },
  {
    id: 'ai',
    name: 'AI Services',
    description: 'AI 모델 및 VAS 서비스 설정',
    variables: [
      { key: 'AI_SERVE_BASE_URL', type: 'url', default: 'http://vas-proxy:7016', description: 'VAS Proxy URL' },
      { key: 'VAS_CORE_URL', type: 'url', default: 'http://vas-core:7012', description: 'VAS Core URL' },
      { key: 'AI_SERVE_DEFAULT_PROVIDER', type: 'select', options: ['github-copilot', 'gemini', 'openai', 'anthropic', 'local'], description: '기본 AI 제공자' },
      { key: 'AI_SERVE_DEFAULT_MODEL', type: 'text', default: 'gpt-4.1', description: '기본 AI 모델' },
      { key: 'GEMINI_API_KEY', type: 'password', isSecret: true, description: 'Gemini API Key' },
      { key: 'GEMINI_MODEL', type: 'text', default: 'gemini-1.5-flash', description: 'Gemini 모델' },
      { key: 'OPENROUTER_API_KEY', type: 'password', isSecret: true, description: 'OpenRouter API Key' },
    ],
  },
  {
    id: 'cloudflare',
    name: 'Cloudflare',
    description: 'D1, R2, Workers 설정',
    variables: [
      { key: 'CF_ACCOUNT_ID', type: 'text', description: 'Cloudflare Account ID' },
      { key: 'CF_API_TOKEN', type: 'password', isSecret: true, description: 'Cloudflare API Token' },
      { key: 'D1_DATABASE_ID', type: 'text', description: 'D1 Database ID' },
      { key: 'R2_BUCKET_NAME', type: 'text', default: 'blog', description: 'R2 Bucket 이름' },
      { key: 'R2_ASSETS_BASE_URL', type: 'url', default: 'https://assets-b.nodove.com', description: 'R2 Assets URL' },
    ],
  },
  {
    id: 'github',
    name: 'GitHub',
    description: 'GitHub 통합 설정',
    variables: [
      { key: 'GITHUB_TOKEN', type: 'password', isSecret: true, description: 'GitHub Personal Access Token' },
      { key: 'GITHUB_REPO_OWNER', type: 'text', description: 'GitHub Repo Owner' },
      { key: 'GITHUB_REPO_NAME', type: 'text', description: 'GitHub Repo Name' },
      { key: 'GIT_USER_NAME', type: 'text', description: 'Git User Name' },
      { key: 'GIT_USER_EMAIL', type: 'text', description: 'Git User Email' },
    ],
  },
  {
    id: 'rag',
    name: 'RAG Services',
    description: 'TEI, ChromaDB 설정',
    variables: [
      { key: 'TEI_URL', type: 'url', default: 'http://embedding-server:80', description: 'TEI Embedding Server URL' },
      { key: 'CHROMA_URL', type: 'url', default: 'http://chromadb:8000', description: 'ChromaDB URL' },
      { key: 'CHROMA_COLLECTION', type: 'text', default: 'blog-posts-all-MiniLM-L6-v2', description: 'ChromaDB Collection' },
    ],
  },
  {
    id: 'auth',
    name: 'Authentication',
    description: '인증 및 보안 설정',
    variables: [
      { key: 'ADMIN_BEARER_TOKEN', type: 'password', isSecret: true, description: 'Admin Bearer Token' },
      { key: 'JWT_SECRET', type: 'password', isSecret: true, description: 'JWT Secret' },
      { key: 'ADMIN_USERNAME', type: 'text', description: 'Admin Username' },
      { key: 'ADMIN_PASSWORD', type: 'password', isSecret: true, description: 'Admin Password' },
    ],
  },
  {
    id: 'firebase',
    name: 'Firebase',
    description: 'Firebase 설정',
    variables: [
      { key: 'FIREBASE_PROJECT_ID', type: 'text', description: 'Firebase Project ID' },
      { key: 'FIREBASE_SERVICE_ACCOUNT_JSON', type: 'textarea', isSecret: true, description: 'Firebase Service Account JSON' },
    ],
  },
];

router.get('/categories', requireAdmin, (req, res) => {
  res.json({ ok: true, data: { categories: CONFIG_CATEGORIES } });
});

router.get('/current', requireAdmin, (req, res) => {
  const currentConfig = {};

  CONFIG_CATEGORIES.forEach((cat) => {
    cat.variables.forEach((variable) => {
      const value = process.env[variable.key];
      currentConfig[variable.key] = {
        value: variable.isSecret ? (value ? '********' : '') : value || '',
        isSecret: variable.isSecret || false,
        isSet: !!value,
        default: variable.default || '',
      };
    });
  });

  res.json({ ok: true, data: { config: currentConfig } });
});

router.post('/validate', requireAdmin, (req, res) => {
  const { key, value } = req.body;

  const category = CONFIG_CATEGORIES.find((cat) => cat.variables.some((v) => v.key === key));
  if (!category) {
    return res.status(404).json({ ok: false, error: 'Unknown variable' });
  }

  const variable = category.variables.find((v) => v.key === key);
  const validation = validateVariable(variable, value);

  res.json({ ok: true, data: validation });
});

function validateVariable(variable, value) {
  if (!value && variable.isRequired) {
    return { valid: false, error: 'Value is required' };
  }

  if (!value) return { valid: true };

  switch (variable.type) {
    case 'number':
      if (isNaN(Number(value))) {
        return { valid: false, error: 'Must be a number' };
      }
      break;
    case 'url':
      try {
        new URL(value);
      } catch {
        return { valid: false, error: 'Invalid URL format' };
      }
      break;
    case 'select':
      if (variable.options && !variable.options.includes(value)) {
        return { valid: false, error: `Must be one of: ${variable.options.join(', ')}` };
      }
      break;
  }

  return { valid: true };
}

router.post('/export', requireAdmin, (req, res) => {
  const { format = 'env', includeSecrets = false } = req.body;

  let output = '';

  if (format === 'env') {
    output = generateEnvFile(includeSecrets);
  } else if (format === 'docker-compose') {
    output = generateDockerComposeEnv(includeSecrets);
  } else if (format === 'wrangler') {
    output = generateWranglerVars(includeSecrets);
  } else {
    return res.status(400).json({ ok: false, error: 'Invalid format' });
  }

  res.json({ ok: true, data: { content: output, format } });
});

function generateEnvFile(includeSecrets = false) {
  const lines = ['# Generated environment configuration', `# Generated at: ${new Date().toISOString()}`, ''];

  CONFIG_CATEGORIES.forEach((cat) => {
    lines.push(`# === ${cat.name} ===`);
    cat.variables.forEach((v) => {
      const value = process.env[v.key] || v.default || '';
      if (v.isSecret && !includeSecrets) {
        lines.push(`# ${v.key}=<secret>`);
      } else {
        lines.push(`${v.key}=${value}`);
      }
    });
    lines.push('');
  });

  return lines.join('\n');
}

function generateDockerComposeEnv(includeSecrets = false) {
  const lines = ['    environment:'];

  CONFIG_CATEGORIES.forEach((cat) => {
    cat.variables.forEach((v) => {
      const value = process.env[v.key] || v.default || '';
      if (v.isSecret && !includeSecrets) {
        lines.push(`      # - ${v.key}=<secret>`);
      } else if (value) {
        lines.push(`      - ${v.key}=${value}`);
      }
    });
  });

  return lines.join('\n');
}

function generateWranglerVars(includeSecrets = false) {
  const lines = ['[vars]'];
  const secretLines = ['', '# Secrets (set via wrangler secret put):'];

  CONFIG_CATEGORIES.forEach((cat) => {
    cat.variables.forEach((v) => {
      const value = process.env[v.key] || v.default || '';
      if (v.isSecret) {
        secretLines.push(`# wrangler secret put ${v.key}`);
      } else if (value) {
        lines.push(`${v.key} = "${value}"`);
      }
    });
  });

  return [...lines, ...secretLines].join('\n');
}

router.post('/save-env', requireAdmin, async (req, res) => {
  const { variables, target = 'backend' } = req.body;

  if (!variables || typeof variables !== 'object') {
    return res.status(400).json({ ok: false, error: 'variables object required' });
  }

  try {
    let envPath;
    if (target === 'root') {
      envPath = path.join(config.content.repoRoot, '.env');
    } else {
      envPath = path.join(config.content.repoRoot, 'backend', '.env');
    }

    const lines = [];
    const allVars = {};

    CONFIG_CATEGORIES.forEach((cat) => {
      cat.variables.forEach((v) => {
        allVars[v.key] = process.env[v.key] || v.default || '';
      });
    });

    Object.entries(variables).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        allVars[key] = value;
      }
    });

    lines.push(`# Auto-generated at ${new Date().toISOString()}`);
    lines.push('');

    CONFIG_CATEGORIES.forEach((cat) => {
      lines.push(`# === ${cat.name} ===`);
      cat.variables.forEach((v) => {
        const val = allVars[v.key] || '';
        if (val || !v.isSecret) {
          lines.push(`${v.key}=${val}`);
        }
      });
      lines.push('');
    });

    await fs.writeFile(envPath, lines.join('\n'), 'utf8');

    res.json({ ok: true, data: { path: envPath, message: 'Environment file saved' } });
  } catch (err) {
    res.status(500).json({ ok: false, error: err.message });
  }
});

router.get('/schema', requireAdmin, (req, res) => {
  const schema = CONFIG_CATEGORIES.map((cat) => ({
    id: cat.id,
    name: cat.name,
    description: cat.description,
    variables: cat.variables.map((v) => ({
      key: v.key,
      type: v.type,
      options: v.options,
      default: v.default,
      isSecret: v.isSecret || false,
      description: v.description,
    })),
  }));

  res.json({ ok: true, data: { schema } });
});

export default router;

```

### images.js

**Path:** `backend/src/routes/images.js`

```javascript
import { Router } from 'express';
import fs from 'fs';
import fse from 'fs-extra';
import path from 'node:path';
import multer from 'multer';
import sharp from 'sharp';
import { config } from '../config.js';
import requireAdmin from '../middleware/adminAuth.js';
import { upload as r2Upload, isR2Configured, generateKey } from '../lib/r2.js';
import { getVASClient } from '../lib/ai-serve.js';

const router = Router();


const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 20 * 1024 * 1024, files: 20 },
});

function sanitizeSegment(s) {
  return String(s || '')
    .replace(/[^a-zA-Z0-9_-]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-/g, '')
    .replace(/-$/g, '')
    .trim();
}

function sanitizeFilename(name) {
  const base = path.basename(String(name || 'file'));
  // Disallow hidden files and traversal
  const cleaned = base.replace(/[^a-zA-Z0-9._-]/g, '-').replace(/-+/g, '-');
  if (!cleaned || cleaned.startsWith('.')) return `file-${Date.now()}`;
  return cleaned;
}

function buildDir({ year, slug, subdir }) {
  const { imagesDir } = config.content;
  if (subdir) {
    const parts = String(subdir)
      .split('/')
      .map(sanitizeSegment)
      .filter(Boolean);
    const rel = parts.join('/');
    return { abs: path.join(imagesDir, rel), rel };
  }
  const y = sanitizeSegment(year);
  const s = sanitizeSegment(slug);
  if (y && /^\d{4}$/.test(y) && s) {
    const rel = path.posix.join(y, s);
    return { abs: path.join(imagesDir, rel), rel };
  }
  const now = new Date();
  const rel = path.posix.join('uploads', `${now.getFullYear()}`, `${String(now.getMonth() + 1).padStart(2, '0')}`);
  return { abs: path.join(imagesDir, rel), rel };
}

async function saveWithVariants(destDirAbs, relDir, file) {
  const origName = sanitizeFilename(file.originalname || 'image');
  const ext = (origName.split('.').pop() || '').toLowerCase();
  const allowed = new Set(['jpg', 'jpeg', 'png', 'webp', 'gif', 'svg']);
  if (!allowed.has(ext)) {
    throw Object.assign(new Error(`Unsupported file type: .${ext}`), { status: 400 });
  }

  fse.ensureDirSync(destDirAbs);

  let finalName = origName;
  let base = origName.replace(/\.[^.]+$/, '');
  let counter = 1;
  while (fs.existsSync(path.join(destDirAbs, finalName))) {
    finalName = `${base}-${counter}.${ext}`;
    counter += 1;
  }

  const absOriginal = path.join(destDirAbs, finalName);
  await fse.writeFile(absOriginal, file.buffer);

  let webpName = null;
  let webpUrl = null;
  try {
    const img = sharp(file.buffer, { failOn: 'none' }).rotate();
    const meta = await img.metadata();
    const maxWidth = 1600;
    const width = meta.width || maxWidth;
    const resized = width > maxWidth ? img.resize({ width: maxWidth }) : img;
    const webpBuffer = await resized.webp({ quality: 82 }).toBuffer();
    const baseName = finalName.replace(/\.[^.]+$/, '');
    webpName = `${baseName}-w${Math.min(width, maxWidth)}.webp`;
    const absWebp = path.join(destDirAbs, webpName);
    await fse.writeFile(absWebp, webpBuffer);
    webpUrl = `/images/${relDir}/${webpName}`;
  } catch (_) {
    // If sharp fails (e.g., SVG), silently skip variant
  }

  return {
    filename: finalName,
    path: `${relDir}/${finalName}`,
    url: `/images/${relDir}/${finalName}`,
    sizeBytes: file.size,
    variantWebp: webpName ? { filename: webpName, url: webpUrl } : null,
  };
}

router.post('/upload', requireAdmin, upload.array('files', 10), async (req, res, next) => {
  try {
    const b = req.body || {};
    const { year, slug, subdir } = b;
    const { abs, rel } = buildDir({ year, slug, subdir });

    const files = Array.isArray(req.files) ? req.files : (req.file ? [req.file] : []);
    if (!files.length) return res.status(400).json({ ok: false, error: 'No files uploaded (use field "files")' });

    const results = [];
    for (const file of files) {
      const item = await saveWithVariants(abs, rel, file);
      results.push(item);
    }

    return res.status(201).json({ ok: true, data: { dir: `/images/${rel}`, items: results } });
  } catch (err) {
    return next(err);
  }
});

router.get('/', requireAdmin, async (req, res, next) => {
  try {
    const q = req.query || {};
    const { year, slug, dir: subdir } = q;
    const { abs, rel } = buildDir({ year, slug, subdir });

    if (!fs.existsSync(abs)) return res.json({ ok: true, data: { dir: `/images/${rel}`, items: [] } });
    const entries = fs.readdirSync(abs);
    const items = entries
      .filter(name => fs.statSync(path.join(abs, name)).isFile())
      .map(name => {
        const stat = fs.statSync(path.join(abs, name));
        return {
          filename: name,
          url: `/images/${rel}/${name}`,
          sizeBytes: stat.size,
          mtime: stat.mtime.toISOString(),
        };
      })
      .sort((a, b) => (a.filename < b.filename ? -1 : 1));

    return res.json({ ok: true, data: { dir: `/images/${rel}`, items } });
  } catch (err) {
    return next(err);
  }
});

router.delete('/:year/:slug/:filename', requireAdmin, async (req, res, next) => {
  try {
    const { year, slug, filename } = req.params || {};
    if (!/^\d{4}$/.test(String(year || '')))
      return res.status(400).json({ ok: false, error: 'Invalid year' });

    const y = sanitizeSegment(year);
    const s = sanitizeSegment(slug);
    const f = sanitizeFilename(filename);
    const rel = path.posix.join(y, s, f);
    const abs = path.join(config.content.imagesDir, rel);

    if (!fs.existsSync(abs)) return res.status(404).json({ ok: false, error: 'Not found' });
    await fse.unlink(abs);

    // attempt to remove variant with -w*.webp
    const base = f.replace(/\.[^.]+$/, '');
    const variantCandidates = fs
      .readdirSync(path.dirname(abs))
      .filter(n => n.startsWith(base + '-w') && n.endsWith('.webp'));
    for (const cand of variantCandidates) {
      try { await fse.unlink(path.join(path.dirname(abs), cand)); } catch (_) {}
    }

    return res.json({ ok: true, data: { deleted: true, path: `/images/${rel}` } });
  } catch (err) {
    return next(err);
  }
});

/**
 * POST /api/v1/images/chat-upload
 * Upload image to R2 for AI Chat and perform vision analysis
 * 
 * Returns: { url, key, size, contentType, imageAnalysis? }
 */
router.post('/chat-upload', upload.single('file'), async (req, res, next) => {
  try {
    const file = req.file;
    if (!file) {
      return res.status(400).json({ ok: false, error: 'file is required' });
    }

    // Check if R2 is configured
    if (!isR2Configured()) {
      return res.status(503).json({
        ok: false,
        error: 'R2 storage not configured (set CF_ACCOUNT_ID, CF_API_TOKEN)',
      });
    }

    // Generate R2 key
    const key = generateKey(file.originalname || 'image', 'ai-chat');

    // Upload to R2
    const result = await r2Upload(key, file.buffer, {
      contentType: file.mimetype || 'application/octet-stream',
    });

    // Perform AI vision analysis if it's an image
    let imageAnalysis = null;
    if (file.mimetype?.startsWith('image/')) {
      try {
        const base64 = file.buffer.toString('base64');
        const client = getVASClient();
        
        const analysisPrompt = `이 이미지를 분석해주세요. 다음 내용을 간결하게 설명해주세요:
1. 이미지에 보이는 주요 요소들
2. 전체적인 분위기나 맥락
3. 텍스트가 있다면 해당 내용

한국어로 2-3문장으로 간결하게 요약해주세요.`;

        imageAnalysis = await client.vision(base64, file.mimetype, analysisPrompt, {
          model: 'gpt-4o',
        });
      } catch (err) {
        // Vision analysis failed, but upload succeeded - continue without analysis
        console.error('Vision analysis failed:', err.message);
      }
    }

    return res.status(201).json({
      ok: true,
      data: {
        url: result.url,
        key: result.key,
        size: result.size,
        contentType: result.contentType,
        imageAnalysis,
      },
    });
  } catch (err) {
    console.error('chat-upload error:', err);
    return next(err);
  }
});

export default router;

```

### og.js

**Path:** `backend/src/routes/og.js`

```javascript
import { Router } from 'express';
import { config } from '../config.js';

const router = Router();

function escapeXml(unsafe = '') {
  return String(unsafe)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

router.get('/', async (req, res, next) => {
  try {
    const q = req.query || {};
    const title = (q.title || 'Blog Post').toString();
    const subtitle = (q.subtitle || '').toString();
    const theme = (q.theme || 'dark').toString();

    const w = Math.max(320, parseInt(q.w || q.width || '1200', 10) || 1200);
    const h = Math.max(180, parseInt(q.h || q.height || '630', 10) || 630);

    const bg = (q.bg || (theme === 'light' ? '#ffffff' : '#0b1220')).toString();
    const fg = (q.fg || (theme === 'light' ? '#111111' : '#ffffff')).toString();

    const safeTitle = escapeXml(title).slice(0, 140);
    const safeSubtitle = escapeXml(subtitle).slice(0, 200);

    const site = config.siteBaseUrl || '';

    const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
  <defs>
    <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0%" stop-color="${bg}" stop-opacity="1" />
      <stop offset="100%" stop-color="${bg}" stop-opacity="0.88" />
    </linearGradient>
  </defs>
  <rect width="100%" height="100%" fill="url(#g)"/>
  <g transform="translate(64, 64)">
    <rect x="-16" y="-16" width="32" height="32" rx="4" fill="${fg}" opacity="0.12" />
    <text x="0" y="0" fill="${fg}" font-family="ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, 'Apple Color Emoji', 'Segoe UI Emoji'" font-size="56" font-weight="700" dominant-baseline="hanging">
      ${safeTitle}
    </text>
    ${safeSubtitle ? `<text x="0" y="88" fill="${fg}" opacity="0.8" font-family="ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial" font-size="28" font-weight="500" dominant-baseline="hanging">${safeSubtitle}</text>` : ''}
  </g>
  <text x="${w - 64}" y="${h - 48}" text-anchor="end" fill="${fg}" opacity="0.6" font-family="ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial" font-size="22">${escapeXml(site)}</text>
</svg>`;

    res.status(200);
    res.setHeader('Content-Type', 'image/svg+xml');
    res.setHeader('Cache-Control', 'public, max-age=3600');
    return res.end(svg);
  } catch (err) {
    return next(err);
  }
});

export default router;

```

### posts.js

**Path:** `backend/src/routes/posts.js`

```javascript
import { Router } from 'express';
import fs from 'fs';
import fse from 'fs-extra';
import path from 'node:path';
import matter from 'gray-matter';
import slugify from 'slugify';
import { config } from '../config.js';
import requireAdmin from '../middleware/adminAuth.js';
import { buildFrontmatterMarkdown } from '../lib/markdown.js';

const router = Router();


function validateFilename(filename) {
  const validFilenamePattern = /^[a-zA-Z0-9][a-zA-Z0-9\-_]*\.md$/;
  return validFilenamePattern.test(filename);
}


function computeItem(year, file, fm, body) {
  const filename = path.basename(file, '.md');
  const slug = fm.slug || filename;
  const date = fm.date || `${year}-01-01`;
  const tags = Array.isArray(fm.tags) ? fm.tags : [];
  const category = fm.category || 'General';
  const author = fm.author || 'Admin';
  const published = fm.published !== false;
  const coverImage = fm.coverImage || fm.cover || undefined;

  const textOnly = String(body)
    .replace(/```[\s\S]*?```/g, '')
    .replace(/<[^>]+>/g, '')
    .trim();
  const snippet = (fm.description || fm.excerpt || textOnly).slice(0, 200).trim();
  const words = textOnly.split(/\s+/).filter(Boolean).length;
  const minutes = Math.max(1, Math.ceil(words / 200));
  const readingTime = `${minutes} min read`;

  return {
    path: `/posts/${year}/${file}`,
    year,
    slug,
    title: fm.title || slug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
    description: fm.description || snippet,
    snippet,
    date,
    tags,
    category,
    author,
    readingTime,
    published,
    coverImage,
    url: `/blog/${year}/${slug}`,
  };
}

function listYears(postsDir) {
  return fs
    .readdirSync(postsDir)
    .filter(item => fs.statSync(path.join(postsDir, item)).isDirectory())
    .filter(year => /^\d{4}$/.test(year));
}

function generatePerYearManifest(year) {
  const { postsDir } = config.content;
  const yearDir = path.join(postsDir, year);
  if (!fs.existsSync(yearDir)) return { valid: 0, invalid: 0 };
  const files = fs.readdirSync(yearDir).filter(f => f.endsWith('.md'));
  const valid = [];
  const invalid = [];
  for (const file of files) {
    if (!validateFilename(file)) {
      invalid.push(file);
      continue;
    }
    const abs = path.join(yearDir, file);
    try {
      const raw = fs.readFileSync(abs, 'utf8');
      if (!raw.trim()) {
        invalid.push(file);
        continue;
      }
      // frontmatter presence is recommended but not required
      valid.push(file);
    } catch {
      invalid.push(file);
    }
  }
  const manifest = {
    files: valid.sort(),
    generatedAt: new Date().toISOString(),
    totalFiles: valid.length,
    excludedFiles: invalid.length,
  };
  fs.writeFileSync(path.join(yearDir, 'manifest.json'), `${JSON.stringify(manifest, null, 2)}\n`);
  return { valid: valid.length, invalid: invalid.length };
}

function generateUnifiedManifest() {
  const { postsDir, publicDir } = config.content;
  const years = listYears(postsDir);
  const items = [];
  for (const year of years) {
    const yearDir = path.join(postsDir, year);
    const files = fs.readdirSync(yearDir).filter(f => f.endsWith('.md'));
    for (const file of files) {
      if (!validateFilename(file)) continue;
      const abs = path.join(yearDir, file);
      try {
        const raw = fs.readFileSync(abs, 'utf8');
        if (!raw.trim()) continue;
        const { data: fm, content } = matter(raw);
        const item = computeItem(year, file, fm, content);
        items.push(item);
      } catch {}
    }
  }
  items.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  const unified = {
    total: items.length,
    items,
    generatedAt: new Date().toISOString(),
    years: years.sort().reverse(),
    format: 2,
  };
  const rootPath = path.join(publicDir, 'posts-manifest.json');
  const nestedPath = path.join(publicDir, 'posts', 'posts-manifest.json');
  fse.ensureDirSync(path.dirname(nestedPath));
  const payload = `${JSON.stringify(unified, null, 2)}\n`;
  fs.writeFileSync(rootPath, payload);
  fs.writeFileSync(nestedPath, payload);
  return unified;
}

router.get('/', async (req, res, next) => {
  try {
    const { postsDir } = config.content;
    const years = listYears(postsDir);
    const q = req.query || {};
    const year = (q.year || '').toString();
    const includeDrafts = String(q.includeDrafts || 'false') === 'true';

    let items = [];
    const yearsToScan = year && /^\d{4}$/.test(year) ? [year] : years;
    for (const y of yearsToScan) {
      const dir = path.join(postsDir, y);
      if (!fs.existsSync(dir)) continue;
      for (const file of fs.readdirSync(dir).filter(f => f.endsWith('.md'))) {
        if (!validateFilename(file)) continue;
        const abs = path.join(dir, file);
        const raw = fs.readFileSync(abs, 'utf8');
        const { data: fm, content } = matter(raw);
        if (fm.published === false && !includeDrafts) continue;
        items.push(computeItem(y, file, fm, content));
      }
    }

    // basic sort by date desc
    items.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    return res.json({ ok: true, data: { items } });
  } catch (err) {
    return next(err);
  }
});

router.get('/:year/:slug', async (req, res, next) => {
  try {
    const { year, slug } = req.params;
    if (!/^\d{4}$/.test(year))
      return res.status(400).json({ ok: false, error: 'Invalid year' });

    const file = `${slug}.md`;
    const abs = path.join(config.content.postsDir, year, file);
    if (!fs.existsSync(abs))
      return res.status(404).json({ ok: false, error: 'Not found' });
    const raw = fs.readFileSync(abs, 'utf8');
    const { data: fm, content } = matter(raw);
    const item = computeItem(year, file, fm, content);
    return res.json({ ok: true, data: { item, markdown: raw } });
  } catch (err) {
    return next(err);
  }
});

router.post('/', requireAdmin, async (req, res, next) => {
  try {
    const { title, slug: slugRaw, year: yearRaw, content, frontmatter } = req.body || {};
    const year = String(yearRaw || new Date().getFullYear());
    if (!/^\d{4}$/.test(year))
      return res.status(400).json({ ok: false, error: 'year must be YYYY' });

    let slug = String(slugRaw || title || 'post');
    slug = slugify(slug, { lower: true, strict: true });
    const filename = `${slug}.md`;
    if (!validateFilename(filename))
      return res.status(400).json({ ok: false, error: 'invalid slug/filename' });

    const yearDir = path.join(config.content.postsDir, year);
    fse.ensureDirSync(yearDir);
    const abs = path.join(yearDir, filename);
    if (fs.existsSync(abs))
      return res.status(409).json({ ok: false, error: 'already exists' });

    const fm = {
      title: title || slug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
      date: new Date().toISOString(),
      tags: [],
      category: 'General',
      published: true,
      ...(frontmatter && typeof frontmatter === 'object' ? frontmatter : {}),
    };
    const body = typeof content === 'string' ? content : '';
    const md = buildFrontmatterMarkdown(fm, body);

    fs.writeFileSync(abs, md);

    // regenerate manifests
    generatePerYearManifest(year);
    const unified = generateUnifiedManifest();

    return res.status(201).json({ ok: true, data: { path: `/posts/${year}/${filename}`, manifestTotal: unified.total } });
  } catch (err) {
    return next(err);
  }
});

router.put('/:year/:slug', requireAdmin, async (req, res, next) => {
  try {
    const { year, slug } = req.params;
    if (!/^\d{4}$/.test(year))
      return res.status(400).json({ ok: false, error: 'Invalid year' });
    const filename = `${slug}.md`;
    const abs = path.join(config.content.postsDir, year, filename);
    if (!fs.existsSync(abs))
      return res.status(404).json({ ok: false, error: 'Not found' });

    const { markdown, frontmatter, content } = req.body || {};
    let newMd;
    if (typeof markdown === 'string') {
      newMd = markdown;
    } else {
      // if fm/content provided, rebuild
      const existing = fs.readFileSync(abs, 'utf8');
      const { data: fm0 } = matter(existing);
      const fm = { ...fm0, ...(frontmatter && typeof frontmatter === 'object' ? frontmatter : {}) };
      const body = typeof content === 'string' ? content : existing.replace(/^---[\s\S]*?---\n?/, '');
      newMd = buildFrontmatterMarkdown(fm, body);
    }

    fs.writeFileSync(abs, newMd);
    generatePerYearManifest(year);
    const unified = generateUnifiedManifest();

    return res.json({ ok: true, data: { updated: true, manifestTotal: unified.total } });
  } catch (err) {
    return next(err);
  }
});

router.delete('/:year/:slug', requireAdmin, async (req, res, next) => {
  try {
    const { year, slug } = req.params;
    if (!/^\d{4}$/.test(year))
      return res.status(400).json({ ok: false, error: 'Invalid year' });
    const filename = `${slug}.md`;
    const abs = path.join(config.content.postsDir, year, filename);
    if (!fs.existsSync(abs))
      return res.status(404).json({ ok: false, error: 'Not found' });

    fs.unlinkSync(abs);
    // If year dir becomes empty, keep dir (front-end expects /posts/<year>/)

    generatePerYearManifest(year);
    const unified = generateUnifiedManifest();

    return res.json({ ok: true, data: { deleted: true, manifestTotal: unified.total } });
  } catch (err) {
    return next(err);
  }
});

router.post('/regenerate-manifests', requireAdmin, async (req, res, next) => {
  try {
    const years = listYears(config.content.postsDir);
    for (const y of years) generatePerYearManifest(y);
    const unified = generateUnifiedManifest();
    return res.json({ ok: true, data: { total: unified.total, years: unified.years } });
  } catch (err) {
    return next(err);
  }
});

export default router;

```

### rag.js

**Path:** `backend/src/routes/rag.js`

```javascript
/**
 * RAG Routes
 * 
 * ChromaDB와 TEI 임베딩 서버에 대한 프록시 엔드포인트
 * Workers에서 터널(api.nodove.com)을 통해 호출합니다.
 * 
 * 엔드포인트:
 * - POST /api/v1/rag/search - 시맨틱 검색 (블로그 포스트)
 * - POST /api/v1/rag/embed - 텍스트 임베딩 생성
 * - GET /api/v1/rag/health - RAG 서비스 상태 확인
 * - POST /api/v1/rag/memories/upsert - 사용자 메모리 임베딩 저장
 * - POST /api/v1/rag/memories/search - 사용자 메모리 시맨틱 검색
 * - DELETE /api/v1/rag/memories/:memoryId - 메모리 임베딩 삭제
 */

import express from 'express';
import { config } from '../config.js';

const router = express.Router();

// Memory collection prefix (user-specific collections)
const MEMORY_COLLECTION_PREFIX = 'user-memories-';

/**
 * TEI 서버에서 텍스트 임베딩 생성
 * @param {string[]} texts - 임베딩할 텍스트 배열
 * @returns {Promise<number[][]>} 임베딩 벡터 배열
 */
async function getEmbeddings(texts) {
  const response = await fetch(config.rag.teiUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ inputs: texts }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`TEI error: ${response.status} - ${errorText}`);
  }

  const data = await response.json();
  // TEI returns either { embeddings: [...] } or direct array
  return data.embeddings || data;
}

/**
 * ChromaDB에서 시맨틱 검색
 * @param {number[]} embedding - 쿼리 임베딩
 * @param {number} nResults - 반환할 결과 수
 * @param {string} collectionName - 컬렉션 이름
 * @param {object} whereFilter - 필터 조건
 * @returns {Promise<object>} 검색 결과
 */
async function queryChroma(embedding, nResults = 5, collectionName = null, whereFilter = null) {
  const collection = collectionName || config.rag.chromaCollection;
  const chromaBase = config.rag.chromaUrl;

  // ChromaDB v0.5+ API: POST /api/v1/collections/{collection_name}/query
  const queryUrl = `${chromaBase}/api/v1/collections/${collection}/query`;
  
  const body = {
    query_embeddings: [embedding],
    n_results: nResults,
    include: ['documents', 'metadatas', 'distances'],
  };

  if (whereFilter) {
    body.where = whereFilter;
  }

  const response = await fetch(queryUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`ChromaDB error: ${response.status} - ${errorText}`);
  }

  return response.json();
}

/**
 * ChromaDB 컬렉션 존재 여부 확인 및 생성
 * @param {string} collectionName - 컬렉션 이름
 */
async function ensureCollection(collectionName) {
  const chromaBase = config.rag.chromaUrl;
  
  // Check if collection exists
  try {
    const checkResp = await fetch(`${chromaBase}/api/v1/collections/${collectionName}`, {
      method: 'GET',
    });
    if (checkResp.ok) return; // Collection exists
  } catch (e) {
    // Collection doesn't exist, create it
  }

  // Create collection
  const createResp = await fetch(`${chromaBase}/api/v1/collections`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      name: collectionName,
      metadata: { 'hnsw:space': 'cosine' },
    }),
  });

  if (!createResp.ok && createResp.status !== 409) {
    const errorText = await createResp.text();
    throw new Error(`Failed to create collection: ${createResp.status} - ${errorText}`);
  }
}

/**
 * ChromaDB에 문서 upsert
 * @param {string} collectionName - 컬렉션 이름
 * @param {string[]} ids - 문서 ID 배열
 * @param {number[][]} embeddings - 임베딩 배열
 * @param {string[]} documents - 문서 텍스트 배열
 * @param {object[]} metadatas - 메타데이터 배열
 */
async function upsertToChroma(collectionName, ids, embeddings, documents, metadatas) {
  const chromaBase = config.rag.chromaUrl;
  
  await ensureCollection(collectionName);

  const upsertUrl = `${chromaBase}/api/v1/collections/${collectionName}/upsert`;
  
  const response = await fetch(upsertUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      ids,
      embeddings,
      documents,
      metadatas,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`ChromaDB upsert error: ${response.status} - ${errorText}`);
  }

  return response.json();
}

/**
 * ChromaDB에서 문서 삭제
 * @param {string} collectionName - 컬렉션 이름
 * @param {string[]} ids - 삭제할 문서 ID 배열
 */
async function deleteFromChroma(collectionName, ids) {
  const chromaBase = config.rag.chromaUrl;
  const deleteUrl = `${chromaBase}/api/v1/collections/${collectionName}/delete`;
  
  const response = await fetch(deleteUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ ids }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`ChromaDB delete error: ${response.status} - ${errorText}`);
  }

  return response.json();
}

/**
 * POST /search - 시맨틱 검색 (블로그 포스트)
 * 
 * Request Body:
 * {
 *   query: string,      // 검색 쿼리
 *   n_results?: number  // 반환할 결과 수 (기본 5)
 * }
 * 
 * Response:
 * {
 *   ok: true,
 *   data: {
 *     results: [{ document, metadata, distance }]
 *   }
 * }
 */
router.post('/search', async (req, res) => {
  try {
    const { query, n_results = 5 } = req.body;

    if (!query || typeof query !== 'string') {
      return res.status(400).json({ ok: false, error: 'query is required' });
    }

    // 1. 쿼리 텍스트를 임베딩으로 변환
    const [embedding] = await getEmbeddings([query]);

    // 2. ChromaDB에서 유사한 문서 검색
    const chromaResult = await queryChroma(embedding, n_results);

    // 3. 결과 포맷팅
    const results = [];
    if (chromaResult.documents && chromaResult.documents[0]) {
      const docs = chromaResult.documents[0];
      const metas = chromaResult.metadatas?.[0] || [];
      const dists = chromaResult.distances?.[0] || [];

      for (let i = 0; i < docs.length; i++) {
        results.push({
          document: docs[i],
          metadata: metas[i] || {},
          distance: dists[i] || null,
        });
      }
    }

    res.json({ ok: true, data: { results } });
  } catch (err) {
    console.error('RAG search error:', err.message);
    res.status(500).json({ ok: false, error: err.message });
  }
});

/**
 * POST /embed - 텍스트 임베딩 생성
 * 
 * Request Body:
 * {
 *   texts: string[]  // 임베딩할 텍스트 배열
 * }
 * 
 * Response:
 * {
 *   ok: true,
 *   data: {
 *     embeddings: number[][]
 *   }
 * }
 */
router.post('/embed', async (req, res) => {
  try {
    const { texts } = req.body;

    if (!texts || !Array.isArray(texts) || texts.length === 0) {
      return res.status(400).json({ ok: false, error: 'texts array is required' });
    }

    if (texts.length > 32) {
      return res.status(400).json({ ok: false, error: 'Maximum 32 texts per request' });
    }

    const embeddings = await getEmbeddings(texts);

    res.json({ ok: true, data: { embeddings } });
  } catch (err) {
    console.error('RAG embed error:', err.message);
    res.status(500).json({ ok: false, error: err.message });
  }
});

/**
 * GET /health - RAG 서비스 상태 확인
 */
router.get('/health', async (req, res) => {
  const status = {
    tei: { ok: false, url: config.rag.teiUrl },
    chroma: { ok: false, url: config.rag.chromaUrl },
  };

  // TEI 상태 확인
  try {
    const teiResp = await fetch(`${config.rag.teiUrl}/health`, { 
      method: 'GET',
      signal: AbortSignal.timeout(5000),
    });
    status.tei.ok = teiResp.ok;
  } catch (err) {
    status.tei.error = err.message;
  }

  // ChromaDB 상태 확인
  try {
    const chromaResp = await fetch(`${config.rag.chromaUrl}/api/v1/heartbeat`, {
      method: 'GET',
      signal: AbortSignal.timeout(5000),
    });
    status.chroma.ok = chromaResp.ok;
  } catch (err) {
    status.chroma.error = err.message;
  }

  const allOk = status.tei.ok && status.chroma.ok;
  res.status(allOk ? 200 : 503).json({
    ok: allOk,
    services: status,
    collection: config.rag.chromaCollection,
  });
});

// ========================================
// MEMORY RAG ENDPOINTS
// ========================================

/**
 * POST /memories/upsert - 사용자 메모리 임베딩 저장
 * 
 * Request Body:
 * {
 *   userId: string,
 *   memories: [{ id, content, memoryType, category }]
 * }
 */
router.post('/memories/upsert', async (req, res) => {
  try {
    const { userId, memories } = req.body;

    if (!userId || typeof userId !== 'string') {
      return res.status(400).json({ ok: false, error: 'userId is required' });
    }

    if (!memories || !Array.isArray(memories) || memories.length === 0) {
      return res.status(400).json({ ok: false, error: 'memories array is required' });
    }

    if (memories.length > 20) {
      return res.status(400).json({ ok: false, error: 'Maximum 20 memories per request' });
    }

    // 1. Extract texts for embedding
    const texts = memories.map(m => m.content);
    
    // 2. Generate embeddings
    const embeddings = await getEmbeddings(texts);

    // 3. Prepare data for ChromaDB
    const ids = memories.map(m => m.id);
    const documents = texts;
    const metadatas = memories.map(m => ({
      user_id: userId,
      memory_type: m.memoryType || 'fact',
      category: m.category || '',
      created_at: new Date().toISOString(),
    }));

    // 4. Upsert to user-specific collection
    const collectionName = `${MEMORY_COLLECTION_PREFIX}${userId}`;
    await upsertToChroma(collectionName, ids, embeddings, documents, metadatas);

    res.json({ ok: true, data: { upserted: ids.length } });
  } catch (err) {
    console.error('Memory upsert error:', err.message);
    res.status(500).json({ ok: false, error: err.message });
  }
});

/**
 * POST /memories/search - 사용자 메모리 시맨틱 검색
 * 
 * Request Body:
 * {
 *   userId: string,
 *   query: string,
 *   n_results?: number,
 *   memoryType?: string,
 *   category?: string
 * }
 */
router.post('/memories/search', async (req, res) => {
  try {
    const { userId, query, n_results = 10, memoryType, category } = req.body;

    if (!userId || typeof userId !== 'string') {
      return res.status(400).json({ ok: false, error: 'userId is required' });
    }

    if (!query || typeof query !== 'string') {
      return res.status(400).json({ ok: false, error: 'query is required' });
    }

    // 1. Generate query embedding
    const [embedding] = await getEmbeddings([query]);

    // 2. Build where filter
    let whereFilter = null;
    if (memoryType || category) {
      whereFilter = {};
      if (memoryType) whereFilter.memory_type = memoryType;
      if (category) whereFilter.category = category;
    }

    // 3. Search in user-specific collection
    const collectionName = `${MEMORY_COLLECTION_PREFIX}${userId}`;
    
    let chromaResult;
    try {
      chromaResult = await queryChroma(embedding, n_results, collectionName, whereFilter);
    } catch (err) {
      // Collection might not exist yet (no memories stored)
      if (err.message.includes('404') || err.message.includes('not found')) {
        return res.json({ ok: true, data: { results: [] } });
      }
      throw err;
    }

    // 4. Format results
    const results = [];
    if (chromaResult.documents && chromaResult.documents[0]) {
      const docs = chromaResult.documents[0];
      const metas = chromaResult.metadatas?.[0] || [];
      const dists = chromaResult.distances?.[0] || [];
      const ids = chromaResult.ids?.[0] || [];

      for (let i = 0; i < docs.length; i++) {
        results.push({
          id: ids[i],
          document: docs[i],
          metadata: metas[i] || {},
          distance: dists[i] || null,
          // Convert distance to similarity score (cosine distance: 0 = identical)
          similarity: dists[i] != null ? Math.max(0, 1 - dists[i]) : null,
        });
      }
    }

    res.json({ ok: true, data: { results } });
  } catch (err) {
    console.error('Memory search error:', err.message);
    res.status(500).json({ ok: false, error: err.message });
  }
});

/**
 * DELETE /memories/:userId/:memoryId - 메모리 임베딩 삭제
 */
router.delete('/memories/:userId/:memoryId', async (req, res) => {
  try {
    const { userId, memoryId } = req.params;

    if (!userId || !memoryId) {
      return res.status(400).json({ ok: false, error: 'userId and memoryId are required' });
    }

    const collectionName = `${MEMORY_COLLECTION_PREFIX}${userId}`;
    
    try {
      await deleteFromChroma(collectionName, [memoryId]);
    } catch (err) {
      // Ignore if collection or document doesn't exist
      if (!err.message.includes('404') && !err.message.includes('not found')) {
        throw err;
      }
    }

    res.json({ ok: true, data: { deleted: true } });
  } catch (err) {
    console.error('Memory delete error:', err.message);
    res.status(500).json({ ok: false, error: err.message });
  }
});

/**
 * POST /memories/batch-delete - 여러 메모리 임베딩 일괄 삭제
 */
router.post('/memories/batch-delete', async (req, res) => {
  try {
    const { userId, memoryIds } = req.body;

    if (!userId || !Array.isArray(memoryIds) || memoryIds.length === 0) {
      return res.status(400).json({ ok: false, error: 'userId and memoryIds are required' });
    }

    const collectionName = `${MEMORY_COLLECTION_PREFIX}${userId}`;
    
    try {
      await deleteFromChroma(collectionName, memoryIds);
    } catch (err) {
      if (!err.message.includes('404') && !err.message.includes('not found')) {
        throw err;
      }
    }

    res.json({ ok: true, data: { deleted: memoryIds.length } });
  } catch (err) {
    console.error('Memory batch-delete error:', err.message);
    res.status(500).json({ ok: false, error: err.message });
  }
});

// ========================================
// INDEX MANAGEMENT ENDPOINTS
// ========================================

/**
 * POST /index - 문서 인덱싱
 * 
 * Request Body:
 * {
 *   documents: [{
 *     id: string,
 *     content: string,
 *     metadata?: object
 *   }],
 *   collection?: string  // Optional custom collection name
 * }
 */
router.post('/index', async (req, res) => {
  try {
    const { documents, collection } = req.body;

    if (!documents || !Array.isArray(documents) || documents.length === 0) {
      return res.status(400).json({ ok: false, error: 'documents array is required' });
    }

    if (documents.length > 100) {
      return res.status(400).json({ ok: false, error: 'Maximum 100 documents per request' });
    }

    // Validate documents
    for (const doc of documents) {
      if (!doc.id || !doc.content) {
        return res.status(400).json({ ok: false, error: 'Each document must have id and content' });
      }
    }

    // 1. Extract texts for embedding
    const texts = documents.map(d => d.content);
    
    // 2. Generate embeddings
    const embeddings = await getEmbeddings(texts);

    // 3. Prepare data for ChromaDB
    const ids = documents.map(d => d.id);
    const metadatas = documents.map(d => ({
      ...d.metadata,
      indexed_at: new Date().toISOString(),
    }));

    // 4. Upsert to collection
    const collectionName = collection || config.rag.chromaCollection;
    await upsertToChroma(collectionName, ids, embeddings, texts, metadatas);

    res.json({ ok: true, data: { indexed: ids.length, collection: collectionName } });
  } catch (err) {
    console.error('RAG index error:', err.message);
    res.status(500).json({ ok: false, error: err.message });
  }
});

/**
 * DELETE /index/:documentId - 인덱스에서 문서 삭제
 */
router.delete('/index/:documentId', async (req, res) => {
  try {
    const { documentId } = req.params;
    const { collection } = req.query;

    if (!documentId) {
      return res.status(400).json({ ok: false, error: 'documentId is required' });
    }

    const collectionName = collection || config.rag.chromaCollection;
    
    try {
      await deleteFromChroma(collectionName, [documentId]);
    } catch (err) {
      if (!err.message.includes('404') && !err.message.includes('not found')) {
        throw err;
      }
    }

    res.json({ ok: true, data: { deleted: true } });
  } catch (err) {
    console.error('RAG delete error:', err.message);
    res.status(500).json({ ok: false, error: err.message });
  }
});

/**
 * GET /status - 인덱스 상태 확인
 */
router.get('/status', async (req, res) => {
  try {
    const { collection } = req.query;
    const collectionName = collection || config.rag.chromaCollection;
    const chromaBase = config.rag.chromaUrl;

    // Get collection info
    const collectionResp = await fetch(`${chromaBase}/api/v1/collections/${collectionName}`, {
      method: 'GET',
      signal: AbortSignal.timeout(5000),
    });

    if (!collectionResp.ok) {
      if (collectionResp.status === 404) {
        return res.json({
          ok: true,
          data: {
            collection: collectionName,
            exists: false,
            count: 0,
          },
        });
      }
      throw new Error(`ChromaDB error: ${collectionResp.status}`);
    }

    const collectionData = await collectionResp.json();

    // Get count
    const countResp = await fetch(`${chromaBase}/api/v1/collections/${collectionName}/count`, {
      method: 'GET',
      signal: AbortSignal.timeout(5000),
    });

    let count = 0;
    if (countResp.ok) {
      const countData = await countResp.json();
      count = countData.count || countData || 0;
    }

    res.json({
      ok: true,
      data: {
        collection: collectionName,
        exists: true,
        count,
        metadata: collectionData.metadata || {},
      },
    });
  } catch (err) {
    console.error('RAG status error:', err.message);
    res.status(500).json({ ok: false, error: err.message });
  }
});

/**
 * GET /collections - 모든 컬렉션 목록
 */
router.get('/collections', async (req, res) => {
  try {
    const chromaBase = config.rag.chromaUrl;
    
    const response = await fetch(`${chromaBase}/api/v1/collections`, {
      method: 'GET',
      signal: AbortSignal.timeout(5000),
    });

    if (!response.ok) {
      throw new Error(`ChromaDB error: ${response.status}`);
    }

    const collections = await response.json();

    res.json({
      ok: true,
      data: {
        collections: collections.map(c => ({
          name: c.name,
          metadata: c.metadata || {},
        })),
        total: collections.length,
      },
    });
  } catch (err) {
    console.error('RAG collections error:', err.message);
    res.status(500).json({ ok: false, error: err.message });
  }
});

export default router;

```

### translate.js

**Path:** `backend/src/routes/translate.js`

```javascript
import { Router } from 'express';
import { queryOne, execute, isD1Configured } from '../lib/d1.js';
import { generateContent } from '../lib/ai-serve.js';

const router = Router();

// Supported languages
const SUPPORTED_LANGS = ['ko', 'en'];
const LANG_NAMES = {
  ko: 'Korean',
  en: 'English',
};

// Middleware to check D1 configuration
const requireD1 = (req, res, next) => {
  if (!isD1Configured()) {
    return res.status(503).json({
      ok: false,
      error: 'Translation service not configured (D1 credentials missing)',
    });
  }
  next();
};

/**
 * Simple hash function for content comparison
 */
function hashContent(content) {
  let hash = 0;
  for (let i = 0; i < content.length; i++) {
    const char = content.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return hash.toString(16);
}

/**
 * Truncate content for translation (to stay within token limits)
 */
function truncateForTranslation(content, maxChars = 30000) {
  if (content.length <= maxChars) return content;
  return content.slice(0, maxChars) + '\n\n[... content truncated for translation ...]';
}

/**
 * POST /api/v1/translate
 * Translate a blog post to target language
 */
router.post('/', requireD1, async (req, res, next) => {
  try {
    const { year, slug, targetLang, title, description, content, forceRefresh } = req.body || {};
    const sourceLang = req.body.sourceLang || 'ko';

    // Validate inputs
    if (!year || !slug || !targetLang || !title || !content) {
      return res.status(400).json({
        ok: false,
        error: 'year, slug, targetLang, title, and content are required',
      });
    }

    if (!SUPPORTED_LANGS.includes(targetLang)) {
      return res.status(400).json({
        ok: false,
        error: `Unsupported target language: ${targetLang}`,
      });
    }

    if (sourceLang === targetLang) {
      return res.json({
        ok: true,
        data: {
          title,
          description: description || '',
          content,
          cached: false,
          message: 'Source and target languages are the same',
        },
      });
    }

    const contentHash = hashContent(content);

    // Check cache first (unless forceRefresh)
    if (!forceRefresh) {
      const cached = await queryOne(
        `SELECT * FROM post_translations_cache 
         WHERE post_slug = ? AND year = ? AND target_lang = ?`,
        slug,
        year,
        targetLang
      );

      if (cached && cached.content_hash === contentHash) {
        return res.json({
          ok: true,
          data: {
            title: cached.title,
            description: cached.description || '',
            content: cached.content,
            cached: true,
            isAiGenerated: cached.is_ai_generated === 1,
          },
        });
      }
    }

    // Generate translation using AI
    const sourceLangName = LANG_NAMES[sourceLang] || sourceLang;
    const targetLangName = LANG_NAMES[targetLang] || targetLang;

    // Translate title
    const titlePrompt = `Translate the following blog post title from ${sourceLangName} to ${targetLangName}. 
Return ONLY the translated title, nothing else.

Title: ${title}`;

    const translatedTitle = await generateContent(titlePrompt, { temperature: 0.1 });

    // Translate description if provided
    let translatedDescription = '';
    if (description) {
      const descPrompt = `Translate the following blog post description from ${sourceLangName} to ${targetLangName}.
Return ONLY the translated description, nothing else.

Description: ${description}`;

      translatedDescription = await generateContent(descPrompt, { temperature: 0.1 });
    }

    // Translate content
    const truncatedContent = truncateForTranslation(content);
    const contentPrompt = `You are a professional translator. Translate the following blog post content from ${sourceLangName} to ${targetLangName}.

IMPORTANT RULES:
1. Preserve ALL markdown formatting exactly (headers, code blocks, lists, links, images, etc.)
2. Do NOT translate code snippets inside \`\`\` blocks
3. Do NOT translate URLs or file paths
4. Preserve technical terms when appropriate (with translation in parentheses if needed)
5. Maintain the same paragraph structure
6. Return ONLY the translated content, no explanations

Content:
${truncatedContent}`;

    const translatedContent = await generateContent(contentPrompt, { temperature: 0.2 });

    // Clean up the responses
    const cleanTitle = translatedTitle.trim().replace(/^["']|["']$/g, '');
    const cleanDescription = translatedDescription.trim().replace(/^["']|["']$/g, '');
    const cleanContent = translatedContent.trim();

    // Cache the translation
    await execute(
      `INSERT INTO post_translations_cache 
         (post_slug, year, source_lang, target_lang, title, description, content, content_hash, is_ai_generated)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1)
       ON CONFLICT(post_slug, year, target_lang)
       DO UPDATE SET
         source_lang = ?,
         title = ?,
         description = ?,
         content = ?,
         content_hash = ?,
         is_ai_generated = 1,
         updated_at = datetime('now')`,
      slug,
      year,
      sourceLang,
      targetLang,
      cleanTitle,
      cleanDescription,
      cleanContent,
      contentHash,
      sourceLang,
      cleanTitle,
      cleanDescription,
      cleanContent,
      contentHash
    );

    return res.json({
      ok: true,
      data: {
        title: cleanTitle,
        description: cleanDescription,
        content: cleanContent,
        cached: false,
        isAiGenerated: true,
      },
    });
  } catch (err) {
    console.error('Translation failed:', err);
    
    const errMsg = String(err?.message || '');
    
    // vas-core 타임아웃 감지
    if (errMsg.includes('timed out') || errMsg.includes('timeout')) {
      return res.status(504).json({
        ok: false,
        error: 'AI 번역 서버 응답 지연',
        code: 'AI_TIMEOUT',
        retryable: true,
        message: 'AI 번역 서버 응답이 30초 이내에 도착하지 않았습니다. 잠시 후 다시 시도해 주세요.',
      });
    }
    
    // 기타 AI 관련 에러
    if (errMsg.includes('AI generation failed') || errMsg.includes('vas-core')) {
      return res.status(502).json({
        ok: false,
        error: 'AI 서버 오류',
        code: 'AI_ERROR',
        retryable: true,
        message: 'AI 번역 서버에서 오류가 발생했습니다. 잠시 후 다시 시도해 주세요.',
      });
    }
    
    return next(err);
  }
});

/**
 * GET /api/v1/translate/:year/:slug/:targetLang
 * Get cached translation for a post
 */
router.get('/:year/:slug/:targetLang', requireD1, async (req, res, next) => {
  try {
    const { year, slug, targetLang } = req.params;

    const cached = await queryOne(
      `SELECT * FROM post_translations_cache 
       WHERE post_slug = ? AND year = ? AND target_lang = ?`,
      slug,
      year,
      targetLang
    );

    if (!cached) {
      return res.status(404).json({ ok: false, error: 'Translation not found' });
    }

    return res.json({
      ok: true,
      data: {
        title: cached.title,
        description: cached.description || '',
        content: cached.content,
        cached: true,
        isAiGenerated: cached.is_ai_generated === 1,
        createdAt: cached.created_at,
        updatedAt: cached.updated_at,
      },
    });
  } catch (err) {
    console.error('Failed to get translation:', err);
    return next(err);
  }
});

/**
 * DELETE /api/v1/translate/:year/:slug/:targetLang
 * Delete cached translation
 */
router.delete('/:year/:slug/:targetLang', requireD1, async (req, res, next) => {
  try {
    const { year, slug, targetLang } = req.params;

    await execute(
      `DELETE FROM post_translations_cache 
       WHERE post_slug = ? AND year = ? AND target_lang = ?`,
      slug,
      year,
      targetLang
    );

    return res.json({ ok: true, data: { deleted: true } });
  } catch (err) {
    console.error('Failed to delete translation:', err);
    return next(err);
  }
});

export default router;

```

### userContent.js

**Path:** `backend/src/routes/userContent.js`

```javascript
import { Router } from 'express';
import { queryAll, queryOne, execute, isD1Configured } from '../lib/d1.js';
import crypto from 'crypto';

const router = Router();

// Middleware to check D1 configuration
const requireD1 = (req, res, next) => {
  if (!isD1Configured()) {
    return res.status(503).json({
      ok: false,
      error: 'User content service not configured (D1 credentials missing)',
    });
  }
  next();
};

// Simple auth check - Bearer token validation
// In production, integrate with your actual auth system
const requireAuth = (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ ok: false, error: 'Unauthorized' });
  }
  // For now, accept any token - integrate with JWT validation in production
  req.userId = 'default-user';
  next();
};

// ============================================================================
// PERSONAS API - /api/personas
// ============================================================================

/**
 * GET /api/personas
 * List all personas for the authenticated user
 */
router.get('/personas', requireD1, requireAuth, async (req, res, next) => {
  try {
    const cursor = req.query.cursor;
    const limit = Math.min(parseInt(req.query.limit) || 50, 100);

    let sql = `SELECT * FROM personas WHERE user_id = ? ORDER BY created_at DESC LIMIT ?`;
    const params = [req.userId, limit + 1];

    if (cursor) {
      sql = `SELECT * FROM personas WHERE user_id = ? AND created_at < ? ORDER BY created_at DESC LIMIT ?`;
      params.splice(1, 0, cursor);
    }

    const items = await queryAll(sql, ...params);
    const hasMore = items.length > limit;
    const data = hasMore ? items.slice(0, limit) : items;

    // Parse tags from JSON string
    const personas = data.map((p) => ({
      id: p.id,
      name: p.name,
      prompt: p.prompt,
      tags: p.tags ? JSON.parse(p.tags) : [],
      createdAt: p.created_at,
      updatedAt: p.updated_at,
    }));

    return res.json({
      ok: true,
      data: personas,
      cursor: hasMore ? data[data.length - 1]?.created_at : undefined,
      hasMore,
    });
  } catch (err) {
    return next(err);
  }
});

/**
 * POST /api/personas
 * Create a new persona
 */
router.post('/personas', requireD1, requireAuth, async (req, res, next) => {
  try {
    const { name, prompt, tags } = req.body || {};

    if (!name || typeof name !== 'string') {
      return res.status(400).json({ ok: false, error: 'name is required' });
    }
    if (!prompt || typeof prompt !== 'string') {
      return res.status(400).json({ ok: false, error: 'prompt is required' });
    }

    const id = `persona-${crypto.randomUUID()}`;
    const now = new Date().toISOString();
    const tagsJson = JSON.stringify(Array.isArray(tags) ? tags : []);

    await execute(
      `INSERT INTO personas (id, user_id, name, prompt, tags, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      id,
      req.userId,
      name.trim().slice(0, 128),
      prompt.trim().slice(0, 4000),
      tagsJson,
      now,
      now
    );

    return res.status(201).json({
      ok: true,
      data: {
        id,
        name: name.trim().slice(0, 128),
        prompt: prompt.trim().slice(0, 4000),
        tags: Array.isArray(tags) ? tags : [],
        createdAt: now,
        updatedAt: now,
      },
    });
  } catch (err) {
    return next(err);
  }
});

/**
 * PUT /api/personas/:id
 * Update a persona
 */
router.put('/personas/:id', requireD1, requireAuth, async (req, res, next) => {
  try {
    const { id } = req.params;
    const { name, prompt, tags } = req.body || {};

    // Check ownership
    const existing = await queryOne(
      `SELECT * FROM personas WHERE id = ? AND user_id = ?`,
      id,
      req.userId
    );

    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Persona not found' });
    }

    // ETag check for optimistic concurrency
    const ifMatch = req.headers['if-match'];
    if (ifMatch && ifMatch !== existing.updated_at) {
      return res.status(412).json({ ok: false, error: 'Precondition failed - resource was modified' });
    }

    const now = new Date().toISOString();
    const newName = name ? name.trim().slice(0, 128) : existing.name;
    const newPrompt = prompt ? prompt.trim().slice(0, 4000) : existing.prompt;
    const newTags = tags !== undefined ? JSON.stringify(Array.isArray(tags) ? tags : []) : existing.tags;

    await execute(
      `UPDATE personas SET name = ?, prompt = ?, tags = ?, updated_at = ? WHERE id = ?`,
      newName,
      newPrompt,
      newTags,
      now,
      id
    );

    return res.json({
      ok: true,
      data: {
        id,
        name: newName,
        prompt: newPrompt,
        tags: JSON.parse(newTags),
        createdAt: existing.created_at,
        updatedAt: now,
      },
    });
  } catch (err) {
    return next(err);
  }
});

/**
 * DELETE /api/personas/:id
 * Delete a persona
 */
router.delete('/personas/:id', requireD1, requireAuth, async (req, res, next) => {
  try {
    const { id } = req.params;

    // Check ownership
    const existing = await queryOne(
      `SELECT * FROM personas WHERE id = ? AND user_id = ?`,
      id,
      req.userId
    );

    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Persona not found' });
    }

    await execute(`DELETE FROM personas WHERE id = ?`, id);

    return res.json({ ok: true });
  } catch (err) {
    return next(err);
  }
});

// ============================================================================
// MEMOS API - /api/memos
// ============================================================================

/**
 * GET /api/memos
 * List all memos for the authenticated user
 */
router.get('/memos', requireD1, requireAuth, async (req, res, next) => {
  try {
    const cursor = req.query.cursor;
    const limit = Math.min(parseInt(req.query.limit) || 50, 100);

    let sql = `SELECT * FROM memos WHERE user_id = ? ORDER BY created_at DESC LIMIT ?`;
    const params = [req.userId, limit + 1];

    if (cursor) {
      sql = `SELECT * FROM memos WHERE user_id = ? AND created_at < ? ORDER BY created_at DESC LIMIT ?`;
      params.splice(1, 0, cursor);
    }

    const items = await queryAll(sql, ...params);
    const hasMore = items.length > limit;
    const data = hasMore ? items.slice(0, limit) : items;

    // Parse JSON fields
    const memos = data.map((m) => ({
      id: m.id,
      originalContent: m.original_content,
      userNote: m.user_note,
      tags: m.tags ? JSON.parse(m.tags) : [],
      source: m.source ? JSON.parse(m.source) : null,
      createdAt: m.created_at,
      updatedAt: m.updated_at,
    }));

    return res.json({
      ok: true,
      data: memos,
      cursor: hasMore ? data[data.length - 1]?.created_at : undefined,
      hasMore,
    });
  } catch (err) {
    return next(err);
  }
});

/**
 * POST /api/memos
 * Create a new memo
 */
router.post('/memos', requireD1, requireAuth, async (req, res, next) => {
  try {
    const { originalContent, userNote, tags, source } = req.body || {};

    if (!originalContent || typeof originalContent !== 'string') {
      return res.status(400).json({ ok: false, error: 'originalContent is required' });
    }

    const id = `memo-${crypto.randomUUID()}`;
    const now = new Date().toISOString();
    const tagsJson = JSON.stringify(Array.isArray(tags) ? tags : []);
    const sourceJson = source ? JSON.stringify(source) : null;

    await execute(
      `INSERT INTO memos (id, user_id, original_content, user_note, tags, source, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      id,
      req.userId,
      originalContent.trim().slice(0, 10000),
      userNote ? userNote.trim().slice(0, 4000) : null,
      tagsJson,
      sourceJson,
      now,
      now
    );

    return res.status(201).json({
      ok: true,
      data: {
        id,
        originalContent: originalContent.trim().slice(0, 10000),
        userNote: userNote ? userNote.trim().slice(0, 4000) : null,
        tags: Array.isArray(tags) ? tags : [],
        source: source || null,
        createdAt: now,
        updatedAt: now,
      },
    });
  } catch (err) {
    return next(err);
  }
});

/**
 * PUT /api/memos/:id
 * Update a memo
 */
router.put('/memos/:id', requireD1, requireAuth, async (req, res, next) => {
  try {
    const { id } = req.params;
    const { originalContent, userNote, tags, source } = req.body || {};

    // Check ownership
    const existing = await queryOne(
      `SELECT * FROM memos WHERE id = ? AND user_id = ?`,
      id,
      req.userId
    );

    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Memo not found' });
    }

    // ETag check for optimistic concurrency
    const ifMatch = req.headers['if-match'];
    if (ifMatch && ifMatch !== existing.updated_at) {
      return res.status(412).json({ ok: false, error: 'Precondition failed - resource was modified' });
    }

    const now = new Date().toISOString();
    const newContent = originalContent ? originalContent.trim().slice(0, 10000) : existing.original_content;
    const newNote = userNote !== undefined ? (userNote ? userNote.trim().slice(0, 4000) : null) : existing.user_note;
    const newTags = tags !== undefined ? JSON.stringify(Array.isArray(tags) ? tags : []) : existing.tags;
    const newSource = source !== undefined ? (source ? JSON.stringify(source) : null) : existing.source;

    await execute(
      `UPDATE memos SET original_content = ?, user_note = ?, tags = ?, source = ?, updated_at = ? WHERE id = ?`,
      newContent,
      newNote,
      newTags,
      newSource,
      now,
      id
    );

    return res.json({
      ok: true,
      data: {
        id,
        originalContent: newContent,
        userNote: newNote,
        tags: JSON.parse(newTags),
        source: newSource ? JSON.parse(newSource) : null,
        createdAt: existing.created_at,
        updatedAt: now,
      },
    });
  } catch (err) {
    return next(err);
  }
});

/**
 * DELETE /api/memos/:id
 * Delete a memo
 */
router.delete('/memos/:id', requireD1, requireAuth, async (req, res, next) => {
  try {
    const { id } = req.params;

    // Check ownership
    const existing = await queryOne(
      `SELECT * FROM memos WHERE id = ? AND user_id = ?`,
      id,
      req.userId
    );

    if (!existing) {
      return res.status(404).json({ ok: false, error: 'Memo not found' });
    }

    await execute(`DELETE FROM memos WHERE id = ?`, id);

    return res.json({ ok: true });
  } catch (err) {
    return next(err);
  }
});

export default router;

```

### workers.js

**Path:** `backend/src/routes/workers.js`

```javascript
import { Router } from 'express';
import { config } from '../config.js';
import requireAdmin from '../middleware/adminAuth.js';
import fs from 'node:fs/promises';
import path from 'node:path';
import { spawn } from 'node:child_process';

const router = Router();

const WORKERS_ROOT = path.join(config.content.repoRoot, 'workers');

const WORKERS_CONFIG = [
  {
    id: 'blog-api',
    name: 'Blog API',
    description: '메인 블로그 API Worker',
    path: '',
    wranglerPath: 'wrangler.toml',
    hasProduction: true,
  },
  {
    id: 'ai-check-gateway',
    name: 'AI Check Gateway',
    description: 'AI 서비스 게이트웨이',
    path: 'ai-check-gateway',
    wranglerPath: 'ai-check-gateway/wrangler.toml',
    hasProduction: true,
  },
  {
    id: 'r2-gateway',
    name: 'R2 Gateway',
    description: 'R2 스토리지 게이트웨이',
    path: 'r2-gateway',
    wranglerPath: 'r2-gateway/wrangler.toml',
    hasProduction: false,
  },
  {
    id: 'terminal-gateway',
    name: 'Terminal Gateway',
    description: '터미널 WebSocket 게이트웨이',
    path: 'terminal-gateway',
    wranglerPath: 'terminal-gateway/wrangler.toml',
    hasProduction: true,
  },
];

const KNOWN_SECRETS = [
  { key: 'JWT_SECRET', description: 'JWT 서명 키', workers: ['blog-api', 'terminal-gateway'] },
  { key: 'GEMINI_API_KEY', description: 'Google Gemini API 키', workers: ['blog-api'] },
  { key: 'ADMIN_USERNAME', description: '관리자 사용자명', workers: ['blog-api'] },
  { key: 'ADMIN_PASSWORD', description: '관리자 비밀번호', workers: ['blog-api'] },
  { key: 'OPENROUTER_API_KEY', description: 'OpenRouter API 키', workers: ['blog-api'] },
  { key: 'AI_SERVE_API_KEY', description: 'AI Serve 내부 API 키', workers: ['blog-api'] },
  { key: 'SECRET_API_KEY', description: 'AI Gateway API 키', workers: ['ai-check-gateway'] },
  { key: 'SECRET_INTERNAL_KEY', description: 'AI Gateway 내부 키', workers: ['ai-check-gateway'] },
  { key: 'ORIGIN_SECRET_KEY', description: 'Origin 인증 키', workers: ['terminal-gateway'] },
];

router.get('/list', requireAdmin, async (req, res) => {
  try {
    const workers = await Promise.all(
      WORKERS_CONFIG.map(async (w) => {
        const wranglerPath = path.join(WORKERS_ROOT, w.wranglerPath);
        let exists = false;
        let config = null;

        try {
          const content = await fs.readFile(wranglerPath, 'utf8');
          exists = true;
          config = parseWranglerToml(content);
        } catch {
          exists = false;
        }

        return {
          ...w,
          exists,
          config,
        };
      })
    );

    res.json({ ok: true, data: { workers } });
  } catch (err) {
    res.status(500).json({ ok: false, error: err.message });
  }
});

router.get('/secrets', requireAdmin, (req, res) => {
  res.json({ ok: true, data: { secrets: KNOWN_SECRETS } });
});

router.get('/:workerId/config', requireAdmin, async (req, res) => {
  const { workerId } = req.params;
  const worker = WORKERS_CONFIG.find((w) => w.id === workerId);

  if (!worker) {
    return res.status(404).json({ ok: false, error: 'Worker not found' });
  }

  try {
    const wranglerPath = path.join(WORKERS_ROOT, worker.wranglerPath);
    const content = await fs.readFile(wranglerPath, 'utf8');
    const parsed = parseWranglerToml(content);

    res.json({
      ok: true,
      data: {
        worker,
        raw: content,
        parsed,
      },
    });
  } catch (err) {
    res.status(500).json({ ok: false, error: err.message });
  }
});

router.post('/:workerId/vars', requireAdmin, async (req, res) => {
  const { workerId } = req.params;
  const { vars, env = 'development' } = req.body;
  const worker = WORKERS_CONFIG.find((w) => w.id === workerId);

  if (!worker) {
    return res.status(404).json({ ok: false, error: 'Worker not found' });
  }

  try {
    const wranglerPath = path.join(WORKERS_ROOT, worker.wranglerPath);
    let content = await fs.readFile(wranglerPath, 'utf8');

    for (const [key, value] of Object.entries(vars)) {
      if (env === 'development') {
        const regex = new RegExp(`^(\\[vars\\][\\s\\S]*?)${key}\\s*=\\s*"[^"]*"`, 'm');
        if (regex.test(content)) {
          content = content.replace(regex, `$1${key} = "${value}"`);
        }
      } else if (env === 'production') {
        const regex = new RegExp(
          `^(\\[env\\.production\\.vars\\][\\s\\S]*?)${key}\\s*=\\s*"[^"]*"`,
          'm'
        );
        if (regex.test(content)) {
          content = content.replace(regex, `$1${key} = "${value}"`);
        }
      }
    }

    await fs.writeFile(wranglerPath, content, 'utf8');

    res.json({ ok: true, data: { message: 'Variables updated', path: wranglerPath } });
  } catch (err) {
    res.status(500).json({ ok: false, error: err.message });
  }
});

router.post('/:workerId/secret', requireAdmin, async (req, res) => {
  const { workerId } = req.params;
  const { key, value, env = 'production' } = req.body;
  const worker = WORKERS_CONFIG.find((w) => w.id === workerId);

  if (!worker) {
    return res.status(404).json({ ok: false, error: 'Worker not found' });
  }

  if (!key || !value) {
    return res.status(400).json({ ok: false, error: 'key and value required' });
  }

  try {
    const cwd = worker.path ? path.join(WORKERS_ROOT, worker.path) : WORKERS_ROOT;
    const args = ['secret', 'put', key];
    if (env === 'production') {
      args.push('--env', 'production');
    }

    const result = await runWranglerCommand(args, cwd, value);

    res.json({ ok: true, data: { message: `Secret ${key} set`, output: result } });
  } catch (err) {
    res.status(500).json({ ok: false, error: err.message });
  }
});

router.post('/:workerId/deploy', requireAdmin, async (req, res) => {
  const { workerId } = req.params;
  const { env = 'production', dryRun = false } = req.body;
  const worker = WORKERS_CONFIG.find((w) => w.id === workerId);

  if (!worker) {
    return res.status(404).json({ ok: false, error: 'Worker not found' });
  }

  try {
    const cwd = worker.path ? path.join(WORKERS_ROOT, worker.path) : WORKERS_ROOT;
    const args = ['deploy'];
    if (env === 'production' && worker.hasProduction) {
      args.push('--env', 'production');
    }
    if (dryRun) {
      args.push('--dry-run');
    }

    const result = await runWranglerCommand(args, cwd);

    res.json({
      ok: true,
      data: {
        message: dryRun ? 'Dry run completed' : 'Deployment completed',
        output: result,
      },
    });
  } catch (err) {
    res.status(500).json({ ok: false, error: err.message });
  }
});

router.get('/:workerId/tail', requireAdmin, async (req, res) => {
  const { workerId } = req.params;
  const worker = WORKERS_CONFIG.find((w) => w.id === workerId);

  if (!worker) {
    return res.status(404).json({ ok: false, error: 'Worker not found' });
  }

  res.json({
    ok: true,
    data: {
      message: 'Use wrangler tail command for real-time logs',
      command: `cd workers${worker.path ? '/' + worker.path : ''} && npx wrangler tail`,
    },
  });
});

router.get('/d1/databases', requireAdmin, async (req, res) => {
  try {
    const result = await runWranglerCommand(['d1', 'list', '--json'], WORKERS_ROOT);
    const databases = JSON.parse(result);
    res.json({ ok: true, data: { databases } });
  } catch (err) {
    res.json({ ok: true, data: { databases: [], error: err.message } });
  }
});

router.get('/kv/namespaces', requireAdmin, async (req, res) => {
  try {
    const result = await runWranglerCommand(['kv:namespace', 'list', '--json'], WORKERS_ROOT);
    const namespaces = JSON.parse(result);
    res.json({ ok: true, data: { namespaces } });
  } catch (err) {
    res.json({ ok: true, data: { namespaces: [], error: err.message } });
  }
});

router.get('/r2/buckets', requireAdmin, async (req, res) => {
  try {
    const result = await runWranglerCommand(['r2', 'bucket', 'list', '--json'], WORKERS_ROOT);
    const buckets = JSON.parse(result);
    res.json({ ok: true, data: { buckets } });
  } catch (err) {
    res.json({ ok: true, data: { buckets: [], error: err.message } });
  }
});

function parseWranglerToml(content) {
  const result = {
    name: '',
    main: '',
    compatibility_date: '',
    account_id: '',
    vars: {},
    production: {
      name: '',
      vars: {},
    },
    d1_databases: [],
    r2_buckets: [],
    kv_namespaces: [],
    routes: [],
  };

  const nameMatch = content.match(/^name\s*=\s*"([^"]+)"/m);
  if (nameMatch) result.name = nameMatch[1];

  const mainMatch = content.match(/^main\s*=\s*"([^"]+)"/m);
  if (mainMatch) result.main = mainMatch[1];

  const compatMatch = content.match(/^compatibility_date\s*=\s*"([^"]+)"/m);
  if (compatMatch) result.compatibility_date = compatMatch[1];

  const accountMatch = content.match(/^account_id\s*=\s*"([^"]+)"/m);
  if (accountMatch) result.account_id = accountMatch[1];

  const varsSection = content.match(/\[vars\]([\s\S]*?)(?=\[|$)/);
  if (varsSection) {
    const varMatches = varsSection[1].matchAll(/^(\w+)\s*=\s*"([^"]*)"/gm);
    for (const m of varMatches) {
      result.vars[m[1]] = m[2];
    }
  }

  const prodVarsSection = content.match(/\[env\.production\.vars\]([\s\S]*?)(?=\[|$)/);
  if (prodVarsSection) {
    const varMatches = prodVarsSection[1].matchAll(/^(\w+)\s*=\s*"([^"]*)"/gm);
    for (const m of varMatches) {
      result.production.vars[m[1]] = m[2];
    }
  }

  const prodNameMatch = content.match(/\[env\.production\][\s\S]*?name\s*=\s*"([^"]+)"/);
  if (prodNameMatch) result.production.name = prodNameMatch[1];

  const d1Matches = content.matchAll(
    /\[\[(?:env\.production\.)?d1_databases\]\]\s*\nbinding\s*=\s*"([^"]+)"\s*\ndatabase_name\s*=\s*"([^"]+)"\s*\ndatabase_id\s*=\s*"([^"]+)"/g
  );
  for (const m of d1Matches) {
    result.d1_databases.push({ binding: m[1], database_name: m[2], database_id: m[3] });
  }

  const r2Matches = content.matchAll(
    /\[\[(?:env\.production\.)?r2_buckets\]\]\s*\nbinding\s*=\s*"([^"]+)"\s*\nbucket_name\s*=\s*"([^"]+)"/g
  );
  for (const m of r2Matches) {
    result.r2_buckets.push({ binding: m[1], bucket_name: m[2] });
  }

  const kvMatches = content.matchAll(
    /\[\[(?:env\.production\.)?kv_namespaces\]\]\s*\nbinding\s*=\s*"([^"]+)"\s*\nid\s*=\s*"([^"]+)"/g
  );
  for (const m of kvMatches) {
    result.kv_namespaces.push({ binding: m[1], id: m[2] });
  }

  return result;
}

function runWranglerCommand(args, cwd, stdin = null) {
  return new Promise((resolve, reject) => {
    const proc = spawn('npx', ['wrangler', ...args], {
      cwd,
      shell: true,
      env: { ...process.env },
    });

    let stdout = '';
    let stderr = '';

    proc.stdout.on('data', (data) => {
      stdout += data.toString();
    });

    proc.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    if (stdin) {
      proc.stdin.write(stdin);
      proc.stdin.end();
    }

    proc.on('close', (code) => {
      if (code === 0) {
        resolve(stdout || stderr);
      } else {
        reject(new Error(stderr || stdout || `Command failed with code ${code}`));
      }
    });

    proc.on('error', (err) => {
      reject(err);
    });
  });
}

export default router;

```

---

## backend/terminal-server

### Dockerfile

**Path:** `backend/terminal-server/Dockerfile`

```dockerfile
# =============================================================================
# Terminal Server Dockerfile
# =============================================================================
# Builds the WebSocket PTY server that bridges browser terminals to Docker
# =============================================================================

FROM node:20-alpine

# Install build dependencies for node-pty
RUN apk add --no-cache python3 make g++ docker-cli

WORKDIR /app

# Copy package files
COPY package.json ./

# Install dependencies
RUN npm install

# Copy source
COPY tsconfig.json ./
COPY src ./src

# Build TypeScript
RUN npm run build

# Expose WebSocket port
EXPOSE 8080

# Run the server
CMD ["node", "dist/index.js"]

```

### package.json

**Path:** `backend/terminal-server/package.json`

```json
{
  "name": "terminal-server",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "start": "node dist/index.js",
    "build": "tsc",
    "docker:build-sandbox": "docker build -t blog-terminal-sandbox ./sandbox"
  },
  "dependencies": {
    "node-pty": "^1.0.0",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "@types/ws": "^8.5.13",
    "tsx": "^4.19.0",
    "typescript": "^5.6.3"
  }
}

```

### tsconfig.json

**Path:** `backend/terminal-server/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "declaration": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

```

---

## backend/terminal-server/sandbox

### Dockerfile

**Path:** `backend/terminal-server/sandbox/Dockerfile`

```dockerfile
# Terminal Sandbox Container
# Minimal Alpine-based container for secure terminal sessions
#
# Security features:
# - Non-root user
# - Minimal packages (no network tools)
# - Read-only filesystem (with /tmp writable)
# - No capabilities
#
# Build: docker build -t blog-terminal-sandbox ./sandbox
# Test:  docker run -it --rm blog-terminal-sandbox

FROM alpine:3.19

# Install minimal utilities
RUN apk add --no-cache \
    bash \
    coreutils \
    less \
    nano \
    tree \
    ncurses \
    && rm -rf /var/cache/apk/*

# Create non-root user
RUN adduser -D -s /bin/sh -h /home/sandbox sandbox

# Create workspace directory
RUN mkdir -p /workspace && chown sandbox:sandbox /workspace

# Set up minimal bashrc
RUN echo 'export PS1="\[\e[32m\]sandbox\[\e[0m\]@\[\e[34m\]docker\[\e[0m\]:\[\e[33m\]\w\[\e[0m\]\$ "' > /home/sandbox/.bashrc \
    && echo 'alias ll="ls -la"' >> /home/sandbox/.bashrc \
    && echo 'alias la="ls -A"' >> /home/sandbox/.bashrc \
    && echo 'cd /workspace' >> /home/sandbox/.bashrc \
    && chown sandbox:sandbox /home/sandbox/.bashrc

# Create welcome message
RUN echo '#!/bin/sh' > /etc/profile.d/welcome.sh \
    && echo 'echo ""' >> /etc/profile.d/welcome.sh \
    && echo 'echo "  ╔══════════════════════════════════════╗"' >> /etc/profile.d/welcome.sh \
    && echo 'echo "  ║   🐳 Blog Terminal Sandbox           ║"' >> /etc/profile.d/welcome.sh \
    && echo 'echo "  ║   Isolated Docker Environment        ║"' >> /etc/profile.d/welcome.sh \
    && echo 'echo "  ╚══════════════════════════════════════╝"' >> /etc/profile.d/welcome.sh \
    && echo 'echo ""' >> /etc/profile.d/welcome.sh \
    && echo 'echo "  Available commands: ls, cat, less, nano, tree"' >> /etc/profile.d/welcome.sh \
    && echo 'echo "  Network: DISABLED | Timeout: 10 minutes"' >> /etc/profile.d/welcome.sh \
    && echo 'echo ""' >> /etc/profile.d/welcome.sh \
    && chmod +x /etc/profile.d/welcome.sh

# Add sample files
RUN mkdir -p /workspace/examples \
    && echo '# Hello from the Sandbox!\n\nThis is a secure, isolated terminal environment.\n\n## Features\n- No network access\n- Limited resources\n- Automatic cleanup' > /workspace/examples/README.md \
    && echo '#!/bin/sh\necho "Hello, World!"' > /workspace/examples/hello.sh \
    && chmod +x /workspace/examples/hello.sh \
    && chown -R sandbox:sandbox /workspace

# Switch to non-root user
USER sandbox
WORKDIR /workspace

# Default shell
CMD ["/bin/sh", "-l"]

```

---

## backend/terminal-server/src

### docker.ts

**Path:** `backend/terminal-server/src/docker.ts`

```typescript
/**
 * Terminal Server - Docker Container Manager
 *
 * Manages Docker container lifecycle for terminal sessions
 */

import { spawn, ChildProcess } from 'child_process';

export interface ContainerConfig {
  userId: string;
  image: string;
  cpus: string;
  memory: string;
  pidsLimit: number;
  networkMode: string;
  timeout: number; // in milliseconds
}

export interface ContainerInfo {
  name: string;
  process: ChildProcess | null;
  createdAt: number;
  userId: string;
}

const DEFAULT_CONFIG: Omit<ContainerConfig, 'userId'> = {
  image: 'blog-terminal-sandbox',
  cpus: '0.5',
  memory: '128m',
  pidsLimit: 50,
  networkMode: 'none',
  timeout: 10 * 60 * 1000, // 10 minutes
};

// Track active containers
const activeContainers = new Map<string, ContainerInfo>();

/**
 * Generate unique container name
 */
export function generateContainerName(userId: string): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 8);
  return `terminal-${userId}-${timestamp}-${random}`;
}

/**
 * Build Docker run arguments
 */
export function buildDockerArgs(
  containerName: string,
  config: ContainerConfig
): string[] {
  return [
    'run',
    '-i', // Interactive (stdin)
    '--rm', // Remove container when it exits
    '--name',
    containerName,
    '--network',
    config.networkMode,
    '--cpus',
    config.cpus,
    '--memory',
    config.memory,
    '--pids-limit',
    String(config.pidsLimit),
    // Security options
    '--security-opt',
    'no-new-privileges:true',
    '--cap-drop',
    'ALL',
    // Read-only root filesystem with writable /tmp
    '--read-only',
    '--tmpfs',
    '/tmp:rw,noexec,nosuid,size=64m',
    // Environment
    '--env',
    'TERM=xterm-256color',
    '--env',
    `USER_ID=${config.userId}`,
    // Image and command
    config.image,
    '/bin/sh',
  ];
}

/**
 * Start a new Docker container
 */
export function startContainer(
  userId: string,
  customConfig?: Partial<ContainerConfig>
): { containerName: string; args: string[] } {
  const config: ContainerConfig = {
    ...DEFAULT_CONFIG,
    ...customConfig,
    userId,
  };

  const containerName = generateContainerName(userId);
  const args = buildDockerArgs(containerName, config);

  // Track container
  activeContainers.set(containerName, {
    name: containerName,
    process: null,
    createdAt: Date.now(),
    userId,
  });

  return { containerName, args };
}

/**
 * Stop and remove a container
 */
export async function stopContainer(containerName: string): Promise<void> {
  return new Promise((resolve) => {
    const proc = spawn('docker', ['rm', '-f', containerName], {
      stdio: 'ignore',
    });

    proc.on('close', () => {
      activeContainers.delete(containerName);
      resolve();
    });

    proc.on('error', () => {
      activeContainers.delete(containerName);
      resolve();
    });
  });
}

/**
 * Get container info
 */
export function getContainerInfo(
  containerName: string
): ContainerInfo | undefined {
  return activeContainers.get(containerName);
}

/**
 * List all active containers for a user
 */
export function getUserContainers(userId: string): ContainerInfo[] {
  return Array.from(activeContainers.values()).filter(
    (c) => c.userId === userId
  );
}

/**
 * Clean up stale containers (older than timeout)
 */
export async function cleanupStaleContainers(
  timeout: number = DEFAULT_CONFIG.timeout
): Promise<number> {
  const now = Date.now();
  let cleaned = 0;

  for (const [name, info] of activeContainers) {
    if (now - info.createdAt > timeout) {
      await stopContainer(name);
      cleaned++;
    }
  }

  return cleaned;
}

/**
 * Get container stats
 */
export function getContainerStats(): {
  active: number;
  byUser: Record<string, number>;
} {
  const byUser: Record<string, number> = {};

  for (const info of activeContainers.values()) {
    byUser[info.userId] = (byUser[info.userId] || 0) + 1;
  }

  return {
    active: activeContainers.size,
    byUser,
  };
}

```

### index.ts

**Path:** `backend/terminal-server/src/index.ts`

```typescript
/**
 * Terminal Server - Main Entry Point
 *
 * HTTP + WebSocket server that handles terminal connections from Cloudflare Workers.
 * Only accepts connections with valid Origin Secret.
 *
 * Features:
 * - WebSocket upgrade handling with secret verification
 * - Docker container spawning per session
 * - PTY bridge for terminal I/O
 * - Session timeout management
 * - Graceful shutdown
 */

import http from 'http';
import { WebSocketServer, WebSocket } from 'ws';
import { startContainer, stopContainer, cleanupStaleContainers } from './docker.js';
import { createPtyBridge, parseTerminalSize } from './pty-bridge.js';

// Configuration
const PORT = parseInt(process.env.PORT || '8080', 10);
const ORIGIN_SECRET = process.env.ORIGIN_SECRET_KEY;
const SESSION_TIMEOUT = parseInt(
  process.env.SESSION_TIMEOUT || String(10 * 60 * 1000),
  10
); // 10 minutes default

if (!ORIGIN_SECRET) {
  console.error('ORIGIN_SECRET_KEY environment variable is required');
  process.exit(1);
}

// Track active sessions for cleanup
interface Session {
  userId: string;
  containerName: string;
  ws: WebSocket;
  timeout: NodeJS.Timeout;
  createdAt: number;
}

const sessions = new Map<string, Session>();

// Create HTTP server
const server = http.createServer((req, res) => {
  // Health check endpoint
  if (req.url === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(
      JSON.stringify({
        status: 'ok',
        sessions: sessions.size,
        uptime: process.uptime(),
      })
    );
    return;
  }

  // Stats endpoint
  if (req.url === '/stats') {
    const sessionList = Array.from(sessions.values()).map((s) => ({
      userId: s.userId,
      containerName: s.containerName,
      uptime: Date.now() - s.createdAt,
    }));

    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ sessions: sessionList }));
    return;
  }

  res.writeHead(404);
  res.end('Not Found');
});

// Create WebSocket server (no automatic handling - we do manual upgrade)
const wss = new WebSocketServer({ noServer: true });

// Handle HTTP upgrade to WebSocket
server.on('upgrade', (request, socket, head) => {
  const url = new URL(request.url || '/', `http://${request.headers.host}`);

  // Only handle /terminal path
  if (url.pathname !== '/terminal' && url.pathname !== '/terminal/') {
    socket.write('HTTP/1.1 404 Not Found\r\n\r\n');
    socket.destroy();
    return;
  }

  // Verify origin secret
  const clientSecret = request.headers['x-origin-secret'];
  if (clientSecret !== ORIGIN_SECRET) {
    console.warn('Unauthorized connection attempt - invalid secret');
    socket.write('HTTP/1.1 401 Unauthorized\r\n\r\n');
    socket.destroy();
    return;
  }

  // Extract user info from headers (set by Cloudflare Worker)
  const userId = request.headers['x-user-id'] as string;
  const clientIP = request.headers['x-client-ip'] as string;
  const requestId = request.headers['x-request-id'] as string;

  if (!userId) {
    console.warn('Missing user ID in request');
    socket.write('HTTP/1.1 400 Bad Request\r\n\r\n');
    socket.destroy();
    return;
  }

  console.log(`[${requestId}] WebSocket upgrade for user: ${userId} from ${clientIP}`);

  // Handle WebSocket upgrade
  wss.handleUpgrade(request, socket, head, (ws) => {
    wss.emit('connection', ws, request, { userId, clientIP, requestId, url });
  });
});

// Handle WebSocket connections
wss.on(
  'connection',
  (
    ws: WebSocket,
    request: http.IncomingMessage,
    context: { userId: string; clientIP: string; requestId: string; url: URL }
  ) => {
    const { userId, clientIP, requestId, url } = context;
    console.log(`[${requestId}] Connection established for user: ${userId}`);

    // Parse terminal size from query params
    const { cols, rows } = parseTerminalSize(url);

    // Start Docker container
    const { containerName, args } = startContainer(userId);
    console.log(`[${requestId}] Starting container: ${containerName}`);

    // Send welcome message
    ws.send(`\x1b[32m[Connected to sandbox terminal]\x1b[0m\r\n`);
    ws.send(`\x1b[90mContainer: ${containerName}\x1b[0m\r\n`);
    ws.send(`\x1b[90mTimeout: ${SESSION_TIMEOUT / 1000}s\x1b[0m\r\n\r\n`);

    // Create PTY bridge
    const bridge = createPtyBridge(ws, 'docker', args, {
      cols,
      rows,
      onExit: (code) => {
        console.log(`[${requestId}] Container exited with code: ${code}`);
        cleanupSession(requestId);
      },
    });

    // Session timeout
    const timeout = setTimeout(() => {
      console.log(`[${requestId}] Session timeout for user: ${userId}`);
      ws.send('\r\n\x1b[31m[Session timeout - disconnecting...]\x1b[0m\r\n');

      setTimeout(() => {
        bridge.kill();
        ws.close(1000, 'Session timeout');
      }, 1000);
    }, SESSION_TIMEOUT);

    // Track session
    const session: Session = {
      userId,
      containerName,
      ws,
      timeout,
      createdAt: Date.now(),
    };
    sessions.set(requestId, session);

    // Cleanup function
    const cleanupSession = async (id: string) => {
      const s = sessions.get(id);
      if (s) {
        clearTimeout(s.timeout);
        sessions.delete(id);
        await stopContainer(s.containerName);
        console.log(`[${id}] Session cleaned up`);
      }
    };

    // Handle WebSocket close
    ws.on('close', () => {
      console.log(`[${requestId}] WebSocket closed`);
      cleanupSession(requestId);
    });

    // Handle WebSocket error
    ws.on('error', (err) => {
      console.error(`[${requestId}] WebSocket error:`, err);
      cleanupSession(requestId);
    });
  }
);

// Periodic cleanup of stale containers
setInterval(async () => {
  const cleaned = await cleanupStaleContainers(SESSION_TIMEOUT);
  if (cleaned > 0) {
    console.log(`Cleaned up ${cleaned} stale containers`);
  }
}, 60 * 1000); // Every minute

// Graceful shutdown
const shutdown = async () => {
  console.log('Shutting down...');

  // Close all sessions
  for (const [id, session] of sessions) {
    clearTimeout(session.timeout);
    session.ws.close(1001, 'Server shutting down');
    await stopContainer(session.containerName);
    console.log(`Closed session: ${id}`);
  }

  wss.close();
  server.close();
  process.exit(0);
};

process.on('SIGTERM', shutdown);
process.on('SIGINT', shutdown);

// Start server
server.listen(PORT, () => {
  console.log(`Terminal server listening on port ${PORT}`);
  console.log(`Session timeout: ${SESSION_TIMEOUT / 1000}s`);
});

```

### pty-bridge.ts

**Path:** `backend/terminal-server/src/pty-bridge.ts`

```typescript
/**
 * Terminal Server - PTY Bridge
 *
 * Bridges WebSocket connections to PTY (pseudo-terminal) sessions
 */

import type { WebSocket } from 'ws';
import type { IPty } from 'node-pty';

export interface PtyBridgeOptions {
  cols?: number;
  rows?: number;
  onData?: (data: string) => void;
  onExit?: (code: number) => void;
}

export interface PtyBridge {
  pty: IPty;
  write: (data: string) => void;
  resize: (cols: number, rows: number) => void;
  kill: () => void;
}

/**
 * Create a PTY bridge for a WebSocket connection
 */
export function createPtyBridge(
  ws: WebSocket,
  command: string,
  args: string[],
  options: PtyBridgeOptions = {}
): PtyBridge {
  // Dynamic import node-pty (ESM compatibility)
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const pty = require('node-pty') as typeof import('node-pty');

  const cols = options.cols || 80;
  const rows = options.rows || 24;

  // Spawn PTY process
  const ptyProcess = pty.spawn(command, args, {
    name: 'xterm-256color',
    cols,
    rows,
    cwd: process.env.HOME || '/tmp',
    env: {
      ...process.env,
      TERM: 'xterm-256color',
    },
  });

  // PTY -> WebSocket
  ptyProcess.onData((data: string) => {
    try {
      if (ws.readyState === ws.OPEN) {
        ws.send(data);
      }
      options.onData?.(data);
    } catch (err) {
      console.error('Error sending to WebSocket:', err);
    }
  });

  // PTY exit handler
  ptyProcess.onExit(({ exitCode }) => {
    console.log(`PTY exited with code: ${exitCode}`);
    options.onExit?.(exitCode);

    // Close WebSocket if still open
    if (ws.readyState === ws.OPEN) {
      ws.close(1000, 'Terminal session ended');
    }
  });

  // WebSocket -> PTY
  ws.on('message', (data: Buffer | string) => {
    try {
      const message = data.toString();

      // Handle resize messages (JSON format: {"type":"resize","cols":80,"rows":24})
      if (message.startsWith('{')) {
        try {
          const parsed = JSON.parse(message);
          if (parsed.type === 'resize' && parsed.cols && parsed.rows) {
            ptyProcess.resize(parsed.cols, parsed.rows);
            return;
          }
        } catch {
          // Not JSON, treat as terminal input
        }
      }

      // Regular terminal input
      ptyProcess.write(message);
    } catch (err) {
      console.error('Error writing to PTY:', err);
    }
  });

  // WebSocket close handler
  ws.on('close', () => {
    console.log('WebSocket closed, killing PTY');
    ptyProcess.kill();
  });

  // WebSocket error handler
  ws.on('error', (err) => {
    console.error('WebSocket error:', err);
    ptyProcess.kill();
  });

  return {
    pty: ptyProcess,
    write: (data: string) => ptyProcess.write(data),
    resize: (cols: number, rows: number) => ptyProcess.resize(cols, rows),
    kill: () => ptyProcess.kill(),
  };
}

/**
 * Parse terminal size from query string
 */
export function parseTerminalSize(url: URL): { cols: number; rows: number } {
  const cols = parseInt(url.searchParams.get('cols') || '80', 10);
  const rows = parseInt(url.searchParams.get('rows') || '24', 10);

  return {
    cols: Math.min(Math.max(cols, 20), 500), // Clamp between 20-500
    rows: Math.min(Math.max(rows, 5), 100), // Clamp between 5-100
  };
}

```

---

## doc-converter

### README.md

**Path:** `doc-converter/README.md`

```markdown
# 문서 → 블로그 변환기 (Document to Blog Converter)

GitHub Pages 블로그를 위한 브라우저 기반 문서 변환 도구입니다. DOCX, PDF 문서를 개인적 경험담 스타일의 Markdown 블로그 포스트로 변환할 수 있습니다.

## ✨ 주요 기능

- **📄 문서 파싱**: DOCX, PDF 파일을 브라우저에서 직접 파싱
- **🤖 지능형 분할**: 문서를 여러 개의 블로그 포스트로 자동 분할
- **✍️ 스타일 변환**: 기술 문서를 개인적 경험담으로 변환
- **🌐 다국어 지원**: 한국어/영어 포스트 생성
- **📝 실시간 편집**: 생성된 포스트를 즉시 편집 가능
- **📦 일괄 다운로드**: ZIP 파일로 모든 포스트를 한번에 다운로드
- **🔒 프라이버시**: 100% 클라이언트 사이드 처리 (서버 전송 없음)

## 🚀 사용 방법

### 1. 문서 업로드

- DOCX 또는 PDF 파일을 드래그 앤 드롭하거나 파일 선택
- 최대 50MB까지 지원

### 2. 변환 설정

- 생성할 포스트 수 (1-15개)
- 언어 선택 (한국어/English)
- 글쓰기 스타일 선택:
  - 개인 경험담 (Personal Experience)
  - 학습 여정 (Learning Journey)
  - 문제 해결기 (Problem Solving)
  - 기술 회고 (Tech Reflection)

### 3. 포스트 생성 및 편집

- 자동으로 생성된 포스트 미리보기
- 필요시 각 포스트 개별 편집
- Frontmatter 및 내용 수정 가능

### 4. 다운로드 및 배포

- ZIP 파일로 모든 포스트 다운로드
- README와 배포 가이드 포함
- GitHub Pages에 바로 업로드 가능

## 🛠 기술 스택

- **Frontend**: React 18 + Vite
- **Styling**: Tailwind CSS
- **State Management**: Zustand
- **Document Parsing**:
  - Mammoth.js (DOCX)
  - PDF.js (PDF)
- **File Processing**: JSZip, FileSaver.js
- **Icons**: Lucide React

## 📦 설치 및 실행

```bash
# 의존성 설치
npm install

# 개발 서버 실행
npm run dev

# 빌드
npm run build

# 빌드된 파일 미리보기
npm run preview
```

## 🏗 프로젝트 구조

```
doc-converter/
├── src/
│   ├── components/          # React 컴포넌트
│   │   ├── DocumentUploader.jsx
│   │   ├── DocumentPreview.jsx
│   │   ├── ConversionSettings.jsx
│   │   ├── PostGenerator.jsx
│   │   ├── PostPreview.jsx
│   │   └── PostDownloader.jsx
│   ├── utils/              # 유틸리티 함수
│   │   ├── browserDocumentParser.js
│   │   └── markdownGenerator.js
│   ├── stores/             # 상태 관리
│   │   └── documentStore.js
│   ├── App.jsx
│   ├── main.jsx
│   └── index.css
├── public/
├── package.json
├── vite.config.js
├── tailwind.config.js
└── README.md
```

## 🎯 주요 특징

### 브라우저 기반 처리

- 모든 문서 처리가 브라우저에서 실행
- 파일이 서버로 전송되지 않아 보안성 확보
- 오프라인에서도 작동 가능

### 지능형 문서 분할

- 섹션 헤더 자동 감지
- 적절한 길이로 포스트 분할
- 내용의 연관성을 고려한 그룹핑

### 경험담 스타일 변환

- 기술적 명령어를 개인적 경험으로 변환
- 읽기 쉬운 스토리텔링 형식
- 자연스러운 한국어/영어 표현

## 📝 생성되는 Markdown 형식

```markdown
---
title: '시리즈명 Part 1: 주요 토픽'
date: 2025-01-01
tags: ['docker', 'guide', 'experience']
series: '시리즈명'
part: 1
totalParts: 5
language: 'ko'
author: 'nodove'
category: 'infrastructure'
description: '실제 경험을 바탕으로 한 가이드입니다...'
---

이번에 새로운 시리즈를 시작하게 되었습니다...

## 주요 섹션

실제로 진행하면서 경험한 내용을 바탕으로...

다음 포스트에서 계속 이어가겠습니다...
```

## 🚀 GitHub Pages 배포

1. 생성된 ZIP 파일 다운로드
2. 압축 해제 후 `.md` 파일들을 블로그 저장소에 복사
3. Git commit & push
4. GitHub Actions가 자동으로 빌드 및 배포

## 🤝 기여하기

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## 📄 라이선스

MIT License - 자세한 내용은 [LICENSE](LICENSE) 파일을 참고하세요.

## 🙏 감사의 말

- [Mammoth.js](https://github.com/mwilliamson/mammoth.js) - DOCX 파싱
- [PDF.js](https://mozilla.github.io/pdf.js/) - PDF 파싱
- [JSZip](https://stuk.github.io/jszip/) - ZIP 파일 생성
- [Tailwind CSS](https://tailwindcss.com/) - 스타일링
- [Lucide](https://lucide.dev/) - 아이콘

---

Made with ❤️ for GitHub Pages bloggers

```

### USAGE.md

**Path:** `doc-converter/USAGE.md`

```markdown
# 문서 변환 도구 사용 가이드

## 🎯 목적

이 도구는 `post-temp` 디렉토리의 Proxmox 가이드 DOCX 파일과 같은 기술 문서를 GitHub Pages 블로그용 Markdown 포스트로 변환하기 위해 개발되었습니다.

## 🚀 빠른 시작

### 1. 개발 환경에서 실행

```bash
cd doc-converter
npm install
npm run dev
```

브라우저에서 `http://localhost:5173/doc-converter/`로 접속

### 2. 프로덕션 빌드 및 배포

```bash
npm run build
# dist 폴더의 내용을 GitHub Pages에 배포
```

## 📋 사용 단계

### Step 1: 문서 업로드

- `post-temp` 디렉토리의 DOCX 파일을 업로드
- 또는 다른 PDF/DOCX 파일 업로드
- 파일이 브라우저에서 직접 파싱됨 (서버 전송 없음)

### Step 2: 문서 분석 확인

- 감지된 섹션 수와 내용 확인
- 총 단어 수와 예상 읽기 시간 확인
- 각 섹션의 제목과 길이 검토

### Step 3: 변환 설정

- **포스트 수**: 1-15개 (권장: 5개)
- **언어**: 한국어 또는 영어
- **스타일**: 개인 경험담 (권장)
- **시리즈 제목**: 자동 생성 또는 수동 입력

### Step 4: 포스트 생성

- 버튼 클릭으로 자동 생성
- 기술 문서 → 개인적 경험담으로 변환
- 각 포스트에 적절한 태그와 메타데이터 추가

### Step 5: 내용 검토 및 편집

- 생성된 각 포스트 미리보기
- 필요시 Markdown 내용 직접 편집
- Frontmatter 수정 가능

### Step 6: 다운로드

- ZIP 파일로 모든 포스트 일괄 다운로드
- README.md와 DEPLOY.md 포함
- GitHub Pages 배포 가이드 제공

## 🔧 고급 기능

### 자동 섹션 감지

- Markdown 헤더 (`# ## ###`)
- 번호 목록 (`1. 2. 3.`)
- 챕터 마커 (`Chapter 1:`)
- 한글 섹션 (`설치 1: 내용`)

### 지능형 분할

- 내용의 연관성을 고려한 그룹핑
- 적절한 길이(1500-3000 단어)로 분할
- 너무 짧은 마지막 포스트는 이전 포스트와 병합

### 경험담 스타일 변환

- "설치하세요" → "설치했습니다"
- "다음과 같이" → "저는 다음과 같이"
- 개인적 인사이트와 경험 표현 추가
- 자연스러운 한국어 문체로 변환

## 📁 출력 파일 형식

### 생성되는 Markdown 파일

```markdown
---
title: 'Proxmox 가이드 Part 1: 설치 및 초기 설정'
date: 2025-01-20
tags: ['proxmox', 'virtualization', 'guide']
series: 'Proxmox 구축기'
part: 1
totalParts: 5
language: 'ko'
author: 'nodove'
---

이번에 새로운 시리즈를 시작하게 되었습니다...
```

### 파일명 규칙

- 형식: `YYYY-MM-DD-series-title-part-N.md`
- 예시: `2025-01-20-proxmox-guide-part-1.md`
- 자동으로 하루씩 간격을 두고 날짜 생성

## 🔄 GitHub Pages 배포 흐름

1. **도구에서 포스트 생성** → ZIP 다운로드
2. **압축 해제** → .md 파일들 확인
3. **블로그 저장소에 복사** → `_posts/` 또는 `public/posts/2025/`
4. **Git 커밋 & 푸시** → `git add . && git commit -m "Add new series" && git push`
5. **GitHub Actions 자동 빌드** → 사이트 업데이트

## ⚠️ 주의사항

### 파일 제한

- 최대 50MB
- DOCX, PDF만 지원
- HWP는 지원하지 않음 (DOCX로 변환 필요)

### 브라우저 호환성

- Chrome, Firefox, Safari, Edge 최신 버전
- JavaScript 활성화 필요
- 로컬 파일 접근 권한 필요

### 콘텐츠 품질

- 자동 생성된 내용이므로 검토 필수
- 기술적 정확성 확인 필요
- 개인적 스타일에 맞게 추가 편집 권장

## 💡 팁과 권장사항

### 최적의 결과를 위해

1. **문서 구조화**: 명확한 헤더와 섹션으로 원본 문서 작성
2. **적절한 분할**: 5-7개 포스트가 시리즈로 적당
3. **내용 검토**: 생성 후 각 포스트를 꼼꼼히 검토
4. **태그 최적화**: SEO를 위해 관련 태그 추가 편집

### 문제 해결

- **파싱 오류**: 파일을 다시 저장하거나 다른 형식으로 변환
- **한글 깨짐**: UTF-8 인코딩 확인
- **섹션 감지 실패**: 수동으로 헤더 추가 후 재시도
- **빌드 오류**: Frontmatter 형식 확인

## 🎉 결과

이 도구를 사용하면 기술 문서를 GitHub Pages 블로그에 적합한 개인적이고 읽기 쉬운 포스트 시리즈로 변환할 수 있습니다. Proxmox 가이드 같은 복잡한 기술 문서도 몇 분 만에 매력적인 블로그 시리즈로 변환됩니다!

```

### index.html

**Path:** `doc-converter/index.html`

```html
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>문서 → 블로그 변환기</title>
    <meta
      name="description"
      content="DOCX, PDF 문서를 GitHub Pages 블로그용 Markdown 파일로 변환하는 도구"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

### package.json

**Path:** `doc-converter/package.json`

```json
{
  "name": "doc-to-blog-converter",
  "version": "1.0.0",
  "description": "Browser-based document to blog post converter for GitHub Pages",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "mammoth": "^1.6.0",
    "pdfjs-dist": "^3.11.174",
    "jszip": "^3.10.1",
    "file-saver": "^2.0.5",
    "markdown-it": "^14.0.0",
    "gray-matter": "^4.0.3",
    "zustand": "^4.4.7",
    "lucide-react": "^0.263.1"
  },
  "devDependencies": {
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.0.3",
    "autoprefixer": "^10.4.14",
    "eslint": "^8.45.0",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.3",
    "postcss": "^8.4.27",
    "tailwindcss": "^3.3.3",
    "vite": "^4.4.5"
  },
  "keywords": [
    "document-converter",
    "blog",
    "github-pages",
    "markdown",
    "docx",
    "pdf"
  ],
  "author": "nodove",
  "license": "MIT"
}

```

### postcss.config.js

**Path:** `doc-converter/postcss.config.js`

```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

```

### tailwind.config.js

**Path:** `doc-converter/tailwind.config.js`

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          100: '#dbeafe',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
        },
      },
      fontFamily: {
        sans: [
          '-apple-system',
          'BlinkMacSystemFont',
          'Segoe UI',
          'Roboto',
          'sans-serif',
        ],
        mono: ['Consolas', 'Monaco', 'Courier New', 'monospace'],
      },
    },
  },
  plugins: [],
};

```

### vite.config.js

**Path:** `doc-converter/vite.config.js`

```javascript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
  plugins: [react()],
  base: '/doc-converter/',
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'pdf-lib': ['pdfjs-dist'],
          'mammoth-lib': ['mammoth'],
          'zip-lib': ['jszip', 'file-saver'],
        },
      },
    },
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
  optimizeDeps: {
    include: ['pdfjs-dist/build/pdf.worker.entry'],
  },
  worker: {
    format: 'es',
  },
});

```

---

## doc-converter/src

### App.css

**Path:** `doc-converter/src/App.css`

```css
/* App specific styles */
.document-uploader {
  /* Custom styles for document uploader if needed */
}

.post-preview {
  /* Custom styles for post preview if needed */
}

/* Loading animations */
@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.animate-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Custom scrollbar */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #a1a1a1;
}

```

### App.jsx

**Path:** `doc-converter/src/App.jsx`

```jsx
import React from 'react';
import { FileText, ArrowRight, Github, Zap } from 'lucide-react';
import { useDocumentStore } from './stores/documentStore';
import DocumentUploader from './components/DocumentUploader';
import DocumentPreview from './components/DocumentPreview';
import ConversionSettings from './components/ConversionSettings';
import PostGenerator from './components/PostGenerator';
import PostPreview from './components/PostPreview';
import PostDownloader from './components/PostDownloader';
import './App.css';

function App() {
  const { currentDocument, parsedContent, generatedPosts, error } =
    useDocumentStore();

  const steps = [
    { id: 1, name: '문서 업로드', completed: !!currentDocument },
    { id: 2, name: '파싱 완료', completed: !!parsedContent },
    { id: 3, name: '포스트 생성', completed: generatedPosts.length > 0 },
    { id: 4, name: '다운로드', completed: false },
  ];

  return (
    <div className='min-h-screen bg-gray-100'>
      {/* 헤더 */}
      <header className='bg-white shadow-sm border-b'>
        <div className='max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4'>
          <div className='flex items-center justify-between'>
            <div className='flex items-center'>
              <FileText className='h-8 w-8 text-blue-600 mr-3' />
              <div>
                <h1 className='text-2xl font-bold text-gray-900'>
                  문서 → 블로그 변환기
                </h1>
                <p className='text-sm text-gray-600'>
                  DOCX, PDF를 GitHub Pages 블로그용 Markdown으로 변환
                </p>
              </div>
            </div>

            <div className='flex items-center space-x-4'>
              <div className='flex items-center space-x-2 text-sm text-gray-600'>
                <Zap className='h-4 w-4' />
                <span>100% 브라우저 처리</span>
              </div>
              <a
                href='https://github.com/nodove/blog'
                target='_blank'
                rel='noopener noreferrer'
                className='flex items-center space-x-2 text-gray-600 hover:text-gray-900'
              >
                <Github className='h-5 w-5' />
                <span>GitHub</span>
              </a>
            </div>
          </div>
        </div>
      </header>

      {/* 진행 단계 표시 */}
      <div className='max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6'>
        <div className='flex items-center justify-between mb-8'>
          {steps.map((step, index) => (
            <div key={step.id} className='flex items-center'>
              <div
                className={`
                flex items-center justify-center w-8 h-8 rounded-full text-sm font-medium
                ${
                  step.completed
                    ? 'bg-green-600 text-white'
                    : 'bg-gray-200 text-gray-600'
                }
              `}
              >
                {step.id}
              </div>
              <span
                className={`
                ml-2 text-sm font-medium
                ${step.completed ? 'text-green-600' : 'text-gray-500'}
              `}
              >
                {step.name}
              </span>
              {index < steps.length - 1 && (
                <ArrowRight className='ml-4 h-5 w-5 text-gray-400' />
              )}
            </div>
          ))}
        </div>

        {/* 오류 표시 */}
        {error && (
          <div className='mb-6 bg-red-50 border border-red-200 rounded-md p-4'>
            <div className='flex'>
              <div className='flex-shrink-0'>
                <svg
                  className='h-5 w-5 text-red-400'
                  viewBox='0 0 20 20'
                  fill='currentColor'
                >
                  <path
                    fillRule='evenodd'
                    d='M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z'
                    clipRule='evenodd'
                  />
                </svg>
              </div>
              <div className='ml-3'>
                <h3 className='text-sm font-medium text-red-800'>
                  오류가 발생했습니다
                </h3>
                <div className='mt-2 text-sm text-red-700'>{error}</div>
              </div>
            </div>
          </div>
        )}

        {/* 메인 컨텐츠 */}
        <div className='space-y-8'>
          {/* Step 1: 문서 업로드 */}
          <section>
            <h2 className='text-lg font-semibold text-gray-900 mb-4'>
              1단계: 문서 업로드
            </h2>
            <DocumentUploader />
          </section>

          {/* Step 2: 문서 미리보기 */}
          {parsedContent && (
            <section>
              <h2 className='text-lg font-semibold text-gray-900 mb-4'>
                2단계: 문서 분석 결과
              </h2>
              <DocumentPreview />
            </section>
          )}

          {/* Step 3: 변환 설정 */}
          {parsedContent && (
            <section>
              <h2 className='text-lg font-semibold text-gray-900 mb-4'>
                3단계: 변환 설정
              </h2>
              <ConversionSettings />
            </section>
          )}

          {/* Step 4: 포스트 생성 */}
          {parsedContent && (
            <section>
              <h2 className='text-lg font-semibold text-gray-900 mb-4'>
                4단계: 포스트 생성
              </h2>
              <PostGenerator />
            </section>
          )}

          {/* Step 5: 포스트 미리보기 */}
          {generatedPosts.length > 0 && (
            <section>
              <h2 className='text-lg font-semibold text-gray-900 mb-4'>
                5단계: 생성된 포스트 확인
              </h2>
              <PostPreview />
            </section>
          )}

          {/* Step 6: 다운로드 */}
          {generatedPosts.length > 0 && (
            <section>
              <h2 className='text-lg font-semibold text-gray-900 mb-4'>
                6단계: 다운로드
              </h2>
              <PostDownloader />
            </section>
          )}
        </div>
      </div>

      {/* 푸터 */}
      <footer className='mt-12 bg-white border-t'>
        <div className='max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8'>
          <div className='text-center text-sm text-gray-600'>
            <p>
              Made with ❤️ for GitHub Pages •
              <a
                href='https://github.com/nodove/blog'
                className='ml-1 text-blue-600 hover:underline'
              >
                Open Source
              </a>
            </p>
            <p className='mt-1'>
              모든 처리는 브라우저에서 실행되며 파일이 서버로 전송되지 않습니다.
            </p>
          </div>
        </div>
      </footer>
    </div>
  );
}

export default App;

```

### index.css

**Path:** `doc-converter/src/index.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    font-family:
      -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  }
}

@layer components {
  .btn-primary {
    @apply px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors;
  }

  .btn-secondary {
    @apply px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors;
  }

  .card {
    @apply bg-white rounded-lg shadow-md;
  }

  .input-field {
    @apply px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500;
  }
}

```

### main.jsx

**Path:** `doc-converter/src/main.jsx`

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

---

## doc-converter/src/components

### ConversionSettings.jsx

**Path:** `doc-converter/src/components/ConversionSettings.jsx`

```jsx
import React from 'react';
import { Settings, Sliders } from 'lucide-react';
import { useDocumentStore } from '../stores/documentStore';

const ConversionSettings = () => {
  const { settings, updateSettings } = useDocumentStore();

  const handleSettingChange = (key, value) => {
    updateSettings({ [key]: value });
  };

  return (
    <div className='w-full max-w-2xl mx-auto bg-white rounded-lg shadow-md p-6'>
      <h2 className='text-xl font-bold text-gray-900 mb-4 flex items-center'>
        <Settings className='mr-2 h-5 w-5' />
        변환 설정
      </h2>

      <div className='space-y-6'>
        {/* 포스트 수 설정 */}
        <div>
          <label className='block text-sm font-medium text-gray-700 mb-2'>
            생성할 포스트 수
          </label>
          <div className='flex items-center space-x-4'>
            <input
              type='range'
              min='1'
              max='15'
              value={settings.targetPosts}
              onChange={e =>
                handleSettingChange('targetPosts', parseInt(e.target.value))
              }
              className='flex-1'
            />
            <span className='text-lg font-semibold text-blue-600 w-8 text-center'>
              {settings.targetPosts}
            </span>
          </div>
          <p className='text-xs text-gray-500 mt-1'>
            문서 길이에 따라 자동으로 최적화됩니다
          </p>
        </div>

        {/* 언어 선택 */}
        <div>
          <label className='block text-sm font-medium text-gray-700 mb-2'>
            언어
          </label>
          <div className='flex space-x-4'>
            <label className='flex items-center'>
              <input
                type='radio'
                name='language'
                value='ko'
                checked={settings.language === 'ko'}
                onChange={e => handleSettingChange('language', e.target.value)}
                className='mr-2'
              />
              <span className='text-sm'>한국어</span>
            </label>
            <label className='flex items-center'>
              <input
                type='radio'
                name='language'
                value='en'
                checked={settings.language === 'en'}
                onChange={e => handleSettingChange('language', e.target.value)}
                className='mr-2'
              />
              <span className='text-sm'>English</span>
            </label>
          </div>
        </div>

        {/* 스타일 선택 */}
        <div>
          <label className='block text-sm font-medium text-gray-700 mb-2'>
            글쓰기 스타일
          </label>
          <select
            value={settings.narrativeStyle}
            onChange={e =>
              handleSettingChange('narrativeStyle', e.target.value)
            }
            className='w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500'
          >
            <option value='experience'>
              개인 경험담 (Personal Experience)
            </option>
            <option value='journey'>학습 여정 (Learning Journey)</option>
            <option value='troubleshooting'>
              문제 해결기 (Problem Solving)
            </option>
            <option value='reflection'>기술 회고 (Tech Reflection)</option>
          </select>
          <p className='text-xs text-gray-500 mt-1'>
            기술 문서를 개인적 경험담으로 변환하는 스타일을 선택하세요
          </p>
        </div>

        {/* 시리즈 제목 */}
        <div>
          <label className='block text-sm font-medium text-gray-700 mb-2'>
            시리즈 제목
          </label>
          <input
            type='text'
            value={settings.seriesTitle}
            onChange={e => handleSettingChange('seriesTitle', e.target.value)}
            placeholder='자동으로 생성됩니다'
            className='w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500'
          />
          <p className='text-xs text-gray-500 mt-1'>
            비워두면 파일명에서 자동 생성됩니다
          </p>
        </div>

        {/* 작성자 이름 */}
        <div>
          <label className='block text-sm font-medium text-gray-700 mb-2'>
            작성자 이름
          </label>
          <input
            type='text'
            value={settings.authorName}
            onChange={e => handleSettingChange('authorName', e.target.value)}
            placeholder='nodove'
            className='w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500'
          />
        </div>
      </div>

      <div className='mt-6 pt-4 border-t'>
        <div className='flex items-center text-sm text-gray-600'>
          <Sliders className='mr-2 h-4 w-4' />
          <span>설정은 자동으로 저장됩니다</span>
        </div>
      </div>
    </div>
  );
};

export default ConversionSettings;

```

### DocumentPreview.jsx

**Path:** `doc-converter/src/components/DocumentPreview.jsx`

```jsx
import React from 'react';
import { FileText, Hash, Clock, Languages } from 'lucide-react';
import { useDocumentStore } from '../stores/documentStore';

const DocumentPreview = () => {
  const { parsedContent } = useDocumentStore();

  if (!parsedContent) return null;

  const { filename, type, sections, wordCount, metadata } = parsedContent;

  return (
    <div className='w-full max-w-4xl mx-auto bg-white rounded-lg shadow-md p-6'>
      <h2 className='text-xl font-bold text-gray-900 mb-4 flex items-center'>
        <FileText className='mr-2 h-5 w-5' />
        문서 분석 결과
      </h2>

      <div className='grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6'>
        <div className='bg-blue-50 rounded-lg p-4'>
          <div className='flex items-center'>
            <FileText className='h-5 w-5 text-blue-600 mr-2' />
            <span className='text-sm font-medium text-blue-900'>파일 정보</span>
          </div>
          <p className='text-lg font-bold text-blue-700 mt-1'>
            {type.toUpperCase()}
          </p>
          <p className='text-xs text-blue-600 truncate'>{filename}</p>
        </div>

        <div className='bg-green-50 rounded-lg p-4'>
          <div className='flex items-center'>
            <Hash className='h-5 w-5 text-green-600 mr-2' />
            <span className='text-sm font-medium text-green-900'>섹션 수</span>
          </div>
          <p className='text-lg font-bold text-green-700 mt-1'>
            {sections.length}개
          </p>
          <p className='text-xs text-green-600'>감지된 구역</p>
        </div>

        <div className='bg-purple-50 rounded-lg p-4'>
          <div className='flex items-center'>
            <Languages className='h-5 w-5 text-purple-600 mr-2' />
            <span className='text-sm font-medium text-purple-900'>단어 수</span>
          </div>
          <p className='text-lg font-bold text-purple-700 mt-1'>
            {wordCount.toLocaleString()}
          </p>
          <p className='text-xs text-purple-600'>
            예상 읽기 시간: {Math.ceil(wordCount / 200)}분
          </p>
        </div>

        <div className='bg-orange-50 rounded-lg p-4'>
          <div className='flex items-center'>
            <Clock className='h-5 w-5 text-orange-600 mr-2' />
            <span className='text-sm font-medium text-orange-900'>
              파일 크기
            </span>
          </div>
          <p className='text-lg font-bold text-orange-700 mt-1'>
            {(metadata.size / 1024 / 1024).toFixed(1)}MB
          </p>
          <p className='text-xs text-orange-600'>
            {metadata.pageCount ? `${metadata.pageCount}페이지` : '문서'}
          </p>
        </div>
      </div>

      <div className='border-t pt-4'>
        <h3 className='text-lg font-semibold text-gray-900 mb-3'>
          감지된 섹션
        </h3>
        <div className='space-y-2 max-h-64 overflow-y-auto'>
          {sections.map((section, index) => (
            <div
              key={index}
              className='flex items-start justify-between p-3 bg-gray-50 rounded-md'
            >
              <div className='flex-1'>
                <h4 className='text-sm font-medium text-gray-900'>
                  {section.title}
                </h4>
                <p className='text-xs text-gray-600 mt-1'>
                  {section.wordCount}단어 • Level {section.level || 1}
                </p>
              </div>
              <div className='text-xs text-gray-500 ml-4'>섹션 {index + 1}</div>
            </div>
          ))}
        </div>
      </div>

      {sections.length === 0 && (
        <div className='text-center py-8'>
          <p className='text-gray-500'>섹션을 감지하지 못했습니다.</p>
          <p className='text-sm text-gray-400'>
            문서가 단일 블록으로 처리됩니다.
          </p>
        </div>
      )}
    </div>
  );
};

export default DocumentPreview;

```

### DocumentUploader.jsx

**Path:** `doc-converter/src/components/DocumentUploader.jsx`

```jsx
import React, { useCallback } from 'react';
import { Upload, File, AlertCircle } from 'lucide-react';
import { useDocumentStore } from '../stores/documentStore';
import { BrowserDocumentParser } from '../utils/browserDocumentParser';

const DocumentUploader = () => {
  const {
    setDocument,
    setParsedContent,
    setProcessing,
    setError,
    clearAll,
    isProcessing,
    error,
  } = useDocumentStore();
  const parser = new BrowserDocumentParser();

  const handleFileUpload = useCallback(
    async file => {
      if (!file) return;

      clearAll();
      setProcessing(true);
      setError(null);

      try {
        // 파일 유효성 검사
        parser.validateFile(file);

        // 파일 파싱
        const parsed = await parser.parseFile(file);

        setDocument(file);
        setParsedContent(parsed);
      } catch (err) {
        console.error('File parsing error:', err);
        setError(err.message);
      } finally {
        setProcessing(false);
      }
    },
    [parser, setDocument, setParsedContent, setProcessing, setError, clearAll]
  );

  const handleDrop = useCallback(
    e => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      handleFileUpload(file);
    },
    [handleFileUpload]
  );

  const handleDragOver = useCallback(e => {
    e.preventDefault();
  }, []);

  const handleInputChange = useCallback(
    e => {
      const file = e.target.files[0];
      handleFileUpload(file);
    },
    [handleFileUpload]
  );

  return (
    <div className='w-full max-w-2xl mx-auto'>
      <div
        className={`
          border-2 border-dashed rounded-lg p-8 text-center transition-colors
          ${isProcessing ? 'border-blue-300 bg-blue-50' : 'border-gray-300 hover:border-gray-400'}
          ${error ? 'border-red-300 bg-red-50' : ''}
        `}
        onDrop={handleDrop}
        onDragOver={handleDragOver}
      >
        {isProcessing ? (
          <div className='space-y-4'>
            <div className='inline-flex items-center justify-center w-16 h-16 bg-blue-100 rounded-full'>
              <div className='animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600'></div>
            </div>
            <div>
              <p className='text-lg font-medium text-blue-900'>
                문서 처리 중...
              </p>
              <p className='text-sm text-blue-600'>파일을 파싱하고 있습니다.</p>
            </div>
          </div>
        ) : error ? (
          <div className='space-y-4'>
            <AlertCircle className='mx-auto h-16 w-16 text-red-500' />
            <div>
              <p className='text-lg font-medium text-red-900'>오류 발생</p>
              <p className='text-sm text-red-600'>{error}</p>
              <button
                onClick={() => setError(null)}
                className='mt-2 text-sm text-red-600 hover:text-red-800 underline'
              >
                다시 시도
              </button>
            </div>
          </div>
        ) : (
          <div className='space-y-4'>
            <Upload className='mx-auto h-16 w-16 text-gray-400' />
            <div>
              <p className='text-lg font-medium text-gray-900'>
                문서를 업로드하세요
              </p>
              <p className='text-sm text-gray-600'>
                DOCX 또는 PDF 파일을 드래그하거나 클릭해서 선택하세요
              </p>
              <p className='text-xs text-gray-500 mt-2'>최대 파일 크기: 50MB</p>
            </div>
            <input
              type='file'
              accept='.docx,.pdf'
              onChange={handleInputChange}
              className='hidden'
              id='file-input'
              disabled={isProcessing}
            />
            <label
              htmlFor='file-input'
              className='inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 cursor-pointer transition-colors'
            >
              <File className='mr-2 h-4 w-4' />
              파일 선택
            </label>
          </div>
        )}
      </div>

      <div className='mt-4 text-xs text-gray-500'>
        <p>지원되는 형식: DOCX, PDF</p>
        <p>처리 방식: 100% 브라우저 내에서 처리 (서버 전송 없음)</p>
      </div>
    </div>
  );
};

export default DocumentUploader;

```

### PostDownloader.jsx

**Path:** `doc-converter/src/components/PostDownloader.jsx`

```jsx
import React from 'react';
import { Download, Package, FileText, AlertCircle } from 'lucide-react';
import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import { useDocumentStore } from '../stores/documentStore';

const PostDownloader = () => {
  const { generatedPosts, settings } = useDocumentStore();

  const generateReadme = () => {
    const readmeContent = `# 생성된 블로그 포스트

## 📝 시리즈 정보
- **시리즈명**: ${settings.seriesTitle || '문서 변환 시리즈'}
- **총 포스트 수**: ${generatedPosts.length}개
- **언어**: ${settings.language === 'ko' ? '한국어' : 'English'}
- **스타일**: ${
      settings.narrativeStyle === 'experience'
        ? '개인 경험담'
        : settings.narrativeStyle === 'journey'
          ? '학습 여정'
          : settings.narrativeStyle === 'troubleshooting'
            ? '문제 해결기'
            : '기술 회고'
    }
- **생성 일시**: ${new Date().toLocaleString('ko-KR')}

## 📂 파일 목록
${generatedPosts
  .map(
    (post, index) =>
      `${index + 1}. **${post.filename}**
   - 제목: ${post.frontmatter.title}
   - 단어 수: ${post.metadata.wordCount}개
   - 예상 읽기 시간: ${post.metadata.readingTime}분
   - 태그: ${post.frontmatter.tags.join(', ')}
`
  )
  .join('\n')}

## 🚀 사용 방법

### 1. GitHub Pages 블로그에 업로드
\`\`\`bash
# 1. 블로그 저장소로 파일들을 복사
cp *.md /path/to/your/blog/_posts/  # Jekyll 기반
# 또는
cp *.md /path/to/your/blog/public/posts/2025/  # 다른 정적 사이트 생성기

# 2. Git으로 커밋 및 푸시
git add .
git commit -m "Add new blog post series: ${settings.seriesTitle || '문서 변환 시리즈'}"
git push origin main
\`\`\`

### 2. 파일 구조 확인
- 모든 파일은 올바른 Markdown 형식으로 생성되었습니다
- Frontmatter에 필요한 메타데이터가 포함되어 있습니다
- 각 파일은 독립적으로 작동하지만 시리즈로 연결됩니다

### 3. 추가 편집
필요에 따라 각 Markdown 파일을 텍스트 에디터로 열어서 수정할 수 있습니다.

## 📋 체크리스트
- [ ] 모든 파일을 블로그 저장소에 복사
- [ ] 파일명과 날짜가 올바른지 확인
- [ ] 각 포스트의 태그와 카테고리 확인
- [ ] Git commit & push 실행
- [ ] 배포 확인

## 🛠 생성 도구
이 포스트들은 [문서→블로그 변환기](/)를 사용하여 생성되었습니다.

---
*이 파일은 자동으로 생성되었습니다.*`;

    return readmeContent;
  };

  const handleDownloadAll = async () => {
    if (generatedPosts.length === 0) return;

    try {
      const zip = new JSZip();
      const postsFolder = zip.folder('posts');

      // 각 포스트 파일 추가
      generatedPosts.forEach(post => {
        postsFolder.file(post.filename, post.content);
      });

      // README 파일 추가
      zip.file('README.md', generateReadme());

      // 배포 가이드 추가
      const deployGuide = `# 배포 가이드

## GitHub Pages 배포 방법

### 방법 1: GitHub 웹 인터페이스 사용
1. GitHub에서 블로그 저장소로 이동
2. \`_posts\` 또는 \`public/posts/2025/\` 폴더로 이동
3. "Add file" > "Upload files" 클릭
4. 모든 .md 파일을 드래그 앤 드롭으로 업로드
5. 커밋 메시지 작성 후 "Commit changes" 클릭

### 방법 2: Git 명령어 사용
\`\`\`bash
# 저장소 클론 (처음만)
git clone https://github.com/YOUR_USERNAME/YOUR_BLOG_REPO.git
cd YOUR_BLOG_REPO

# 포스트 파일들 복사
cp /path/to/downloaded/posts/*.md _posts/
# 또는 다른 경로: cp /path/to/downloaded/posts/*.md public/posts/2025/

# 커밋 및 푸시
git add .
git commit -m "Add new blog post series"
git push origin main
\`\`\`

### 방법 3: GitHub Desktop 사용
1. GitHub Desktop에서 저장소 열기
2. 포스트 파일들을 적절한 폴더에 복사
3. 변경사항 확인 후 커밋
4. Push origin 클릭

## 주의사항
- 파일명의 날짜 형식이 올바른지 확인하세요 (YYYY-MM-DD)
- Frontmatter 형식이 블로그 설정과 일치하는지 확인하세요
- 이미지나 링크가 있다면 경로를 확인하세요

## 문제 해결
- 빌드 오류가 발생하면 Frontmatter 형식을 확인하세요
- 한글 인코딩 문제가 있다면 파일을 UTF-8로 다시 저장하세요
- Jekyll 사용시 \`bundle exec jekyll serve\`로 로컬에서 먼저 테스트하세요
`;

      zip.file('DEPLOY.md', deployGuide);

      // ZIP 파일 생성 및 다운로드
      const blob = await zip.generateAsync({ type: 'blob' });
      const timestamp = new Date().toISOString().slice(0, 10);
      const filename = `blog-posts-${timestamp}.zip`;

      saveAs(blob, filename);
    } catch (error) {
      console.error('Download error:', error);
      alert('다운로드 중 오류가 발생했습니다: ' + error.message);
    }
  };

  const calculateTotalStats = () => {
    return generatedPosts.reduce(
      (stats, post) => ({
        totalWords: stats.totalWords + post.metadata.wordCount,
        totalReadingTime: stats.totalReadingTime + post.metadata.readingTime,
        totalTags: stats.totalTags + post.frontmatter.tags.length,
      }),
      { totalWords: 0, totalReadingTime: 0, totalTags: 0 }
    );
  };

  if (generatedPosts.length === 0) {
    return (
      <div className='w-full max-w-2xl mx-auto bg-gray-50 rounded-lg p-8 text-center'>
        <Package className='mx-auto h-12 w-12 text-gray-400 mb-4' />
        <p className='text-gray-600'>
          포스트가 생성되면 다운로드할 수 있습니다
        </p>
      </div>
    );
  }

  const stats = calculateTotalStats();

  return (
    <div className='w-full max-w-4xl mx-auto bg-white rounded-lg shadow-md p-6'>
      <h2 className='text-xl font-bold text-gray-900 mb-4 flex items-center'>
        <Download className='mr-2 h-5 w-5' />
        다운로드
      </h2>

      {/* 통계 정보 */}
      <div className='grid grid-cols-1 md:grid-cols-3 gap-4 mb-6'>
        <div className='bg-blue-50 rounded-lg p-4 text-center'>
          <FileText className='mx-auto h-8 w-8 text-blue-600 mb-2' />
          <p className='text-2xl font-bold text-blue-700'>
            {generatedPosts.length}
          </p>
          <p className='text-sm text-blue-600'>포스트</p>
        </div>

        <div className='bg-green-50 rounded-lg p-4 text-center'>
          <FileText className='mx-auto h-8 w-8 text-green-600 mb-2' />
          <p className='text-2xl font-bold text-green-700'>
            {stats.totalWords.toLocaleString()}
          </p>
          <p className='text-sm text-green-600'>총 단어</p>
        </div>

        <div className='bg-purple-50 rounded-lg p-4 text-center'>
          <FileText className='mx-auto h-8 w-8 text-purple-600 mb-2' />
          <p className='text-2xl font-bold text-purple-700'>
            {stats.totalReadingTime}
          </p>
          <p className='text-sm text-purple-600'>분 읽기</p>
        </div>
      </div>

      {/* 다운로드 버튼 */}
      <button
        onClick={handleDownloadAll}
        className='w-full flex items-center justify-center px-6 py-4 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-lg font-medium'
      >
        <Package className='mr-3 h-6 w-6' />
        모든 포스트 다운로드 (.zip)
      </button>

      {/* 포함 내용 안내 */}
      <div className='mt-6 bg-blue-50 rounded-lg p-4'>
        <h3 className='font-semibold text-blue-900 mb-2 flex items-center'>
          <FileText className='mr-2 h-4 w-4' />
          다운로드 포함 내용
        </h3>
        <ul className='text-sm text-blue-800 space-y-1 ml-4'>
          <li>• {generatedPosts.length}개의 Markdown 포스트 파일</li>
          <li>• README.md (시리즈 정보 및 사용 방법)</li>
          <li>• DEPLOY.md (GitHub Pages 배포 가이드)</li>
          <li>• 올바른 Frontmatter와 태그 포함</li>
          <li>• 날짜별 정렬된 파일명</li>
        </ul>
      </div>

      {/* 사용 방법 */}
      <div className='mt-4 bg-yellow-50 border border-yellow-200 rounded-lg p-4'>
        <div className='flex items-start'>
          <AlertCircle className='h-5 w-5 text-yellow-600 mr-2 mt-0.5' />
          <div>
            <h4 className='font-semibold text-yellow-800'>사용 방법</h4>
            <ol className='text-sm text-yellow-700 mt-1 space-y-1 ml-4'>
              <li>1. 위 버튼을 클릭해 ZIP 파일 다운로드</li>
              <li>2. 압축 해제 후 .md 파일들을 블로그 저장소에 복사</li>
              <li>3. Git commit & push 실행</li>
              <li>4. GitHub Actions가 자동으로 사이트 빌드 및 배포</li>
            </ol>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PostDownloader;

```

### PostGenerator.jsx

**Path:** `doc-converter/src/components/PostGenerator.jsx`

```jsx
import React from 'react';
import { Wand2, FileText, AlertCircle } from 'lucide-react';
import { useDocumentStore } from '../stores/documentStore';
import { MarkdownGenerator } from '../utils/markdownGenerator';

const PostGenerator = () => {
  const {
    parsedContent,
    settings,
    generatedPosts,
    setGeneratedPosts,
    setProcessing,
    setError,
    isProcessing,
  } = useDocumentStore();

  const generator = new MarkdownGenerator();

  const handleGenerate = async () => {
    if (!parsedContent) {
      setError('먼저 문서를 업로드하고 파싱해주세요.');
      return;
    }

    setProcessing(true);
    setError(null);

    try {
      const options = {
        ...settings,
        seriesTitle:
          settings.seriesTitle || generator.extractSeriesTitle(parsedContent),
      };

      const posts = generator.generatePostSeries(parsedContent, options);
      setGeneratedPosts(posts);
    } catch (err) {
      console.error('Post generation error:', err);
      setError(err.message);
    } finally {
      setProcessing(false);
    }
  };

  if (!parsedContent) {
    return (
      <div className='w-full max-w-2xl mx-auto bg-gray-50 rounded-lg p-8 text-center'>
        <FileText className='mx-auto h-12 w-12 text-gray-400 mb-4' />
        <p className='text-gray-600'>
          문서를 업로드하면 포스트 생성이 가능합니다
        </p>
      </div>
    );
  }

  return (
    <div className='w-full max-w-2xl mx-auto'>
      <div className='bg-white rounded-lg shadow-md p-6'>
        <h2 className='text-xl font-bold text-gray-900 mb-4 flex items-center'>
          <Wand2 className='mr-2 h-5 w-5' />
          포스트 생성
        </h2>

        <div className='mb-6 p-4 bg-blue-50 rounded-lg'>
          <h3 className='font-semibold text-blue-900 mb-2'>생성 예상 정보</h3>
          <ul className='text-sm text-blue-800 space-y-1'>
            <li>• 예상 포스트 수: {settings.targetPosts}개</li>
            <li>• 언어: {settings.language === 'ko' ? '한국어' : 'English'}</li>
            <li>
              • 스타일:{' '}
              {settings.narrativeStyle === 'experience'
                ? '개인 경험담'
                : settings.narrativeStyle === 'journey'
                  ? '학습 여정'
                  : settings.narrativeStyle === 'troubleshooting'
                    ? '문제 해결기'
                    : '기술 회고'}
            </li>
            <li>• 총 섹션: {parsedContent.sections.length}개</li>
            <li>• 총 단어 수: {parsedContent.wordCount.toLocaleString()}개</li>
          </ul>
        </div>

        <button
          onClick={handleGenerate}
          disabled={isProcessing}
          className={`
            w-full flex items-center justify-center px-4 py-3 rounded-md text-white font-medium
            ${
              isProcessing
                ? 'bg-gray-400 cursor-not-allowed'
                : 'bg-blue-600 hover:bg-blue-700 active:bg-blue-800'
            } transition-colors
          `}
        >
          {isProcessing ? (
            <>
              <div className='animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-2'></div>
              포스트 생성 중...
            </>
          ) : (
            <>
              <Wand2 className='mr-2 h-5 w-5' />
              {generatedPosts.length > 0
                ? '포스트 다시 생성'
                : '포스트 생성하기'}
            </>
          )}
        </button>

        {generatedPosts.length > 0 && (
          <div className='mt-4 p-4 bg-green-50 rounded-lg'>
            <p className='text-green-800 font-medium'>
              ✅ {generatedPosts.length}개의 포스트가 생성되었습니다!
            </p>
            <p className='text-sm text-green-600 mt-1'>
              아래에서 각 포스트를 미리보기하고 편집할 수 있습니다.
            </p>
          </div>
        )}
      </div>

      <div className='mt-4 text-xs text-gray-500 text-center'>
        <p>• 생성된 포스트는 개인적 경험담 스타일로 자동 변환됩니다</p>
        <p>• 기술적 정확성을 유지하면서 읽기 쉬운 형태로 변환합니다</p>
        <p>• 생성 후 각 포스트를 개별적으로 편집할 수 있습니다</p>
      </div>
    </div>
  );
};

export default PostGenerator;

```

### PostPreview.jsx

**Path:** `doc-converter/src/components/PostPreview.jsx`

```jsx
import React, { useState } from 'react';
import {
  Eye,
  Edit,
  Trash2,
  Download,
  FileText,
  Clock,
  Hash,
} from 'lucide-react';
import { useDocumentStore } from '../stores/documentStore';

const PostPreview = () => {
  const { generatedPosts, updatePost, deletePost } = useDocumentStore();
  const [expandedPost, setExpandedPost] = useState(null);
  const [editingPost, setEditingPost] = useState(null);
  const [editContent, setEditContent] = useState('');

  const handleEdit = (index, post) => {
    setEditingPost(index);
    setEditContent(post.content);
  };

  const handleSaveEdit = index => {
    updatePost(index, { content: editContent });
    setEditingPost(null);
    setEditContent('');
  };

  const handleCancelEdit = () => {
    setEditingPost(null);
    setEditContent('');
  };

  const handleDownloadSingle = post => {
    const blob = new Blob([post.content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = post.filename;
    a.click();
    URL.revokeObjectURL(url);
  };

  if (generatedPosts.length === 0) {
    return (
      <div className='w-full max-w-4xl mx-auto bg-gray-50 rounded-lg p-8 text-center'>
        <FileText className='mx-auto h-12 w-12 text-gray-400 mb-4' />
        <p className='text-gray-600'>
          포스트를 생성하면 여기서 미리보기할 수 있습니다
        </p>
      </div>
    );
  }

  return (
    <div className='w-full max-w-6xl mx-auto'>
      <div className='bg-white rounded-lg shadow-md p-6'>
        <h2 className='text-xl font-bold text-gray-900 mb-4 flex items-center'>
          <Eye className='mr-2 h-5 w-5' />
          생성된 포스트 ({generatedPosts.length}개)
        </h2>

        <div className='space-y-4'>
          {generatedPosts.map((post, index) => (
            <div key={index} className='border rounded-lg'>
              {/* 포스트 헤더 */}
              <div className='p-4 border-b bg-gray-50 flex items-center justify-between'>
                <div className='flex-1'>
                  <h3 className='font-semibold text-gray-900'>
                    {post.frontmatter.title}
                  </h3>
                  <p className='text-sm text-gray-600 mt-1'>
                    파일명: {post.filename}
                  </p>

                  <div className='flex items-center space-x-4 mt-2 text-xs text-gray-500'>
                    <span className='flex items-center'>
                      <Hash className='h-3 w-3 mr-1' />
                      Part {post.frontmatter.part}/{post.frontmatter.totalParts}
                    </span>
                    <span className='flex items-center'>
                      <FileText className='h-3 w-3 mr-1' />
                      {post.metadata.wordCount}단어
                    </span>
                    <span className='flex items-center'>
                      <Clock className='h-3 w-3 mr-1' />
                      {post.metadata.readingTime}분 읽기
                    </span>
                  </div>
                </div>

                <div className='flex items-center space-x-2'>
                  <button
                    onClick={() =>
                      setExpandedPost(expandedPost === index ? null : index)
                    }
                    className='p-2 text-blue-600 hover:bg-blue-100 rounded'
                    title='미리보기'
                  >
                    <Eye className='h-4 w-4' />
                  </button>
                  <button
                    onClick={() => handleEdit(index, post)}
                    className='p-2 text-green-600 hover:bg-green-100 rounded'
                    title='편집'
                  >
                    <Edit className='h-4 w-4' />
                  </button>
                  <button
                    onClick={() => handleDownloadSingle(post)}
                    className='p-2 text-purple-600 hover:bg-purple-100 rounded'
                    title='다운로드'
                  >
                    <Download className='h-4 w-4' />
                  </button>
                  <button
                    onClick={() => deletePost(index)}
                    className='p-2 text-red-600 hover:bg-red-100 rounded'
                    title='삭제'
                  >
                    <Trash2 className='h-4 w-4' />
                  </button>
                </div>
              </div>

              {/* 태그 및 메타데이터 */}
              <div className='px-4 py-2 bg-gray-50 border-b'>
                <div className='flex flex-wrap gap-2'>
                  {post.frontmatter.tags.map((tag, tagIndex) => (
                    <span
                      key={tagIndex}
                      className='px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded-full'
                    >
                      {tag}
                    </span>
                  ))}
                </div>
                {post.metadata.sectionsIncluded.length > 0 && (
                  <div className='mt-2 text-xs text-gray-600'>
                    포함된 섹션:{' '}
                    {post.metadata.sectionsIncluded.slice(0, 3).join(', ')}
                    {post.metadata.sectionsIncluded.length > 3 && ' ...'}
                  </div>
                )}
              </div>

              {/* 편집 모드 */}
              {editingPost === index && (
                <div className='p-4'>
                  <div className='mb-3 flex items-center justify-between'>
                    <h4 className='font-medium text-gray-900'>포스트 편집</h4>
                    <div className='space-x-2'>
                      <button
                        onClick={() => handleSaveEdit(index)}
                        className='px-3 py-1 text-sm bg-green-600 text-white rounded hover:bg-green-700'
                      >
                        저장
                      </button>
                      <button
                        onClick={handleCancelEdit}
                        className='px-3 py-1 text-sm bg-gray-600 text-white rounded hover:bg-gray-700'
                      >
                        취소
                      </button>
                    </div>
                  </div>
                  <textarea
                    value={editContent}
                    onChange={e => setEditContent(e.target.value)}
                    className='w-full h-96 p-3 border border-gray-300 rounded-md font-mono text-sm focus:outline-none focus:ring-2 focus:ring-blue-500'
                    placeholder='Markdown 내용을 편집하세요...'
                  />
                  <div className='mt-2 text-xs text-gray-500'>
                    Markdown 형식으로 작성하세요. Frontmatter(---로 둘러싸인
                    부분)를 수정할 수 있습니다.
                  </div>
                </div>
              )}

              {/* 미리보기 모드 */}
              {expandedPost === index && editingPost !== index && (
                <div className='p-4'>
                  <div className='mb-3 flex items-center justify-between'>
                    <h4 className='font-medium text-gray-900'>미리보기</h4>
                    <button
                      onClick={() => setExpandedPost(null)}
                      className='text-gray-500 hover:text-gray-700'
                    >
                      접기
                    </button>
                  </div>
                  <div className='bg-gray-50 rounded-md p-4 max-h-96 overflow-y-auto'>
                    <pre className='whitespace-pre-wrap text-sm font-mono text-gray-800'>
                      {post.content}
                    </pre>
                  </div>
                </div>
              )}
            </div>
          ))}
        </div>

        {generatedPosts.length > 0 && (
          <div className='mt-6 text-center text-sm text-gray-600'>
            <p>각 포스트를 개별적으로 편집하고 다운로드할 수 있습니다.</p>
            <p>
              모든 포스트를 한번에 다운로드하려면 아래의 일괄 다운로드 버튼을
              사용하세요.
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default PostPreview;

```

---

## doc-converter/src/stores

### documentStore.js

**Path:** `doc-converter/src/stores/documentStore.js`

```javascript
import { create } from 'zustand';

export const useDocumentStore = create((set, get) => ({
  // 상태
  currentDocument: null,
  parsedContent: null,
  generatedPosts: [],
  isProcessing: false,
  error: null,

  // 설정
  settings: {
    targetPosts: 5,
    language: 'ko',
    narrativeStyle: 'experience',
    seriesTitle: '',
    authorName: 'nodove',
  },

  // 액션
  setDocument: document => set({ currentDocument: document }),

  setParsedContent: content => set({ parsedContent: content }),

  setGeneratedPosts: posts => set({ generatedPosts: posts }),

  setProcessing: isProcessing => set({ isProcessing }),

  setError: error => set({ error }),

  updateSettings: newSettings =>
    set(state => ({
      settings: { ...state.settings, ...newSettings },
    })),

  clearAll: () =>
    set({
      currentDocument: null,
      parsedContent: null,
      generatedPosts: [],
      isProcessing: false,
      error: null,
    }),

  // 편의 메서드
  hasDocument: () => get().currentDocument !== null,
  hasParsedContent: () => get().parsedContent !== null,
  hasGeneratedPosts: () => get().generatedPosts.length > 0,

  updatePost: (index, updates) =>
    set(state => {
      const newPosts = [...state.generatedPosts];
      newPosts[index] = { ...newPosts[index], ...updates };
      return { generatedPosts: newPosts };
    }),

  deletePost: index =>
    set(state => ({
      generatedPosts: state.generatedPosts.filter((_, i) => i !== index),
    })),
}));

```

---

## doc-converter/src/utils

### browserDocumentParser.js

**Path:** `doc-converter/src/utils/browserDocumentParser.js`

```javascript
import mammoth from 'mammoth/mammoth.browser';
import * as pdfjsLib from 'pdfjs-dist';

// PDF.js worker 설정
pdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;

export class BrowserDocumentParser {
  constructor() {
    this.supportedFormats = ['docx', 'pdf'];
  }

  async parseFile(file) {
    const fileType = this.getFileType(file);

    if (!this.supportedFormats.includes(fileType)) {
      throw new Error(`지원하지 않는 파일 형식입니다: ${fileType}`);
    }

    switch (fileType) {
      case 'docx':
        return await this.parseDocx(file);
      case 'pdf':
        return await this.parsePdf(file);
      default:
        throw new Error(`처리할 수 없는 파일 형식: ${fileType}`);
    }
  }

  getFileType(file) {
    const extension = file.name.split('.').pop().toLowerCase();
    return extension;
  }

  async parseDocx(file) {
    try {
      const arrayBuffer = await file.arrayBuffer();
      const result = await mammoth.extractRawText({ arrayBuffer });
      const htmlResult = await mammoth.convertToHtml({ arrayBuffer });

      const sections = this.detectSections(result.value);

      return {
        type: 'docx',
        filename: file.name,
        text: result.value,
        html: htmlResult.value,
        sections,
        wordCount: this.countWords(result.value),
        metadata: {
          size: file.size,
          lastModified: new Date(file.lastModified),
          parsedAt: new Date(),
        },
      };
    } catch (error) {
      throw new Error(`DOCX 파일 파싱 실패: ${error.message}`);
    }
  }

  async parsePdf(file) {
    try {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let fullText = '';
      const pages = [];

      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        const pageText = textContent.items
          .filter(item => item.str && item.str.trim())
          .map(item => item.str)
          .join(' ');

        pages.push({
          pageNumber: i,
          text: pageText,
        });

        fullText += pageText + '\n\n';
      }

      const sections = this.detectSections(fullText);

      return {
        type: 'pdf',
        filename: file.name,
        text: fullText.trim(),
        pages,
        sections,
        wordCount: this.countWords(fullText),
        metadata: {
          size: file.size,
          pageCount: pdf.numPages,
          lastModified: new Date(file.lastModified),
          parsedAt: new Date(),
        },
      };
    } catch (error) {
      throw new Error(`PDF 파일 파싱 실패: ${error.message}`);
    }
  }

  detectSections(text) {
    const lines = text
      .split('\n')
      .map(line => line.trim())
      .filter(line => line);
    const sections = [];
    let currentSection = {
      title: '도입부',
      content: [],
      startIndex: 0,
      level: 0,
    };

    lines.forEach((line, index) => {
      const headerInfo = this.analyzeSectionHeader(line);

      if (headerInfo.isHeader) {
        // 이전 섹션 저장
        if (currentSection.content.length > 0) {
          currentSection.content = currentSection.content.join('\n');
          currentSection.wordCount = this.countWords(currentSection.content);
          sections.push(currentSection);
        }

        // 새 섹션 시작
        currentSection = {
          title: headerInfo.cleanTitle,
          content: [],
          startIndex: index,
          level: headerInfo.level,
          type: headerInfo.type,
        };
      } else if (line.length > 10) {
        // 너무 짧은 줄은 제외
        currentSection.content.push(line);
      }
    });

    // 마지막 섹션 처리
    if (currentSection.content.length > 0) {
      currentSection.content = currentSection.content.join('\n');
      currentSection.wordCount = this.countWords(currentSection.content);
      sections.push(currentSection);
    }

    return sections.filter(section => section.wordCount > 50); // 너무 짧은 섹션 제거
  }

  analyzeSectionHeader(line) {
    // 다양한 헤더 패턴 검사
    const patterns = [
      {
        regex: /^#{1,6}\s+(.+)/,
        type: 'markdown',
        level: match => match[0].match(/#/g).length,
      },
      { regex: /^(\d+)\.\s+(.+)/, type: 'numbered', level: 1 },
      { regex: /^(\d+\.\d+)\s+(.+)/, type: 'numbered', level: 2 },
      { regex: /^(\d+\.\d+\.\d+)\s+(.+)/, type: 'numbered', level: 3 },
      {
        regex: /^(Chapter|Section|Part)\s+(\d+):?\s*(.+)/i,
        type: 'chapter',
        level: 1,
      },
      { regex: /^([A-Z][^.]*):$/, type: 'title', level: 1 },
      { regex: /^([가-힣]+)\s*(\d+)\s*[:.]\s*(.+)/, type: 'korean', level: 1 },
    ];

    for (const pattern of patterns) {
      const match = line.match(pattern.regex);
      if (match) {
        let cleanTitle = '';
        let level = 1;

        if (pattern.type === 'markdown') {
          cleanTitle = match[1].trim();
          level = pattern.level(match);
        } else if (pattern.type === 'numbered') {
          cleanTitle = match[2].trim();
          level = pattern.level;
        } else if (pattern.type === 'chapter') {
          cleanTitle = match[3] ? match[3].trim() : `${match[1]} ${match[2]}`;
          level = pattern.level;
        } else if (pattern.type === 'title') {
          cleanTitle = match[1].trim();
          level = pattern.level;
        } else if (pattern.type === 'korean') {
          cleanTitle = match[3] ? match[3].trim() : `${match[1]} ${match[2]}`;
          level = pattern.level;
        }

        return {
          isHeader: true,
          cleanTitle,
          level,
          type: pattern.type,
          originalText: line,
        };
      }
    }

    // 헤더가 아닌 경우도 체크 (대문자로만 이루어진 짧은 줄)
    if (line.length < 100 && line === line.toUpperCase() && line.length > 3) {
      return {
        isHeader: true,
        cleanTitle: line,
        level: 1,
        type: 'uppercase',
        originalText: line,
      };
    }

    return { isHeader: false };
  }

  countWords(text) {
    if (!text) return 0;

    // 한글과 영어를 모두 고려한 단어 수 계산
    const koreanChars = (text.match(/[가-힣]/g) || []).length;
    const englishWords = (text.match(/[a-zA-Z]+/g) || []).length;
    const numbers = (text.match(/\d+/g) || []).length;

    // 한글은 글자 수 / 2, 영어는 단어 수로 계산
    return Math.floor(koreanChars / 2) + englishWords + numbers;
  }

  validateFile(file) {
    const maxSize = 50 * 1024 * 1024; // 50MB
    const allowedTypes = [
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/pdf',
    ];

    if (file.size > maxSize) {
      throw new Error('파일 크기는 50MB를 초과할 수 없습니다.');
    }

    if (
      !allowedTypes.includes(file.type) &&
      !this.supportedFormats.includes(this.getFileType(file))
    ) {
      throw new Error(
        '지원되지 않는 파일 형식입니다. DOCX 또는 PDF 파일만 업로드할 수 있습니다.'
      );
    }

    return true;
  }
}

```

### markdownGenerator.js

**Path:** `doc-converter/src/utils/markdownGenerator.js`

```javascript
export class MarkdownGenerator {
  constructor() {
    this.personalIntros = [
      '이번 포스트에서는',
      '오늘 다룰 내용은',
      '이제 본격적으로',
      '계속해서 진행할 내용은',
      '다음 단계로 넘어가서',
    ];

    this.personalOutros = [
      '다음 포스트에서 계속 이어가겠습니다.',
      '다음 편에서 더 자세히 알아보겠습니다.',
      '계속해서 다음 내용을 살펴보도록 하겠습니다.',
      '다음 글에서 더 깊이 있는 내용을 다뤄보겠습니다.',
      '이어지는 포스트에서 실제 구현을 살펴보겠습니다.',
    ];

    this.experienceTransitions = [
      '실제로 해보니',
      '직접 경험해보면서',
      '과정에서 느낀 점은',
      '개인적으로는',
      '여기서 주의할 점은',
    ];
  }

  generatePostSeries(document, options = {}) {
    const {
      targetPosts = 5,
      language = 'ko',
      narrativeStyle = 'experience',
      seriesTitle,
      authorName = '작성자',
    } = options;

    const sections = document.sections || [];
    if (sections.length === 0) {
      throw new Error('문서에서 섹션을 찾을 수 없습니다.');
    }

    const chunks = this.intelligentSplit(sections, targetPosts);
    const posts = [];

    chunks.forEach((chunk, index) => {
      const post = this.generatePost({
        sections: chunk.sections,
        postNumber: index + 1,
        totalPosts: chunks.length,
        seriesTitle: seriesTitle || this.extractSeriesTitle(document),
        language,
        narrativeStyle,
        authorName,
        originalDocument: document,
      });

      posts.push(post);
    });

    return posts;
  }

  intelligentSplit(sections, targetPosts) {
    if (sections.length <= targetPosts) {
      return sections.map(section => ({ sections: [section] }));
    }

    const totalWords = sections.reduce(
      (sum, section) => sum + (section.wordCount || 0),
      0
    );
    const avgWordsPerPost = Math.ceil(totalWords / targetPosts);
    const minWordsPerPost = avgWordsPerPost * 0.5;
    const maxWordsPerPost = avgWordsPerPost * 1.5;

    const chunks = [];
    let currentChunk = { sections: [], wordCount: 0 };

    sections.forEach(section => {
      const sectionWords = section.wordCount || 0;

      // 현재 청크에 추가했을 때의 단어 수
      const potentialWordCount = currentChunk.wordCount + sectionWords;

      // 새로운 청크를 시작해야 하는 조건
      const shouldStartNewChunk =
        currentChunk.sections.length > 0 &&
        (potentialWordCount > maxWordsPerPost ||
          (potentialWordCount > avgWordsPerPost &&
            currentChunk.sections.length >= 2));

      if (shouldStartNewChunk) {
        chunks.push(currentChunk);
        currentChunk = { sections: [], wordCount: 0 };
      }

      currentChunk.sections.push(section);
      currentChunk.wordCount += sectionWords;
    });

    // 마지막 청크 추가
    if (currentChunk.sections.length > 0) {
      chunks.push(currentChunk);
    }

    // 너무 짧은 마지막 청크는 이전 청크와 합치기
    if (
      chunks.length > 1 &&
      chunks[chunks.length - 1].wordCount < minWordsPerPost
    ) {
      const lastChunk = chunks.pop();
      chunks[chunks.length - 1].sections.push(...lastChunk.sections);
      chunks[chunks.length - 1].wordCount += lastChunk.wordCount;
    }

    return chunks;
  }

  generatePost({
    sections,
    postNumber,
    totalPosts,
    seriesTitle,
    language,
    narrativeStyle,
    authorName,
    originalDocument,
  }) {
    const date = new Date();
    date.setDate(date.getDate() + (postNumber - 1));

    const frontmatter = this.generateFrontmatter({
      postNumber,
      totalPosts,
      seriesTitle,
      language,
      date,
      sections,
      originalDocument,
    });

    const content = this.generateContent({
      sections,
      postNumber,
      totalPosts,
      narrativeStyle,
      language,
    });

    const filename = this.generateFilename({
      date,
      seriesTitle,
      postNumber,
      language,
    });

    const markdown = this.assembleMarkdown(frontmatter, content);

    return {
      filename,
      content: markdown,
      frontmatter,
      metadata: {
        wordCount: this.countWords(content),
        readingTime: this.calculateReadingTime(content),
        sectionsIncluded: sections.map(s => s.title),
      },
    };
  }

  generateFrontmatter({
    postNumber,
    totalPosts,
    seriesTitle,
    language,
    date,
    sections,
    originalDocument,
  }) {
    const tags = this.extractTags(sections);
    const title = this.generateTitle(
      sections,
      postNumber,
      seriesTitle,
      language
    );

    const frontmatter = {
      title,
      date: date.toISOString().split('T')[0],
      tags,
      series: seriesTitle,
      part: postNumber,
      totalParts: totalPosts,
      language,
      author: 'nodove',
    };

    // 카테고리 자동 감지
    const category = this.detectCategory(sections);
    if (category) {
      frontmatter.category = category;
    }

    // 설명 생성
    frontmatter.description = this.generateDescription(sections, language);

    return frontmatter;
  }

  generateTitle(sections, postNumber, seriesTitle, language) {
    const mainTopic = this.extractMainTopic(sections);

    const templates = {
      ko: [
        `${seriesTitle} ${postNumber}부: ${mainTopic}`,
        `${seriesTitle} 가이드 #${postNumber} - ${mainTopic}`,
        `${seriesTitle} 실전 경험기 (${postNumber}/${postNumber === 1 ? '총 몇 부작' : ''})`,
        `${mainTopic} 구축하기 - ${seriesTitle} Part ${postNumber}`,
      ],
      en: [
        `${seriesTitle} Part ${postNumber}: ${mainTopic}`,
        `${seriesTitle} Guide #${postNumber} - ${mainTopic}`,
        `Building ${mainTopic}: ${seriesTitle} Chapter ${postNumber}`,
        `${mainTopic} Implementation - ${seriesTitle} Episode ${postNumber}`,
      ],
    };

    const templateList = templates[language] || templates.ko;
    return templateList[0]; // 첫 번째 템플릿 사용
  }

  generateContent({
    sections,
    postNumber,
    totalPosts,
    narrativeStyle,
    language,
  }) {
    let content = this.addPersonalIntro(postNumber, totalPosts, language);

    sections.forEach((section, index) => {
      content += `\\n\\n## ${section.title}\\n\\n`;

      // 섹션 내용을 경험담 스타일로 변환
      const transformedContent = this.transformToNarrative(
        section.content,
        narrativeStyle,
        language,
        index === 0 // 첫 번째 섹션 여부
      );

      content += transformedContent;
    });

    content += this.addPersonalOutro(postNumber, totalPosts, language);

    return content;
  }

  addPersonalIntro(postNumber, totalPosts, language) {
    if (language === 'ko') {
      if (postNumber === 1) {
        return `이번에 새로운 시리즈를 시작하게 되었습니다. 총 ${totalPosts}부작으로 구성될 예정이며, 첫 번째 포스트에서는 기본적인 내용부터 차근차근 다뤄보겠습니다.`;
      } else if (postNumber === totalPosts) {
        return `드디어 시리즈의 마지막 편입니다. 지금까지의 내용을 바탕으로 마무리 단계를 진행해보겠습니다.`;
      } else {
        return `${this.personalIntros[postNumber % this.personalIntros.length]} ${postNumber}번째 파트를 다뤄보겠습니다. 이전 포스트에서 이어지는 내용이니 참고해서 읽어주세요.`;
      }
    } else {
      if (postNumber === 1) {
        return `I'm starting a new series that will consist of ${totalPosts} parts. In this first post, I'll cover the fundamentals step by step.`;
      } else if (postNumber === totalPosts) {
        return `This is the final part of our series. Based on everything we've covered, let's complete the final steps.`;
      } else {
        return `Continuing with part ${postNumber} of our series. This builds on the previous posts, so please refer to them as needed.`;
      }
    }
  }

  addPersonalOutro(postNumber, totalPosts, language) {
    if (language === 'ko') {
      if (postNumber === totalPosts) {
        return `\\n\\n이로써 ${totalPosts}부작으로 구성된 시리즈가 완료되었습니다. 긴 여정이었지만 많은 것을 배울 수 있었던 좋은 경험이었습니다. 궁금한 점이 있으시면 언제든 댓글로 남겨주세요!`;
      } else {
        return `\\n\\n${this.personalOutros[postNumber % this.personalOutros.length]} 다음 편에서는 더 흥미로운 내용들을 준비해두었으니 기대해 주세요!`;
      }
    } else {
      if (postNumber === totalPosts) {
        return `\\n\\nThis completes our ${totalParts}-part series. It's been quite a journey, and I've learned a lot along the way. Feel free to leave any questions in the comments!`;
      } else {
        return `\\n\\nI'll continue with more interesting content in the next post. Stay tuned!`;
      }
    }
  }

  transformToNarrative(content, style, language, isFirst = false) {
    // 기술적 내용을 개인적 경험담으로 변환
    let narrative = content;

    // 명령형을 경험담으로 변환
    if (language === 'ko') {
      // "설치하세요" -> "설치했습니다"
      narrative = narrative.replace(/([가-힣]+)하세요/g, '$1했습니다');
      narrative = narrative.replace(
        /([가-힣]+)해야 합니다/g,
        '$1해야 했습니다'
      );
      narrative = narrative.replace(/다음과 같이/g, '저는 다음과 같이');

      if (isFirst && style === 'experience') {
        narrative =
          `실제로 진행하면서 경험한 내용을 바탕으로 설명드리겠습니다.\\n\\n` +
          narrative;
      }

      // 경험적 표현 추가
      const experienceMarkers = [
        '여기서 중요한 점은',
        '실제로 해보니',
        '개인적으로는',
        '경험상',
      ];
      if (Math.random() > 0.7) {
        // 30% 확률로 경험적 표현 추가
        const marker =
          experienceMarkers[
            Math.floor(Math.random() * experienceMarkers.length)
          ];
        narrative = narrative.replace(/\\n\\n([가-힣])/g, `\\n\\n${marker} $1`);
      }
    } else {
      // 영어 변환
      narrative = narrative.replace(/You should/g, 'I');
      narrative = narrative.replace(/You can/g, 'I was able to');
      narrative = narrative.replace(/You need to/g, 'I needed to');

      if (isFirst && style === 'experience') {
        narrative =
          `Based on my actual experience, here's what I learned:\\n\\n` +
          narrative;
      }
    }

    return narrative;
  }

  extractMainTopic(sections) {
    // 첫 번째 섹션 제목에서 주요 토픽 추출
    if (sections.length === 0) return '설정 가이드';

    const firstTitle = sections[0].title;
    const keywords = firstTitle.match(/[A-Za-z가-힣]+/g);

    if (keywords && keywords.length > 0) {
      return keywords[0];
    }

    return '구성 요소';
  }

  extractTags(sections) {
    const allText = sections.map(s => `${s.title} ${s.content}`).join(' ');
    const tags = new Set();

    // 기술 키워드 추출
    const techTerms = [
      'Docker',
      'Kubernetes',
      'Proxmox',
      'Linux',
      'Ubuntu',
      'CentOS',
      'VM',
      'Container',
      'Network',
      'Storage',
      'Server',
      'Cloud',
      'Installation',
      'Configuration',
      'Setup',
      'Guide',
      'Tutorial',
      '도커',
      '쿠버네티스',
      '프록스목스',
      '리눅스',
      '우분투',
      '가상머신',
      '컨테이너',
      '네트워크',
      '스토리지',
      '서버',
      '클라우드',
      '설치',
      '구성',
      '설정',
      '가이드',
      '튜토리얼',
    ];

    techTerms.forEach(term => {
      if (allText.toLowerCase().includes(term.toLowerCase())) {
        tags.add(term.toLowerCase());
      }
    });

    return Array.from(tags).slice(0, 8);
  }

  detectCategory(sections) {
    const allText = sections
      .map(s => s.title + ' ' + s.content)
      .join(' ')
      .toLowerCase();

    const categories = {
      infrastructure: ['server', 'network', 'proxmox', 'vm', 'infrastructure'],
      containerization: ['docker', 'kubernetes', 'container', 'k8s'],
      linux: ['linux', 'ubuntu', 'centos', 'terminal', 'shell'],
      development: ['development', 'programming', 'code', 'api'],
      tutorial: ['guide', 'tutorial', 'how-to', '가이드', '튜토리얼'],
    };

    for (const [category, keywords] of Object.entries(categories)) {
      if (keywords.some(keyword => allText.includes(keyword))) {
        return category;
      }
    }

    return 'general';
  }

  generateDescription(sections, language) {
    const mainTopic = this.extractMainTopic(sections);
    const firstContent = sections[0]?.content || '';

    if (language === 'ko') {
      return `${mainTopic}에 대한 실제 경험을 바탕으로 한 가이드입니다. ${firstContent.substring(0, 100)}...`;
    } else {
      return `A practical guide to ${mainTopic} based on real experience. ${firstContent.substring(0, 100)}...`;
    }
  }

  generateFilename({ date, seriesTitle, postNumber, language }) {
    const dateStr = date.toISOString().split('T')[0];
    const titleSlug = this.createSlug(seriesTitle);
    const langSuffix = language === 'en' ? '-en' : '';

    return `${dateStr}-${titleSlug}-part-${postNumber}${langSuffix}.md`;
  }

  createSlug(text) {
    return text
      .toLowerCase()
      .replace(/[^a-z0-9가-힣\\s-]/g, '')
      .replace(/\\s+/g, '-')
      .replace(/-+/g, '-')
      .substring(0, 50)
      .replace(/-$/, '');
  }

  extractSeriesTitle(document) {
    // 파일명에서 시리즈 제목 추출
    const filename = document.filename || 'Document';
    return filename
      .replace(/\\.[^/.]+$/, '') // 확장자 제거
      .replace(/[_-]/g, ' ') // 언더스코어, 대시를 공백으로
      .replace(/\\b\\w/g, l => l.toUpperCase()); // 각 단어 첫글자 대문자
  }

  assembleMarkdown(frontmatter, content) {
    const frontmatterStr = Object.entries(frontmatter)
      .map(([key, value]) => {
        if (Array.isArray(value)) {
          return `${key}: [${value.map(v => `"${v}"`).join(', ')}]`;
        }
        return `${key}: "${value}"`;
      })
      .join('\\n');

    return `---\\n${frontmatterStr}\\n---\\n\\n${content}`;
  }

  countWords(text) {
    if (!text) return 0;
    const koreanChars = (text.match(/[가-힣]/g) || []).length;
    const englishWords = (text.match(/[a-zA-Z]+/g) || []).length;
    return Math.floor(koreanChars / 2) + englishWords;
  }

  calculateReadingTime(text) {
    const wordCount = this.countWords(text);
    return Math.ceil(wordCount / 200); // 분당 200단어 기준
  }
}

```

---

## docs

### AI-feature-architecture-1226.md

**Path:** `docs/AI-feature-architecture-1226.md`

```markdown
# AI 기능 전체 아키텍처 분석

> **작성일**: 2025-12-26  
> **목적**: 서비스별 AI 사용 현황 정리 및 통합 관리 방안 도출

---

## 1. AI 서비스 아키텍처 개요

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Frontend (React)                               │
│  ┌──────────┐ ┌──────────┐ ┌───────────┐ ┌──────────┐ ┌─────────────────┐  │
│  │ AI Chat  │ │ AI Memo  │ │ Sentio    │ │Translate │ │  Image Analysis │  │
│  │ Widget   │ │ Pad      │ │(Spark)    │ │          │ │                 │  │
│  └────┬─────┘ └────┬─────┘ └─────┬─────┘ └────┬─────┘ └────────┬────────┘  │
│       │            │             │            │                 │           │
│       │      ┌─────┴─────┐       │            │                 │           │
│       │      │ ai-memo.js│       │            │                 │           │
│       │      │(Web Comp) │       │            │                 │           │
│       │      └─────┬─────┘       │            │                 │           │
│       └────────────┼─────────────┼────────────┼─────────────────┘           │
│                    │             │            │                              │
│  ┌─────────────────┴─────────────┴────────────┴─────────────────────────┐   │
│  │                    Frontend AI Services                               │   │
│  │  - services/ai.ts (sketch, prism, chain, summary)                    │   │
│  │  - services/chat/api.ts (chat session management)                    │   │
│  └──────────────────────────────────┬───────────────────────────────────┘   │
└─────────────────────────────────────┼───────────────────────────────────────┘
                                      │
                    ┌─────────────────┴─────────────────┐
                    │         Backend API (Express)     │
                    │                                   │
                    │  ┌─────────────────────────────┐  │
                    │  │      API Routes             │  │
                    │  │  /api/v1/ai/*              │  │
                    │  │  /api/v1/chat/*            │  │
                    │  │  /api/v1/translate/*       │  │
                    │  │  /api/v1/images/*          │  │
                    │  └──────────────┬──────────────┘  │
                    │                 │                 │
                    │  ┌──────────────┴──────────────┐  │
                    │  │   Unified AI Service        │  │
                    │  │   (ai-service.js)           │  │
                    │  │   - Provider abstraction    │  │
                    │  │   - Task execution          │  │
                    │  │   - Fallback handling       │  │
                    │  └──────────────┬──────────────┘  │
                    │                 │                 │
                    │  ┌──────────────┴──────────────┐  │
                    │  │    LiteLLM Client           │  │
                    │  │    (litellm-client.js)      │  │
                    │  │    - Circuit breaker        │  │
                    │  │    - Health caching         │  │
                    │  └──────────────┬──────────────┘  │
                    └─────────────────┼─────────────────┘
                                      │
                    ┌─────────────────┴─────────────────┐
                    │      LiteLLM Proxy (Port 4000)    │
                    │  - Unified OpenAI-compatible API  │
                    │  - Automatic fallback routing     │
                    │  - Load balancing                 │
                    └─────────────────┬─────────────────┘
                                      │
          ┌───────────────────────────┼───────────────────────────┐
          │                           │                           │
          ▼                           ▼                           ▼
┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐
│  VAS (GitHub    │       │  Google Gemini  │       │   Anthropic     │
│  Copilot)       │       │  API            │       │   Claude API    │
│  - gpt-4.1      │       │  - gemini-1.5   │       │  - claude-3.5   │
│  - gpt-4o       │       │  - gemini-2.0   │       │  - claude-3     │
│  - claude-sonnet│       │                 │       │                 │
└─────────────────┘       └─────────────────┘       └─────────────────┘
```

---

## 2. 서비스별 AI 사용 현황

### 2.1 AI Chat Widget

| 항목 | 내용 |
|------|------|
| **위치** | `frontend/src/components/features/chat/` |
| **백엔드** | `/api/v1/chat/session/:id/message` |
| **기능** | 실시간 대화, 세션 관리, 컨텍스트 유지 |
| **AI Provider** | VAS (GitHub Copilot) via LiteLLM |
| **스트리밍** | SSE (Server-Sent Events) |

**주요 흐름:**
```
User Input → ensureSession() → POST /chat/session/:id/message
→ VAS Client → SSE Response → UI Update
```

### 2.2 AI Memo Pad (Web Component)

| 항목 | 내용 |
|------|------|
| **위치** | `frontend/public/ai-memo/ai-memo.js` |
| **백엔드** | `/api/v1/ai/generate`, `/api/v1/ai/generate/stream` |
| **기능** | 메모 작성 보조, 요약, Catalyst 제안 |
| **AI Provider** | AIService (litellm → vas → gemini fallback) |
| **특징** | Shadow DOM 기반 독립 컴포넌트 |

**주요 기능:**
- **Draft 저장**: LocalStorage + IndexedDB 동기화
- **Catalyst**: 창의적 제안 생성 (`runCatalyst()`)
- **Cloud Sync**: GitHub 기반 메모 저장/불러오기
- **History**: 버전 관리 및 복원

### 2.3 Sentio (Spark Inline)

| 항목 | 내용 |
|------|------|
| **위치** | `frontend/src/components/features/sentio/SparkInline.tsx` |
| **백엔드** | `/api/v1/chat/session/:id/task` |
| **기능** | 블로그 포스트 텍스트 분석 (Sketch, Prism, Chain) |
| **AI Provider** | VAS via Chat Task API |

**Task 유형:**
| Task | 설명 | 출력 형식 |
|------|------|----------|
| `sketch` | 감정(mood) + 핵심 포인트(bullets) | `{ mood, bullets[] }` |
| `prism` | 다각도 분석 (facets) | `{ facets[{ title, points[] }] }` |
| `chain` | 후속 질문 생성 | `{ questions[{ q, why }] }` |
| `summary` | 요약 | `{ summary }` |
| `catalyst` | 창의적 제안 | `{ suggestions[{ idea, reason }] }` |

### 2.4 Translation Service

| 항목 | 내용 |
|------|------|
| **위치** | `backend/src/routes/translate.js` |
| **백엔드** | `/api/v1/translate` |
| **기능** | 다국어 번역 (한↔영 등) |
| **AI Provider** | AIService |

### 2.5 Image Analysis (Vision)

| 항목 | 내용 |
|------|------|
| **위치** | `backend/src/routes/ai.js` (`/vision/analyze`) |
| **백엔드** | `/api/v1/ai/vision/analyze` |
| **기능** | 이미지 설명 생성 |
| **AI Provider** | AIService with `gpt-4o` (vision-capable) |
| **입력** | `imageUrl` 또는 `imageBase64` |

---

## 3. Backend AI Infrastructure

### 3.1 파일 구조

```
backend/src/
├── lib/
│   ├── ai-service.js      # 통합 AI 서비스 (Provider 추상화)
│   ├── litellm-client.js  # LiteLLM 프록시 클라이언트
│   ├── ai-serve.js        # VAS (GitHub Copilot) 클라이언트
│   └── gemini.js          # Google Gemini 직접 클라이언트 (Legacy)
├── routes/
│   ├── ai.js              # AI 관련 엔드포인트
│   ├── chat.js            # 채팅 세션 및 Task 처리
│   ├── translate.js       # 번역 엔드포인트
│   └── images.js          # 이미지 관련 (Vision 포함)
└── config.js              # AI Provider 설정
```

### 3.2 AIService 클래스 (ai-service.js)

**역할**: Provider 추상화 및 통합 인터페이스

```javascript
class AIService {
  // Provider 자동 감지 (litellm > vas > gemini)
  provider = getActiveProvider();
  
  // 주요 메서드
  generate(prompt, options)     // 텍스트 생성
  chat(messages, options)       // 대화 완료
  vision(imageData, prompt)     // 이미지 분석
  stream(prompt, options)       // 스트리밍 생성
  embeddings(input, options)    // 임베딩 (LiteLLM only)
  task(mode, payload)           // 구조화된 Task 실행
  health()                      // 상태 확인
}
```

### 3.3 LiteLLM Client (litellm-client.js)

**역할**: LiteLLM 프록시와 통신

**특징:**
- **Circuit Breaker**: 5회 실패 시 30초 차단
- **Health Cache**: 10초 캐싱
- **Timeout**: 기본 2분, Vision/번역 5분

### 3.4 API Endpoints 요약

| Endpoint | Method | 기능 |
|----------|--------|------|
| `/api/v1/ai/models` | GET | 사용 가능한 모델 목록 |
| `/api/v1/ai/auto-chat` | POST | 채팅 완료 |
| `/api/v1/ai/health` | GET | AI 서비스 상태 |
| `/api/v1/ai/status` | GET | 상세 상태 정보 |
| `/api/v1/ai/summarize` | POST | 텍스트 요약 |
| `/api/v1/ai/sketch` | POST | Sketch 분석 |
| `/api/v1/ai/prism` | POST | Prism 분석 |
| `/api/v1/ai/chain` | POST | Chain 질문 생성 |
| `/api/v1/ai/generate` | POST | 일반 텍스트 생성 |
| `/api/v1/ai/generate/stream` | GET | 스트리밍 생성 (SSE) |
| `/api/v1/ai/vision/analyze` | POST | 이미지 분석 |
| `/api/v1/chat/session` | POST | 세션 생성 |
| `/api/v1/chat/session/:id/message` | POST | 메시지 전송 (SSE) |
| `/api/v1/chat/session/:id/task` | POST | Task 실행 |
| `/api/v1/translate` | POST | 번역 |

---

## 4. LiteLLM Configuration

### 4.1 설정 파일 위치

- **Production**: `backend/litellm_config.yaml`
- **Local Dev**: `litellm_config.local.yaml`

### 4.2 지원 모델

| Provider | 모델 | 설명 |
|----------|------|------|
| GitHub Copilot (VAS) | `gpt-4.1`, `gpt-4o`, `claude-sonnet-4` | 기본 Provider |
| OpenAI Direct | `openai/gpt-4o`, `openai/gpt-4-turbo` | 별도 API 키 필요 |
| Google Gemini | `gemini-1.5-flash`, `gemini-1.5-pro`, `gemini-2.0-flash` | Fallback |
| Anthropic | `claude-3.5-sonnet`, `claude-3-opus`, `claude-3-haiku` | 선택적 |
| Local (Ollama) | `local/llama3`, `local/codellama` | 개발용 |

### 4.3 Fallback 전략

```yaml
fallbacks:
  - gpt-4.1: ["gemini-1.5-flash", "claude-3-haiku"]
  - gpt-4o: ["gemini-1.5-pro", "claude-3.5-sonnet"]
  - claude-sonnet-4: ["claude-3.5-sonnet", "gemini-1.5-pro"]

context_window_fallbacks:
  - gpt-4.1: ["gemini-1.5-pro"]  # 1M context
```

---

## 5. Frontend AI Services

### 5.1 파일 구조

```
frontend/src/
├── services/
│   ├── ai.ts              # Sentio Task 호출 (sketch, prism, chain)
│   └── chat/
│       ├── api.ts         # Chat API 클라이언트
│       ├── types.ts       # 타입 정의
│       └── index.ts       # 세션 관리 (ensureSession)
├── components/features/
│   ├── chat/              # AI Chat Widget
│   ├── sentio/            # Spark Inline (Sketch/Prism/Chain)
│   └── memo/              # AI Memo 관련 (FAB에서 연동)
└── public/ai-memo/
    └── ai-memo.js         # AI Memo Web Component
```

### 5.2 services/ai.ts

**역할**: Sentio 기능용 Task API 호출

```typescript
// 주요 함수
sketch(input)   // → POST /chat/session/:id/task { mode: 'sketch' }
prism(input)    // → POST /chat/session/:id/task { mode: 'prism' }
chain(input)    // → POST /chat/session/:id/task { mode: 'chain' }
summary(input)  // → POST /chat/session/:id/task { mode: 'summary' }
```

### 5.3 AI Memo Web Component

**역할**: 독립 실행 가능한 메모 패드

**주요 기능:**
- `runCatalyst()`: AI 기반 창의적 제안
- `syncToCloud()`: GitHub 저장소 연동
- `loadHistory()` / `saveHistory()`: 버전 관리
- Shadow DOM 기반 스타일 격리

---

## 6. 데이터 흐름 예시

### 6.1 Chat Message Flow

```
1. User types message in ChatWidget
2. ensureSession() → GET/POST /chat/session
3. POST /chat/session/:id/message { parts: [...] }
4. Backend: getVASClient().chat(messages)
5. SSE stream: { type: 'text', text: chunk }
6. Frontend: Update UI in real-time
7. SSE: { type: 'done' }
```

### 6.2 Sentio Task Flow

```
1. User selects text in BlogPost
2. SparkInline component activates
3. User clicks "Sketch" tab
4. sketch({ paragraph, postTitle })
5. → POST /chat/session/:id/task { mode: 'sketch', payload: {...} }
6. Backend: buildTaskPrompt() → generateContent()
7. Response: { ok: true, data: { mood, bullets } }
8. UI: Display mood badge + bullet points
```

### 6.3 AI Memo Catalyst Flow

```
1. User writes memo in ai-memo-pad
2. User clicks "Catalyst" button
3. runCatalyst() in ai-memo.js
4. → GET /api/v1/ai/generate/stream?prompt=...
5. SSE stream: event: token, data: { token: "..." }
6. UI: Append tokens to suggestions panel
7. SSE: event: done
```

---

## 7. 개선 필요 사항

### 7.1 현재 이슈

| 이슈 | 설명 | 우선순위 |
|------|------|----------|
| 모델 선택 UI 부재 | 사용자가 모델을 선택할 수 없음 | Medium |
| 비용 추적 없음 | 사용량/비용 모니터링 불가 | Medium |
| 세션 메모리 휘발성 | 서버 재시작 시 채팅 히스토리 손실 | High |
| AI Memo 위치 버그 | FAB이 페이지 레이아웃 밖으로 나옴 | High |
| 에러 핸들링 일관성 | Provider별 에러 메시지 불일치 | Low |

### 7.2 권장 개선사항

1. **모델 선택 UI**: Chat Widget에 모델 드롭다운 추가
2. **세션 지속성**: D1 또는 KV를 활용한 세션 저장
3. **사용량 대시보드**: Admin 패널에 AI 사용 통계 추가
4. **통합 에러 처리**: AIService 레벨에서 일관된 에러 포맷

---

## 8. 환경 변수 요약

| 변수 | 설명 | 기본값 |
|------|------|--------|
| `AI_PROVIDER` | 사용할 Provider (`litellm`, `vas`, `gemini`) | 자동 감지 |
| `LITELLM_BASE_URL` | LiteLLM 프록시 URL | `http://litellm:4000` |
| `LITELLM_API_KEY` | LiteLLM Master Key | `sk-litellm-master-key` |
| `AI_DEFAULT_MODEL` | 기본 모델 | `gpt-4.1` |
| `AI_SERVE_BASE_URL` | VAS Core URL | - |
| `GOOGLE_API_KEY` | Gemini API Key | - |
| `OPENAI_API_KEY` | OpenAI Direct API Key | - |
| `ANTHROPIC_API_KEY` | Anthropic API Key | - |

---

## 9. 관련 문서

- [AI 모델 관리 계획서](./PRD-ai-model-management-1226.md)
- [LiteLLM 설정](../backend/litellm_config.yaml)
- [AI Service 구현](../backend/src/lib/ai-service.js)

```

### PRD-ai-chat-markdown-1102.md

**Path:** `docs/PRD-ai-chat-markdown-1102.md`

```markdown
# PRD: AI Chat Markdown Rendering Refresh (1102)

- **Author**: Cascade (AI assistant)
- **Date**: 2025-11-02
- **Status**: Draft / For Review
- **Related initiative**: AI Chat UI/UX 개선

---

## 1. Background & Problem Statement

The in-page AI Chat widget currently streams assistant responses as plain text bubbles without Markdown semantics. This prevents code blocks, inline code, lists, links, and emphasis from rendering correctly, reducing readability for technical answers. The blog already ships a rich Markdown renderer (`frontend/src/components/features/blog/MarkdownRenderer.tsx`) that supports syntax highlighting, link styling, blockquotes, and Spark inline augmentations that could be reused for a consistent look and feel across the product.

## 2. Goals

1. Render AI assistant responses with full Markdown support (code, lists, inline formatting, links, blockquotes).
2. Scope the styling so only assistant chat bubbles adopt the Markdown look without impacting user bubbles or other UI components.
3. Maintain streaming UX—partial messages should progressively format without jank.
4. Preserve existing source references and follow-up button regions below the formatted response.

## 3. Non-Goals

- Changing backend streaming payloads.
- Altering message persistence or follow-up suggestion logic.
- Introducing new assistant content types beyond Markdown.

## 4. Current State Summary

- Chat messages render inside `ChatWidget` as `<div>`s with `whitespace-pre-wrap`; Markdown tokens are shown raw (e.g., ``` fenced code ```).
- The `MarkdownRenderer` component wraps `react-markdown`, `remark-gfm`, and `react-syntax-highlighter` with one-dark theme, copy buttons, and anchored headings; it assumes blog prose width and inline Spark injection.
- No CSS module currently targets assistant bubbles specifically, so introducing Markdown must not leak `.prose` typography globally.

## 5. User Stories & Acceptance Criteria

### Story A1 – Markdown rendering for assistant text

- Role: reader using the AI chat
- Goal: view Markdown syntax in answers rendered with typography, code highlighting, and clickable links
- Benefit: multi-format answers stay legible

#### Acceptance criteria – assistant responses

1. Triple-backtick code blocks appear inside a distinct container with monospace font, background, padding, and optional copy affordance.
2. Inline code renders with subtle background and monospace font.
3. Ordered/unordered lists respect indentation and bullet styling.
4. Bold, italics, strikethrough, and blockquotes match blog styling guidelines.
5. Links open in a new tab with hover states.

### Story A2 – Scoped styling

- Assistant bubbles use Markdown styles without affecting user/system message bubbles.
- Chat widget layout (max width, spacing) remains unchanged aside from typography inside assistant bubble.

### Story A3 – Streaming UX resilience

- Partial chunks (while streaming) should render without page reflow or flashing.
- Upon completion the message is fully formatted.

## 6. Functional Requirements

1. Integrate a Markdown renderer for assistant messages.
   - Option 1: Reuse `MarkdownRenderer` with props for chat context (disable Spark inline, slim spacing, limit heading sizes, adjust copy button placement).
   - Option 2: Create a trimmed chat-specific Markdown component sharing styling tokens.
2. Ensure the renderer is invoked only for `role === 'assistant'` messages.
3. Provide CSS isolation (e.g., wrapping bubble with `.chat-assistant-markdown` and using Tailwind `prose` classes or CSS modules).
4. Preserve newline handling for streaming text (avoid double formatting).
5. Provide fallback to plain text if Markdown parsing fails.

## 7. UX & Visual Guidelines

- Match blog code block palette (one-dark) but reduce margins to suit bubble width.
- Limit heading sizes to ~`text-base`–`text-lg` to avoid oversized titles inside chat.
- Add minimal spacing between paragraphs; prefer `max-w-full` inside bubble.
- Copy button: show top-right on hover similar to blog, but ensure icon remains tappable on mobile.

## 8. Technical Notes

- Evaluate memoization to avoid rerender storms while streaming (e.g., keep raw text state and let Markdown render on each diff, or throttle).
- Keep `whitespace-pre-wrap` for non-Markdown roles.
- Test with long code block streaming; ensure `overflow-auto` on `<pre>`.
- Confirm Tailwind classes available; otherwise add scoped CSS.

## 9. Analytics / Telemetry

- Track (optional) the number of assistant messages containing fenced code vs rendered, via existing telemetry pipeline if available.
- Monitor performance impact (render time) in dev tools.

## 10. Dependencies / Risks

- `react-markdown`, `remark-gfm`, `react-syntax-highlighter` already bundled; confirm tree-shaking unaffected.
- Potential increase in bundle size if new renderer duplicates dependencies—prefer reuse.
- Streaming state might break if Markdown parser expects complete document; mitigate with incremental rendering.
- Need to test in dark mode.

## 11. QA Checklist

- ✅ Markdown sample coverage (headings, list, nested list, blockquote, inline code, fenced code, links).
- ✅ Streaming message showing partial (simulate slow network).
- ✅ Mobile viewport (<= 375px) for code overflow.
- ✅ Source list + follow-up buttons still aligned under Markdown section.
- ✅ No regressions on user/system bubble styling.

## 12. Rollout Plan

- Behind feature flag? Optional if heavy change. Otherwise push with manual QA.
- Communicate update in changelog/blog.

## 13. Open Questions

1. Should copy button appear on mobile (tap) or remain hover-only?
2. Do we need to support tables? (Not mentioned but can piggyback on MarkdownRenderer capability.)

---

## Appendix A – Reference Artifacts

- Chat widget implementation: `frontend/src/components/features/chat/ChatWidget.tsx`
- Blog Markdown renderer: `frontend/src/components/features/blog/MarkdownRenderer.tsx`

```

### PRD-ai-memo-ux-1102.md

**Path:** `docs/PRD-ai-memo-ux-1102.md`

```markdown
# PRD: Floating AI Memo UX Revamp (1102)

- **Author**: Cascade (AI assistant)
- **Date**: 2025-11-02
- **Status**: Draft / For Review
- **Related initiative**: 떠다니는 AI 메모 개선

---

## 1. Background & Problem Statement

The floating AI Memo widget ships as a Shadow DOM injection that currently splits the "편집기" (editor) and "미리보기" (preview) panes vertically (stacked top ↔ bottom). Screenshots and field feedback show that the narrow vertical layout greatly limits horizontal reading space for longer Markdown content or code. Users struggle to scan preview output and maintain context while editing. The CSS toggles a `preview-mode` host class to switch to side-by-side layout, but the experience is inconsistent and not user-driven.

## 2. Goals

1. Provide a more readable layout for editing and previewing Markdown notes (e.g., side-by-side horizontal split or tabbed view).
2. Allow users to switch between preferred layouts (split, tabs) when possible.
3. Improve Catalyst prompt entry and inline AI interactions without blocking memo usage.
4. Preserve mobile usability and responsive behavior.

## 3. Non-Goals

- Rewriting the entire AI Memo feature or backend flows.
- Replacing the Shadow DOM delivery approach.
- Changing persistence model (localStorage keys) beyond what's needed for new UX state.

## 4. Current State Summary

- Layout behavior controlled via CSS classes inside `/frontend/public/ai-memo/ai-memo.css` and toggled by host classes (e.g., `.preview-mode`).
- JavaScript controller (`/frontend/public/ai-memo/ai-memo.js`) handles tab switching and memo state.
- Catalyst UI opens inline within footer area with limited feedback.
- Mobile breakpoint collapses to column layout but lacks layout switching logic.

## 5. User Stories & Acceptance Criteria

### Story B1 – Horizontal split option

- Role: memo power user editing long notes
- Goal: view editor and preview side by side with generous width
- Benefit: reduces scrolling and improves comprehension of formatted output

#### Acceptance criteria – horizontal split

1. Toggling to horizontal split gives each pane ~50% width with responsive flex (minimum width safeguards).
2. Resizing window retains side-by-side layout until mobile breakpoint (< 640px) where it gracefully stacks.
3. Divider spacing and scroll independence preserved (each pane scrolls independently).

### Story B2 – Tabbed editor/preview

- Role: writer on smaller laptop
- Goal: switch between full-width editor and full-width preview using tabs
- Benefit: maximizes space per mode while keeping navigation lightweight

#### Acceptance criteria – tabbed view

1. Tabs labeled "편집" and "미리보기" show only the active pane; other is hidden.
2. Active tab persists for the session via localStorage key (optional but recommended).
3. Keyboard/mouse focus remains in editor when returning from preview.

### Story B3 – Layout toggle control

- Role: memo user with diverse workflows
- Goal: quickly choose between split vs tab view
- Benefit: gives agency without diving into settings modal

#### Acceptance criteria – layout toggle

1. Add layout toggle button(s) near tabs or toolbar (e.g., icon group for split/tabs).
2. State persists between sessions (localStorage, separate key).
3. Clear affordance indicates current mode (active state or tooltip).

### Story B4 – Catalyst UX polish

- Role: user invoking Catalyst prompt
- Goal: avoid disruptive modal overlay and get subtle status cues
- Benefit: maintains editing flow while AI result inserts calmly

#### Acceptance criteria

1. Replace full popup spinner with inline indicator (e.g., pulsing spark icon near Catalyst button) during generation.
2. When Catalyst runs, disable input with busy affordance but keep panel accessible.
3. On success insert text with highlight animation (optional) and toasts for feedback; on error show non-blocking toast.
4. Error toasts replace `alert` usage; use existing toast div or add a more modern pattern.

## 6. Functional Requirements

1. Introduce layout state machine with modes: `split-horizontal`, `split-vertical` (optional legacy), and `tabbed`.
   - Default: horizontal split for desktop, tabbed for < 1024px if desired.
   - Provide toggle control UI and persist via `aiMemo.layout` key.
2. Update CSS (`ai-memo.css`) to support horizontal split by default, with responsive fallbacks.
3. Adjust JS (`ai-memo.js`) to:
   - Initialize layout from storage / viewport.
   - Handle toggle interactions and class switching.
   - Manage tab visibility without relying solely on `preview-mode` host class.
4. Revise Catalyst interactions in `runCatalyst` and toolbar handlers.
   - Replace spinner overlay with inline icon state.
   - Route feedback through toast helper.
   - Optionally integrate with shadcn-style toast if available in Shadow DOM (otherwise keep custom toast).
5. Add accessibility considerations: aria labels for toggles, focus management after layout switches.

## 7. UX & Visual Guidelines

- Horizontal split: 16px gap, balanced pane widths, subtle divider line (optional).
- Tabs: use existing `.tab` styles; highlight active with bottom border.
- Toggle buttons: small icon buttons consistent with memo toolbar (e.g., 32px square, tooltip on hover).
- Catalyst indicator: animate Spark icon or show inline dot; avoid modal overlays.
- Toast copy examples: "Catalyst 결과가 메모에 추가되었습니다", "Catalyst 생성 중 오류가 발생했습니다.".

## 8. Technical Notes

- Shadow DOM limits direct usage of Tailwind; rely on existing CSS or inline styles.
- Ensure layout toggles respect `:host(.memo-full)` fullscreen mode.
- Use MutationObserver or ResizeObserver sparingly; prefer CSS `@media` for responsiveness.
- For Catalyst indicator, reuse existing `out.setStatus` or extend to include icon state.
- When adjusting runCatalyst endpoint once unified (see Catalyst refactor PRD) ensure loading UI still works.

## 9. Analytics / Telemetry

- Log layout mode changes via `logEvent({ type: 'layout_change', mode })` to reuse local storage telemetry.
- Track Catalyst success/error counts for UX evaluation.

## 10. Dependencies / Risks

- Storage schema changes should handle existing users (fallback to default when missing).
- Toggle control must not conflict with existing toolbar buttons (space constraints).
- Catalyst refactor overlaps with API routing plan—coordinate merges to avoid conflicts.

## 11. QA Checklist

- ✅ Desktop horizontal split with long markdown sample
- ✅ Tabbed mode persistence across reload
- ✅ Mobile viewport < 640px: layout stacks gracefully, toggle hidden or adapted
- ✅ Catalyst busy state and toast messaging (success + failure)
- ✅ Regression: memo drag/move, fullscreen mode, history overlay unaffected

## 12. Rollout Plan

- Ship behind runtime flag? If necessary, add query param or localStorage flag for staged rollout.
- Announce in release notes once validated.

## 13. Open Questions

1. Should vertical split remain an option or removed entirely?
2. Do we need resizable divider for horizontal split? (Stretch goal.)
3. Should Catalyst results insert at cursor or append? (Currently appends; consider user preference.)

---

## Appendix B – Reference Artifacts

- Stylesheet: `frontend/public/ai-memo/ai-memo.css`
- Controller script: `frontend/public/ai-memo/ai-memo.js`
- Catalyst telemetry keys: `aiMemo.events`

```

### PRD-ai-model-management-1226.md

**Path:** `docs/PRD-ai-model-management-1226.md`

```markdown
# AI 모델 관리 시스템 계획서

> **작성일**: 2025-12-26  
> **상태**: 계획 단계  
> **우선순위**: Medium

---

## 1. 현재 상태 분석

### 1.1 현재 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                        Frontend (React)                         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────────────────┐│
│  │AI Chat  │  │AI Memo  │  │Catalyst │  │Sketch/Prism/Chain   ││
│  └────┬────┘  └────┬────┘  └────┬────┘  └──────────┬──────────┘│
└───────┼────────────┼────────────┼──────────────────┼───────────┘
        │            │            │                  │
        ▼            ▼            ▼                  ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Backend API (Express)                       │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    AIService (Unified)                    │  │
│  │  - Provider auto-detection (litellm > vas > gemini)      │  │
│  │  - Structured tasks (sketch, prism, chain, summary)      │  │
│  │  - Streaming, Vision, Embeddings support                 │  │
│  └──────────────────────┬───────────────────────────────────┘  │
│                         │                                       │
│  ┌──────────────────────▼───────────────────────────────────┐  │
│  │              LiteLLM Client (OpenAI-compatible)          │  │
│  │  - Circuit breaker                                        │  │
│  │  - Health check caching                                   │  │
│  │  - Timeout management                                     │  │
│  └──────────────────────┬───────────────────────────────────┘  │
└─────────────────────────┼───────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                   LiteLLM Proxy (Port 4000)                     │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │ Router Settings                                            │ │
│  │  - routing_strategy: latency-based-routing                │ │
│  │  - fallbacks: gpt-4.1 → gemini-1.5-flash → claude-3-haiku │ │
│  │  - num_retries: 3                                         │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │ Model List                                                 │ │
│  │  ├─ GitHub Copilot (VAS): gpt-4.1, gpt-4o, claude-sonnet-4│ │
│  │  ├─ OpenAI Direct: gpt-4o, gpt-4-turbo, gpt-3.5-turbo    │ │
│  │  ├─ Google Gemini: gemini-1.5-flash, gemini-1.5-pro      │ │
│  │  ├─ Anthropic: claude-3.5-sonnet, claude-3-opus          │ │
│  │  └─ Local (Ollama): llama3, codellama                    │ │
│  └───────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 현재 설정 파일

| 파일 | 역할 |
|------|------|
| `backend/litellm_config.yaml` | LiteLLM 프록시 설정 (모델 목록, 라우팅, fallback) |
| `backend/src/lib/litellm-client.js` | OpenAI 호환 LiteLLM 클라이언트 |
| `backend/src/lib/ai-service.js` | 통합 AI 서비스 (Provider 추상화) |
| `shared/ai/adapters.ts` | Provider별 응답 형식 어댑터 |

### 1.3 현재 한계점

1. **정적 설정**: `litellm_config.yaml` 수정 시 서비스 재시작 필요
2. **모델 관리 UI 부재**: 관리자가 모델 추가/삭제/수정 불가
3. **비용 추적 없음**: 모델별 사용량 및 비용 모니터링 부재
4. **API 키 관리 분산**: 환경변수로 분산 관리됨

---

## 2. 목표 아키텍처

### 2.1 개선된 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                      Admin Dashboard                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              AI Model Management UI                      │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌───────────────┐  │   │
│  │  │ Models  │ │Providers│ │ Routes  │ │   Monitoring  │  │   │
│  │  └─────────┘ └─────────┘ └─────────┘ └───────────────┘  │   │
│  └──────────────────────────┬──────────────────────────────┘   │
└─────────────────────────────┼───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Backend API (Express)                        │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              AI Config API (/api/v1/admin/ai)            │  │
│  │  - GET/POST /models       : 모델 CRUD                    │  │
│  │  - GET/POST /providers    : Provider 관리                │  │
│  │  - GET/POST /routes       : 라우팅 규칙 관리             │  │
│  │  - GET /usage             : 사용량 조회                  │  │
│  │  - POST /reload           : LiteLLM 설정 리로드          │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              AI Config Store (D1 Database)               │  │
│  │  - ai_providers: Provider 정보 (이름, API Key, 상태)     │  │
│  │  - ai_models: 모델 정보 (이름, provider, 파라미터)       │  │
│  │  - ai_routes: 라우팅 규칙 (fallback, context_window)     │  │
│  │  - ai_usage_logs: 사용량 로그 (모델, 토큰, 비용)         │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│               LiteLLM Proxy (Dynamic Config)                    │
│  - /config/update API로 런타임 설정 변경                        │
│  - 데이터베이스 기반 모델/라우팅 설정                           │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 데이터베이스 스키마

```sql
-- AI Provider 관리
CREATE TABLE ai_providers (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,                    -- 'openai', 'anthropic', 'gemini', 'vas'
  display_name TEXT NOT NULL,            -- 'OpenAI', 'Anthropic Claude'
  api_base_url TEXT,                     -- Provider API URL
  api_key_env TEXT,                      -- 환경변수 이름 (보안)
  is_enabled INTEGER DEFAULT 1,
  health_status TEXT DEFAULT 'unknown',  -- 'healthy', 'degraded', 'down'
  last_health_check TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- AI 모델 관리
CREATE TABLE ai_models (
  id TEXT PRIMARY KEY,
  provider_id TEXT NOT NULL REFERENCES ai_providers(id),
  model_name TEXT NOT NULL,              -- 'gpt-4.1' (LiteLLM에서 사용하는 이름)
  display_name TEXT NOT NULL,            -- 'GPT-4.1 (GitHub Copilot)'
  litellm_model TEXT NOT NULL,           -- 'openai/gpt-4.1' (실제 LiteLLM 모델명)
  description TEXT,
  context_window INTEGER,                -- 128000
  max_tokens INTEGER,                    -- 4096
  input_cost_per_1k REAL,               -- $0.01
  output_cost_per_1k REAL,              -- $0.03
  supports_vision INTEGER DEFAULT 0,
  supports_streaming INTEGER DEFAULT 1,
  supports_function_calling INTEGER DEFAULT 0,
  is_enabled INTEGER DEFAULT 1,
  priority INTEGER DEFAULT 0,            -- 높을수록 우선 사용
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- 라우팅 규칙
CREATE TABLE ai_routes (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,                    -- 'default', 'high-context', 'fast'
  description TEXT,
  routing_strategy TEXT DEFAULT 'latency-based-routing',
  primary_model_id TEXT REFERENCES ai_models(id),
  fallback_model_ids TEXT,               -- JSON array of model IDs
  context_window_fallback_ids TEXT,      -- JSON array for long context
  num_retries INTEGER DEFAULT 3,
  timeout_seconds INTEGER DEFAULT 120,
  is_default INTEGER DEFAULT 0,
  is_enabled INTEGER DEFAULT 1,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- 사용량 로그
CREATE TABLE ai_usage_logs (
  id TEXT PRIMARY KEY,
  model_id TEXT REFERENCES ai_models(id),
  route_id TEXT REFERENCES ai_routes(id),
  request_type TEXT,                     -- 'chat', 'completion', 'embedding', 'vision'
  prompt_tokens INTEGER,
  completion_tokens INTEGER,
  total_tokens INTEGER,
  estimated_cost REAL,
  latency_ms INTEGER,
  status TEXT,                           -- 'success', 'error', 'timeout'
  error_message TEXT,
  user_id TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- 일별 사용량 집계
CREATE TABLE ai_usage_daily (
  date TEXT NOT NULL,
  model_id TEXT NOT NULL REFERENCES ai_models(id),
  total_requests INTEGER DEFAULT 0,
  total_tokens INTEGER DEFAULT 0,
  total_cost REAL DEFAULT 0,
  success_count INTEGER DEFAULT 0,
  error_count INTEGER DEFAULT 0,
  avg_latency_ms REAL,
  PRIMARY KEY (date, model_id)
);
```

---

## 3. Admin UI 설계

### 3.1 AI Models 탭

```
┌─────────────────────────────────────────────────────────────────┐
│ AI Models                                           [+ Add Model]│
├─────────────────────────────────────────────────────────────────┤
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ Filter: [All Providers ▼] [Enabled Only ☑]  Search: [____] │ │
│ └─────────────────────────────────────────────────────────────┘ │
│                                                                 │
│ ┌───────────────────────────────────────────────────────────┐   │
│ │ 🟢 gpt-4.1                              GitHub Copilot    │   │
│ │ GPT-4.1 via VAS - Primary model for all AI features       │   │
│ │ Context: 128K | Vision: ✓ | Streaming: ✓                  │   │
│ │ Cost: $0.01/1K input, $0.03/1K output                     │   │
│ │ Today: 1,234 requests | 45.2K tokens | $1.35              │   │
│ │                                    [Test] [Edit] [Disable]│   │
│ └───────────────────────────────────────────────────────────┘   │
│                                                                 │
│ ┌───────────────────────────────────────────────────────────┐   │
│ │ 🟢 gemini-1.5-flash                     Google Gemini     │   │
│ │ Fast, cheap fallback model                                │   │
│ │ Context: 1M | Vision: ✓ | Streaming: ✓                    │   │
│ │ Cost: $0.00035/1K input, $0.0014/1K output               │   │
│ │ Today: 89 requests | 12.1K tokens | $0.02                 │   │
│ │                                    [Test] [Edit] [Disable]│   │
│ └───────────────────────────────────────────────────────────┘   │
│                                                                 │
│ ┌───────────────────────────────────────────────────────────┐   │
│ │ 🔴 claude-3.5-sonnet                    Anthropic         │   │
│ │ API Key not configured                                    │   │
│ │                                    [Configure] [Remove]   │   │
│ └───────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 Routing 탭

```
┌─────────────────────────────────────────────────────────────────┐
│ Routing Rules                                      [+ Add Route]│
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ ┌───────────────────────────────────────────────────────────┐   │
│ │ ★ Default Route (Active)                                  │   │
│ │ ┌─────────────────────────────────────────────────────┐   │   │
│ │ │ Strategy: Latency-Based Routing                     │   │   │
│ │ │                                                     │   │   │
│ │ │ Primary: gpt-4.1                                    │   │   │
│ │ │    ↓ (on failure)                                   │   │   │
│ │ │ Fallback 1: gemini-1.5-flash                       │   │   │
│ │ │    ↓ (on failure)                                   │   │   │
│ │ │ Fallback 2: claude-3-haiku                         │   │   │
│ │ │                                                     │   │   │
│ │ │ Retries: 3 | Timeout: 120s                         │   │   │
│ │ └─────────────────────────────────────────────────────┘   │   │
│ │                                           [Edit] [Clone]  │   │
│ └───────────────────────────────────────────────────────────┘   │
│                                                                 │
│ ┌───────────────────────────────────────────────────────────┐   │
│ │ Long Context Route                                        │   │
│ │ For requests > 32K tokens                                 │   │
│ │ Primary: gemini-1.5-pro (1M context)                     │   │
│ │                                [Set as Default] [Edit]    │   │
│ └───────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 Usage & Monitoring 탭

```
┌─────────────────────────────────────────────────────────────────┐
│ Usage & Monitoring                        Period: [Last 7 Days ▼]│
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ Summary                                                     │ │
│ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────────────┐│ │
│ │ │ Requests │ │  Tokens  │ │   Cost   │ │  Avg Latency     ││ │
│ │ │  8,234   │ │  1.2M    │ │  $24.56  │ │    1.2s          ││ │
│ │ │  +12%    │ │  +8%     │ │  +15%    │ │    -0.3s         ││ │
│ │ └──────────┘ └──────────┘ └──────────┘ └──────────────────┘│ │
│ └─────────────────────────────────────────────────────────────┘ │
│                                                                 │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ Usage by Model                                              │ │
│ │ ████████████████████████░░░░░░░░░░ gpt-4.1 (72%)           │ │
│ │ ██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░ gemini-1.5-flash (18%)  │ │
│ │ ███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ claude-3-haiku (10%)    │ │
│ └─────────────────────────────────────────────────────────────┘ │
│                                                                 │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ Daily Trend Chart                                           │ │
│ │     ^                                                       │ │
│ │  2k │    ▄▄                                                │ │
│ │     │  ▄████▄▄    ▄▄                                       │ │
│ │  1k │▄████████▄▄▄████▄▄▄▄                                  │ │
│ │     └────────────────────────────────────────────>         │ │
│ │      Mon  Tue  Wed  Thu  Fri  Sat  Sun                     │ │
│ └─────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. API 설계

### 4.1 Models API

```typescript
// GET /api/v1/admin/ai/models
// 모델 목록 조회
Response: {
  models: [{
    id: string;
    modelName: string;
    displayName: string;
    provider: { id: string; name: string; displayName: string };
    contextWindow: number;
    capabilities: { vision: boolean; streaming: boolean; functionCalling: boolean };
    cost: { inputPer1k: number; outputPer1k: number };
    isEnabled: boolean;
    healthStatus: 'healthy' | 'degraded' | 'down' | 'unknown';
  }]
}

// POST /api/v1/admin/ai/models
// 모델 추가
Request: {
  modelName: string;
  displayName: string;
  providerId: string;
  litellmModel: string;
  contextWindow?: number;
  maxTokens?: number;
  inputCostPer1k?: number;
  outputCostPer1k?: number;
  supportsVision?: boolean;
}

// PUT /api/v1/admin/ai/models/:id
// 모델 수정

// DELETE /api/v1/admin/ai/models/:id
// 모델 삭제

// POST /api/v1/admin/ai/models/:id/test
// 모델 테스트
Request: { prompt?: string }
Response: { success: boolean; latencyMs: number; response?: string; error?: string }
```

### 4.2 Providers API

```typescript
// GET /api/v1/admin/ai/providers
// Provider 목록 조회

// POST /api/v1/admin/ai/providers
// Provider 추가
Request: {
  name: string;           // 'openai', 'anthropic', etc.
  displayName: string;
  apiBaseUrl?: string;
  apiKeyEnv: string;      // 환경변수 이름 (실제 키는 저장하지 않음)
}

// PUT /api/v1/admin/ai/providers/:id/health
// Health check 실행
Response: { status: 'healthy' | 'degraded' | 'down'; latencyMs: number; error?: string }
```

### 4.3 Routes API

```typescript
// GET /api/v1/admin/ai/routes
// 라우팅 규칙 목록

// POST /api/v1/admin/ai/routes
// 라우팅 규칙 추가
Request: {
  name: string;
  routingStrategy: 'simple' | 'latency-based-routing' | 'cost-based-routing';
  primaryModelId: string;
  fallbackModelIds: string[];
  numRetries?: number;
  timeoutSeconds?: number;
  isDefault?: boolean;
}

// POST /api/v1/admin/ai/reload
// LiteLLM 설정 리로드 (DB 기반 설정을 YAML로 변환 후 적용)
```

### 4.4 Usage API

```typescript
// GET /api/v1/admin/ai/usage
// 사용량 조회
Query: { 
  startDate: string;  // ISO date
  endDate: string;
  modelId?: string;
  groupBy?: 'day' | 'model' | 'route';
}
Response: {
  summary: {
    totalRequests: number;
    totalTokens: number;
    totalCost: number;
    avgLatencyMs: number;
  };
  breakdown: [{
    date?: string;
    model?: { id: string; name: string };
    requests: number;
    tokens: number;
    cost: number;
  }]
}
```

---

## 5. 구현 계획

### Phase 1: 기반 구축 (1주)

| 항목 | 설명 |
|------|------|
| DB 스키마 | D1 마이그레이션 파일 작성 |
| Seed 데이터 | 기존 `litellm_config.yaml` 기반 초기 데이터 생성 |
| Backend API | Models, Providers CRUD API 구현 |

### Phase 2: Admin UI (1주)

| 항목 | 설명 |
|------|------|
| Models 탭 | 모델 목록, 추가/수정/삭제, 테스트 기능 |
| Providers 탭 | Provider 관리, Health check |
| 통합 | AdminConfig 페이지에 AI 탭 추가 |

### Phase 3: 라우팅 & 모니터링 (1주)

| 항목 | 설명 |
|------|------|
| Routes 탭 | 라우팅 규칙 관리 UI |
| LiteLLM 연동 | 동적 설정 리로드 API |
| Usage 탭 | 사용량 대시보드, 차트 |

### Phase 4: 고급 기능 (추후)

| 항목 | 설명 |
|------|------|
| 예산 관리 | 일/월별 비용 한도 설정 |
| 알림 | 비용 초과, 장애 알림 (Slack, Email) |
| A/B 테스트 | 모델 성능 비교 테스트 |

---

## 6. 보안 고려사항

1. **API 키 관리**
   - API 키는 데이터베이스에 직접 저장하지 않음
   - 환경변수 이름만 저장하고, 실제 키는 환경변수로 관리
   - Workers Secrets 또는 Backend .env 파일 사용

2. **접근 제어**
   - 모든 `/admin/ai/*` 엔드포인트는 `requireAdmin` 미들웨어 적용
   - JWT 토큰 또는 Bearer 토큰 인증 필수

3. **감사 로그**
   - 모델/Provider 변경 시 감사 로그 기록
   - 설정 변경 이력 추적

---

## 7. 예상 효과

| 항목 | Before | After |
|------|--------|-------|
| 모델 추가 | YAML 수정 → 서비스 재시작 | UI에서 실시간 추가 |
| 비용 추적 | 수동 계산 | 자동 집계 및 대시보드 |
| 장애 대응 | 로그 확인 후 수동 전환 | 자동 fallback + 알림 |
| Provider 전환 | 코드 수정 필요 | UI에서 활성화/비활성화 |

---

## 8. 참고 자료

- [LiteLLM Documentation](https://docs.litellm.ai/)
- [LiteLLM Proxy Config](https://docs.litellm.ai/docs/proxy/configs)
- [LiteLLM Dynamic Config](https://docs.litellm.ai/docs/proxy/config)
- 기존 설정: `backend/litellm_config.yaml`
- AI Service: `backend/src/lib/ai-service.js`

```

### PRD-catalyst-refactor-1102.md

**Path:** `docs/PRD-catalyst-refactor-1102.md`

```markdown
# PRD: AI Chat Bot Image Attachment & Catalyst Unification (1102)

- **Author**: Cascade (AI assistant)
- **Date**: 2025-11-02
- **Status**: Draft / For Review
- **Related initiative**: AI Chat Bot multimodal upgrade & Catalyst inline AI 강화

---

## 1. Background & Problem Statement

We are upgrading the Nodove AI Chat bot to accept user-uploaded images (leveraging GPT-4.1 image understanding) while continuing the Catalyst/Spark refactor. Today:

- Chat widget supports text-only prompts streaming via `/api/v1/chat`, lacking a structured attachment pipeline.
- Catalyst inline helpers still hit legacy `/api/v1/ai/*` routes, creating duplicated logic and uneven telemetry.
- Floating memo and inline tools do not surface a consistent attachment UX, making future reuse harder.

The immediate priority is a production-ready image-attachment workflow for the AI Chat bot, then extending the same infrastructure to Catalyst/Spark so both experiences converge on a unified task API.

## 2. Goals

1. Deliver image attachment support in the AI Chat bot (web) with GPT-4.1 analysis, including upload, preview, and streaming response UX.
2. Reuse the same unified chat task infrastructure for Catalyst/Spark to avoid duplicated fetch logic and to unlock multimodal prompts later.
3. Refresh Catalyst inline UX (non-blocking loader, toast errors) without regressing recently refactored memo layout.
4. Maintain or improve response time, reliability, and telemetry with attachment metadata.

## 3. Non-Goals

- Supporting image editing or drawing (attachments are read-only inputs).
- Changing provider beyond GPT-4.1; prompt tweaks are limited to enabling multimodal context.
- Replacing recently refactored memo layout or history export/import flows.

## 4. Current State Summary

- Chat widget (`ChatWidget.tsx`) consumes `streamChatEvents` for text prompts only; no attachment schema exists.
- `frontend/src/services/chat.ts` now exposes `invokeChatTask` behind the `aiUnified` flag, but callers still pass text payloads.
- Catalyst (`frontend/public/ai-memo/ai-memo.js`) invokes `/api/v1/ai/summarize`; SparkInline (`frontend/src/services/ai.ts`) now routes through `invokeChatTask` when enabled but lacks image awareness.
- Worker/Backend: `/api/v1/chat/session/:id/message` proxied by `workers/src/routes/chat.ts`; `/api/v1/ai/*` routes remain for legacy clients.
- No shared attachment storage or upload policy. Browser drag-drop/upload logic is absent.

## 5. User Stories & Acceptance Criteria

### Story A1 – AI Chat bot image attachments (Priority P0)

- **Role**: blog visitor chatting with GPT-4.1 bot
- **Goal**: upload 1–3 supporting images, receive multimodal responses inline
- **Benefit**: richer answers for visual questions, parity with GPT product expectations

#### Acceptance Criteria (Chat Attachments)

1. Chat composer exposes an “이미지 추가” button and drag-drop zone (desktop + mobile) with thumbnail previews and remove controls.
2. Attachments validate type (`image/png`, `image/jpeg`, `image/webp`) and size (<= 4 MB each); failure surfaces inline error + toast.
3. `invokeChatTask` payload includes `attachments: [{ id, mimeType, dataURL|signedUrl, width, height }]` when flag enabled.
4. Worker proxy forwards attachment metadata (and uploads if required) to the upstream GPT-4.1 gateway.
5. Streaming response UI indicates when image analysis is in progress (e.g., status chip) and falls back gracefully on failure.

### Story C1 – Unified API endpoint for Catalyst & Spark (P1)

- **Role**: developer maintaining AI features
- **Goal**: route Catalyst/Spark requests through the same chat task contract used by the chat bot
- **Benefit**: consistent auth, future multimodal extension, central telemetry

#### Acceptance Criteria (Catalyst & Spark API)

1. SparkInline (`sketch/prism/chain`) and Catalyst run calls use `invokeChatTask` with `mode` + optional `attachments`.
2. Worker `ai.ts` becomes thin shim or is removed; `/api/v1/chat` handles all AI tasks.
3. Shared JSON schema documented (mode, prompt, payload, attachments) and referenced by both frontends.
4. Regression smoke: chat bot + SparkInline + Catalyst succeed under unified flag.

### Story C2 – Catalyst UX modernization (P1)

- **Role**: AI memo user
- **Goal**: experience subtle inline loading and toast-based feedback when Catalyst runs (with optional images later)
- **Benefit**: preserves editing flow, matches new chat UX

#### Acceptance Criteria (Catalyst UX)

1. Catalyst button shows pulse loader and disables duplicate submissions.
2. Toast component displays success/error; no blocking modal.
3. Optional attachments preview reuses chat thumbnail component when available.
4. Busy state keeps memo editable; layout responsive in split/tab modes.

### Story C3 – Observability & telemetry (P1)

- **Role**: product analyst
- **Goal**: measure multimodal usage across chat and Catalyst
- **Benefit**: consistent analytics for product decisions

#### Acceptance Criteria (Telemetry)

1. `logEvent` records `chat_attach_add/remove`, `chat_attach_fail`, `chat_multimodal_response` with payload sizes & latency.
2. Catalyst events log `attachmentsCount` and `attachmentBytes` when present.
3. Worker emits structured logs with request IDs & attachment metadata (no inline image contents).
4. Documentation updated (Notion + repo `docs/metrics.md`).

## 6. Functional Requirements

1. **Attachment ingestion**: client-side compression (<= 2048px longest edge), EXIF strip, and Base64 or Blob upload before task invocation.
2. **API schema**: extend `invokeChatTask` request to include attachments array; update TypeScript types.
3. **Gateway proxy**: worker handles multipart/form-data or signed URL fetch to upstream GPT-4.1 endpoint.
4. **Fallback**: when `aiUnified` flag disabled or browser unsupported, hide attachment UI and continue text-only flow.
5. **Reuse**: Catalyst/Spark adopt same attachment serializer once P0 released.

## 7. UX & Visual Guidelines

- Chat composer: attachment button uses rounded icon button (align with existing send button). Thumbnails appear above input with removable chips.
- Drag-drop overlay: dark translucent sheet with “이미지를 여기에 놓으세요” copy.
- Loading: thumbnail displays spinner overlay until upload completes; send button disabled during upload.
- Chat transcript: first assistant message acknowledges attachments (“첨부 이미지를 분석 중입니다…”).
- Catalyst (future P1): reuses chat thumbnail component inside memo panel; toast copy localized (“이미지 분석 실패” 등).

## 8. Technical Notes

- Prefer Blob URL uploads stored temporarily; convert to Base64 only if upstream requires inline payload.
- Apply rate limiting per session when attachments present (configurable server-side throttle).
- Chat bot UI lives in React app; use Zustand/Context store to manage attachments (clear after send).
- Shadow DOM memo (Catalyst) cannot reuse React components directly; expose lightweight web component variant after P0.
- Ensure CSP headers allow data URLs or signed storage domain for images.

## 9. Analytics / Telemetry

- Record upload latency, file size distribution, and error codes in local events + optional analytics endpoint.
- Instrument worker with structured logs capturing attachment counts & MIME types.
- Generate weekly dashboard slice comparing text-only vs multimodal sessions.

## 10. Dependencies / Risks

- GPT-4.1 endpoint must accept our attachment schema; fallback path required if quota/location issues occur.
- Browser memory usage may spike with large images; need client-side resizing.
- Signed URL storage (if used) introduces storage billing & cleanup policies.
- Feature flag & QA coverage must guard against regression in legacy browsers.

## 11. QA Checklist

- ✅ Chat bot: upload/remove multiple images, mobile safari + chrome.
- ✅ GPT-4.1 response includes image reasoning tokens; fallback message when analysis disabled.
- ✅ Catalyst/Spark text-only flow remains functional behind flag.
- ✅ Dark mode alignment for thumbnails, drag overlay, memo preview.
- ✅ Accessibility: keyboard navigation, screen reader labels for attachments.

## 12. Rollout Plan

1. Implement chat attachments hidden behind `window.__APP_CONFIG.aiUnifiedAttachments`.
2. Internal QA with GPT-4.1 sandbox credentials; monitor logs.
3. Gradual beta rollout (10% traffic) after final load testing.
4. Expand to Catalyst/Spark once chat metrics stable; retire legacy `/api/v1/ai/*` routes.
5. Provide rollback toggle per feature flag.

## 13. Open Questions

1. Will GPT-4.1 respond synchronously with images, or do we need polling for analysis readiness?
2. Should attachments persist in chat history exports/downloads?
3. What retention policy applies to uploaded images on server/storage?
4. How quickly can Catalyst adopt multimodal prompts after chat launch?

---

## Appendix C – Reference Artifacts

- SparkInline component: `frontend/src/components/features/sentio/SparkInline.tsx`
- Chat service client: `frontend/src/services/chat.ts`
- Legacy AI client: `frontend/src/services/ai.ts`
- Worker routes: `workers/src/routes/chat.ts`, `workers/src/routes/ai.ts`
- Floating memo script: `frontend/public/ai-memo/ai-memo.js`

```

### PRD-floating-action-bar.md

**Path:** `docs/PRD-floating-action-bar.md`

```markdown
# PRD: Floating Action Bar (FAB) & History Button UI/UX Improvement

- Version: v1.0 (Final)
- Date: 2025-10-20
- Owner: Blog UX/FE
- Status: Approved & Implementing

## 1) Background / Problem
- Contextless memo buttons are visible even when the memo panel is closed.
- History entry point is inconsistent across pages.
- Multiple floating buttons create visual noise and distract from content.

## 2) Goals
- Tie actions to context (memo actions visible only when memo is open).
- Persistent, consistent History access site‑wide.
- Simplify bottom UI into a single bar.

KPIs: History entry CTR +20%, 0 misclick reports on memo actions, no performance regression (CLS +0, transition 60fps).

## 3) In / Out of Scope
- In: New FAB, persistent History button, contextual visibility, animations, a11y, responsive, instrumentation.
- Out: Memo core logic and History overlay features (graph, search) — unchanged.

## 4) User Scenarios
- Any page: History in the same bottom‑right location.
- When memo opens: contextual memo actions fade‑in on FAB; close → fade‑out.

## 5) Requirements

### 5.1 Unified FAB
- Position: fixed bottom, centered; safe‑area padding; z-index above footer, below modals.
- Style: semi‑transparent background + backdrop blur, rounded, subtle shadow.
- Areas: left/center (memo actions), right (History).
- Always mounted; respects reduced motion.

### 5.2 History Button
- Persistent at FAB right end.
- Responsive label: desktop (md+) icon + “History”; mobile icon‑only with `aria-label`.
- Badge (dot): shown when there are new events since last open; cleared upon opening overlay.
- Opens AI‑memo “Web of Curiosity” overlay.

### 5.3 Contextual Memo Buttons
- Targets: Add selection, Add to graph, AI summary, Catalyst, Download.
- Visibility: hidden by default; shown only when memo panel is open (fade). Disabled with tooltip when no data.
- Keyboard accessible; logical tab order.

## 6) Interaction & Animation
- Use opacity/transform transitions (150–200ms). Respect `prefers-reduced-motion`.
- No focus stealing; restore focus on overlay close.

## 7) Accessibility
- FAB: `role="toolbar"`, labeled groups via `role="group"`.
- AA contrast, keyboard/reader-friendly. `aria-expanded` where applicable.

## 8) Technical
- Feature flag: `VITE_FEATURE_FAB` + runtime override `localStorage['aiMemo.fab.enabled']`.
- Memo state source: AI Memo panel open state from web component (shadowRoot `.panel.open`) + `localStorage['aiMemo.isOpen']`.
- Global mount: in layout (`frontend/src/App.tsx`).
- Styling: Tailwind; `backdrop-filter` support with graceful fallback; iOS safe‑area handled.
- Performance: CSS animations only; minimal JS observers.

## 9) Instrumentation
- Events: `fab_impression`, `fab_history_click`, `fab_memo_*` (add_selection, add_graph, ai_summary, catalyst, download), `fab_error`.

## 10) Responsive / Devices
- Mobile: horizontal scroll if actions overflow; 40px min hit target.
- Desktop: icon+text when space allows; tooltips.
- Print: hidden.

## 11) Edge Cases
- Footer overlap: FAB layered above.
- Third‑party widgets: z‑index tokens to avoid conflicts.
- Safari backdrop support: non‑blur fallback.
- Modal policy: when any site modal opens, FAB hides.

## 12) Rollout
- Phase 0: Off by default; QA via localStorage override.
- Phase 1: Dev on.
- Phase 2: Prod 10% on via env.
- Phase 3: 100% on and remove legacy AI Memo launchers and scattered buttons.
- Rollback: set `VITE_FEATURE_FAB=false` or override localStorage false.

## 13) Risks & Dependencies
- Memo state mismatch ↔ observer+storage handled.
- z-index conflicts ↔ tokens & QA matrix.
- Shadow DOM access stability ↔ fallback via launcher click.

## 14) Decisions (Resolved)
- History label: responsive — desktop icon+text, mobile icon‑only with aria‑label.
- History badge: dot indicator since last open; cleared on overlay open.
- FAB during modal: hidden (do not blur) to avoid focus trap and distraction.
- Legacy buttons removal: at Phase 3 start (immediately upon 100% rollout).

## 15) Acceptance Criteria
- [ ] On load, only History shows in FAB.
- [ ] History visible/working regardless of memo panel state.
- [ ] Opening memo shows memo actions with fade‑in; closing hides with fade‑out.
- [ ] FAB remains fixed on scroll; safe‑area respected; print hidden.
- [ ] Desktop shows icon+text for History; mobile icon‑only with `aria-label`.
- [ ] Badge shows when there are new history events since last open; opening overlay clears it.
- [ ] Any site modal open → FAB hidden; closed → FAB restored.
- [ ] `prefers-reduced-motion`: no animations.
- [ ] CLS 0, perf regression none; transitions 60fps.
- [ ] Instrumentation events fire as specified.

## 16) QA Verification Checklist (PASS/FAIL with evidence)
- **[Layout/Position]** All breakpoints fixed positioning & safe‑area → PASS/FAIL (+screenshots)
- **[Contextual Visibility]** Memo open/close transitions & disabled states → PASS/FAIL (+video/log)
- **[History Badge]** New events increment and clear on open → PASS/FAIL (+steps)
- **[Accessibility]** Keyboard nav, roles/labels, screen reader behavior → PASS/FAIL (+reader log)
- **[Performance]** 60fps transitions, no memory growth → PASS/FAIL (+perf capture)
- **[Browser Matrix]** Chrome/Firefox/Safari/iOS/Android → PASS/FAIL (+notes)
- **[Modal Policy]** With dialog/sheet/alert-dialog open, FAB hidden → PASS/FAIL (+screens)
- **[Instrumentation]** Events visible in analytics or console → PASS/FAIL (+capture)

---

## Implementation Notes
- Component: `frontend/src/components/features/memo/FloatingActionBar.tsx`.
- Integration: `frontend/src/App.tsx` renders FAB globally; hides `VisitedPostsMinimap` when the FAB is enabled to avoid duplicate History triggers.
- AI Memo launchers are hidden when FAB is enabled (Phase 3 will remove legacy codepaths).

```

### PRD-web-of-curiosity.md

**Path:** `docs/PRD-web-of-curiosity.md`

```markdown
# PRD: Web of Curiosity 기능 고도화 및 시각화 개선

본 문서는 사용자의 지적 호기심 경로를 추적·시각화하는 Web of Curiosity 기능의 문제를 해결하고, 실제로 유용한 인사이트를 제공하는 제품으로 발전시키기 위한 요구사항과 구현 계획을 정의합니다.

---

## 1) 개요 및 문제 정의

- 문제 배경: 현재 기능은 사용자의 블로그 내 탐색·학습 경로를 되돌아보게 하는 것을 목표로 하나, 데이터의 의미·시각화·핵심 기능 모두 미흡합니다.
- 핵심 문제점
  1) 무의미한 데이터 수집: 패널 열고 닫기 등 UI 상호작용 중심으로 기록되어 실제 관심사 추적에 도움이 되지 않음.
  2) 비효율적 시각화: 시간 순서로 수평 나열되어 노드 관계를 파악하기 어렵고 스케일에 취약함.
  3) 핵심 컨텍스트 부재: 게시글 방문, 특정 위치의 메모, 태그 클릭, 검색 실행 등 가치 있는 이벤트가 추적되지 않음.

---

## 2) 목표 (Objectives)

- 데이터 품질 향상 (P0): 의미 있는 행동만 선별 수집. 불필요한 UI 이벤트 제외.
- 시각화 직관성 강화 (P0): 선형에서 네트워크형(Force-Directed)으로 전환하여 관계·군집을 직관적으로 표현.
- 기능적 가치 증대 (P1): 게시글·메모·태그·검색 등 핵심 컨텍스트 노드 추가로 복기·인사이트 창출.
- 접근성/성능 (P1): 대량 노드에서도 상호작용 가능한 FPS, 키보드 내비게이션·명확 대비·포커스링 제공.

---

## 3) 사용자 시나리오 (User Stories)

- 독자: 지난 2주간 내가 어떤 주제/태그를 따라가며 무엇을 읽고 메모했는지 한눈에 보고 싶다.
- 작성자: 독자의 탐색 패턴에서 인기 주제/연결을 파악하고 다음 콘텐츠 아이디어를 얻고 싶다.
- 연구자형 사용자: 특정 문제(예: 알고리즘) 학습 과정에서 어떤 포스트들을 순회·재방문했고 어떤 메모를 남겼는지 흐름을 복기하고 싶다.

---

## 4) 범위 (Scope)

- 포함: 프런트엔드 이벤트 수집/로컬 저장, 그래프 시각화 UI, 필터·검색, 내보내기(이미지/JSON), 기본 프라이버시 설정.
- 제외(비범위): 서버 사이드 사용자별 장기 저장·동기화(후속 단계), 계정별 협업 뷰, 추천 알고리즘.

---

## 5) 기능 요구사항 (Functional Requirements)

### FR-1: 이벤트 트래킹 시스템 개선 (P0)
- FR-1.1 추적 대상 이벤트(노드 생성 트리거)
  - 게시글 방문: BlogPost 진입 시 `{type: 'post_view', postId, path, title, tags, ts}`
  - 메모 작성: 특정 포스트/선택범위에서 `{type: 'memo_create', postId, selectionHash, snippet, ts}`
  - 태그 클릭: `{type: 'tag_click', tag, fromPostId?, ts}`
  - 카테고리 선택: `{type: 'category_filter', category, ts}`
  - 검색 실행: `{type: 'search', queryHash, queryText?, ts}` (원문은 기본 비저장, 해시 우선)
- FR-1.2 이벤트 필터링(제외)
  - 패널 열기/닫기, 스크롤, 비컨텐츠 단순 클릭 등 의미 없는 UI 이벤트 제외.
- FR-1.3 이벤트 저장/용량
  - 기본 로컬 우선: `localStorage('curiosity.events')` 또는 IndexedDB(`curiosity-db`) 선택 저장(환경 특성 고려).
  - 최대 이벤트 수: 기본 1,500개(최신 우선 보존, 오래된 항목 드롭). 설정에서 500~5000 범위 조정.
- FR-1.4 개인 정보/보안
  - 민감 데이터 비수집 원칙. 검색어는 해시 보관을 기본값, 원문 저장은 옵트인 토글.
  - 도메인 외부 링크/페이지는 기본 비수집.

### FR-2: 그래프 시각화 알고리즘 변경 (P0)
- FR-2.1 Force-Directed 레이아웃(D3-Force)
  - 링크 기반 인과관계/동시 컨텍스트에 따라 물리 시뮬레이션 적용.
  - 노드 충돌 방지, 군집화(태그/카테고리 기반), 중력·전하 파라미터 노출.
- FR-2.2 노드 시각적 구분
  - 타입별 색상/아이콘: post, memo, tag, category, search.
  - 강조: 최근 N분 내 생성, 재방문 수 상위, 북마크 표시 등.
- FR-2.3 인터랙션
  - Hover 툴팁: 제목/태그/메모 일부·타임스탬프.
  - Click: 포스트 이동, 메모 전체 보기, 태그 필터 적용.
  - 드래그 고정/해제, 확대/이동(Zoom/Pan), 미니맵.
- FR-2.4 접근성
  - 키보드 포커스 가능한 노드/컨트롤, 스크린리더 레이블, 색각보정 팔레트.

### FR-3: 노드 간 연결(Edge) 로직 (P1)
- FR-3.1 컨텍스트 기반 연결
  - post_view → memo_create(같은 postId): post—memo 에지.
  - post_view → tag_click(해당 포스트의 태그): post—tag 에지.
  - search → post_view(검색 결과로 유입 추정 시): search—post 에지.
  - tag_click → post_view(태그 목록에서 유입 추정 시): tag—post 에지.
- FR-3.2 시각적 피드백
  - 방향성/강도 표현(얇기/투명도/애니메이션), 최근 경로 하이라이트, 재생(Timeline scrub).

### FR-4: 필터링·탐색 UI (P1)
- 시간 범위 슬라이더(최근 1일/7일/30일/전체), 타입 토글, 태그 검색, 최소 연결도(차수) 필터.
- 프리셋: “학습 흐름만(포스트+메모)”, “태그 중심 뷰”, “검색에서 시작된 경로”.

### FR-5: 데이터 내보내기/관리 (P1)
- PNG/SVG로 그래프 스냅샷 다운로드, JSON 내보내기/가져오기.
- 데이터 비우기(Reset) 및 백업/복원.

### FR-6: 설정/프라이버시 (P0)
- 옵트인/옵트아웃 토글, 검색 원문 저장 여부, 최대 저장 용량, 데이터 유지기간(기본 90일).
- 간단한 투명성 뷰: 최근 20개 이벤트 원본 미리보기.

---

## 6) 비기능 요구사항 (Non-Functional)

- 성능: 500~1,000 노드/에지에서 상호작용 FPS 30 이상(데스크톱 기준). 모바일 200 노드 내 권장.
- 안정성: 저장 중단/복구 시 손상 방지(배치 커밋, 스키마 버전).
- 보안/프라이버시: 민감정보 비수집, 옵트인 정책 기본, 데이터 삭제/내보내기 투명성.
- 확장성: 후속 서버 동기화/다기기 동기화와 호환되는 이벤트 스키마.

---

## 7) 기술 설계 개요 (Technical Design)

- 이벤트 스키마(예시 JSON)
```json
{
  "id": "evt_1712345678901_abc",
  "type": "post_view | memo_create | tag_click | category_filter | search",
  "ts": 1712345678901,
  "context": {
    "postId": "2025/react-nextjs-modern-web-development",
    "path": "/blog/2025/react-nextjs-modern-web-development",
    "title": "React/Next.js 현대 웹 개발",
    "tags": ["react", "nextjs"],
    "selectionHash": "sha1:...",
    "snippet": "선택된 텍스트 일부 ...",
    "tag": "react",
    "category": "algorithm",
    "queryHash": "sha1:..."
  },
  "meta": {
    "version": 1,
    "ua": "agent-summary-or-omitted",
    "ref": "inferred:search|tag|direct"
  }
}
```

- 저장소 선택
  - 기본: IndexedDB(`curiosity-db.events`) + 메모리 캐시. Fallback: localStorage(`curiosity.events`).
  - 회전 정책: 최대 N개 유지, 오래된 항목 드롭.

- 시각화 스택
  - D3-Force 또는 vis-network. React 래퍼 구성, 캔버스/웹GL 선택적 전환(노드 수에 따라).
  - 레이아웃 파라미터: linkDistance, charge, collision radius, center force를 설정 패널로 노출.

- 에지 생성 규칙
  - 직전 의미 이벤트 간의 인과 에지 + 같은 postId·같은 태그 컨텍스트 에지.
  - 세션 경계(탭/시간) 고려하여 약한 연결로 표기.

- 통합 지점(기존 코드와의 연결)
  - VisitedPostsMinimap/History와 충돌 방지: FAB/오버레이 상태 고려(완료됨).
  - FloatingActionBar 이벤트 브리지: `window.dispatchEvent(new CustomEvent('fab:event', ...))`를 통한 추후 연계 포인트.
  - 기존 `localStorage('aiMemo.events')`는 분리 유지. 새 스키마는 `curiosity.events`/IndexedDB 사용.

---

## 8) UX 흐름 & 와이어프레임(개략)

- 진입: FAB의 History → “Web of Curiosity” 열기.
- 상단 바: 기간 필터, 타입 토글, 검색, 내보내기, 설정 아이콘.
- 메인 캔버스: 네트워크 그래프(미니맵 오른쪽 하단), 툴팁/클릭 액션.
- 하단 타임라인: 재생/일시정지, 스크러브로 경로 재현.

---

## 9) 롤아웃·플래그 (Rollout)

- 기능 플래그: `VITE_FEATURE_CURIOSITY_WEB` + `localStorage('curiosity.web.enabled')`로 제어.
- 단계적 공개: 내부/베타(10%) → 전체. 오류/성능 수집(옵트인)과 핫픽스 경로 확보.

---

## 10) 성공 지표 (Success Metrics)

- 정량
  - UI 상호작용(비의미) 이벤트 생성률 0%.
  - 핵심 노드(포스트/메모/태그/검색) 비중 ≥ 95%.
  - 노드당 평균 연결수 ≥ 1.5 (선형 탈피 지표).
  - 평균 그래프 체류시간/인터랙션(줌/클릭/필터) 증가.
- 정성
  - 사용자 테스트에서 “관심사 흐름 파악에 도움” 응답 ≥ 80%.

---

## 11) 마일스톤 (Milestones)

- Phase 1 (P0, 1~2주)
  - 이벤트 트래커 리팩터링(포스트/태그/검색/메모 생성 후킹)
  - IndexedDB 저장/회전 정책, 내보내기(JSON)
  - 네트워크 레이아웃 MVP + 기본 툴팁/클릭
  - 설정(프라이버시·용량·옵트인)
- Phase 2 (P1, 2~3주)
  - 컨텍스트 에지 규칙·타임라인 재현
  - 필터링·프리셋·미니맵·스냅샷(PNG/SVG)
  - 접근성·성능 최적화(가상화/LOD)

---

## 12) 수용 기준 (Acceptance Criteria)

- 의미 이벤트만 저장되고 UI 이벤트는 기록되지 않는다(유닛·E2E 확인).
- 500 노드·800 에지에서 데스크톱 상호작용 FPS 30+ 유지.
- 타입별 색상/아이콘·툴팁·클릭 내비게이션 작동.
- 기간/타입/태그 필터가 즉시 반영되고, 내보내기(JSON/PNG)가 동작.
- 옵트아웃 시 신규 수집 중단·데이터 삭제 기능 제공.

---

## 13) 리스크 & 완화

- 성능 병목: 대규모 노드 시 WebGL 고려, LOD/클러스터링 도입.
- 프라이버시: 검색 원문 저장은 옵트인, 해시 기본. 도메인 외부는 차단.
- 정확한 인과 추정: referrer/직전 이벤트 기반 휴리스틱 → 설정에서 사용자 제어/수정 지원.

---

## 14) 오픈 이슈

- 서버 동기화/멀티 디바이스 지원 필요 시점과 저장소 설계.
- 추천 기능(그래프 기반 탐색 가이드)의 범위·시기.
- 편집 가능한 노드 메모(후속), 협업(공유) 여부.

```

---

## docs/tasks/catalyst

### tasks-1102.json

**Path:** `docs/tasks/catalyst/tasks-1102.json`

```json
{
  "project": "Catalyst API & UX Refactor",
  "date": "2025-11-02",
  "owner": "frontend+workers",
  "epic": "Catalyst inline AI 강화",
  "tasks": [
    {
      "id": "CAT-1102-001",
      "title": "Unify Catalyst backend route with chat proxy",
      "description": "Remove legacy /api/v1/ai endpoints and expand chat proxy to handle Catalyst payloads with mode metadata.",
      "locations": [
        "workers/src/routes/chat.ts",
        "workers/src/routes/ai.ts",
        "workers/src/index.ts"
      ],
      "acceptance": [
        "Catalyst requests forward through chat proxy with correct headers.",
        "Legacy ai.ts route removed or deprecated behind flag.",
        "Chat widget regression tests pass."
      ]
    },
    {
      "id": "CAT-1102-002",
      "title": "Refactor frontend AI services to shared client",
      "description": "Create shared helper for chat/catalyst tasks, update SparkInline to use new client, and delete unused ai.ts endpoints.",
      "locations": [
        "frontend/src/services/chat.ts",
        "frontend/src/services/ai.ts",
        "frontend/src/components/features/sentio/SparkInline.tsx"
      ],
      "acceptance": [
        "SparkInline sketch/prism/chain call unified helper.",
        "No remaining references to deprecated /api/v1/ai/generate routes.",
        "Types updated and build passes."
      ]
    },
    {
      "id": "CAT-1102-003",
      "title": "Modernize Catalyst UX feedback",
      "description": "Swap modal spinner for inline pulse animation, wire toast-based error handling, and ensure busy state UX meets PRD.",
      "locations": [
        "frontend/public/ai-memo/ai-memo.js",
        "frontend/public/ai-memo/ai-memo.css"
      ],
      "acceptance": [
        "Catalyst button pulses during run and stops afterward.",
        "Success/error messages use toast, no alert dialogs remain.",
        "Memo stays editable while run is in progress."
      ]
    },
    {
      "id": "CAT-1102-004",
      "title": "Implement telemetry for Catalyst unified flow",
      "description": "Log Catalyst invocation, completion, and errors with request timing in front-end and ensure worker logs include identifiers.",
      "locations": [
        "frontend/public/ai-memo/ai-memo.js",
        "frontend/src/components/features/sentio/SparkInline.tsx",
        "workers/src/routes/chat.ts"
      ],
      "acceptance": [
        "logEvent entries include catalyst_invoke / catalyst_error with metadata.",
        "Worker logs include route and request ID fields.",
        "Documentation updated with new telemetry events."
      ]
    },
    {
      "id": "CAT-1102-005",
      "title": "QA unified Catalyst workflow",
      "description": "Run smoke tests for SparkInline, memo Catalyst, and chat to confirm unified API behavior.",
      "locations": ["manual"],
      "acceptance": [
        "SparkInline Sketch/Prism/Chain return expected JSON.",
        "Memo Catalyst run succeeds and handles errors gracefully.",
        "Chat widget unaffected."
      ]
    }
  ],
  "notes": "Coordinate rollout with AI gateway; keep feature flag for quick rollback."
}

```

---

## docs/tasks/chat

### tasks-1102.json

**Path:** `docs/tasks/chat/tasks-1102.json`

```json
{
  "project": "AI Chat Markdown Rendering Refresh",
  "date": "2025-11-02",
  "owner": "frontend",
  "epic": "AI Chat UI/UX 개선",
  "tasks": [
    {
      "id": "CHAT-1102-001",
      "title": "Introduce Markdown renderer into ChatWidget assistant messages",
      "description": "Wrap assistant responses with a Markdown rendering component that supports GFM, syntax highlighting, and scoped styling without affecting user bubbles.",
      "locations": [
        "frontend/src/components/features/chat/ChatWidget.tsx",
        "frontend/src/components/features/blog/MarkdownRenderer.tsx"
      ],
      "dependencies": ["MarkdownRenderer component", "react-markdown", "remark-gfm"],
      "acceptance": [
        "Assistant messages render Markdown elements (code blocks, inline code, lists, emphasis, links).",
        "Code blocks display one-dark syntax highlighting with copy button.",
        "Non-assistant bubbles retain current styling."
      ]
    },
    {
      "id": "CHAT-1102-002",
      "title": "Scope Markdown styles to chat assistant bubble",
      "description": "Add chat-specific wrappers or classes so prose typography applies only inside assistant responses and remains responsive on mobile.",
      "locations": [
        "frontend/src/components/features/chat/ChatWidget.tsx"
      ],
      "acceptance": [
        "Markdown styles are contained within assistant bubble wrapper.",
        "Layouts and spacing unchanged for user/system messages.",
        "Dark mode verified for code blocks and links."
      ]
    },
    {
      "id": "CHAT-1102-003",
      "title": "Optimize streaming rendering performance",
      "description": "Ensure incremental Markdown parsing during streaming does not cause jitter; optionally throttle renders or reuse memoized component state.",
      "locations": [
        "frontend/src/components/features/chat/ChatWidget.tsx"
      ],
      "acceptance": [
        "Streaming responses display progressively without layout thrash.",
        "Large code blocks remain scrollable within bubble.",
        "Unit/regression tests updated or added." ]
    },
    {
      "id": "CHAT-1102-004",
      "title": "QA & regression checklist",
      "description": "Execute the QA checklist defined in PRD (Markdown coverage, streaming, mobile, sources/followups).",
      "locations": ["manual"],
      "acceptance": [
        "QA checklist items validated and documented.",
        "No regressions found in chat persistence or follow-up buttons."
      ]
    }
  ],
  "notes": "Keep copy button mobile-friendly; consider future table support if needed."
}

```

---

## docs/tasks/memo

### tasks-1102.json

**Path:** `docs/tasks/memo/tasks-1102.json`

```json
{
  "project": "Floating AI Memo UX Revamp",
  "date": "2025-11-02",
  "owner": "frontend",
  "epic": "떠다니는 AI 메모 개선",
  "tasks": [
    {
      "id": "MEMO-1102-001",
      "title": "Implement memo layout mode state machine",
      "description": "Introduce persisted layout modes (split-horizontal, tabbed) and initialize from localStorage or viewport.",
      "locations": [
        "frontend/public/ai-memo/ai-memo.js"
      ],
      "acceptance": [
        "Layout mode toggles update Shadow DOM classes appropriately.",
        "Selected mode persists across reloads via localStorage.",
        "Fullscreen memo mode continues working."
      ]
    },
    {
      "id": "MEMO-1102-002",
      "title": "Update memo CSS for horizontal split and responsive behavior",
      "description": "Refine `.split` styles so desktop uses horizontal panes with balanced widths and mobile stacks vertically.",
      "locations": [
        "frontend/public/ai-memo/ai-memo.css"
      ],
      "acceptance": [
        "Desktop shows side-by-side editor/preview with independent scrolling.",
        "Mobile breakpoint (<640px) stacks panes and hides toggle if needed.",
        "Spacing and divider styles match PRD guidance."
      ]
    },
    {
      "id": "MEMO-1102-003",
      "title": "Add layout toggle control UI",
      "description": "Insert toggle buttons near memo tabs to switch between split and tab modes with clear affordance.",
      "locations": [
        "frontend/public/ai-memo/ai-memo.js",
        "frontend/public/ai-memo/ai-memo.css"
      ],
      "acceptance": [
        "Toggle buttons reflect current layout and are keyboard-accessible.",
        "State changes emit telemetry via logEvent.",
        "UI adapts for mobile (toggle hidden or repositioned)."
      ]
    },
    {
      "id": "MEMO-1102-004",
      "title": "Polish Catalyst prompt UX",
      "description": "Replace modal spinner with inline pulsing icon, disable inputs during run, and surface toast-based messaging.",
      "locations": [
        "frontend/public/ai-memo/ai-memo.js",
        "frontend/public/ai-memo/ai-memo.css"
      ],
      "acceptance": [
        "Catalyst invoke shows pulsing icon and keeps memo usable.",
        "Success and error toasts replace alert dialogs.",
        "Busy state prevents duplicate submissions but clears correctly afterward."
      ]
    },
    {
      "id": "MEMO-1102-005",
      "title": "Execute memo UX QA checklist",
      "description": "Validate desktop split, tab persistence, mobile stacking, and Catalyst feedback per PRD.",
      "locations": ["manual"],
      "acceptance": [
        "QA evidence recorded for all checklist items.",
        "No regressions in memo drag, fullscreen, or history overlay."
      ]
    }
  ],
  "notes": "Consider optional vertical split removal based on open questions; evaluate resizable divider as stretch goal."
}

```

---

## docs/tasks/terminal

### PRD-docker-terminal-cloudflare.md

**Path:** `docs/tasks/terminal/PRD-docker-terminal-cloudflare.md`

```markdown
# Docker Terminal via Cloudflare Tunnel - Implementation Plan

## 1. Architecture Overview

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                              USER'S BROWSER                                   │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  FloatingActionBar.tsx (Shell Commander)                                 │ │
│  │  - 현재: 가상 파일시스템 (VFS)                                            │ │
│  │  - 확장: xterm.js WebSocket 연결                                         │ │
│  │  - 모드 전환: "local" (VFS) ↔ "docker" (실제 컨테이너)                    │ │
│  └────────────────────────────────┬────────────────────────────────────────┘ │
└───────────────────────────────────┼──────────────────────────────────────────┘
                                    │ wss://terminal.nodove.com
                                    ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                     CLOUDFLARE WORKERS (Security Gateway)                     │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  workers/terminal-gateway/                                               │ │
│  │  ┌─────────────┐  ┌──────────────┐  ┌─────────────────┐                 │ │
│  │  │ Auth Layer  │→ │ Rate Limiter │→ │ Secret Injector │                 │ │
│  │  │ (JWT/Token) │  │ (KV-based)   │  │ (X-Origin-Key)  │                 │ │
│  │  └─────────────┘  └──────────────┘  └────────┬────────┘                 │ │
│  └──────────────────────────────────────────────┼──────────────────────────┘ │
└─────────────────────────────────────────────────┼────────────────────────────┘
                                                  │ Cloudflare Tunnel
                                                  ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                         ORIGIN SERVER (Home/VPS)                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  backend/terminal-server/ (Node.js + ws + node-pty)                      │ │
│  │  - Secret Key 검증                                                       │ │
│  │  - Docker 컨테이너 생성/관리                                              │ │
│  │  - WebSocket ↔ PTY 브릿지                                                │ │
│  └────────────────────────────────┬────────────────────────────────────────┘ │
│                                   │ docker run                               │
│                                   ▼                                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Sandboxed Container (per user session)                                  │ │
│  │  - Alpine Linux                                                          │ │
│  │  - --network none (외부 접근 차단)                                        │ │
│  │  - --cpus 0.5 --memory 128m (리소스 제한)                                │ │
│  │  - 10분 타임아웃 후 자동 삭제                                             │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. Implementation Phases

### Phase 1: Cloudflare Infrastructure Setup
**Cloudflare MCP로 확인/생성할 리소스**

| Resource | Purpose | MCP Command |
|----------|---------|-------------|
| Workers KV | Rate limiting, session tracking | `kv_namespace_create` |
| Durable Objects | WebSocket 세션 관리 (Optional) | Workers 코드에서 선언 |
| Tunnel | Origin 연결 | `cloudflared tunnel create` (CLI) |
| DNS Record | terminal.nodove.com | `dns_record_create` |

**체크리스트:**
- [ ] 기존 KV namespace 확인 (`blog-kv`)
- [ ] 새 tunnel 생성 여부 (기존 `blog-api` 재사용 가능)
- [ ] DNS 레코드 추가: `terminal.nodove.com` → Tunnel

### Phase 2: Terminal Gateway Worker
**파일 구조:**
```
workers/
├── terminal-gateway/
│   ├── src/
│   │   ├── index.ts          # WebSocket 업그레이드 핸들링
│   │   ├── auth.ts           # JWT/토큰 검증
│   │   ├── ratelimit.ts      # KV 기반 속도 제한
│   │   └── types.ts
│   ├── wrangler.toml
│   └── package.json
```

**핵심 코드 (index.ts):**
```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // 1. WebSocket 업그레이드 요청 확인
    const upgradeHeader = request.headers.get('Upgrade');
    if (upgradeHeader !== 'websocket') {
      return new Response('Expected WebSocket', { status: 426 });
    }

    // 2. 인증 (쿼리 파라미터 또는 쿠키에서 토큰)
    const url = new URL(request.url);
    const token = url.searchParams.get('token');
    const user = await verifyToken(token, env);
    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    // 3. Rate Limiting
    const clientIP = request.headers.get('CF-Connecting-IP') || 'unknown';
    const rateLimitOk = await checkRateLimit(clientIP, env.KV);
    if (!rateLimitOk) {
      return new Response('Too Many Requests', { status: 429 });
    }

    // 4. Origin으로 프록시 (Secret Key 주입)
    const originUrl = `${env.TERMINAL_ORIGIN}/terminal`;
    const originRequest = new Request(originUrl, request);
    originRequest.headers.set('X-Origin-Secret', env.ORIGIN_SECRET_KEY);
    originRequest.headers.set('X-User-ID', user.id);
    originRequest.headers.set('X-Client-IP', clientIP);

    return fetch(originRequest);
  }
};
```

### Phase 3: Origin Terminal Server
**파일 구조:**
```
backend/
├── terminal-server/
│   ├── src/
│   │   ├── index.ts          # HTTP + WebSocket 서버
│   │   ├── docker.ts         # Docker 컨테이너 관리
│   │   ├── pty-bridge.ts     # node-pty ↔ WebSocket
│   │   └── session.ts        # 세션 타임아웃 관리
│   ├── Dockerfile            # 서버용 (node-pty 빌드 필요)
│   ├── sandbox/
│   │   └── Dockerfile        # 사용자 컨테이너 이미지
│   └── package.json
```

**핵심 코드 (index.ts):**
```typescript
import { WebSocketServer } from 'ws';
import { spawn } from 'node-pty';
import http from 'http';

const EXPECTED_SECRET = process.env.ORIGIN_SECRET_KEY;
const SESSION_TIMEOUT = 10 * 60 * 1000; // 10분

const server = http.createServer();
const wss = new WebSocketServer({ noServer: true });

server.on('upgrade', (req, socket, head) => {
  // Secret 검증
  const secret = req.headers['x-origin-secret'];
  if (secret !== EXPECTED_SECRET) {
    socket.write('HTTP/1.1 401 Unauthorized\r\n\r\n');
    socket.destroy();
    return;
  }

  wss.handleUpgrade(req, socket, head, (ws) => {
    wss.emit('connection', ws, req);
  });
});

wss.on('connection', (ws, req) => {
  const userId = req.headers['x-user-id'] as string;
  
  // Docker 컨테이너 생성
  const containerName = `terminal-${userId}-${Date.now()}`;
  const term = spawn('docker', [
    'run', '-it', '--rm',
    '--name', containerName,
    '--network', 'none',
    '--cpus', '0.5',
    '--memory', '128m',
    '--pids-limit', '50',
    'blog-terminal-sandbox', '/bin/sh'
  ], {
    name: 'xterm-256color',
    cols: 80,
    rows: 24,
  });

  // 타임아웃 설정
  const timeout = setTimeout(() => {
    ws.send('\r\n\x1b[31m[Session timeout - disconnecting...]\x1b[0m\r\n');
    term.kill();
    ws.close();
  }, SESSION_TIMEOUT);

  // 양방향 데이터 파이프
  term.onData((data) => ws.send(data));
  ws.on('message', (msg) => term.write(msg.toString()));

  ws.on('close', () => {
    clearTimeout(timeout);
    term.kill();
    // 컨테이너 강제 삭제 (혹시 남아있으면)
    spawn('docker', ['rm', '-f', containerName]);
  });
});

server.listen(8080);
```

### Phase 4: Frontend Integration
**기존 FloatingActionBar.tsx 확장:**

```typescript
// 새 모드 추가
type ShellMode = 'local' | 'docker';

// xterm.js 통합 훅
function useDockerTerminal(enabled: boolean) {
  const terminalRef = useRef<HTMLDivElement>(null);
  const xtermRef = useRef<Terminal | null>(null);
  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    if (!enabled || !terminalRef.current) return;

    const terminal = new Terminal({
      cursorBlink: true,
      theme: {
        background: '#1a1a2e',
        foreground: '#eee',
        cursor: '#0ff',
      },
    });
    terminal.open(terminalRef.current);
    xtermRef.current = terminal;

    // WebSocket 연결
    const token = getAuthToken(); // 인증 토큰 가져오기
    const ws = new WebSocket(`wss://terminal.nodove.com?token=${token}`);
    wsRef.current = ws;

    ws.onmessage = (e) => terminal.write(e.data);
    terminal.onData((data) => ws.send(data));

    return () => {
      ws.close();
      terminal.dispose();
    };
  }, [enabled]);

  return { terminalRef };
}
```

### Phase 5: Cloudflare Tunnel Configuration
**업데이트된 `cloudflared-config.yml`:**

```yaml
tunnel: blog-api  # 기존 터널 재사용

ingress:
  # 기존 서비스들...
  - hostname: tei.yourdomain.com
    service: http://embedding-server:80
  - hostname: api.yourdomain.com
    service: http://opencode-serve:7012

  # 새 터미널 서비스
  - hostname: terminal.nodove.com
    service: http://localhost:8080
    originRequest:
      noTLSVerify: true
      # WebSocket 지원 활성화
      http2Origin: false
      connectTimeout: 30s
      noHappyEyeballs: true

  - service: http_status:404
```

---

## 3. Security Measures

### 3.1 Worker Level (Cloudflare)
| Layer | Implementation |
|-------|----------------|
| **Authentication** | JWT 토큰 검증 (blog-api와 동일한 secret 사용) |
| **Rate Limiting** | IP당 분당 5개 연결, 동시 1개 세션 |
| **Geo-Blocking** | (선택) 특정 국가 차단 |
| **Bot Detection** | CF Bot Management score 활용 |

### 3.2 Origin Level (Node.js)
| Layer | Implementation |
|-------|----------------|
| **Secret Verification** | X-Origin-Secret 헤더 필수 |
| **Session Limit** | 사용자당 1개 세션 |
| **Container Isolation** | --network none, 리소스 제한 |
| **Timeout** | 10분 자동 종료 |

### 3.3 Container Level (Docker)
| Restriction | Flag |
|-------------|------|
| 네트워크 차단 | `--network none` |
| CPU 제한 | `--cpus 0.5` |
| 메모리 제한 | `--memory 128m` |
| 프로세스 제한 | `--pids-limit 50` |
| 읽기 전용 rootfs | `--read-only` (선택) |
| non-root 사용자 | `USER nobody` in Dockerfile |

---

## 4. Cloudflare MCP Verification Steps

### Step 1: 현재 리소스 확인
```bash
# MCP를 통해 실행 (opencode에서)
# 또는 wrangler CLI 직접 사용

# KV 네임스페이스 목록
wrangler kv:namespace list

# 현재 Workers 목록  
wrangler deployments list

# Tunnel 목록
cloudflared tunnel list
```

### Step 2: 필요한 리소스 생성
```bash
# 1. Terminal Gateway Worker용 KV (rate limiting)
wrangler kv:namespace create "TERMINAL_SESSIONS"

# 2. DNS 레코드 (Cloudflare Dashboard 또는 API)
# terminal.nodove.com -> CNAME -> <tunnel-id>.cfargotunnel.com

# 3. Tunnel 설정 업데이트
# cloudflared-config.yml에 terminal hostname 추가 후
cloudflared tunnel ingress update
```

### Step 3: Secrets 설정
```bash
# Terminal Gateway Worker에 secrets 추가
cd workers/terminal-gateway
wrangler secret put ORIGIN_SECRET_KEY
wrangler secret put JWT_SECRET
```

---

## 5. File Structure (Final)

```
blog-1120/
├── workers/
│   ├── terminal-gateway/          # NEW: WebSocket 게이트웨이
│   │   ├── src/
│   │   │   ├── index.ts
│   │   │   ├── auth.ts
│   │   │   └── ratelimit.ts
│   │   ├── wrangler.toml
│   │   └── package.json
│   └── ... (기존 workers)
│
├── backend/
│   ├── terminal-server/           # NEW: Origin 터미널 서버
│   │   ├── src/
│   │   │   ├── index.ts
│   │   │   ├── docker.ts
│   │   │   └── pty-bridge.ts
│   │   ├── Dockerfile
│   │   ├── sandbox/
│   │   │   └── Dockerfile         # 샌드박스 컨테이너 이미지
│   │   └── package.json
│   ├── deploy/
│   │   └── cloudflared-config.yml # UPDATED: terminal hostname 추가
│   └── ... (기존 backend)
│
└── frontend/
    └── src/
        └── components/
            └── features/
                └── terminal/      # NEW: xterm.js 통합
                    ├── DockerTerminal.tsx
                    └── useDockerTerminal.ts
```

---

## 6. Implementation Checklist

### Cloudflare Setup
- [ ] KV namespace 생성 (TERMINAL_SESSIONS)
- [ ] DNS 레코드 추가 (terminal.nodove.com)
- [ ] Tunnel ingress 설정 업데이트
- [ ] Worker secrets 설정

### Worker Development
- [ ] terminal-gateway Worker 생성
- [ ] JWT 인증 로직 구현
- [ ] Rate limiting 구현
- [ ] WebSocket 프록시 로직

### Origin Server Development  
- [ ] terminal-server Node.js 앱 생성
- [ ] Docker 컨테이너 관리 로직
- [ ] node-pty 통합
- [ ] 세션 타임아웃 관리
- [ ] Sandbox Dockerfile 작성

### Frontend Integration
- [ ] xterm.js 패키지 추가
- [ ] DockerTerminal 컴포넌트 생성
- [ ] FloatingActionBar에 모드 전환 UI 추가
- [ ] 연결 상태 표시 (connecting/connected/disconnected)

### Deployment
- [ ] Sandbox 이미지 빌드 및 Origin에 배포
- [ ] terminal-server 시스템 서비스 등록
- [ ] cloudflared tunnel 재시작
- [ ] terminal-gateway Worker 배포
- [ ] E2E 테스트

---

## 7. Estimated Timeline

| Phase | Duration | Dependencies |
|-------|----------|--------------|
| Phase 1: Cloudflare Setup | 1-2 hours | Cloudflare 계정 접근 |
| Phase 2: Gateway Worker | 3-4 hours | Phase 1 완료 |
| Phase 3: Origin Server | 4-6 hours | Docker 환경 |
| Phase 4: Frontend | 2-3 hours | Phase 2, 3 완료 |
| Phase 5: Tunnel Config | 1 hour | cloudflared 설치됨 |
| Testing & Debug | 2-4 hours | 전체 완료 |

**Total: ~15-20 hours**

---

## 8. Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Container escape | AppArmor/seccomp 프로파일 적용 |
| Resource exhaustion | Cgroup 제한 + 자동 정리 cron |
| WebSocket 연결 끊김 | Heartbeat + 자동 재연결 |
| Origin 서버 다운 | Cloudflare에서 503 반환, 프론트엔드에서 우아한 폴백 |

```

---

## frontend

### Dockerfile

**Path:** `frontend/Dockerfile`

```dockerfile
# =============================================================================
# Frontend Dockerfile - Multi-stage build for production
# =============================================================================
# Build Args:
#   - VITE_API_BASE_URL: API endpoint URL (default: https://blog-test.nodove.com)
#   - VITE_SITE_BASE_URL: Site base URL for SEO (default: https://blog-test.nodove.com)
#
# Usage:
#   docker build --build-arg VITE_API_BASE_URL=https://blog-test.nodove.com -t blog-frontend .
# =============================================================================

# -----------------------------------------------------------------------------
# Stage 1: Build
# -----------------------------------------------------------------------------
FROM node:20-alpine AS builder

WORKDIR /app

# Build arguments for environment variables
ARG VITE_API_BASE_URL=https://blog-test.nodove.com
ARG VITE_SITE_BASE_URL=https://blog-test.nodove.com

# Set environment variables for build
ENV VITE_API_BASE_URL=${VITE_API_BASE_URL}
ENV VITE_SITE_BASE_URL=${VITE_SITE_BASE_URL}

# Copy package files
COPY package.json package-lock.json* ./

# Install all dependencies (including devDependencies for build)
RUN npm ci

# Copy source files
COPY . .

# Build the application
RUN npm run build

# -----------------------------------------------------------------------------
# Stage 2: Production
# -----------------------------------------------------------------------------
FROM nginx:alpine AS production

# Copy custom nginx configuration
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Copy built assets from builder stage
COPY --from=builder /app/dist /usr/share/nginx/html

# Expose port 80
EXPOSE 80

# Health check
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
  CMD wget -q --spider http://localhost/ || exit 1

CMD ["nginx", "-g", "daemon off;"]

```

### e2e-test.mjs

**Path:** `frontend/e2e-test.mjs`

```javascript
#!/usr/bin/env node
/**
 * E2E Test Script using Playwright
 * Tests all major features of the blog frontend
 */

import { chromium } from 'playwright';

const BASE_URL = 'http://localhost:8080';

// Test results collector
const results = [];
function log(status, test, message = '') {
  const icon = status === 'PASS' ? '\x1b[32m✓\x1b[0m' : status === 'FAIL' ? '\x1b[31m✗\x1b[0m' : '\x1b[33m⚠\x1b[0m';
  console.log(`${icon} ${test}${message ? `: ${message}` : ''}`);
  results.push({ status, test, message });
}

async function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function runTests() {
  console.log('\n\x1b[36m=== E2E Tests Starting ===\x1b[0m\n');
  console.log(`Base URL: ${BASE_URL}\n`);

  const browser = await chromium.launch({ 
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  
  const context = await browser.newContext({
    viewport: { width: 1280, height: 800 },
    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) E2E-Test'
  });
  
  const page = await context.newPage();

  try {
    // ========================================
    // 1. Home Page (Index)
    // ========================================
    console.log('\x1b[34m--- Home Page Tests ---\x1b[0m');
    
    try {
      await page.goto(BASE_URL, { waitUntil: 'networkidle', timeout: 30000 });
      log('PASS', 'Home page loads');
    } catch (e) {
      log('FAIL', 'Home page loads', e.message);
    }

    // Check header exists
    try {
      const header = await page.locator('header').first();
      await header.waitFor({ state: 'visible', timeout: 5000 });
      log('PASS', 'Header is visible');
    } catch (e) {
      log('FAIL', 'Header is visible', e.message);
    }

    // Check footer exists
    try {
      const footer = await page.locator('footer').first();
      await footer.waitFor({ state: 'attached', timeout: 5000 });
      log('PASS', 'Footer is present');
    } catch (e) {
      log('FAIL', 'Footer is present', e.message);
    }

    // ========================================
    // 2. Blog Page
    // ========================================
    console.log('\n\x1b[34m--- Blog Page Tests ---\x1b[0m');
    
    try {
      await page.goto(`${BASE_URL}/#/blog`, { waitUntil: 'networkidle', timeout: 30000 });
      await wait(1000);
      log('PASS', 'Blog page loads');
    } catch (e) {
      log('FAIL', 'Blog page loads', e.message);
    }

    // Check for blog posts list
    try {
      // Wait for some content to appear
      await page.waitForSelector('main', { timeout: 5000 });
      const mainContent = await page.locator('main').textContent();
      if (mainContent && mainContent.length > 50) {
        log('PASS', 'Blog page has content');
      } else {
        log('WARN', 'Blog page has content', 'Content seems minimal');
      }
    } catch (e) {
      log('FAIL', 'Blog page has content', e.message);
    }

    // ========================================
    // 3. Blog Post Page
    // ========================================
    console.log('\n\x1b[34m--- Blog Post Tests ---\x1b[0m');
    
    try {
      // Navigate to a specific post (using common test post)
      await page.goto(`${BASE_URL}/#/blog/2025/latest`, { waitUntil: 'networkidle', timeout: 30000 });
      await wait(1500);
      
      // Check if post content loaded
      const article = await page.locator('article, main').first();
      await article.waitFor({ state: 'visible', timeout: 5000 });
      log('PASS', 'Blog post page loads');
    } catch (e) {
      log('FAIL', 'Blog post page loads', e.message);
    }

    // ========================================
    // 4. About Page
    // ========================================
    console.log('\n\x1b[34m--- About Page Tests ---\x1b[0m');
    
    try {
      await page.goto(`${BASE_URL}/#/about`, { waitUntil: 'networkidle', timeout: 30000 });
      await wait(1000);
      log('PASS', 'About page loads');
    } catch (e) {
      log('FAIL', 'About page loads', e.message);
    }

    // ========================================
    // 5. Contact Page
    // ========================================
    console.log('\n\x1b[34m--- Contact Page Tests ---\x1b[0m');
    
    try {
      await page.goto(`${BASE_URL}/#/contact`, { waitUntil: 'networkidle', timeout: 30000 });
      await wait(1000);
      log('PASS', 'Contact page loads');
    } catch (e) {
      log('FAIL', 'Contact page loads', e.message);
    }

    // ========================================
    // 6. Insight Page
    // ========================================
    console.log('\n\x1b[34m--- Insight Page Tests ---\x1b[0m');
    
    try {
      await page.goto(`${BASE_URL}/#/insight`, { waitUntil: 'networkidle', timeout: 30000 });
      await wait(1500);
      log('PASS', 'Insight page loads');
    } catch (e) {
      log('FAIL', 'Insight page loads', e.message);
    }

    // ========================================
    // 7. Floating Action Bar (FAB)
    // ========================================
    console.log('\n\x1b[34m--- Floating Action Bar Tests ---\x1b[0m');
    
    // Go back to home for FAB tests
    await page.goto(BASE_URL, { waitUntil: 'networkidle', timeout: 30000 });
    await wait(1000);
    
    // Check FAB toolbar exists
    try {
      const fabToolbar = await page.locator('[role="toolbar"][aria-label="Floating actions"]').first();
      await fabToolbar.waitFor({ state: 'visible', timeout: 5000 });
      log('PASS', 'FAB toolbar is visible');
    } catch (e) {
      log('WARN', 'FAB toolbar is visible', 'FAB may be disabled or hidden');
    }

    // Test Chat button
    try {
      const chatButton = await page.locator('button[aria-label="Chat"]').first();
      if (await chatButton.isVisible()) {
        await chatButton.click();
        await wait(500);
        
        // Check if chat widget opened (look for chat-related elements)
        const chatWidget = await page.locator('[class*="chat"], [class*="Chat"]').first();
        await chatWidget.waitFor({ state: 'visible', timeout: 3000 });
        log('PASS', 'Chat widget opens');
        
        // Close chat if possible
        const closeButton = await page.locator('button[aria-label*="close" i], button[aria-label*="Close" i]').first();
        if (await closeButton.isVisible()) {
          await closeButton.click();
          await wait(500);
        }
      } else {
        log('WARN', 'Chat widget opens', 'Chat button not visible');
      }
    } catch (e) {
      log('WARN', 'Chat widget opens', e.message);
    }

    // ========================================
    // 8. Theme Toggle
    // ========================================
    console.log('\n\x1b[34m--- Theme Tests ---\x1b[0m');
    
    try {
      // Look for theme toggle button in header
      const themeButton = await page.locator('button[aria-label*="theme" i], button[aria-label*="Theme" i], button[aria-label*="mode" i]').first();
      if (await themeButton.isVisible()) {
        const initialClasses = await page.locator('html').getAttribute('class');
        await themeButton.click();
        await wait(500);
        const newClasses = await page.locator('html').getAttribute('class');
        
        if (initialClasses !== newClasses) {
          log('PASS', 'Theme toggle works');
        } else {
          log('WARN', 'Theme toggle works', 'Classes did not change');
        }
      } else {
        log('WARN', 'Theme toggle works', 'Theme button not found');
      }
    } catch (e) {
      log('WARN', 'Theme toggle works', e.message);
    }

    // ========================================
    // 9. Navigation
    // ========================================
    console.log('\n\x1b[34m--- Navigation Tests ---\x1b[0m');
    
    try {
      // Test navigation links in header
      const navLinks = await page.locator('header nav a, header a').all();
      if (navLinks.length > 0) {
        log('PASS', 'Navigation links exist', `Found ${navLinks.length} links`);
      } else {
        log('WARN', 'Navigation links exist', 'No nav links found');
      }
    } catch (e) {
      log('FAIL', 'Navigation links exist', e.message);
    }

    // ========================================
    // 10. 404 Page
    // ========================================
    console.log('\n\x1b[34m--- 404 Page Tests ---\x1b[0m');
    
    try {
      await page.goto(`${BASE_URL}/#/non-existent-page-12345`, { waitUntil: 'networkidle', timeout: 30000 });
      await wait(1000);
      
      const pageContent = await page.locator('main').first().textContent();
      if (pageContent && (pageContent.includes('404') || pageContent.toLowerCase().includes('not found'))) {
        log('PASS', '404 page shows correctly');
      } else {
        log('WARN', '404 page shows correctly', 'Page loaded but 404 message not found');
      }
    } catch (e) {
      log('FAIL', '404 page shows correctly', e.message);
    }

    // ========================================
    // 11. Responsive Check (Mobile)
    // ========================================
    console.log('\n\x1b[34m--- Mobile Responsive Tests ---\x1b[0m');
    
    try {
      await page.setViewportSize({ width: 375, height: 667 }); // iPhone SE size
      await page.goto(BASE_URL, { waitUntil: 'networkidle', timeout: 30000 });
      await wait(1000);
      
      // Check if content is still visible
      const mainContent = await page.locator('main').first();
      await mainContent.waitFor({ state: 'visible', timeout: 5000 });
      log('PASS', 'Mobile viewport renders');
    } catch (e) {
      log('FAIL', 'Mobile viewport renders', e.message);
    }

    // Reset viewport
    await page.setViewportSize({ width: 1280, height: 800 });

    // ========================================
    // 12. Performance Check
    // ========================================
    console.log('\n\x1b[34m--- Performance Tests ---\x1b[0m');
    
    try {
      const startTime = Date.now();
      await page.goto(BASE_URL, { waitUntil: 'domcontentloaded', timeout: 30000 });
      const loadTime = Date.now() - startTime;
      
      if (loadTime < 3000) {
        log('PASS', 'Page load time', `${loadTime}ms`);
      } else if (loadTime < 5000) {
        log('WARN', 'Page load time', `${loadTime}ms (slow)`);
      } else {
        log('FAIL', 'Page load time', `${loadTime}ms (too slow)`);
      }
    } catch (e) {
      log('FAIL', 'Page load time', e.message);
    }

    // ========================================
    // 13. Console Errors Check
    // ========================================
    console.log('\n\x1b[34m--- Console Errors Check ---\x1b[0m');
    
    const consoleErrors = [];
    page.on('console', msg => {
      if (msg.type() === 'error') {
        consoleErrors.push(msg.text());
      }
    });
    
    await page.goto(BASE_URL, { waitUntil: 'networkidle', timeout: 30000 });
    await wait(2000);
    
    if (consoleErrors.length === 0) {
      log('PASS', 'No console errors');
    } else {
      log('WARN', 'Console errors found', `${consoleErrors.length} errors`);
      consoleErrors.slice(0, 3).forEach(err => console.log(`   - ${err.slice(0, 100)}`));
    }

  } catch (error) {
    console.error('\n\x1b[31mTest execution error:\x1b[0m', error.message);
  } finally {
    await browser.close();
  }

  // ========================================
  // Summary
  // ========================================
  console.log('\n\x1b[36m=== Test Summary ===\x1b[0m\n');
  
  const passed = results.filter(r => r.status === 'PASS').length;
  const failed = results.filter(r => r.status === 'FAIL').length;
  const warned = results.filter(r => r.status === 'WARN').length;
  
  console.log(`\x1b[32m  Passed: ${passed}\x1b[0m`);
  console.log(`\x1b[31m  Failed: ${failed}\x1b[0m`);
  console.log(`\x1b[33m  Warnings: ${warned}\x1b[0m`);
  console.log(`  Total: ${results.length}\n`);

  if (failed > 0) {
    console.log('\x1b[31mFailed tests:\x1b[0m');
    results.filter(r => r.status === 'FAIL').forEach(r => {
      console.log(`  - ${r.test}: ${r.message}`);
    });
    console.log('');
  }

  process.exit(failed > 0 ? 1 : 0);
}

runTests().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});

```

### index.html

**Path:** `frontend/index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nodove blog</title>
    <meta name="description" content="nodove 블로그" />

    <meta property="og:title" content="nodove blog" />
    <meta property="og:description" content="nodove 블로그" />
    <meta property="og:type" content="website" />

    <meta name="twitter:card" content="summary" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

    <!-- Fonts: Pretendard (sans) + JetBrains Mono (mono) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pretendard@latest/dist/web/variable/pretendardvariable-dynamic-subset.css" />
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">

    <script>
      (function() {
        const theme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const root = document.documentElement;
        root.classList.remove('light', 'dark', 'terminal');
        
        if (theme === 'terminal') {
          // Terminal uses dark as base with additional terminal class
          root.classList.add('dark', 'terminal');
        } else if (theme === 'dark' || (theme === 'system' && prefersDark) || (!theme && prefersDark)) {
          root.classList.add('dark');
        } else if (theme === 'light') {
          root.classList.add('light');
        } else if (!theme) {
          // Default: terminal theme for new visitors
          root.classList.add('dark', 'terminal');
        }
      })();
    </script>
  </head>

  <body>
    <div id="root"></div>
    <script type="module">
      // Runtime configuration injected by Vite at build time
      // Allows the static site (GitHub Pages) to find the unified backend
      // Note: import.meta.env.* will be statically replaced by Vite during build
      // If not set, getApiBaseUrl() will fall back to localStorage or null
      window.APP_CONFIG = Object.assign({}, window.APP_CONFIG || {}, {
        apiBaseUrl: import.meta.env.VITE_API_BASE_URL || null,
        chatBaseUrl: import.meta.env.VITE_CHAT_BASE_URL || null,
        chatApiKey: import.meta.env.VITE_CHAT_API_KEY || null,
      });
    </script>
    <script type="module" src="/src/main.tsx"></script>
    <script defer src="/ai-memo/ai-memo.js?v=20251019-1"></script>
  </body>
</html>

```

### package.json

**Path:** `frontend/package.json`

```json
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "predev": "npm run generate-manifests",
    "dev": "vite --config config/vite.config.ts",
    "prebuild": "npm run generate-manifests && npm run generate-seo",
    "build": "vite build --config config/vite.config.ts",
    "build:dev": "vite build --mode development --config config/vite.config.ts",
    "build:analyze": "vite build --mode production --config config/vite.config.ts && open dist/stats.html",
    "lint": "eslint src --config config/eslint.config.js --report-unused-disable-directives --max-warnings 0",
    "lint:fix": "eslint src --config config/eslint.config.js --fix",
    "format": "prettier --config config/prettier.config.js --write \"src/**/*.{ts,tsx,js,jsx,json,css,scss,md}\"",
    "format:check": "prettier --config config/prettier.config.js --check \"src/**/*.{ts,tsx,js,jsx,json,css,scss,md}\"",
    "type-check": "tsc --project config/tsconfig.json --noEmit",
    "test": "vitest --config config/vite.config.ts",
    "test:run": "vitest run --config config/vite.config.ts",
    "test:ui": "vitest --ui --config config/vite.config.ts",
    "test:coverage": "vitest run --coverage --config config/vite.config.ts",
    "preview": "vite preview --config config/vite.config.ts",
    "generate-manifests": "node scripts/generate-manifests.js",
    "generate-seo": "node scripts/generate-seo.js",
    "deploy": "npm run generate-manifests && npm run generate-seo && npm run build",
    "build:all": "npm run build",
    "lint:workspaces": "npm run lint",
    "test:workspaces": "npm run test",
    "prepare": "husky",
    "korean:scan": "node scripts/korean-normalize.js",
    "korean:fix": "node scripts/korean-normalize.js --fix --remove-zero-width",
    "korean:scan:ci": "node scripts/korean-normalize.js --ci --silent"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.0",
    "@octokit/rest": "^20.1.0",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-alert-dialog": "^1.1.1",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-collapsible": "^1.1.0",
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-hover-card": "^1.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@tanstack/react-query": "^5.56.2",
    "@types/react-syntax-highlighter": "^15.5.13",
    "@xterm/addon-fit": "^0.10.0",
    "@xterm/addon-web-links": "^0.11.0",
    "@xterm/xterm": "^5.5.0",
    "buffer": "^6.0.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "date-fns": "^3.6.0",
    "dotenv": "^17.2.1",
    "embla-carousel-react": "^8.3.0",
    "firebase-admin": "^12.5.0",
    "fuse.js": "^7.1.0",
    "gray-matter": "^4.0.3",
    "immer": "^10.2.0",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.462.0",
    "next-themes": "^0.3.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.0",
    "react-markdown": "^10.1.0",
    "react-resizable-panels": "^2.1.3",
    "react-router-dom": "^6.26.2",
    "react-syntax-highlighter": "^15.6.6",
    "reading-time": "^1.5.0",
    "recharts": "^2.12.7",
    "rehype-highlight": "^7.0.2",
    "rehype-raw": "^7.0.0",
    "rehype-slug": "^6.0.0",
    "remark-frontmatter": "^5.0.0",
    "remark-gfm": "^4.0.1",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.3",
    "zod": "^3.23.8",
    "zustand": "^4.5.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@tailwindcss/typography": "^0.5.15",
    "@testing-library/jest-dom": "^6.8.0",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^22.5.5",
    "@types/react": "^18.3.23",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^5.0.1",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.9.0",
    "eslint-plugin-import": "^2.32.0",
    "eslint-plugin-jsx-a11y": "^6.10.2",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "husky": "^9.1.7",
    "jsdom": "^26.1.0",
    "lint-staged": "^16.1.5",
    "lovable-tagger": "^1.1.7",
    "playwright": "^1.57.0",
    "postcss": "^8.4.47",
    "prettier": "^3.3.3",
    "rollup-plugin-visualizer": "^6.0.3",
    "tailwindcss": "^3.4.11",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1",
    "vitest": "^3.2.4"
  },
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": [
      "eslint --config config/eslint.config.js --fix",
      "prettier --config config/prettier.config.js --write"
    ],
    "*.{json,css,scss,md}": [
      "prettier --config config/prettier.config.js --write"
    ]
  },
  "packageManager": "pnpm@10.14.0+sha512.ad27a79641b49c3e481a16a805baa71817a04bbe06a38d17e60e2eaee83f6a146c6a688125f5792e48dd5ba30e7da52a5cda4c3992b9ccf333f9ce223af84748"
}

```

### test-shell.mjs

**Path:** `frontend/test-shell.mjs`

```javascript
import playwright from 'playwright';
const { chromium } = playwright;

(async () => {
  const browser = await chromium.launch({ headless: true });
  
  // Mobile - Terminal Theme with Shell Open
  const page = await browser.newPage({ viewport: { width: 375, height: 812 } });
  await page.goto('http://localhost:8081');
  await page.waitForLoadState('networkidle');
  await page.waitForTimeout(1500);
  
  // Click on shell bar to open it
  const shellBar = await page.$('[role="button"]');
  if (shellBar) {
    await shellBar.click();
    await page.waitForTimeout(1000);
    console.log('Shell bar clicked');
  } else {
    console.log('Shell bar not found');
  }
  
  await page.screenshot({ path: '../screenshots/mobile-terminal-shell-open.png', fullPage: false });
  console.log('Screenshot saved');
  
  await browser.close();
})();

```

### tsconfig.json

**Path:** `frontend/tsconfig.json`

```json
{
  "extends": "./config/tsconfig.json",
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "bundler"
  },
  "include": ["src"]
}

```

---

## frontend/config

### components.json

**Path:** `frontend/config/components.json`

```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

```

### eslint.config.js

**Path:** `frontend/config/eslint.config.js`

```javascript
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  { ignores: ['dist', 'node_modules', '*.config.js'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
      '@typescript-eslint/no-unused-vars': [
        'error',
        { argsIgnorePattern: '^_' },
      ],
      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-explicit-any': 'warn',
      'prefer-const': 'error',
      'no-var': 'error',
      'object-shorthand': 'error',
      'prefer-template': 'error',
    },
  },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      globals: globals.browser,
      parserOptions: {
        ecmaFeatures: { jsx: true },
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
      'prefer-const': 'error',
      'no-var': 'error',
      'object-shorthand': 'error',
      'prefer-template': 'error',
    },
  }
);

```

### postcss.config.js

**Path:** `frontend/config/postcss.config.js`

```javascript
export default {
  plugins: {
    tailwindcss: {
      config: new URL('./tailwind.config.js', import.meta.url).pathname,
    },
    autoprefixer: {},
  },
};

```

### prettier.config.js

**Path:** `frontend/config/prettier.config.js`

```javascript
export default {
  semi: true,
  trailingComma: 'es5',
  singleQuote: true,
  printWidth: 80,
  tabWidth: 2,
  useTabs: false,
  bracketSpacing: true,
  arrowParens: 'avoid',
  endOfLine: 'lf',
  jsxSingleQuote: true,
  quoteProps: 'as-needed',
};

```

### tailwind.config.js

**Path:** `frontend/config/tailwind.config.js`

```javascript
/** JS mirror of Tailwind config to ensure CI compatibility */
const tailwindcssAnimate = require('tailwindcss-animate');
const path = require('path');

// Resolve project root from the config/ directory
const root = path.resolve(__dirname, '..');

/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ['class'],
  content: [
    // Use absolute paths so CI resolves correctly from any CWD
    path.join(root, 'index.html'),
    path.join(root, 'src/**/*.{ts,tsx,js,jsx}'),
    path.join(root, 'src/**/*.{md,mdx}'),
    path.join(root, 'public/posts/**/*.{md,mdx}'),
  ],
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        sidebar: {
          DEFAULT: 'hsl(var(--sidebar-background))',
          foreground: 'hsl(var(--sidebar-foreground))',
          primary: 'hsl(var(--sidebar-primary))',
          'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
          accent: 'hsl(var(--sidebar-accent))',
          'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
          border: 'hsl(var(--sidebar-border))',
          ring: 'hsl(var(--sidebar-ring))',
        },
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
      },
    },
  },
  plugins: [tailwindcssAnimate],
};

```

### tailwind.config.ts

**Path:** `frontend/config/tailwind.config.ts`

```typescript
import type { Config } from 'tailwindcss';
import tailwindcssAnimate from 'tailwindcss-animate';
import { fontFamily } from 'tailwindcss/defaultTheme';

export default {
  darkMode: ['class'],
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  prefix: '',
  theme: {
    container: {
      center: true,
      padding: '1rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      fontFamily: {
        sans: ['Pretendard', ...fontFamily.sans],
        mono: ['JetBrains Mono', ...fontFamily.mono],
      },
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        sidebar: {
          DEFAULT: 'hsl(var(--sidebar-background))',
          foreground: 'hsl(var(--sidebar-foreground))',
          primary: 'hsl(var(--sidebar-primary))',
          'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
          accent: 'hsl(var(--sidebar-accent))',
          'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
          border: 'hsl(var(--sidebar-border))',
          ring: 'hsl(var(--sidebar-ring))',
        },
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      keyframes: {
        'accordion-down': {
          from: {
            height: '0',
          },
          to: {
            height: 'var(--radix-accordion-content-height)',
          },
        },
        'accordion-up': {
          from: {
            height: 'var(--radix-accordion-content-height)',
          },
          to: {
            height: '0',
          },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
      },
    },
  },
  plugins: [tailwindcssAnimate],
} satisfies Config;

```

### tsconfig.app.json

**Path:** `frontend/config/tsconfig.app.json`

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitAny": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitReturns": true,
    "noImplicitOverride": true,

    "baseUrl": "..",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["../src"]
}

```

### tsconfig.json

**Path:** `frontend/config/tsconfig.json`

```json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": "..",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

```

### tsconfig.node.json

**Path:** `frontend/config/tsconfig.node.json`

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts", "../scripts/**/*"]
}

```

### vite.config.ts

**Path:** `frontend/config/vite.config.ts`

```typescript
/// <reference types="vitest" />
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react-swc';
import path from 'path';
import { componentTagger } from 'lovable-tagger';
import { visualizer } from 'rollup-plugin-visualizer';

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, path.resolve(__dirname, '..', '..'), '');
  const devHost = env.VITE_DEV_HOST || '::';
  const devPort = Number(env.VITE_DEV_PORT || 8080);
  return {
  css: {
    postcss: path.resolve(__dirname, './postcss.config.js'),
  },
  // Explicit base for clarity on GH Pages/custom domain
  base: '/',
  publicDir: 'public',
  // Load .env from repo root so a single .env controls all
  envDir: path.resolve(__dirname, '..', '..'),
  server: {
    host: devHost,
    port: devPort,
  },
  optimizeDeps: {
    include: ['buffer'],
  },
  build: {
    outDir: 'dist',
    emptyOutDir: true,
    copyPublicDir: true,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom', 'react-router-dom'],
          ui: [
            'lucide-react',
            '@radix-ui/react-accordion',
            '@radix-ui/react-avatar',
            '@radix-ui/react-dialog',
          ],
          markdown: [
            'react-markdown',
            'react-syntax-highlighter',
            'remark-gfm',
            'remark-frontmatter',
          ],
          utils: ['clsx', 'class-variance-authority', 'tailwind-merge'],
          search: ['fuse.js'],
        },
      },
    },
    assetsDir: 'assets',
    chunkSizeWarningLimit: 600,
    sourcemap: mode === 'development',
  },
  plugins: [
    react(),
    mode === 'development' && componentTagger(),
    mode === 'production' &&
      visualizer({
        filename: 'dist/stats.html',
        open: false,
        gzipSize: true,
        brotliSize: true,
      }),
  ].filter(Boolean),
  resolve: {
    alias: {
      '@': path.resolve(__dirname, '../src'),
      buffer: 'buffer',
    },
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: [path.resolve(__dirname, '../src/test/setup.ts')],
    css: true,
  },
};
});

```

---

## frontend/public

### 404.html

**Path:** `frontend/public/404.html`

```html
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Page Not Found - nodove blog</title>
    <meta name="description" content="페이지를 찾을 수 없습니다. 홈페이지로 돌아가세요." />
    <script>
      // Preserve the original path and redirect to hash-based route for SPA
      (function () {
        var l = window.location;
        var path = l.pathname || '/';
        var search = l.search || '';
        var hash = l.hash || '';
        // Redirect to '/#/path?query#hash' so HashRouter can handle it
        var redirectUrl = '/#' + path + search + hash;
        l.replace(redirectUrl);
      })();
    </script>
  </head>
  <body>
    <div style="text-align: center; padding: 50px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">
      <h1>404 - 페이지를 찾을 수 없습니다</h1>
      <p>홈페이지로 리다이렉트하는 중...</p>
    </div>
  </body>
</html>

```

### CNAME

**Path:** `frontend/public/CNAME`

```
noblog.nodove.com

```

### posts-manifest.json

**Path:** `frontend/public/posts-manifest.json`

```json
{
  "total": 133,
  "items": [
    {
      "path": "/posts/2025/k8s-overview.md",
      "year": "2025",
      "slug": "k8s-overview",
      "title": "쿠버네티스 기본 구조",
      "description": "전통적 배포 방식부터 쿠버네티스 에코시스템까지, 개념을 정리하는 글",
      "snippet": "전통적 배포 방식부터 쿠버네티스 에코시스템까지, 개념을 정리하는 글",
      "date": "2025-12-02",
      "tags": [
        "Kubernetes",
        "DevOps",
        "Cloud Native",
        "컨테이너 오케스트레이션"
      ],
      "category": "Kubernetes",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/k8s/k8s-deployment-era-traditional-virtualized-container.png",
      "url": "/blog/2025/k8s-overview"
    },
    {
      "path": "/posts/2025/AnimalsMind.md",
      "year": "2025",
      "slug": "AnimalsMind",
      "title": "우리는 DNA의 꼭두각시인가: 이성의 붕괴와 야성적 충동의 역설에 대한 생각",
      "description": "애덤 스미스의 이성적 인간관에 대한 반박부터 케인스와 민스키의 야성적 충동, 그리고 진화심리학적 관점까지. 인간 본성의 모순에 대한 생각",
      "snippet": "애덤 스미스의 이성적 인간관에 대한 반박부터 케인스와 민스키의 야성적 충동, 그리고 진화심리학적 관점까지. 인간 본성의 모순에 대한 생각",
      "date": "2025-12-01",
      "tags": [
        "Philosophy",
        "Economics",
        "Psychology",
        "Minsky",
        "Evolution"
      ],
      "category": "Essays",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/AnimalsMind"
    },
    {
      "path": "/posts/2025/algorithm_solv.md",
      "year": "2025",
      "slug": "algorithm_solv",
      "title": "알고리즘의 역발상 관점",
      "description": "피보나치 수열, 행렬 곱셈, 그리디 알고리즘, 문자열 검색, P vs NP까지 — 컴퓨터 과학의 고전 알고리즘을 역발상 관점으로 정리",
      "snippet": "피보나치 수열, 행렬 곱셈, 그리디 알고리즘, 문자열 검색, P vs NP까지 — 컴퓨터 과학의 고전 알고리즘을 역발상 관점으로 정리",
      "date": "2025-11-29",
      "tags": [
        "알고리즘",
        "동적 프로그래밍",
        "그리디",
        "문자열 알고리즘",
        "P vs NP"
      ],
      "category": "Computer Science",
      "author": "Admin",
      "readingTime": "8 min read",
      "published": true,
      "coverImage": "/images/2025/algoritm_solv/algorithm-solve-dp-fibonacci.png",
      "url": "/blog/2025/algorithm_solv"
    },
    {
      "path": "/posts/2025/AI-api-server-temporary-dev.md",
      "year": "2025",
      "slug": "AI-api-server-temporary-dev",
      "title": "Kafka와 LLM 서버 사이에 버퍼 존을 둔 AI 서버 설계기",
      "description": "Kafka와 LLM 서버 사이에 작은 버퍼 존을 두고 Gateway와 Buffer Worker를 나누어 설계한 이유, 그리고 이를 Kafka 토픽·메시지 스키마·docker-compose로 구체화해 가는 과정을 정리했다",
      "snippet": "Kafka와 LLM 서버 사이에 작은 버퍼 존을 두고 Gateway와 Buffer Worker를 나누어 설계한 이유, 그리고 이를 Kafka 토픽·메시지 스키마·docker-compose로 구체화해 가는 과정을 정리했다",
      "date": "2025-11-20",
      "tags": [
        "Kafka",
        "LLM",
        "RAG",
        "Gateway",
        "백엔드아키텍처"
      ],
      "category": "Backend",
      "author": "Admin",
      "readingTime": "8 min read",
      "published": true,
      "coverImage": "/images/2025/AI-server.png",
      "url": "/blog/2025/AI-api-server-temporary-dev"
    },
    {
      "path": "/posts/2025/nat-gateway-bottleneck-journal.md",
      "year": "2025",
      "slug": "nat-gateway-bottleneck-journal",
      "title": "네트워크 병목과 NAT 게이트웨이의 한계: 한 CS 학생의 속마음",
      "description": "프라이빗 서브넷과 퍼블릭 서브넷, NAT Gateway와 IGW가 등장하는 전형적인 VPC 그림을 보던 수업 시간. 모두가 보안을 이야기할 때, 내 눈에는 그 구조가 거대한 깔때기 실험처럼 보였다. 이 글은 그 순간 머릿속에서 떠오른 병목에 대한 질문과 직관을 그대로 옮긴 기록이다.",
      "snippet": "프라이빗 서브넷과 퍼블릭 서브넷, NAT Gateway와 IGW가 등장하는 전형적인 VPC 그림을 보던 수업 시간. 모두가 보안을 이야기할 때, 내 눈에는 그 구조가 거대한 깔때기 실험처럼 보였다. 이 글은 그 순간 머릿속에서 떠오른 병목에 대한 질문과 직관을 그대로 옮긴 기록이다.",
      "date": "2025-11-19",
      "tags": [
        "NAT",
        "클라우드네트워크",
        "VPC",
        "프라이빗서브넷",
        "병목"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "coverImage": "/images/2025/natgateway.png",
      "url": "/blog/2025/nat-gateway-bottleneck-journal"
    },
    {
      "path": "/posts/2025/future-tech-six-insights.md",
      "year": "2025",
      "slug": "future-tech-six-insights",
      "title": "제가 뇌를 리셋하게 만든 미래 기술 문서에서 발견한 6가지 깨달음",
      "description": "미래 기술 문서들 속에서 발견한 6가지 통찰과 인간 역할의 재정의를 공유합니다.",
      "snippet": "미래 기술 문서들 속에서 발견한 6가지 통찰과 인간 역할의 재정의를 공유합니다.",
      "date": "2025-11-04",
      "tags": [
        "AI",
        "DevOps",
        "Future",
        "Infrastructure",
        "Self-Evolving Systems"
      ],
      "category": "Tech Essay",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/future-map.jpg",
      "url": "/blog/2025/future-tech-six-insights"
    },
    {
      "path": "/posts/2025/sorting-algorithms-pseudocode-analysis.md",
      "year": "2025",
      "slug": "sorting-algorithms-pseudocode-analysis",
      "title": "정렬 알고리즘 수도 코드 완전 해부: 라인별 분석",
      "description": "버블 정렬부터 힙 정렬까지, 핵심 수도 코드를 한 줄씩 뜯어보며 왜 그런 로직이 필요한지 한국어로 상세하게 분석합니다.",
      "snippet": "버블 정렬부터 힙 정렬까지, 핵심 수도 코드를 한 줄씩 뜯어보며 왜 그런 로직이 필요한지 한국어로 상세하게 분석합니다.",
      "date": "2025-11-02",
      "tags": [
        "정렬",
        "알고리즘",
        "수도코드",
        "학습노트"
      ],
      "category": "알고리즘",
      "author": "Admin",
      "readingTime": "7 min read",
      "published": true,
      "url": "/blog/2025/sorting-algorithms-pseudocode-analysis"
    },
    {
      "path": "/posts/2025/path-new-friend-essay.md",
      "year": "2025",
      "slug": "path-new-friend-essay",
      "title": "PATH에 새 친구를 초대하는 방법",
      "description": "심볼릭 링크가 말을 안 듣던 날, PATH를 다시 다듬으며 정리한 나만의 에세이.",
      "snippet": "심볼릭 링크가 말을 안 듣던 날, PATH를 다시 다듬으며 정리한 나만의 에세이.",
      "date": "2025-11-01",
      "tags": [
        "PATH",
        "리눅스",
        "환경설정",
        "터미널",
        "작업자동화"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/path-new-friend-essay"
    },
    {
      "path": "/posts/2025/sorting-algorithms-masterclass.md",
      "year": "2025",
      "slug": "sorting-algorithms-masterclass",
      "title": "정렬 알고리즘 완전 정복: 버블 정렬부터 힙 정렬까지",
      "description": "버블 정렬부터 힙 정렬까지, 핵심 비유와 수도 코드, Java 구현으로 정렬 알고리즘을 완전 정복합니다.",
      "snippet": "버블 정렬부터 힙 정렬까지, 핵심 비유와 수도 코드, Java 구현으로 정렬 알고리즘을 완전 정복합니다.",
      "date": "2025-11-01",
      "tags": [
        "정렬",
        "알고리즘",
        "Java"
      ],
      "category": "알고리즘",
      "author": "Admin",
      "readingTime": "7 min read",
      "published": true,
      "url": "/blog/2025/sorting-algorithms-masterclass"
    },
    {
      "path": "/posts/2025/wine-clipboard-bridge-journal.md",
      "year": "2025",
      "slug": "wine-clipboard-bridge-journal",
      "title": "Wayland 위에서 Wine 카카오톡이 복붙을 잃어버린 날",
      "description": "EndeavourOS에서 Wine 카카오톡과 호스트 사이 복붙이 끊겼던 사건을 기록하며, 왜 그런지 그리고 어떻게 우회했는지 정리했다.",
      "snippet": "EndeavourOS에서 Wine 카카오톡과 호스트 사이 복붙이 끊겼던 사건을 기록하며, 왜 그런지 그리고 어떻게 우회했는지 정리했다.",
      "date": "2025-10-31",
      "tags": [
        "Wine",
        "Wayland",
        "클립보드",
        "Hyprland",
        "wl-clipboard"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "url": "/blog/2025/wine-clipboard-bridge-journal"
    },
    {
      "path": "/posts/2025/java-concurrency-journal.md",
      "year": "2025",
      "slug": "java-concurrency-journal",
      "title": "스레드 덤프와 데드락 다이어그램, 자바 동시성의 밤을 기록하다",
      "description": "Thread, synchronized, ExecutorService, ForkJoinPool을 오가며 레이스와 데드락을 추적했던 내 1인칭 동시성 일기",
      "snippet": "Thread, synchronized, ExecutorService, ForkJoinPool을 오가며 레이스와 데드락을 추적했던 내 1인칭 동시성 일기",
      "date": "2025-10-27",
      "tags": [
        "Java",
        "Concurrency",
        "Thread",
        "ExecutorService",
        "락"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/fataldeadlock.png",
      "url": "/blog/2025/java-concurrency-journal"
    },
    {
      "path": "/posts/2025/java-memory-model-journal.md",
      "year": "2025",
      "slug": "java-memory-model-journal",
      "title": "Happens-before를 붙잡기까지, 자바 메모리 모델을 해부한 내 여정",
      "description": "JMM 명세와 volatile, synchronized, reorder의 경계를 파헤치며 가시성과 순서를 이해한 개발자의 기록",
      "snippet": "JMM 명세와 volatile, synchronized, reorder의 경계를 파헤치며 가시성과 순서를 이해한 개발자의 기록",
      "date": "2025-10-27",
      "tags": [
        "Java",
        "메모리모델",
        "volatile",
        "HappensBefore",
        "JMM"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/java-memory-model-journal"
    },
    {
      "path": "/posts/2025/java-stream-api-journal.md",
      "year": "2025",
      "slug": "java-stream-api-journal",
      "title": "람다와 파이프라인 사이, 스트림 API에 빠져들던 밤",
      "description": "람다 표현식과 스트림 파이프라인을 처음 만났을 때의 놀람, 컬렉터와 병렬 스트림 튜닝까지 기록한 1인칭 에세이",
      "snippet": "람다 표현식과 스트림 파이프라인을 처음 만났을 때의 놀람, 컬렉터와 병렬 스트림 튜닝까지 기록한 1인칭 에세이",
      "date": "2025-10-27",
      "tags": [
        "Java",
        "StreamAPI",
        "Lambda",
        "FunctionalProgramming",
        "병렬스트림"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/java-stream-api-journal"
    },
    {
      "path": "/posts/2025/shell-powertools-journal.md",
      "year": "2025",
      "slug": "shell-powertools-journal",
      "title": "awk와 sed, 그리고 xargs에 빚진 작은 승리들",
      "description": "파이프라인 하나로 서버를 살린 순간을 떠올리며, 내가 사랑하는 세 가지 쉘 친구들을 일기처럼 적어 봤습니다.",
      "snippet": "파이프라인 하나로 서버를 살린 순간을 떠올리며, 내가 사랑하는 세 가지 쉘 친구들을 일기처럼 적어 봤습니다.",
      "date": "2025-10-27",
      "tags": [
        "awk",
        "sed",
        "xargs",
        "리눅스쉘",
        "자동화"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2025/shell-powertools-journal"
    },
    {
      "path": "/posts/2025/java-gc-journal.md",
      "year": "2025",
      "slug": "java-gc-journal",
      "title": "Stop-the-world의 숨결을 들으며, GC와 화해한 나의 기록",
      "description": "Serial, CMS, G1을 거치며 힙 덤프와 함께 밤을 지새운 개발자가 GC의 진화와 전략을 되돌아본 일기",
      "snippet": "Serial, CMS, G1을 거치며 힙 덤프와 함께 밤을 지새운 개발자가 GC의 진화와 전략을 되돌아본 일기",
      "date": "2025-10-26",
      "tags": [
        "Java",
        "GarbageCollection",
        "JVM",
        "G1",
        "메모리관리"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/java-gc-journal"
    },
    {
      "path": "/posts/2025/grub-kernel-error-journal.md",
      "year": "2025",
      "slug": "grub-kernel-error-journal",
      "title": "'You need to load the kernel first'와 함께한 새벽의 구조 요청",
      "description": "pacman -Syu 한 번 눌렀을 뿐인데 부팅이 멈췄다면? 새벽에 겪은 GRUB 구출기를 일기처럼 정리했습니다.",
      "snippet": "pacman -Syu 한 번 눌렀을 뿐인데 부팅이 멈췄다면? 새벽에 겪은 GRUB 구출기를 일기처럼 정리했습니다.",
      "date": "2025-10-25",
      "tags": [
        "Arch Linux",
        "GRUB",
        "부팅오류",
        "시스템복구",
        "에세이"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/kernelfault.png",
      "url": "/blog/2025/grub-kernel-error-journal"
    },
    {
      "path": "/posts/2025/java-generics-journal.md",
      "year": "2025",
      "slug": "java-generics-journal",
      "title": "타입 변수와 야생의 캐스팅: 제네릭을 길들이던 내 기록",
      "description": "로 타입과 ClassCastException에 질려, 제네릭이 도입되던 현장을 지켜보며 타입 안정성을 붙잡은 개발자 일기",
      "snippet": "로 타입과 ClassCastException에 질려, 제네릭이 도입되던 현장을 지켜보며 타입 안정성을 붙잡은 개발자 일기",
      "date": "2025-10-25",
      "tags": [
        "Java",
        "Generics",
        "타입시스템",
        "Erasure",
        "컬렉션"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/java-generics-journal"
    },
    {
      "path": "/posts/2025/6g-sentient-future-journal.md",
      "year": "2025",
      "slug": "6g-sentient-future-journal",
      "title": "6G 연구소의 밤, 지각 있는 네트워크를 그리는 상상",
      "description": "테라헤르츠 실험과 지능형 표면, AI 네이티브 아키텍처, 통신-감지 통합을 넘나들며 6G의 미래를 환상과 현실 사이에서 탐구한 기록",
      "snippet": "테라헤르츠 실험과 지능형 표면, AI 네이티브 아키텍처, 통신-감지 통합을 넘나들며 6G의 미래를 환상과 현실 사이에서 탐구한 기록",
      "date": "2025-10-24",
      "tags": [
        "6G",
        "테라헤르츠",
        "RIS",
        "AI네이티브",
        "JCS"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/6g-sentient-future-journal"
    },
    {
      "path": "/posts/2025/proxmox-thin-provision.md",
      "year": "2025",
      "slug": "proxmox-thin-provision",
      "title": "ZFS 풀 앞에서 멈춰 선 Proxmox, 그 밤의 기록",
      "description": "1.85TB 디스크를 추가하려다 ZFS가 '공간 없음'을 외친 밤. 스냅샷과 예약 공간 사이에서 배운 얇은 줄타기 경험담",
      "snippet": "1.85TB 디스크를 추가하려다 ZFS가 '공간 없음'을 외친 밤. 스냅샷과 예약 공간 사이에서 배운 얇은 줄타기 경험담",
      "date": "2025-10-24",
      "tags": [
        "Proxmox",
        "ZFS",
        "Thin Provision",
        "가상화",
        "스토리지"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/proxmox-thin-provision"
    },
    {
      "path": "/posts/2025/5g-intelligent-fabric-journal.md",
      "year": "2025",
      "slug": "5g-intelligent-fabric-journal",
      "title": "5G 기지국 그림자에서, 슬라이스와 에지가 만든 새로운 질서",
      "description": "URLLC, 슬라이스, 에지 노드를 직접 구축하며 5G가 사람과 기계를 동시에 품어내는 과정을 기록했다",
      "snippet": "URLLC, 슬라이스, 에지 노드를 직접 구축하며 5G가 사람과 기계를 동시에 품어내는 과정을 기록했다",
      "date": "2025-10-23",
      "tags": [
        "5G",
        "네트워크슬라이싱",
        "에지컴퓨팅",
        "URLLC",
        "제로트러스트"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/5g-intelligent-fabric-journal"
    },
    {
      "path": "/posts/2025/linux-device-mount-journal.md",
      "year": "2025",
      "slug": "linux-device-mount-journal",
      "title": "언마운트 이후에도 /dev/sda1이 남아있는 이유를 이해한 밤",
      "description": "장치 파일과 마운트의 차이를 헤맸던 날, 그리고 USB 허브의 SD 카드를 다시 인식시키기까지의 기록",
      "snippet": "장치 파일과 마운트의 차이를 헤맸던 날, 그리고 USB 허브의 SD 카드를 다시 인식시키기까지의 기록",
      "date": "2025-10-23",
      "tags": [
        "mount",
        "umount",
        "장치파일",
        "USB",
        "네트워킹"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/notunmounted.png",
      "url": "/blog/2025/linux-device-mount-journal"
    },
    {
      "path": "/posts/2025/java-static-polymorphism-masterclass.md",
      "year": "2025",
      "slug": "java-static-polymorphism-masterclass",
      "title": "static 키워드와 다형성으로 밤을 지새운 어느 개발자의 기록",
      "description": "정적 영역과 힙 사이에서 헤매던 날, 다형성의 그림자와 씨름한 새벽, 그리고 equals를 다시 쓰며 깨달은 객체지향의 본질",
      "snippet": "정적 영역과 힙 사이에서 헤매던 날, 다형성의 그림자와 씨름한 새벽, 그리고 equals를 다시 쓰며 깨달은 객체지향의 본질",
      "date": "2025-10-22",
      "tags": [
        "Java",
        "static",
        "Polymorphism",
        "OOP 심화",
        "JVM 메모리"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2025/java-static-polymorphism-masterclass"
    },
    {
      "path": "/posts/2025/lte-cloud-native-journal.md",
      "year": "2025",
      "slug": "lte-cloud-native-journal",
      "title": "4G 신호와 클라우드 콘솔 사이, 앱 경제를 실감한 나의 하루",
      "description": "LTE 필드 테스트와 데이터센터 자동화가 교차하던 2010년대, 앱 경제와 클라우드 네트워크를 동시에 길들인 개발자의 기록",
      "snippet": "LTE 필드 테스트와 데이터센터 자동화가 교차하던 2010년대, 앱 경제와 클라우드 네트워크를 동시에 길들인 개발자의 기록",
      "date": "2025-10-22",
      "tags": [
        "4G",
        "LTE",
        "클라우드컴퓨팅",
        "SDN",
        "NFV",
        "IPv6"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/lte-cloud-native-journal"
    },
    {
      "path": "/posts/2025/broadband-cdn-transition-journal.md",
      "year": "2025",
      "slug": "broadband-cdn-transition-journal",
      "title": "ADSL 불빛과 CDN 랙 사이에서 보낸 2000년대의 밤",
      "description": "DSL 모뎀의 깜박임, 아카마이 캐시의 열기, 3G 기지국의 소음 속에서 상시 접속 시대를 맞이한 나의 기록",
      "snippet": "DSL 모뎀의 깜박임, 아카마이 캐시의 열기, 3G 기지국의 소음 속에서 상시 접속 시대를 맞이한 나의 기록",
      "date": "2025-10-21",
      "tags": [
        "광대역",
        "CDN",
        "3G",
        "NAT",
        "TLS"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/broadband-cdn-transition-journal"
    },
    {
      "path": "/posts/2025/java-oop-superchallenge.md",
      "year": "2025",
      "slug": "java-oop-superchallenge",
      "title": "JVM 메모리 지도 들고 자바 OOP 문제를 풀어본 기록",
      "description": "정적 초기화 블록에서 시작해 super()로 끝나는 여섯 가지  문제들. 그 밤의 디버깅 노트를 그대로 옮겨 붙였습니다.",
      "snippet": "정적 초기화 블록에서 시작해 super()로 끝나는 여섯 가지  문제들. 그 밤의 디버깅 노트를 그대로 옮겨 붙였습니다.",
      "date": "2025-10-21",
      "tags": [
        "Java",
        "JVM 메모리",
        "static",
        "다형성",
        "상속",
        "instanceof"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2025/java-oop-superchallenge"
    },
    {
      "path": "/posts/2025/java-through-my-bytecode-journal.md",
      "year": "2025",
      "slug": "java-through-my-bytecode-journal",
      "title": "바이트코드 기차를 타고 자바 세계를 일주한 날",
      "description": "Write once, run anywhere라는 간판을 붙인 자바의 철도를 따라가며, JDK에서 GC까지 몸소 느꼈던 이야기와 살아 있는 코드 메모",
      "snippet": "Write once, run anywhere라는 간판을 붙인 자바의 철도를 따라가며, JDK에서 GC까지 몸소 느꼈던 이야기와 살아 있는 코드 메모",
      "date": "2025-10-20",
      "tags": [
        "Java",
        "JVM",
        "자료형",
        "연산자",
        "객체지향"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "coverImage": "/images/2025/javatrain.png",
      "url": "/blog/2025/java-through-my-bytecode-journal"
    },
    {
      "path": "/posts/2025/web-commercialization-journal.md",
      "year": "2025",
      "slug": "web-commercialization-journal",
      "title": "모자이크를 띄운 날, 월드 와이드 웹이 손에 들어왔다",
      "description": "웹 브라우저와 DNS, BGP가 열어젖힌 1990년대 인터넷의 폭발을 현장에서 지켜본 나의 기록",
      "snippet": "웹 브라우저와 DNS, BGP가 열어젖힌 1990년대 인터넷의 폭발을 현장에서 지켜본 나의 기록",
      "date": "2025-10-20",
      "tags": [
        "월드와이드웹",
        "모자이크",
        "NSFNET",
        "BGP",
        "CIDR"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/web-commercialization-journal"
    },
    {
      "path": "/posts/2025/algorithms-through-my-eyes.md",
      "year": "2025",
      "slug": "algorithms-through-my-eyes",
      "title": "알고리즘 수업 노트를 다시 펼쳐 보며",
      "description": "기초 알고리즘 수업 노트를 다시 펼쳐 보며...",
      "snippet": "기초 알고리즘 수업 노트를 다시 펼쳐 보며...",
      "date": "2025-10-19",
      "tags": [
        "알고리즘",
        "복잡도",
        "분할정복",
        "동적계획법",
        "탐욕법"
      ],
      "category": "Computer Science",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "url": "/blog/2025/algorithms-through-my-eyes"
    },
    {
      "path": "/posts/2025/tcpip-revolution-journal.md",
      "year": "2025",
      "slug": "tcpip-revolution-journal",
      "title": "TCP/IP 깃발 아래, 내가 본 인터넷의 탄생",
      "description": "NCP에서 TCP/IP로 전환하던 플래그 데이의 긴장과 감동을 되살린 개발자의 일기",
      "snippet": "NCP에서 TCP/IP로 전환하던 플래그 데이의 긴장과 감동을 되살린 개발자의 일기",
      "date": "2025-10-19",
      "tags": [
        "TCPIP",
        "인터넷역사",
        "플래그데이",
        "프로토콜디자인",
        "인터네트워킹"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "coverImage": "/images/2025/deadlock.png",
      "url": "/blog/2025/tcpip-revolution-journal"
    },
    {
      "path": "/posts/2025/algorithm-mental-simulator.md",
      "year": "2025",
      "slug": "algorithm-mental-simulator",
      "title": "알고리즘을 메모리 영화관에서 돌려보는 밤",
      "description": "Big-O는 교통수단, 병합 정렬은 지도 조각, 해시는 주소 직통. 시뮬레이터형 두뇌로 재생한 알고리즘 18편의 심화 문제와 비유",
      "snippet": "Big-O는 교통수단, 병합 정렬은 지도 조각, 해시는 주소 직통. 시뮬레이터형 두뇌로 재생한 알고리즘 18편의 심화 문제와 비유",
      "date": "2025-10-18",
      "tags": [
        "알고리즘",
        "시간복잡도",
        "정렬",
        "탐색트리",
        "해시",
        "DP",
        "Greedy"
      ],
      "category": "Computer Science",
      "author": "Admin",
      "readingTime": "6 min read",
      "published": true,
      "url": "/blog/2025/algorithm-mental-simulator"
    },
    {
      "path": "/posts/2025/arpanet-resilience-journal.md",
      "year": "2025",
      "slug": "arpanet-resilience-journal",
      "title": "스푸트니크의 그림자 아래, 내가 본 ARPANET의 첫 호흡",
      "description": "냉전의 긴장 속에서 태어난 ARPANET을 따라가며, 패킷 교환과 IMP가 가져온 혁신을 밤새 되짚은 나의 기록",
      "snippet": "냉전의 긴장 속에서 태어난 ARPANET을 따라가며, 패킷 교환과 IMP가 가져온 혁신을 밤새 되짚은 나의 기록",
      "date": "2025-10-18",
      "tags": [
        "ARPANET",
        "패킷교환",
        "인터넷역사",
        "ColdWar",
        "네트워크아키텍처"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/nuclear.png",
      "url": "/blog/2025/arpanet-resilience-journal"
    },
    {
      "path": "/posts/2025/BST-think01.md",
      "year": "2025",
      "slug": "BST-think01",
      "title": "BST TreeInsertion 횟수 구하기 고민한 내용 정리",
      "description": "BST 트리 호출 횟수 구하기를 보다가 떠오른 최적화 방안 생각 정리",
      "snippet": "BST 트리 호출 횟수 구하기를 보다가 떠오른 최적화 방안 생각 정리",
      "date": "2025-10-17",
      "tags": [
        "Machine Learning",
        "BST",
        "최적화",
        "줌인"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/BST-think01"
    },
    {
      "path": "/posts/2025/Limitation-Of-Transformer.md",
      "year": "2025",
      "slug": "Limitation-Of-Transformer",
      "title": "트랜스포머의 한계에 대하여: 바텀업을 넘어 하향식으로",
      "description": "트랜스포머가 왜 강하고 왜 비켜가야 하는지, PIM·RAG·압축·NAS를 오가며 고찰한 기록.",
      "snippet": "트랜스포머가 왜 강하고 왜 비켜가야 하는지, PIM·RAG·압축·NAS를 오가며 고찰한 기록.",
      "date": "2025-10-17",
      "tags": [
        "Transformer",
        "RAG",
        "PIM",
        "Inference",
        "Training",
        "LayerFusion",
        "Quantization",
        "Pruning",
        "Distillation",
        "NAS",
        "TopDown",
        "BottomUp"
      ],
      "category": "AI",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2025/Limitation-Of-Transformer"
    },
    {
      "path": "/posts/2025/QuantumShadow.md",
      "year": "2025",
      "slug": "QuantumShadow",
      "title": "보이지 않는 나는 양자 상태인가?: 물리적 현실과 심리학적 진실의 경계",
      "description": "물리학의 '결어긋남'은 우리 몸의 양자 상태를 부정하지만, '무의식'의 작동 원리를 설명하는 가장 완벽한 비유일지도 모릅니다.",
      "snippet": "물리학의 '결어긋남'은 우리 몸의 양자 상태를 부정하지만, '무의식'의 작동 원리를 설명하는 가장 완벽한 비유일지도 모릅니다.",
      "date": "2025-10-17",
      "tags": [
        "양자역학",
        "칼융",
        "무의식",
        "결어긋남",
        "의식",
        "심리학"
      ],
      "category": "과학 & 철학",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/QuantumShadow"
    },
    {
      "path": "/posts/2025/QuantumSpaceInside.md",
      "year": "2025",
      "slug": "QuantumSpaceInside",
      "title": "나의 고독은 우주의 시작과 맞닿아 있었다",
      "description": "개인의 고독에 대한 내면 탐험이 어떻게 칼 융의 심리학과 양자역학을 거쳐, 결국 우주의 시작과 끝에 대한 거대한 통찰로 이어지는지에 대한 철학적 에세이.",
      "snippet": "개인의 고독에 대한 내면 탐험이 어떻게 칼 융의 심리학과 양자역학을 거쳐, 결국 우주의 시작과 끝에 대한 거대한 통찰로 이어지는지에 대한 철학적 에세이.",
      "date": "2025-10-17",
      "tags": [
        "칼융",
        "양자역학",
        "블랙홀",
        "순환우주론",
        "무의식",
        "철학적사유"
      ],
      "category": "철학 & 사유",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/QuantumSpaceInside"
    },
    {
      "path": "/posts/2025/ci-trigger-test.md",
      "year": "2025",
      "slug": "ci-trigger-test",
      "title": "CI Trigger Test",
      "description": "Non-visible post to exercise CI path filters.",
      "snippet": "Non-visible post to exercise CI path filters.",
      "date": "2025-10-17",
      "tags": [
        "ci",
        "workflow"
      ],
      "category": "Maintenance",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/ci-trigger-test"
    },
    {
      "path": "/posts/2025/network-evolution-intro-journal.md",
      "year": "2025",
      "slug": "network-evolution-intro-journal",
      "title": "네트워크 연표를 다시 걷기 전, 내가 세운 질문들",
      "description": "ARPANET부터 6G까지 다시 추적하기 전에, 지각 있는 연결 구조란 무엇인지 스스로에게 던진 질문을 정리한 나의 서문",
      "snippet": "ARPANET부터 6G까지 다시 추적하기 전에, 지각 있는 연결 구조란 무엇인지 스스로에게 던진 질문을 정리한 나의 서문",
      "date": "2025-10-17",
      "tags": [
        "네트워크역사",
        "인터넷진화",
        "서론",
        "에세이"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/network-evolution-intro-journal"
    },
    {
      "path": "/posts/2025/spring-boot-realtime-communication.md",
      "year": "2025",
      "slug": "spring-boot-realtime-communication",
      "title": "SSE와 WebSocket 사이에서, 나의 실시간 통신 여정을 적다",
      "description": "JavaScript와 Spring Boot로 SSE와 WebSocket을 번갈아 구현하며 Redis와 Kafka를 저울질한 밤의 기록",
      "snippet": "JavaScript와 Spring Boot로 SSE와 WebSocket을 번갈아 구현하며 Redis와 Kafka를 저울질한 밤의 기록",
      "date": "2025-09-17",
      "tags": [
        "SSE",
        "WebSocket",
        "Redis",
        "Kafka",
        "실시간통신"
      ],
      "category": "Web",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "url": "/blog/2025/spring-boot-realtime-communication"
    },
    {
      "path": "/posts/2025/network-evolution-history.md",
      "year": "2025",
      "slug": "network-evolution-history",
      "title": "네트워크 발전의 역사: ARPANET에서 5G/6G까지",
      "description": "패킷 교환의 탄생부터 인터넷 표준화, 웹의 폭발적 성장, 모바일·클라우드·엣지, 그리고 5G/6G로 이어지는 네트워크 발전사를 핵심 이정표 중심으로 정리합니다.",
      "snippet": "패킷 교환의 탄생부터 인터넷 표준화, 웹의 폭발적 성장, 모바일·클라우드·엣지, 그리고 5G/6G로 이어지는 네트워크 발전사를 핵심 이정표 중심으로 정리합니다.",
      "date": "2025-08-31T00:00:00.000Z",
      "tags": [
        "network",
        "history",
        "internet",
        "5G",
        "6G",
        "protocols",
        "architecture"
      ],
      "category": "CS",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "coverImage": "/images/covers/network-history.jpg",
      "url": "/blog/2025/network-evolution-history"
    },
    {
      "path": "/posts/2025/hooks.md",
      "year": "2025",
      "slug": "hooks",
      "title": "리액트 hooks 훑어보기",
      "description": "# React Hooks 완벽 가이드\n\n## 개요\nReact의 Hooks는 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 기능입니다. React 16.8에서 처음 도입된 이 기능은 클래스형 컴포넌트를 사용하는 대신, 더 간결하고 이해하기 쉬운 코드를 작성할 수 있도록 도와줍니다. 이번 글에서는 React",
      "snippet": "# React Hooks 완벽 가이드\n\n## 개요\nReact의 Hooks는 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 기능입니다. React 16.8에서 처음 도입된 이 기능은 클래스형 컴포넌트를 사용하는 대신, 더 간결하고 이해하기 쉬운 코드를 작성할 수 있도록 도와줍니다. 이번 글에서는 React",
      "date": "2025-08-11",
      "tags": [],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/hooks"
    },
    {
      "path": "/posts/2024/blade-runner-philosophy.md",
      "year": "2024",
      "slug": "blade-runner-philosophy",
      "title": "블레이드 러너(Blade Runner, 1982) - 인간성의 경계를 묻는 철학적 걸작",
      "description": "# 블레이드 러너(Blade Runner, 1982) - 인간성의 경계를 묻는 철학적 걸작\n\n## 영화 개관과 감독의 비전\n\n**블레이드 러너**는 1982년 리들리 스콧 감독이 필립 K. 딕의 소설 『안드로이드는 전기양의 꿈을 꾸는가?』를 각색한 SF 누아르의 금자탑입니다. 개봉 당시 상업적으로는 실패했지만, 시간이 지나면서 **인간 존재의 본질에 대한.",
      "snippet": "# 블레이드 러너(Blade Runner, 1982) - 인간성의 경계를 묻는 철학적 걸작\n\n## 영화 개관과 감독의 비전\n\n**블레이드 러너**는 1982년 리들리 스콧 감독이 필립 K. 딕의 소설 『안드로이드는 전기양의 꿈을 꾸는가?』를 각색한 SF 누아르의 금자탑입니다. 개봉 당시 상업적으로는 실패했지만, 시간이 지나면서 **인간 존재의 본질에 대한.",
      "date": "2025-08-10",
      "tags": [
        "블레이드러너",
        "리들리스콧",
        "필립K딕",
        "레플리칸트",
        "인공지능",
        "데카르트",
        "하이데거",
        "니체",
        "베르그송",
        "레비나스",
        "보드리야르",
        "아도르노",
        "SF누아르",
        "인간성",
        "존재론"
      ],
      "category": "사고와 인식",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "url": "/blog/2024/blade-runner-philosophy"
    },
    {
      "path": "/posts/2024/jung-psychology-cinema.md",
      "year": "2024",
      "slug": "jung-psychology-cinema",
      "title": "칼 융 내면 성찰에 관련된 영화들",
      "description": "칼 융의 분석심리학에서 핵심 개념인 **개성화(Individuation)**는 개인이 그림자를 통합하고 집단무의식에서 진정한 자아를 분리해 온전한 인간이 되는 여정을 가리킵니다. 융이 강조한 **내면의 강인함**은 외부 기준이나 집단 압력에 굴복하지 않고 내면 목소리에 따르는 용기에서 비롯됩니다. 아래 영화들은 이러한 융의 철학을 깊이 있게 반영한 작품들입",
      "snippet": "칼 융의 분석심리학에서 핵심 개념인 **개성화(Individuation)**는 개인이 그림자를 통합하고 집단무의식에서 진정한 자아를 분리해 온전한 인간이 되는 여정을 가리킵니다. 융이 강조한 **내면의 강인함**은 외부 기준이나 집단 압력에 굴복하지 않고 내면 목소리에 따르는 용기에서 비롯됩니다. 아래 영화들은 이러한 융의 철학을 깊이 있게 반영한 작품들입",
      "date": "2025-08-10",
      "tags": [
        "칼융",
        "개성화",
        "분석심리학",
        "집단무의식",
        "그림자",
        "아니마",
        "동시성",
        "내면강인함",
        "자아실현",
        "데인저러스메소드",
        "세렌디피티",
        "매트릭스",
        "작은아씨들",
        "디센트"
      ],
      "category": "사고와 인식",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/jung-psychology-cinema"
    },
    {
      "path": "/posts/2024/proxmox-qdevice-voting-problem-guide.md",
      "year": "2024",
      "slug": "proxmox-qdevice-voting-problem-guide",
      "title": "Proxmox QDevice 투표 문제에 대해서",
      "description": "Proxmox 클러스터에서 QDevice가 투표권을 갖지 못하는 문제 트러블슈팅",
      "snippet": "Proxmox 클러스터에서 QDevice가 투표권을 갖지 못하는 문제 트러블슈팅",
      "date": "2025-08-10",
      "tags": [
        "Proxmox",
        "QDevice",
        "클러스터",
        "쿼럼",
        "Raspberry Pi",
        "고가용성"
      ],
      "category": "Proxmox",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2024/proxmox-qdevice-voting-problem-guide"
    },
    {
      "path": "/posts/2025/mole-observation-diary.md",
      "year": "2025",
      "slug": "mole-observation-diary",
      "title": "두더지에 대해서..",
      "description": "# 두더지 관찰 일기\n\n## 개요\n이번 일기는 내가 두더지를 관찰한 경험을 기록한 것입니다. 두더지는 생태계에서 중요한 역할을 하는 포유류로, 그들의 행동과 생태적 의미를 이해하는 것은 매우 흥미로운 일이었습니다. 이 일기에서는 두더지의 서식지, 행동, 그리고 관찰한 내용을 중심으로 작성하겠습니다.\n\n## 1일차: 준비 과정\n오늘은 두더지를 관찰하기 위해",
      "snippet": "# 두더지 관찰 일기\n\n## 개요\n이번 일기는 내가 두더지를 관찰한 경험을 기록한 것입니다. 두더지는 생태계에서 중요한 역할을 하는 포유류로, 그들의 행동과 생태적 의미를 이해하는 것은 매우 흥미로운 일이었습니다. 이 일기에서는 두더지의 서식지, 행동, 그리고 관찰한 내용을 중심으로 작성하겠습니다.\n\n## 1일차: 준비 과정\n오늘은 두더지를 관찰하기 위해",
      "date": "2025-08-10",
      "tags": [
        "두더지",
        "dothechi"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/mole-observation-diary"
    },
    {
      "path": "/posts/2025/integration-04-microservices-deployment.md",
      "year": "2025",
      "slug": "integration-04-microservices-deployment",
      "title": "마이크로서비스 배포 전략 (이벤트 기반)",
      "description": "준비 중: 이벤트 기반 MSA, 버전 전략, Observability, Rollout 패턴.",
      "snippet": "준비 중: 이벤트 기반 MSA, 버전 전략, Observability, Rollout 패턴.",
      "date": "2025-03-05",
      "tags": [
        "DevOps",
        "Microservices",
        "Deployment",
        "Kafka",
        "Kubernetes"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/integration-04-microservices-deployment"
    },
    {
      "path": "/posts/2025/integration-03-k8s-kafka.md",
      "year": "2025",
      "slug": "integration-03-k8s-kafka",
      "title": "Kubernetes에서 Kafka 운영 전략",
      "description": "준비 중: Strimzi/옵저버빌리티/스토리지/토픽 운영.",
      "snippet": "준비 중: Strimzi/옵저버빌리티/스토리지/토픽 운영.",
      "date": "2025-03-04",
      "tags": [
        "DevOps",
        "Kubernetes",
        "Kafka",
        "운영"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/integration-03-k8s-kafka"
    },
    {
      "path": "/posts/2025/integration-02-terraform-k8s.md",
      "year": "2025",
      "slug": "integration-02-terraform-k8s",
      "title": "Terraform으로 Kubernetes 클러스터 프로비저닝",
      "description": "준비 중: Terraform + K8s 클러스터 EKS/모듈 설계 패턴.",
      "snippet": "준비 중: Terraform + K8s 클러스터 EKS/모듈 설계 패턴.",
      "date": "2025-03-03",
      "tags": [
        "DevOps",
        "Terraform",
        "Kubernetes",
        "Integration"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/integration-02-terraform-k8s"
    },
    {
      "path": "/posts/2025/kubernetes-05-statefulset-storage.md",
      "year": "2025",
      "slug": "kubernetes-05-statefulset-storage",
      "title": "Kubernetes StatefulSet과 스토리지",
      "description": "준비 중: 상태 저장 워크로드, PV/PVC, Headless Service, 스토리지 클래스.",
      "snippet": "준비 중: 상태 저장 워크로드, PV/PVC, Headless Service, 스토리지 클래스.",
      "date": "2025-02-26",
      "tags": [
        "DevOps",
        "Kubernetes",
        "StatefulSet",
        "Storage"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/kubernetes-05-statefulset-storage"
    },
    {
      "path": "/posts/2025/kubernetes-04-configmap-secret.md",
      "year": "2025",
      "slug": "kubernetes-04-configmap-secret",
      "title": "Kubernetes ConfigMap & Secret 활용",
      "description": "준비 중: 환경 구성/민감정보 주입, 볼륨 마운트와 보안 고려.",
      "snippet": "준비 중: 환경 구성/민감정보 주입, 볼륨 마운트와 보안 고려.",
      "date": "2025-02-25",
      "tags": [
        "DevOps",
        "Kubernetes",
        "ConfigMap",
        "Secret"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/kubernetes-04-configmap-secret"
    },
    {
      "path": "/posts/2025/kubernetes-03-services-networking.md",
      "year": "2025",
      "slug": "kubernetes-03-services-networking",
      "title": "Kubernetes Service와 네트워킹",
      "description": "준비 중: ClusterIP, NodePort, LoadBalancer, Ingress, DNS 내부 구조.",
      "snippet": "준비 중: ClusterIP, NodePort, LoadBalancer, Ingress, DNS 내부 구조.",
      "date": "2025-02-24",
      "tags": [
        "DevOps",
        "Kubernetes",
        "Service",
        "Networking"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/kubernetes-03-services-networking"
    },
    {
      "path": "/posts/2025/FutureClouding.md",
      "year": "2025",
      "slug": "FutureClouding",
      "title": "격자를 부수다: 폰 노이만 아키텍처의 종말과 그리드 시스템의 한계",
      "description": "우리가 당연하게 여겼던 중앙화된 '그리드' 시스템의 환상을 깨고, 폰 노이만 아키텍처의 근본적 한계를 넘어 분산형 미래로 나아가는 길을 제시합니다.",
      "snippet": "우리가 당연하게 여겼던 중앙화된 '그리드' 시스템의 환상을 깨고, 폰 노이만 아키텍처의 근본적 한계를 넘어 분산형 미래로 나아가는 길을 제시합니다.",
      "date": "2025-02-21",
      "tags": [
        "폰노이만아키텍처",
        "그리드시스템",
        "분산컴퓨팅",
        "엣지컴퓨팅",
        "블록체인"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/FutureClouding"
    },
    {
      "path": "/posts/2025/kafka-04-topics-partitions.md",
      "year": "2025",
      "slug": "kafka-04-topics-partitions",
      "title": "Kafka 토픽·파티션·스토리지 관리",
      "description": "준비 중: 파티션 설계, 리밸런싱, retention/compaction 전략.",
      "snippet": "준비 중: 파티션 설계, 리밸런싱, retention/compaction 전략.",
      "date": "2025-02-18",
      "tags": [
        "DevOps",
        "Kafka",
        "Topic",
        "Partition"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/kafka-04-topics-partitions"
    },
    {
      "path": "/posts/2025/kafka-03-producer-consumer.md",
      "year": "2025",
      "slug": "kafka-03-producer-consumer",
      "title": "Kafka Producer/Consumer 실습과 신뢰성 패턴",
      "description": "준비 중: acks, retries, idempotent producer, consumer offset 전략.",
      "snippet": "준비 중: acks, retries, idempotent producer, consumer offset 전략.",
      "date": "2025-02-17",
      "tags": [
        "DevOps",
        "Kafka",
        "Producer",
        "Consumer"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/kafka-03-producer-consumer"
    },
    {
      "path": "/posts/2025/ansible-04-roles.md",
      "year": "2025",
      "slug": "ansible-04-roles",
      "title": "Ansible Role 설계와 재사용성",
      "description": "Role 디렉터리를 생활 속 사례로 풀어내며 재사용성과 협업 패턴을 정리한 실습 에세이.",
      "snippet": "Role 디렉터리를 생활 속 사례로 풀어내며 재사용성과 협업 패턴을 정리한 실습 에세이.",
      "date": "2025-02-12",
      "tags": [
        "DevOps",
        "Ansible",
        "Role",
        "구조"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/ansible-04-roles"
    },
    {
      "path": "/posts/2025/ansible-03-playbook-examples.md",
      "year": "2025",
      "slug": "ansible-03-playbook-examples",
      "title": "Ansible Playbook 작성 실습 모음",
      "description": "첫 Playbook을 써 내려가며 겪은 시행착오와 재사용 패턴을 에세이처럼 풀어낸 실습 노트.",
      "snippet": "첫 Playbook을 써 내려가며 겪은 시행착오와 재사용 패턴을 에세이처럼 풀어낸 실습 노트.",
      "date": "2025-02-11",
      "tags": [
        "DevOps",
        "Ansible",
        "Playbook",
        "실습"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/ansible-03-playbook-examples"
    },
    {
      "path": "/posts/2025/ansible-02-inventory-basics.md",
      "year": "2025",
      "slug": "ansible-02-inventory-basics",
      "title": "Ansible Inventory 심화: 그룹/변수/패턴",
      "description": "Static/동적 인벤토리, 그룹 중첩, 변수 계층, 패턴 매칭, 환경 분리 전략까지 실전 정리",
      "snippet": "Static/동적 인벤토리, 그룹 중첩, 변수 계층, 패턴 매칭, 환경 분리 전략까지 실전 정리",
      "date": "2025-02-10",
      "tags": [
        "DevOps",
        "Ansible",
        "Inventory",
        "Pattern"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2025/ansible-02-inventory-basics"
    },
    {
      "path": "/posts/2025/terraform-04-variables-outputs.md",
      "year": "2025",
      "slug": "terraform-04-variables-outputs",
      "title": "Terraform 변수와 출력 고급 패턴",
      "description": "변수 타입/검증, locals, dynamic/for_each, map/object, 민감정보, 출력 패턴까지 실무형 레시피로 정리합니다.",
      "snippet": "변수 타입/검증, locals, dynamic/for_each, map/object, 민감정보, 출력 패턴까지 실무형 레시피로 정리합니다.",
      "date": "2025-02-04",
      "tags": [
        "DevOps",
        "Terraform",
        "Variables",
        "Outputs"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/terraform-04-variables-outputs"
    },
    {
      "path": "/posts/2025/terraform-03-state-management.md",
      "year": "2025",
      "slug": "terraform-03-state-management",
      "title": "Terraform 상태 관리와 모듈화",
      "description": "Terraform state 원격 백엔드, 잠금(lock), drift 감지, 워크스페이스 전략과 모듈화 베스트 프랙티스를 손에 잡히게 정리합니다.",
      "snippet": "Terraform state 원격 백엔드, 잠금(lock), drift 감지, 워크스페이스 전략과 모듈화 베스트 프랙티스를 손에 잡히게 정리합니다.",
      "date": "2025-02-03",
      "tags": [
        "DevOps",
        "Terraform",
        "State",
        "Module"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/terraform-03-state-management"
    },
    {
      "path": "/posts/2024/dark-city-existentialism.md",
      "year": "2024",
      "slug": "dark-city-existentialism",
      "title": "다크시티(Dark City, 1998) - 실존주의 철학으로 읽는 SF 걸작",
      "description": "# 다크시티(Dark City, 1998) - 실존주의 철학으로 읽는 SF 걸작\n\n## 영화 개관\n\n**다크시티**는 1998년 알렉스 프로야스 감독이 선보인 SF 누아르 영화로, 매트릭스보다 1년 앞서 시뮬레이션 현실이라는 혁신적 개념을 다룬 숨겨진 걸작입니다. 하지만 이 영화의 진정한 가치는 단순한 SF적 상상력을 넘어, **실존주의 철학의 핵심 명제들",
      "snippet": "# 다크시티(Dark City, 1998) - 실존주의 철학으로 읽는 SF 걸작\n\n## 영화 개관\n\n**다크시티**는 1998년 알렉스 프로야스 감독이 선보인 SF 누아르 영화로, 매트릭스보다 1년 앞서 시뮬레이션 현실이라는 혁신적 개념을 다룬 숨겨진 걸작입니다. 하지만 이 영화의 진정한 가치는 단순한 SF적 상상력을 넘어, **실존주의 철학의 핵심 명제들",
      "date": "2025-01-24T07:30:00.000Z",
      "tags": [
        "다크시티",
        "실존주의",
        "사르트르",
        "키에르케고르",
        "카뮈",
        "하이데거",
        "니체",
        "SF누아르",
        "알렉스프로야스",
        "시뮬레이션현실",
        "자유의지",
        "정체성"
      ],
      "category": "General",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/dark-city-existentialism"
    },
    {
      "path": "/posts/2024/brazil-1985-review.md",
      "year": "2024",
      "slug": "brazil-1985-review",
      "title": "브라질(Brazil, 1985) - 현대 문명에 대한 철학적 절망과 저항의 서사",
      "description": "# 브라질(Brazil, 1985) - 현대 문명에 대한 철학적 절망과 저항의 서사\n\n## 영화 개관과 감독의 비전\n\n**브라질**은 1985년 테리 길리엄 감독이 선보인 디스토피아 SF 블랙 코미디로, 조지 오웰의 『1984』를 넘어서는 현대 문명 비판의 걸작입니다[1]. 길리엄은 이 작품을 통해 **관료제가 미쳐버린 산업 세계에 대한 평생의 분노**를",
      "snippet": "# 브라질(Brazil, 1985) - 현대 문명에 대한 철학적 절망과 저항의 서사\n\n## 영화 개관과 감독의 비전\n\n**브라질**은 1985년 테리 길리엄 감독이 선보인 디스토피아 SF 블랙 코미디로, 조지 오웰의 『1984』를 넘어서는 현대 문명 비판의 걸작입니다[1]. 길리엄은 이 작품을 통해 **관료제가 미쳐버린 산업 세계에 대한 평생의 분노**를",
      "date": "2025-01-24T06:30:00.000Z",
      "tags": [
        "테리 길리엄",
        "브라질",
        "디스토피아",
        "블랙코미디",
        "SF영화",
        "관료제",
        "카프카",
        "철학적영화",
        "1985년",
        "프랑크푸르트학파",
        "감시사회",
        "현대문명비판"
      ],
      "category": "General",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "url": "/blog/2024/brazil-1985-review"
    },
    {
      "path": "/posts/2025/BankRuptIn1929.md",
      "year": "2025",
      "slug": "BankRuptIn1929",
      "title": "왜 Bank of America는 있는데, Bank of United States는 없을까?",
      "description": "1929년 뉴욕 퀸즈에서 한 은행 앞에 몰린 예금자 행렬은 미국 금융사의 결정적 장면으로 남았다. 이름만 보면 국립은행처럼 신뢰를 줬던 Bank of United States는 단 며칠 사이에 무너졌고, 그 여파는 대공황을 더욱 깊게 만들었다. 이 글은 1929년 정점에서 1933년 바닥까지, 기업의 재무 데이터를 따라가며 생존과 몰락의 서사를 재구성한다.",
      "snippet": "1929년 뉴욕 퀸즈에서 한 은행 앞에 몰린 예금자 행렬은 미국 금융사의 결정적 장면으로 남았다. 이름만 보면 국립은행처럼 신뢰를 줬던 Bank of United States는 단 며칠 사이에 무너졌고, 그 여파는 대공황을 더욱 깊게 만들었다. 이 글은 1929년 정점에서 1933년 바닥까지, 기업의 재무 데이터를 따라가며 생존과 몰락의 서사를 재구성한다.",
      "date": "2025-01-20",
      "tags": [
        "대공황",
        "기업사",
        "재무데이터",
        "은행위기",
        "생존전략"
      ],
      "category": "History",
      "author": "Admin",
      "readingTime": "9 min read",
      "published": true,
      "url": "/blog/2025/BankRuptIn1929"
    },
    {
      "path": "/posts/2025/integration-01-devops-pipeline.md",
      "year": "2025",
      "slug": "integration-01-devops-pipeline",
      "title": "DevOps 통합 실습: Terraform · Ansible · Kubernetes · Kafka",
      "description": "네 가지 도구를 연결해 인프라 프로비저닝→설정 자동화→클러스터 구성→Kafka+마이크로서비스 배포까지 단일 파이프라인 시나리오.",
      "snippet": "네 가지 도구를 연결해 인프라 프로비저닝→설정 자동화→클러스터 구성→Kafka+마이크로서비스 배포까지 단일 파이프라인 시나리오.",
      "date": "2025-01-20",
      "tags": [
        "DevOps",
        "Terraform",
        "Ansible",
        "Kubernetes",
        "Kafka",
        "Pipeline"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/integration-01-devops-pipeline"
    },
    {
      "path": "/posts/2025/kubernetes-02-pods-deployments.md",
      "year": "2025",
      "slug": "kubernetes-02-pods-deployments",
      "title": "Kubernetes Pod와 Deployment 핵심 실습",
      "description": "단일/멀티 컨테이너 Pod, Deployment 생성·스케일·롤링 업데이트·롤백·레이블·셀렉터·Probe까지 실무 핵심 정리.",
      "snippet": "단일/멀티 컨테이너 Pod, Deployment 생성·스케일·롤링 업데이트·롤백·레이블·셀렉터·Probe까지 실무 핵심 정리.",
      "date": "2025-01-17",
      "tags": [
        "DevOps",
        "Kubernetes",
        "Pod",
        "Deployment",
        "실습"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/kubernetes-02-pods-deployments"
    },
    {
      "path": "/posts/2025/QuantumLayerLLM.md",
      "year": "2025",
      "slug": "QuantumLayerLLM",
      "title": "양자 얽힘으로 AI의 애매모호함 해결하기: 양자 기계 학습의 미래",
      "description": "양자역학의 얽힘 원리를 활용해 딥러닝 레이어 간 애매모호함을 해결하는 혁명적 접근법",
      "snippet": "양자역학의 얽힘 원리를 활용해 딥러닝 레이어 간 애매모호함을 해결하는 혁명적 접근법",
      "date": "2025-01-16",
      "tags": [
        "양자컴퓨팅",
        "AI",
        "양자기계학습",
        "QML",
        "양자얽힘"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/QuantumLayerLLM"
    },
    {
      "path": "/posts/2025/kubernetes-01-cluster-setup.md",
      "year": "2025",
      "slug": "kubernetes-01-cluster-setup",
      "title": "Kubernetes 로컬 클러스터 설치 (minikube·kind·Docker Desktop)",
      "description": "minikube, kind, Docker Desktop 세 가지 방법으로 로컬 K8s 클러스터 구성하고 kubectl 기본 명령을 익힌다.",
      "snippet": "minikube, kind, Docker Desktop 세 가지 방법으로 로컬 K8s 클러스터 구성하고 kubectl 기본 명령을 익힌다.",
      "date": "2025-01-16",
      "tags": [
        "DevOps",
        "Kubernetes",
        "Cluster",
        "minikube",
        "kind"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/kubernetes-01-cluster-setup"
    },
    {
      "path": "/posts/2025/kafka-02-installation-setup.md",
      "year": "2025",
      "slug": "kafka-02-installation-setup",
      "title": "Kafka 로컬 설치: Docker & 네이티브",
      "description": "Docker Compose로 3 Broker 클러스터 구성과 네이티브 설치 두 가지 방식 비교, 기본 명령어/Topic/Consumer Group 실습.",
      "snippet": "Docker Compose로 3 Broker 클러스터 구성과 네이티브 설치 두 가지 방식 비교, 기본 명령어/Topic/Consumer Group 실습.",
      "date": "2025-01-15",
      "tags": [
        "DevOps",
        "Kafka",
        "설치",
        "Docker",
        "실습"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2025/kafka-02-installation-setup"
    },
    {
      "path": "/posts/2025/kafka-01-concepts-architecture.md",
      "year": "2025",
      "slug": "kafka-01-concepts-architecture",
      "title": "Kafka 핵심 개념과 아키텍처",
      "description": "Topic, Partition, Broker, Replication, Producer/Consumer와 Consumer Group까지 Kafka 구조를 시각적으로 이해.",
      "snippet": "Topic, Partition, Broker, Replication, Producer/Consumer와 Consumer Group까지 Kafka 구조를 시각적으로 이해.",
      "date": "2025-01-14",
      "tags": [
        "DevOps",
        "Kafka",
        "Streaming",
        "아키텍처",
        "초급"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/kafka-01-concepts-architecture"
    },
    {
      "path": "/posts/2025/ansible-01-installation-setup.md",
      "year": "2025",
      "slug": "ansible-01-installation-setup",
      "title": "Ansible 설치와 첫 Inventory 구성",
      "description": "패키지 설치부터 SSH 키, Inventory 작성, Ad-hoc 명령(ping, shell) 실행까지 Ansible 입문 필수 흐름.",
      "snippet": "패키지 설치부터 SSH 키, Inventory 작성, Ad-hoc 명령(ping, shell) 실행까지 Ansible 입문 필수 흐름.",
      "date": "2025-01-13",
      "tags": [
        "DevOps",
        "Ansible",
        "자동화",
        "Inventory",
        "초급"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/ansible-01-installation-setup"
    },
    {
      "path": "/posts/2025/terraform-02-aws-ec2-example.md",
      "year": "2025",
      "slug": "terraform-02-aws-ec2-example",
      "title": "Terraform로 AWS EC2 배포 실습",
      "description": "VPC, Subnet, Security Group, EC2, User Data까지 포함한 AWS 웹 서버 인프라를 Terraform으로 단계별 구성.",
      "snippet": "VPC, Subnet, Security Group, EC2, User Data까지 포함한 AWS 웹 서버 인프라를 Terraform으로 단계별 구성.",
      "date": "2025-01-10",
      "tags": [
        "DevOps",
        "Terraform",
        "AWS",
        "EC2",
        "실습"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/terraform-02-aws-ec2-example"
    },
    {
      "path": "/posts/2025/terraform-01-basic-setup.md",
      "year": "2025",
      "slug": "terraform-01-basic-setup",
      "title": "Terraform 기본 설정과 첫 리소스",
      "description": "Terraform 설치부터 첫 local_file 리소스 생성까지 필수 워크플로우(init, plan, apply, destroy)를 단계별로 정리.",
      "snippet": "Terraform 설치부터 첫 local_file 리소스 생성까지 필수 워크플로우(init, plan, apply, destroy)를 단계별로 정리.",
      "date": "2025-01-09",
      "tags": [
        "DevOps",
        "Terraform",
        "IaC",
        "초급",
        "실습"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/terraform-01-basic-setup"
    },
    {
      "path": "/posts/2025/devops-toolchain-overview.md",
      "year": "2025",
      "slug": "devops-toolchain-overview",
      "title": "DevOps 시리즈 개요: Terraform · Ansible · Kafka · Kubernetes",
      "description": "DevOps 시리즈 전체 구조와 학습 로드맵을 한눈에 정리한 개요 글.",
      "snippet": "DevOps 시리즈 전체 구조와 학습 로드맵을 한눈에 정리한 개요 글.",
      "date": "2025-01-08",
      "tags": [
        "DevOps",
        "Terraform",
        "Ansible",
        "Kafka",
        "Kubernetes",
        "Series"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/devops-toolchain-overview"
    },
    {
      "path": "/posts/2025/latest.md",
      "year": "2025",
      "slug": "latest",
      "title": "최신 게시글",
      "description": "",
      "snippet": "",
      "date": "2025-01-07",
      "tags": [],
      "category": "기술",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2025/latest"
    },
    {
      "path": "/posts/2025/middle-east-ai-conflicts.md",
      "year": "2025",
      "slug": "middle-east-ai-conflicts",
      "title": "중동 지역 AI 도입으로 생긴 새로운 갈등들을 보면서 드는 생각",
      "description": "중동 지역의 AI 기술 도입이 어떤 새로운 갈등 구조를 만들어내고 있는지 분석해본 내용",
      "snippet": "중동 지역의 AI 기술 도입이 어떤 새로운 갈등 구조를 만들어내고 있는지 분석해본 내용",
      "date": "2025-01-04",
      "tags": [
        "중동",
        "AI",
        "지정학",
        "기술패권",
        "디지털권위주의",
        "사이버보안"
      ],
      "category": "Technology",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/middle-east-ai-conflicts"
    },
    {
      "path": "/posts/2025/AdversialNeuron.md",
      "year": "2025",
      "slug": "AdversialNeuron",
      "title": "AdversialNeuron",
      "description": "# Adversarial Neuron Ablation for Variant-Sensitive Genomic Embeddings\n\n**nodove**\n\n---\n\n## Abstract\n\nGenomic language models (gLMs) have shown remarkable capability in learning compressed representat",
      "snippet": "# Adversarial Neuron Ablation for Variant-Sensitive Genomic Embeddings\n\n**nodove**\n\n---\n\n## Abstract\n\nGenomic language models (gLMs) have shown remarkable capability in learning compressed representat",
      "date": "2025-01-01",
      "tags": [],
      "category": "General",
      "author": "Admin",
      "readingTime": "11 min read",
      "published": true,
      "url": "/blog/2025/AdversialNeuron"
    },
    {
      "path": "/posts/2025/memory-management-study.md",
      "year": "2025",
      "slug": "memory-management-study",
      "title": "메모리 관리 공부하다가 깨달은 페이징 시스템의 진짜 장점",
      "description": "운영체제 메모리 관리를 공부하면서 페이징과 스와핑이 왜 필요했는지 이해한 과정",
      "snippet": "운영체제 메모리 관리를 공부하면서 페이징과 스와핑이 왜 필요했는지 이해한 과정",
      "date": "2025-01-01",
      "tags": [
        "메모리관리",
        "페이징",
        "MMU",
        "스와핑",
        "운영체제"
      ],
      "category": "Computer Science",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/memory-management-study"
    },
    {
      "path": "/posts/2024/react-native-springboot-mongodb-diary-app.md",
      "year": "2024",
      "slug": "react-native-springboot-mongodb-diary-app",
      "title": "React Native + Spring Boot + MongoDB로 일기 앱 만들기",
      "description": "React Native 클라이언트와 Spring Boot 백엔드, Python AI 서버를 연동해서 일기 앱을 만든 경험",
      "snippet": "React Native 클라이언트와 Spring Boot 백엔드, Python AI 서버를 연동해서 일기 앱을 만든 경험",
      "date": "2024-12-28",
      "tags": [
        "React Native",
        "Spring Boot",
        "MongoDB",
        "Python",
        "AI",
        "일기앱"
      ],
      "category": "개발",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/react-native-springboot-mongodb-diary-app"
    },
    {
      "path": "/posts/2025/git-submodule-guide.md",
      "year": "2025",
      "slug": "git-submodule-guide",
      "title": "Git 서브모듈, 진짜 쓸 만한 걸까?",
      "description": "Git 서브모듈을 실제 프로젝트에서 써본 후기와 실용적인 사용법 정리",
      "snippet": "Git 서브모듈을 실제 프로젝트에서 써본 후기와 실용적인 사용법 정리",
      "date": "2024-12-25",
      "tags": [
        "Git",
        "서브모듈",
        "버전관리",
        "개발도구",
        "프로젝트관리"
      ],
      "category": "개발",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/git-submodule-guide"
    },
    {
      "path": "/posts/2024/knapsack.md",
      "year": "2024",
      "slug": "knapsack",
      "title": "배낭 문제 (Knapsack Problem)",
      "description": "0-1 배낭 문제와 무한 배낭 문제를 동적 계획법으로 해결하는 다양한 방법을 학습합니다.",
      "snippet": "0-1 배낭 문제와 무한 배낭 문제를 동적 계획법으로 해결하는 다양한 방법을 학습합니다.",
      "date": "2024-12-21",
      "tags": [
        "Knapsack",
        "배낭문제",
        "동적계획법",
        "최적화"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/knapsack"
    },
    {
      "path": "/posts/2024/prime-numbers.md",
      "year": "2024",
      "slug": "prime-numbers",
      "title": "소수 판별과 소인수분해 알고리즘",
      "description": "효율적인 소수 판별과 소인수분해를 위한 다양한 수학 알고리즘들을 학습합니다.",
      "snippet": "효율적인 소수 판별과 소인수분해를 위한 다양한 수학 알고리즘들을 학습합니다.",
      "date": "2024-12-17",
      "tags": [
        "소수",
        "에라토스테네스의체",
        "소인수분해",
        "밀러라빈"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/prime-numbers"
    },
    {
      "path": "/posts/2024/firebase-hosting-guide.md",
      "year": "2024",
      "slug": "firebase-hosting-guide",
      "title": "Flutter 웹앱을 Firebase에 무료로 배포하기",
      "description": "Flutter 웹앱을 Firebase Hosting에 배포하는 방법을 실제 경험을 바탕으로 단계별 설명",
      "snippet": "Flutter 웹앱을 Firebase Hosting에 배포하는 방법을 실제 경험을 바탕으로 단계별 설명",
      "date": "2024-12-14",
      "tags": [
        "Flutter",
        "Firebase",
        "Hosting",
        "웹배포",
        "개발"
      ],
      "category": "개발",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/firebase-hosting-guide"
    },
    {
      "path": "/posts/2024/dfs.md",
      "year": "2024",
      "slug": "dfs",
      "title": "깊이 우선 탐색 (DFS, Depth-First Search)",
      "description": "깊이 우선 탐색(DFS) 알고리즘의 원리와 구현, 다양한 응용 문제 해결법을 학습합니다.",
      "snippet": "깊이 우선 탐색(DFS) 알고리즘의 원리와 구현, 다양한 응용 문제 해결법을 학습합니다.",
      "date": "2024-12-11",
      "tags": [
        "DFS",
        "그래프",
        "탐색",
        "재귀",
        "스택"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/dfs"
    },
    {
      "path": "/posts/2024/lis.md",
      "year": "2024",
      "slug": "lis",
      "title": "최장 증가 부분 수열 (LIS, Longest Increasing Subsequence)",
      "description": "최장 증가 부분 수열(LIS) 문제를 동적 계획법과 이분 탐색으로 효율적으로 해결하는 방법을 학습합니다.",
      "snippet": "최장 증가 부분 수열(LIS) 문제를 동적 계획법과 이분 탐색으로 효율적으로 해결하는 방법을 학습합니다.",
      "date": "2024-12-08",
      "tags": [
        "LIS",
        "동적계획법",
        "이분탐색",
        "부분수열"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/lis"
    },
    {
      "path": "/posts/2024/binary-search.md",
      "year": "2024",
      "slug": "binary-search",
      "title": "이진 탐색(Binary Search) 완전 정복",
      "description": "정렬된 배열에서 O(log n) 시간에 원소를 찾는 이진 탐색의 모든 것",
      "snippet": "정렬된 배열에서 O(log n) 시간에 원소를 찾는 이진 탐색의 모든 것",
      "date": "2024-12-05",
      "tags": [
        "이진탐색",
        "탐색",
        "분할정복",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/binary-search"
    },
    {
      "path": "/posts/2024/os-study-notes.md",
      "year": "2024",
      "slug": "os-study-notes",
      "title": "운영체제 공부하면서 헷갈렸던 핵심 개념들 정리",
      "description": "운영체제 공부하면서 반복해서 헷갈렸던 개념들을 정리해본 개인 노트",
      "snippet": "운영체제 공부하면서 반복해서 헷갈렸던 개념들을 정리해본 개인 노트",
      "date": "2024-12-01",
      "tags": [
        "OS",
        "CPU 스케줄링",
        "메모리 관리",
        "교착상태",
        "공부 노트"
      ],
      "category": "Computer Science",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/os-study-notes"
    },
    {
      "path": "/posts/2025/QueryDSL.md",
      "year": "2025",
      "slug": "QueryDSL",
      "title": "SpringBoot 3.x.x + QueryDSL 6.x.x 사용기",
      "description": "스프링부트 3.x.x 버전에 QueryDSL 6.x.x 최신 버전 사용 방법",
      "snippet": "스프링부트 3.x.x 버전에 QueryDSL 6.x.x 최신 버전 사용 방법",
      "date": "2024-11-27",
      "tags": [
        "QueryDSL",
        "스프링부트",
        "springboot+queryDSL",
        "쿼리DSL",
        "openfeign.querydsl",
        "querydsl fork",
        "queryDSL openfeign"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2025/QueryDSL"
    },
    {
      "path": "/posts/2025/ai-models-for-coding.md",
      "year": "2025",
      "slug": "ai-models-for-coding",
      "title": "코딩용 AI 모델, 어떤 걸 써야 할까?",
      "description": "개발자 입장에서 GPT, Claude, Gemini 등 주요 AI 모델들을 실제로 써보고 비교해본 후기",
      "snippet": "개발자 입장에서 GPT, Claude, Gemini 등 주요 AI 모델들을 실제로 써보고 비교해본 후기",
      "date": "2024-11-23",
      "tags": [
        "AI",
        "개발",
        "GPT",
        "Claude",
        "Gemini",
        "코딩"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/ai-models-for-coding"
    },
    {
      "path": "/posts/2024/gemini-gui-dev-tool-idea.md",
      "year": "2024",
      "slug": "gemini-gui-dev-tool-idea",
      "title": "Gemini-CLI를 GUI로? 비개발자도 쓸 수 있는 AI 개발도구 아이디어",
      "description": "Gemini-CLI를 Flutter로 감싸서 비개발자도 쉽게 앱을 만들 수 있는 도구를 만들면 어떨까?",
      "snippet": "Gemini-CLI를 Flutter로 감싸서 비개발자도 쉽게 앱을 만들 수 있는 도구를 만들면 어떨까?",
      "date": "2024-11-19",
      "tags": [
        "Gemini-CLI",
        "Flutter",
        "GUI",
        "AI개발도구",
        "앱개발",
        "아이디어"
      ],
      "category": "Development",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/gemini-gui-dev-tool-idea"
    },
    {
      "path": "/posts/2024/algorithm-atelier-binary-search.md",
      "year": "2024",
      "slug": "algorithm-atelier-binary-search",
      "title": "알고리즘 아틀리에: 이분 탐색 — 5단계 직관 학습",
      "description": "단조성 위에 세운 불변식과 범위 수축 — 답을 직접 찾지 말고 조건을 이분합니다.",
      "snippet": "단조성 위에 세운 불변식과 범위 수축 — 답을 직접 찾지 말고 조건을 이분합니다.",
      "date": "2024-11-18",
      "tags": [
        "이분탐색",
        "Binary Search",
        "단조성",
        "파라메트릭 서치",
        "알고리즘 아틀리에"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/algorithm-atelier-binary-search"
    },
    {
      "path": "/posts/2024/algorithm-atelier-dp.md",
      "year": "2024",
      "slug": "algorithm-atelier-dp",
      "title": "알고리즘 아틀리에: 동적 계획법(DP) — 5단계 직관 학습",
      "description": "반복되는 하위 문제와 최적 부분 구조를 비유로 깨닫고, 점화식→테이블→코드로 잇습니다.",
      "snippet": "반복되는 하위 문제와 최적 부분 구조를 비유로 깨닫고, 점화식→테이블→코드로 잇습니다.",
      "date": "2024-11-17",
      "tags": [
        "DP",
        "동적계획법",
        "메모이제이션",
        "점화식",
        "알고리즘 아틀리에"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/algorithm-atelier-dp"
    },
    {
      "path": "/posts/2024/algorithm-atelier-bfs.md",
      "year": "2024",
      "slug": "algorithm-atelier-bfs",
      "title": "알고리즘 아틀리에: BFS — 5단계 직관 학습",
      "description": "물결 비유로 시작해 큐 기반 레이어 탐색의 원리와 코드를 연결합니다.",
      "snippet": "물결 비유로 시작해 큐 기반 레이어 탐색의 원리와 코드를 연결합니다.",
      "date": "2024-11-16",
      "tags": [
        "BFS",
        "그래프",
        "최단경로(무가중치)",
        "큐",
        "알고리즘 아틀리에"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/algorithm-atelier-bfs"
    },
    {
      "path": "/posts/2024/algorithm-atelier-dijkstra.md",
      "year": "2024",
      "slug": "algorithm-atelier-dijkstra",
      "title": "알고리즘 아틀리에: 다익스트라 — 5단계 직관 학습",
      "description": "비유→원리→메커니즘→자료구조→코드로 다익스트라를 직관적으로 체득합니다.",
      "snippet": "비유→원리→메커니즘→자료구조→코드로 다익스트라를 직관적으로 체득합니다.",
      "date": "2024-11-15",
      "tags": [
        "다익스트라",
        "최단경로",
        "그래프",
        "우선순위 큐",
        "알고리즘 아틀리에"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/algorithm-atelier-dijkstra"
    },
    {
      "path": "/posts/2024/bfs.md",
      "year": "2024",
      "slug": "bfs",
      "title": "BFS (너비 우선 탐색) 완전 정복",
      "description": "큐를 이용한 레벨별 그래프 탐색과 최단 경로 알고리즘의 핵심",
      "snippet": "큐를 이용한 레벨별 그래프 탐색과 최단 경로 알고리즘의 핵심",
      "date": "2024-11-15",
      "tags": [
        "BFS",
        "그래프",
        "탐색",
        "최단경로",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/bfs"
    },
    {
      "path": "/posts/2024/arch-linux-gui-setup-experience.md",
      "year": "2024",
      "slug": "arch-linux-gui-setup-experience",
      "title": "아치 리눅스 설치하면서 깨달은 GUI 환경 선택의 중요성",
      "description": "아치 리눅스 설치 과정에서 데스크톱 환경을 선택하면서 느낀 점들과 각 환경의 특징",
      "snippet": "아치 리눅스 설치 과정에서 데스크톱 환경을 선택하면서 느낀 점들과 각 환경의 특징",
      "date": "2024-11-12",
      "tags": [
        "ArchLinux",
        "UEFI",
        "KDE",
        "GNOME",
        "i3wm",
        "Hyprland",
        "리눅스설치"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/arch-linux-gui-setup-experience"
    },
    {
      "path": "/posts/2024/kmp.md",
      "year": "2024",
      "slug": "kmp",
      "title": "KMP 알고리즘 (Knuth-Morris-Pratt)",
      "description": "KMP 알고리즘을 통해 문자열 패턴 매칭을 효율적으로 수행하는 방법과 실패 함수의 원리를 학습합니다.",
      "snippet": "KMP 알고리즘을 통해 문자열 패턴 매칭을 효율적으로 수행하는 방법과 실패 함수의 원리를 학습합니다.",
      "date": "2024-11-08",
      "tags": [
        "KMP",
        "문자열매칭",
        "패턴매칭",
        "실패함수"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/kmp"
    },
    {
      "path": "/posts/2024/rabin-karp.md",
      "year": "2024",
      "slug": "rabin-karp",
      "title": "라빈-카프 알고리즘 (Rabin-Karp Algorithm)",
      "description": "라빈-카프 알고리즘을 통해 해싱을 활용한 효율적인 문자열 패턴 매칭과 롤링 해시 기법을 학습합니다.",
      "snippet": "라빈-카프 알고리즘을 통해 해싱을 활용한 효율적인 문자열 패턴 매칭과 롤링 해시 기법을 학습합니다.",
      "date": "2024-11-05",
      "tags": [
        "Rabin-Karp",
        "해싱",
        "문자열매칭",
        "롤링해시"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/rabin-karp"
    },
    {
      "path": "/posts/2024/arch-linux-uefi-guide.md",
      "year": "2024",
      "slug": "arch-linux-uefi-guide",
      "title": "아치 리눅스 설치하고 예쁘게 꾸미기",
      "description": "아치 리눅스 UEFI 설치부터 데스크톱 꾸미기까지 실제 경험을 바탕으로 정리",
      "snippet": "아치 리눅스 UEFI 설치부터 데스크톱 꾸미기까지 실제 경험을 바탕으로 정리",
      "date": "2024-11-01",
      "tags": [
        "Linux",
        "Arch Linux",
        "UEFI",
        "데스크톱 환경",
        "커스터마이징"
      ],
      "category": "시스템",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/arch-linux-uefi-guide"
    },
    {
      "path": "/posts/2024/quick-sort.md",
      "year": "2024",
      "slug": "quick-sort",
      "title": "퀵 정렬(Quick Sort) 완전 정복",
      "description": "분할 정복을 이용한 최고 성능의 정렬 알고리즘, 퀵 정렬의 모든 것",
      "snippet": "분할 정복을 이용한 최고 성능의 정렬 알고리즘, 퀵 정렬의 모든 것",
      "date": "2024-10-27",
      "tags": [
        "퀵정렬",
        "정렬",
        "분할정복",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/quick-sort"
    },
    {
      "path": "/posts/2025/dijkstra.md",
      "year": "2025",
      "slug": "dijkstra",
      "title": "다익스트라 알고리즘 (Dijkstra's Algorithm)",
      "description": "다익스트라 알고리즘을 통해 가중 그래프에서의 최단 경로를 효율적으로 찾는 방법을 학습합니다.",
      "snippet": "다익스트라 알고리즘을 통해 가중 그래프에서의 최단 경로를 효율적으로 찾는 방법을 학습합니다.",
      "date": "2024-10-25",
      "tags": [
        "Dijkstra",
        "최단경로",
        "우선순위큐",
        "그래프"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/dijkstra"
    },
    {
      "path": "/posts/2024/queue.md",
      "year": "2024",
      "slug": "queue",
      "title": "큐(Queue) 완전 정복",
      "description": "FIFO 구조의 큐 자료구조 개념부터 우선순위 큐까지 완벽 가이드",
      "snippet": "FIFO 구조의 큐 자료구조 개념부터 우선순위 큐까지 완벽 가이드",
      "date": "2024-10-22",
      "tags": [
        "큐",
        "자료구조",
        "FIFO",
        "BFS",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/queue"
    },
    {
      "path": "/posts/2024/stack.md",
      "year": "2024",
      "slug": "stack",
      "title": "스택(Stack) 완전 정복",
      "description": "LIFO 구조의 스택 자료구조 개념부터 실전 활용까지 완벽 가이드",
      "snippet": "LIFO 구조의 스택 자료구조 개념부터 실전 활용까지 완벽 가이드",
      "date": "2024-10-15",
      "tags": [
        "스택",
        "자료구조",
        "LIFO",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/stack"
    },
    {
      "path": "/posts/2025/python-ai-chatbot-development.md",
      "year": "2025",
      "slug": "python-ai-chatbot-development",
      "title": "Python으로 AI 챗봇 만들기",
      "description": "OpenAI API를 활용하여 실용적인 AI 챗봇을 구현하는 과정을 단계별로 설명합니다.",
      "snippet": "OpenAI API를 활용하여 실용적인 AI 챗봇을 구현하는 과정을 단계별로 설명합니다.",
      "date": "2024-10-11",
      "tags": [
        "Python",
        "AI",
        "Chatbot",
        "OpenAI"
      ],
      "category": "AI/ML",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/python-ai-chatbot-development"
    },
    {
      "path": "/posts/2024/react-nextjs-modern-web-development.md",
      "year": "2024",
      "slug": "react-nextjs-modern-web-development",
      "title": "React와 Next.js로 모던 웹 개발하기",
      "description": "최신 React 기능과 Next.js의 장점을 활용한 웹 개발 방법론을 소개합니다.",
      "snippet": "최신 React 기능과 Next.js의 장점을 활용한 웹 개발 방법론을 소개합니다.",
      "date": "2024-10-08",
      "tags": [
        "React",
        "Next.js",
        "JavaScript",
        "Frontend"
      ],
      "category": "Web Development",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/react-nextjs-modern-web-development"
    },
    {
      "path": "/posts/2024/docker-kubernetes-guide.md",
      "year": "2024",
      "slug": "docker-kubernetes-guide",
      "title": "Docker와 Kubernetes 삽질기",
      "description": "컨테이너 기술의 핵심인 Docker와 오케스트레이션 도구 Kubernetes 활용법을 다룹니다.",
      "snippet": "컨테이너 기술의 핵심인 Docker와 오케스트레이션 도구 Kubernetes 활용법을 다룹니다.",
      "date": "2024-10-04",
      "tags": [
        "Docker",
        "Kubernetes",
        "DevOps",
        "Container"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/docker-kubernetes-guide"
    },
    {
      "path": "/posts/2024/opensource-schedule-management-analysis.md",
      "year": "2024",
      "slug": "opensource-schedule-management-analysis",
      "title": "비개발자를 위한 오픈소스 스케줄 관리 도구 완전 분석",
      "description": "레딧 사용자 만족도가 높은 비개발자용 스케줄 관리 오픈소스 도구들을 Docker 컨테이너 기반으로 심층 분석합니다.",
      "snippet": "레딧 사용자 만족도가 높은 비개발자용 스케줄 관리 오픈소스 도구들을 Docker 컨테이너 기반으로 심층 분석합니다.",
      "date": "2024-10-01",
      "tags": [
        "스케줄 관리",
        "Docker",
        "오픈소스",
        "Easy!Appointments",
        "Cal.com",
        "Plane"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/opensource-schedule-management-analysis"
    },
    {
      "path": "/posts/2024/7.md",
      "year": "2024",
      "slug": "7",
      "title": "인텔 486: 컴퓨팅의 혁명",
      "description": "개인용 컴퓨팅을 변화시킨 인텔 486 마이크로프로세서에 대한 역사적인 고찰.",
      "snippet": "개인용 컴퓨팅을 변화시킨 인텔 486 마이크로프로세서에 대한 역사적인 고찰.",
      "date": "2024-09-27",
      "tags": [
        "인텔",
        "486",
        "컴퓨팅 역사"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "coverImage": "/images/2025/intelDX2.png",
      "url": "/blog/2024/7"
    },
    {
      "path": "/posts/2024/week3-4.md",
      "year": "2024",
      "slug": "week3-4",
      "title": "3-4주차: 정렬 및 탐색 기법",
      "description": "핵심 정렬 알고리즘과 이진 탐색을 마스터하여 효율적인 데이터 처리의 기초를 다진다",
      "snippet": "핵심 정렬 알고리즘과 이진 탐색을 마스터하여 효율적인 데이터 처리의 기초를 다진다",
      "date": "2024-09-23",
      "tags": [
        "정렬",
        "탐색",
        "이진탐색",
        "시간복잡도",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week3-4"
    },
    {
      "path": "/posts/2024/multimodal-recommendation-system-research.md",
      "year": "2024",
      "slug": "multimodal-recommendation-system-research",
      "title": "웹 기반 다중 모달 추천 시스템 연구",
      "description": "텍스트, 이미지, 영상 데이터를 종합적으로 처리하는 하이브리드 추천 시스템의 알고리즘 설계와 구현 방법에 대한 심화 연구입니다.",
      "snippet": "텍스트, 이미지, 영상 데이터를 종합적으로 처리하는 하이브리드 추천 시스템의 알고리즘 설계와 구현 방법에 대한 심화 연구입니다.",
      "date": "2024-09-20",
      "tags": [
        "추천 시스템",
        "다중 모달",
        "Word2Vec",
        "CNN",
        "LSTM",
        "협업 필터링",
        "딥러닝"
      ],
      "category": "AI",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/multimodal-recommendation-system-research"
    },
    {
      "path": "/posts/2024/week15-16.md",
      "year": "2024",
      "slug": "week15-16",
      "title": "15-16주차: 고급 DP 및 기타 주제",
      "description": "비트마스크 DP와 트리 DP의 고급 기법을 마스터하고, 문자열 알고리즘의 기초를 다진다",
      "snippet": "비트마스크 DP와 트리 DP의 고급 기법을 마스터하고, 문자열 알고리즘의 기초를 다진다",
      "date": "2024-09-17",
      "tags": [
        "고급DP",
        "비트마스크",
        "트리DP",
        "KMP",
        "문자열알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week15-16"
    },
    {
      "path": "/posts/2024/week7-8.md",
      "year": "2024",
      "slug": "week7-8",
      "title": "7-8주차: 동적 계획법(DP) 기초",
      "description": "최적 부분 구조와 중복 부분 문제를 이용한 효율적 문제 해결 기법을 마스터한다",
      "snippet": "최적 부분 구조와 중복 부분 문제를 이용한 효율적 문제 해결 기법을 마스터한다",
      "date": "2024-09-13",
      "tags": [
        "동적계획법",
        "DP",
        "메모이제이션",
        "최적화",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week7-8"
    },
    {
      "path": "/posts/2024/week5-6.md",
      "year": "2024",
      "slug": "week5-6",
      "title": "5-6주차: 재귀와 분할 정복",
      "description": "재귀적 사고를 통한 문제 해결과 분할 정복 패러다임의 강력함을 경험한다",
      "snippet": "재귀적 사고를 통한 문제 해결과 분할 정복 패러다임의 강력함을 경험한다",
      "date": "2024-09-09",
      "tags": [
        "재귀",
        "분할정복",
        "하노이탑",
        "피보나치",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/week5-6"
    },
    {
      "path": "/posts/2024/nanopi-neo3-ubuntu-setup-guide.md",
      "year": "2024",
      "slug": "nanopi-neo3-ubuntu-setup-guide",
      "title": "NanoPi Neo3 우분투 설정 및 네트워크 구성 완벽 가이드",
      "description": "NanoPi Neo3에 우분투 설치 후 로그인부터 고정 IP 설정까지 완벽한 설정 가이드를 제공합니다.",
      "snippet": "NanoPi Neo3에 우분투 설치 후 로그인부터 고정 IP 설정까지 완벽한 설정 가이드를 제공합니다.",
      "date": "2024-09-05",
      "tags": [
        "NanoPi Neo3",
        "Ubuntu",
        "NetworkManager",
        "ARM SBC",
        "IoT",
        "고정 IP"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/nanopi-neo3-ubuntu-setup-guide"
    },
    {
      "path": "/posts/2024/tmux-session-management-guide.md",
      "year": "2024",
      "slug": "tmux-session-management-guide",
      "title": "tmux 세션 관리 완벽 가이드",
      "description": "tmux 터미널 멀티플렉서의 기본 사용법과 세션이 사라지는 문제 해결 방법을 자세히 설명합니다.",
      "snippet": "tmux 터미널 멀티플렉서의 기본 사용법과 세션이 사라지는 문제 해결 방법을 자세히 설명합니다.",
      "date": "2024-09-02",
      "tags": [
        "tmux",
        "터미널",
        "세션 관리",
        "Linux",
        "멀티플렉서"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/tmux-session-management-guide"
    },
    {
      "path": "/posts/2024/9.md",
      "year": "2024",
      "slug": "9",
      "title": "Nginx 설정 파일 구조 및 작성 방법",
      "description": "Nginx 설정 파일(conf)의 구조와 작성 방법에 대한 가이드.",
      "snippet": "Nginx 설정 파일(conf)의 구조와 작성 방법에 대한 가이드.",
      "date": "2024-08-29",
      "tags": [
        "Nginx",
        "Configuration",
        "Web Server"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/9"
    },
    {
      "path": "/posts/2024/week13-14.md",
      "year": "2024",
      "slug": "week13-14",
      "title": "13-14주차: 탐욕법 & 분리 집합",
      "description": "탐욕 알고리즘의 핵심 원리를 이해하고, Union-Find 자료구조로 효율적인 집합 관리를 마스터한다",
      "snippet": "탐욕 알고리즘의 핵심 원리를 이해하고, Union-Find 자료구조로 효율적인 집합 관리를 마스터한다",
      "date": "2024-08-25",
      "tags": [
        "탐욕법",
        "그리디",
        "크루스칼",
        "프림",
        "Union-Find",
        "MST"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week13-14"
    },
    {
      "path": "/posts/2024/rsync-custom-ssh-port-guide.md",
      "year": "2024",
      "slug": "rsync-custom-ssh-port-guide",
      "title": "Rsync 커스텀 SSH 포트 사용법 완벽 가이드",
      "description": "Rsync를 사용할 때 기본 SSH 포트가 아닌 커스텀 포트를 지정하는 올바른 방법을 상세히 설명합니다.",
      "snippet": "Rsync를 사용할 때 기본 SSH 포트가 아닌 커스텀 포트를 지정하는 올바른 방법을 상세히 설명합니다.",
      "date": "2024-08-21",
      "tags": [
        "rsync",
        "SSH",
        "파일 동기화",
        "백업",
        "Linux"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/rsync-custom-ssh-port-guide"
    },
    {
      "path": "/posts/2024/6.md",
      "year": "2024",
      "slug": "6",
      "title": "마지막 시간",
      "description": "시간, 속죄, 그리고 미래를 조종하는 모래시계에 대한 이야기.",
      "snippet": "시간, 속죄, 그리고 미래를 조종하는 모래시계에 대한 이야기.",
      "date": "2024-08-14",
      "tags": [
        "판타지",
        "시간여행"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/6"
    },
    {
      "path": "/posts/2024/3.md",
      "year": "2024",
      "slug": "3",
      "title": "컴공총론정리",
      "description": "컴공 총론 개론",
      "snippet": "컴공 총론 개론",
      "date": "2024-08-10",
      "tags": [],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "coverImage": "/images/2024/process.png",
      "url": "/blog/2024/3"
    },
    {
      "path": "/posts/2024/1.md",
      "year": "2024",
      "slug": "1",
      "title": "[Hugo] .Summary 사용법",
      "description": "Hugo-library .Summary 사용법에 관한 포스트입니다.",
      "snippet": "Hugo-library .Summary 사용법에 관한 포스트입니다.",
      "date": "2024-08-07",
      "tags": [],
      "category": "기술",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "coverImage": "https://github.com/user-attachments/assets/42e76be2-9749-47c2-92a4-a14ea5f91237",
      "url": "/blog/2024/1"
    },
    {
      "path": "/posts/2024/8.md",
      "year": "2024",
      "slug": "8",
      "title": "세계 1차 대전에서 기관총의 영향",
      "description": "세계 1차 대전 동안 기관총이 전쟁 양상을 어떻게 변화시켰는지에 대한 탐구.",
      "snippet": "세계 1차 대전 동안 기관총이 전쟁 양상을 어떻게 변화시켰는지에 대한 탐구.",
      "date": "2024-08-04",
      "tags": [
        "세계 1차 대전",
        "기관총",
        "역사"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/8"
    },
    {
      "path": "/posts/2024/week1-2.md",
      "year": "2024",
      "slug": "week1-2",
      "title": "1-2주차: 기초 수학 및 자료구조 복습",
      "description": "알고리즘 학습의 첫 걸음, 이산수학과 기본 자료구조를 탄탄히 다지는 시간",
      "snippet": "알고리즘 학습의 첫 걸음, 이산수학과 기본 자료구조를 탄탄히 다지는 시간",
      "date": "2024-08-01",
      "tags": [
        "알고리즘",
        "자료구조",
        "이산수학",
        "배열",
        "스택",
        "큐"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/week1-2"
    },
    {
      "path": "/posts/2024/database-containerization-guide.md",
      "year": "2024",
      "slug": "database-containerization-guide",
      "title": "데이터베이스 및 애플리케이션 컨테이너화 설치 가이드",
      "description": "MySQL, PostgreSQL, Redis, RabbitMQ, Kavita 등 주요 데이터베이스와 애플리케이션의 Docker 컨테이너화 및 호스트 설치 방법을 SSL/TLS 설정과 함께 소개합니다.",
      "snippet": "MySQL, PostgreSQL, Redis, RabbitMQ, Kavita 등 주요 데이터베이스와 애플리케이션의 Docker 컨테이너화 및 호스트 설치 방법을 SSL/TLS 설정과 함께 소개합니다.",
      "date": "2024-07-29",
      "tags": [
        "MySQL",
        "PostgreSQL",
        "Redis",
        "RabbitMQ",
        "Kavita",
        "SSL",
        "TLS",
        "Container"
      ],
      "category": "Database",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2024/database-containerization-guide"
    },
    {
      "path": "/posts/2024/week11-12.md",
      "year": "2024",
      "slug": "week11-12",
      "title": "11-12주차: 고급 자료구조 및 최단경로",
      "description": "힙과 우선순위 큐를 마스터하고, 다익스트라와 벨만-포드 최단경로 알고리즘을 정복한다",
      "snippet": "힙과 우선순위 큐를 마스터하고, 다익스트라와 벨만-포드 최단경로 알고리즘을 정복한다",
      "date": "2024-07-25",
      "tags": [
        "힙",
        "우선순위큐",
        "다익스트라",
        "벨만포드",
        "최단경로"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week11-12"
    },
    {
      "path": "/posts/2024/changedetection-io-guide.md",
      "year": "2024",
      "slug": "changedetection-io-guide",
      "title": "ChangeDetection.io 완벽 활용 가이드",
      "description": "웹페이지 변경 감지 서비스 ChangeDetection.io의 Duration Time 설정과 Discord 웹훅 연동을 통한 효율적인 모니터링 방법을 소개합니다.",
      "snippet": "웹페이지 변경 감지 서비스 ChangeDetection.io의 Duration Time 설정과 Discord 웹훅 연동을 통한 효율적인 모니터링 방법을 소개합니다.",
      "date": "2024-07-21",
      "tags": [
        "웹 모니터링",
        "자동화",
        "Discord",
        "Webhook",
        "ChangeDetection"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/changedetection-io-guide"
    },
    {
      "path": "/posts/2024/vim-split-window-guide.md",
      "year": "2024",
      "slug": "vim-split-window-guide",
      "title": "Vim 분할 창 사용법과 파일 간 전환 방법",
      "description": "Vim에서 vertical split view를 사용하여 여러 파일을 동시에 편집하고 파일 간 전환하는 방법을 소개합니다.",
      "snippet": "Vim에서 vertical split view를 사용하여 여러 파일을 동시에 편집하고 파일 간 전환하는 방법을 소개합니다.",
      "date": "2024-07-17",
      "tags": [
        "Vim",
        "편집기",
        "분할 창",
        "Linux",
        "단축키"
      ],
      "category": "Editor",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/vim-split-window-guide"
    },
    {
      "path": "/posts/2024/linux-networkmanager-static-ip.md",
      "year": "2024",
      "slug": "linux-networkmanager-static-ip",
      "title": "NetworkManager를 사용한 Linux Static IP 설정 완벽 가이드",
      "description": "NetworkManager를 활용하여 다양한 Linux 배포판에서 고정 IP를 설정하는 방법을 상세히 설명합니다.",
      "snippet": "NetworkManager를 활용하여 다양한 Linux 배포판에서 고정 IP를 설정하는 방법을 상세히 설명합니다.",
      "date": "2024-07-14",
      "tags": [
        "NetworkManager",
        "Static IP",
        "nmcli",
        "nmtui",
        "Ubuntu",
        "CentOS",
        "Rocky Linux"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/linux-networkmanager-static-ip"
    },
    {
      "path": "/posts/2024/week9-10.md",
      "year": "2024",
      "slug": "week9-10",
      "title": "9-10주차: 그래프 이론 기초",
      "description": "그래프의 표현 방법과 BFS, DFS 탐색 알고리즘을 완벽하게 마스터한다",
      "snippet": "그래프의 표현 방법과 BFS, DFS 탐색 알고리즘을 완벽하게 마스터한다",
      "date": "2024-07-10",
      "tags": [
        "그래프",
        "BFS",
        "DFS",
        "탐색",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week9-10"
    },
    {
      "path": "/posts/2024/4.md",
      "year": "2024",
      "slug": "4",
      "title": "hugo 외부 이미지 사용하기",
      "description": "hugo 외부 이미지 사용하기",
      "snippet": "hugo 외부 이미지 사용하기",
      "date": "2024-07-06",
      "tags": [],
      "category": "기술",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "coverImage": "https://images.unsplash.com/photo-1727200452521-ee63ae8682a8?w=1400&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxmZWF0dXJlZC1waG90b3MtZmVlZHw1Mnx8fGVufDB8fHx8fA%3D%3D",
      "url": "/blog/2024/4"
    },
    {
      "path": "/posts/2024/5.md",
      "year": "2024",
      "slug": "5",
      "title": "조용한 속삭임",
      "description": "잊혀진 마을에서 들려오는 신비한 속삭임에 대한 이야기.",
      "snippet": "잊혀진 마을에서 들려오는 신비한 속삭임에 대한 이야기.",
      "date": "2024-07-02",
      "tags": [
        "소설",
        "미스터리"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/5"
    },
    {
      "path": "/posts/2024/coding-test-guide.md",
      "year": "2024",
      "slug": "coding-test-guide",
      "title": "코딩테스트 완벽 대비 전략",
      "description": "대기업 코딩테스트 합격을 위한 실전 준비 가이드와 핵심 문제 유형별 공략법",
      "snippet": "대기업 코딩테스트 합격을 위한 실전 준비 가이드와 핵심 문제 유형별 공략법",
      "date": "2024-06-28",
      "tags": [
        "코딩테스트",
        "취업",
        "알고리즘",
        "프로그래밍",
        "면접"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/coding-test-guide"
    },
    {
      "path": "/posts/2024/2.md",
      "year": "2024",
      "slug": "2",
      "title": "김치캣과 요약문 실험기",
      "description": "블로그 요약 기능을 테스트하며 만난 길고양이 김치캣의 기록.",
      "snippet": "블로그 요약 기능을 테스트하며 만난 길고양이 김치캣의 기록.",
      "date": "2024-06-25",
      "tags": [
        "블로그",
        "Hugo",
        "기록"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "coverImage": "https://github.com/user-attachments/assets/64b064ef-d713-4e7e-90a8-b9c83ae0e1c8",
      "url": "/blog/2024/2"
    },
    {
      "path": "/posts/2024/ai-personalized-learning-system.md",
      "year": "2024",
      "slug": "ai-personalized-learning-system",
      "title": "AI 기반 맞춤형 학습 시스템 프로젝트",
      "description": "인간의 기억 메커니즘과 과학적 학습법을 AI 기술과 결합하여 개인화된 학습 경험을 제공하는 혁신적인 교육 시스템 설계.",
      "snippet": "인간의 기억 메커니즘과 과학적 학습법을 AI 기술과 결합하여 개인화된 학습 경험을 제공하는 혁신적인 교육 시스템 설계.",
      "date": "2024-06-08",
      "tags": [
        "AI 교육",
        "맞춤형 학습",
        "간격 반복",
        "인출 연습",
        "이중부호화",
        "학습 시스템"
      ],
      "category": "AI",
      "author": "Admin",
      "readingTime": "7 min read",
      "published": true,
      "url": "/blog/2024/ai-personalized-learning-system"
    },
    {
      "path": "/posts/2024/algorithm-guide.md",
      "year": "2024",
      "slug": "algorithm-guide",
      "title": "알고리즘 학습 가이드",
      "description": "효과적인 알고리즘 공부 방법과 실전 팁을 제공합니다",
      "snippet": "효과적인 알고리즘 공부 방법과 실전 팁을 제공합니다",
      "date": "2024-06-05",
      "tags": [
        "알고리즘",
        "학습법",
        "코딩테스트",
        "자료구조"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/algorithm-guide"
    },
    {
      "path": "/posts/2024/_index.md",
      "year": "2024",
      "slug": "_index",
      "title": "영화",
      "description": "영화 리뷰와 분석, 철학적 사고를 담은 시네마 에세이",
      "snippet": "영화 리뷰와 분석, 철학적 사고를 담은 시네마 에세이",
      "date": "2024-01-01",
      "tags": [],
      "category": "General",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2024/_index"
    }
  ],
  "generatedAt": "2025-12-26T07:57:25.815Z",
  "years": [
    "2025",
    "2024"
  ],
  "format": 2
}

```

---

## frontend/public/ai-memo

### ai-memo.css

**Path:** `frontend/public/ai-memo/ai-memo.css`

```css
/* Floating AI Memo - Shadow DOM scoped styles */
/* Redesigned for clarity and modern aesthetics */
/* TUI (Terminal UI) style for terminal theme compatibility */

:host {
  all: initial;
  --memo-radius: 16px;
  --memo-shadow: 0 20px 50px rgba(0, 0, 0, 0.15), 0 8px 20px rgba(0, 0, 0, 0.1);
  --memo-shadow-dark: 0 20px 50px rgba(0, 0, 0, 0.4), 0 8px 20px rgba(0, 0, 0, 0.3);
  --memo-border: rgba(0, 0, 0, 0.06);
  --memo-border-dark: rgba(255, 255, 255, 0.08);
  --memo-accent: #10b981; /* Emerald green for light theme */
  --memo-accent-hover: #059669;
}

/* Dark mode: Use Teal for a calmer, more sophisticated look */
:host(.dark) {
  --memo-accent: #14b8a6; /* Teal 500 - softer than Emerald on dark backgrounds */
  --memo-accent-hover: #0d9488; /* Teal 600 */
}

.button {
  cursor: pointer;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

/* Launcher - Hidden by FAB, but kept for compatibility */
.launcher {
  position: fixed;
  right: 16px;
  bottom: calc(96px + env(safe-area-inset-bottom, 0px));
  z-index: 2147483647;
  width: 48px;
  height: 48px;
  border-radius: 9999px;
  background: #111827;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.08);
  opacity: 0.5;
  transform: scale(0.98);
  transition: opacity 0.2s ease, transform 0.15s ease, filter 0.15s ease;
}
.launcher:hover {
  filter: brightness(1.1);
  opacity: 1;
  transform: scale(1);
}
.launcher.history {
  bottom: calc(152px + env(safe-area-inset-bottom, 0px));
}

/* Panel - Main container */
.panel {
  position: fixed;
  z-index: 2147483647;
  width: 400px;
  max-width: min(480px, calc(100vw - 32px));
  height: min(520px, calc(100dvh - 100px));
  max-height: calc(100dvh - 80px);
  right: 20px;
  bottom: calc(100px + env(safe-area-inset-bottom, 0px));
  display: none;
  background: rgba(255, 255, 255, 0.92);
  backdrop-filter: blur(24px);
  -webkit-backdrop-filter: blur(24px);
  color: #111827;
  border-radius: var(--memo-radius);
  box-shadow: 
    var(--memo-shadow),
    inset 0 1px 0 rgba(255, 255, 255, 0.6); /* Inner highlight for glass depth */
  border: 1px solid rgba(0, 0, 0, 0.08); /* Slightly stronger border */
  overflow: hidden;
  contain: layout paint style;
}

.panel.open {
  display: flex;
  flex-direction: column;
  animation: memo-slide-in 0.25s ease-out;
}

@keyframes memo-slide-in {
  from {
    opacity: 0;
    transform: translateY(10px) scale(0.98);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

:host(.dark) .panel {
  background: rgba(15, 23, 42, 0.95);
  color: #e5e7eb;
  border-color: var(--memo-border-dark);
  box-shadow: var(--memo-shadow-dark);
}

/* Header - Clean minimal design */
.header {
  display: flex;
  align-items: center;
  padding: 14px 16px;
  gap: 12px;
  border-bottom: 1px solid var(--memo-border);
  cursor: move;
  user-select: none;
  flex-shrink: 0;
  background: transparent;
}

:host(.dark) .header {
  border-bottom-color: var(--memo-border-dark);
}

.header .title {
  font: 600 15px/1.3 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #0f172a;
  letter-spacing: -0.01em;
}

:host(.dark) .header .title {
  color: #f1f5f9;
}

.header .spacer {
  flex: 1;
}

.header .close {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  border-radius: 8px;
  font-size: 16px;
  color: #94a3b8;
  cursor: pointer;
  transition: all 0.15s ease;
}

.header .close:hover {
  background: rgba(0, 0, 0, 0.06);
  color: #334155;
}

:host(.dark) .header .close:hover {
  background: rgba(255, 255, 255, 0.1);
  color: #f1f5f9;
}

/* Tabs - Pill style */
.tabs {
  display: flex;
  gap: 4px;
  padding: 10px 14px;
  border-bottom: 1px solid var(--memo-border);
  flex-shrink: 0;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
  background: rgba(248, 250, 252, 0.5);
}

.tabs::-webkit-scrollbar {
  display: none;
}

:host(.dark) .tabs {
  border-bottom-color: var(--memo-border-dark);
  background: rgba(30, 41, 59, 0.3);
}

.tab {
  padding: 8px 14px;
  font: 500 13px/1.3 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #64748b;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.15s ease;
  white-space: nowrap;
  border: none;
  background: transparent;
}

.tab:hover {
  background: rgba(0, 0, 0, 0.05);
  color: #334155;
  transform: translateY(-1px); /* Subtle lift on hover */
}

.tab:active {
  transform: translateY(0);
}

.tab.active {
  background: #0f172a;
  color: #fff;
  font-weight: 600;
}

:host(.dark) .tab {
  color: #94a3b8;
}

:host(.dark) .tab:hover {
  background: rgba(255, 255, 255, 0.08);
  color: #e2e8f0;
}

:host(.dark) .tab.active {
  background: var(--memo-accent);
  color: #022c22;
  font-weight: 600;
  text-shadow: 0 1px 0 rgba(255, 255, 255, 0.1);
}

/* Body content */
.body {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 16px;
  display: none;
  -webkit-overflow-scrolling: touch;
}

.body.active {
  display: block;
}

/* ========================================
   CUSTOM SCROLLBAR - Modern thin style
   ======================================== */
.body::-webkit-scrollbar,
.textarea::-webkit-scrollbar,
.preview-md::-webkit-scrollbar,
.history-info-body::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

.body::-webkit-scrollbar-track,
.textarea::-webkit-scrollbar-track,
.preview-md::-webkit-scrollbar-track,
.history-info-body::-webkit-scrollbar-track {
  background: transparent;
  border-radius: 3px;
}

.body::-webkit-scrollbar-thumb,
.textarea::-webkit-scrollbar-thumb,
.preview-md::-webkit-scrollbar-thumb,
.history-info-body::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.15);
  border-radius: 3px;
  transition: background 0.2s ease;
}

.body::-webkit-scrollbar-thumb:hover,
.textarea::-webkit-scrollbar-thumb:hover,
.preview-md::-webkit-scrollbar-thumb:hover,
.history-info-body::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.25);
}

.body::-webkit-scrollbar-corner,
.textarea::-webkit-scrollbar-corner,
.preview-md::-webkit-scrollbar-corner,
.history-info-body::-webkit-scrollbar-corner {
  background: transparent;
}

/* Dark mode scrollbar */
:host(.dark) .body::-webkit-scrollbar-thumb,
:host(.dark) .textarea::-webkit-scrollbar-thumb,
:host(.dark) .preview-md::-webkit-scrollbar-thumb,
:host(.dark) .history-info-body::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.15);
}

:host(.dark) .body::-webkit-scrollbar-thumb:hover,
:host(.dark) .textarea::-webkit-scrollbar-thumb:hover,
:host(.dark) .preview-md::-webkit-scrollbar-thumb:hover,
:host(.dark) .history-info-body::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.25);
}

/* Firefox scrollbar */
.body,
.textarea,
.preview-md,
.history-info-body {
  scrollbar-width: thin;
  scrollbar-color: rgba(0, 0, 0, 0.15) transparent;
}

:host(.dark) .body,
:host(.dark) .textarea,
:host(.dark) .preview-md,
:host(.dark) .history-info-body {
  scrollbar-color: rgba(255, 255, 255, 0.15) transparent;
}

/* Section */
.section {
  margin-bottom: 20px;
}

.section:last-child {
  margin-bottom: 0;
}

/* Section with form elements - better spacing */
.section .memo-toolbar + .textarea,
.section .memo-hint + .textarea {
  margin-top: 8px;
}

/* ========================================
   MEMO TOOLBAR - TUI Style
   ======================================== */
.memo-toolbar {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 8px 10px;
  background: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  margin-bottom: 12px;
  flex-wrap: wrap;
}

:host(.dark) .memo-toolbar {
  background: rgba(15, 23, 42, 0.6);
  border-color: rgba(255, 255, 255, 0.1);
}

.toolbar-group {
  display: flex;
  align-items: center;
  gap: 2px;
}

.toolbar-divider {
  width: 1px;
  height: 20px;
  background: #cbd5e1;
  margin: 0 6px;
}

:host(.dark) .toolbar-divider {
  background: rgba(255, 255, 255, 0.15);
}

.toolbar-spacer {
  flex: 1;
  min-width: 8px;
}

.toolbar-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  min-width: 32px;
  height: 32px;
  padding: 0 8px;
  font: 600 12px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #475569;
  background: transparent;
  border: 1px solid transparent;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.12s ease;
}

.toolbar-btn:hover {
  background: #fff;
  border-color: #cbd5e1;
  color: #0f172a;
}

.toolbar-btn:active {
  background: #e2e8f0;
  transform: translateY(1px);
}

.toolbar-btn .icon {
  font-size: 13px;
  font-weight: 700;
}

.toolbar-btn .icon.italic {
  font-style: italic;
}

.toolbar-btn .icon.mono {
  font-size: 11px;
}

.toolbar-btn .label {
  font-size: 11px;
  font-weight: 500;
}

/* Action buttons with labels */
.toolbar-btn.action {
  padding: 0 10px;
  color: #64748b;
}

.toolbar-btn.action:hover {
  color: var(--memo-accent);
  border-color: var(--memo-accent);
}

/* AI buttons - special styling */
.toolbar-btn.ai {
  padding: 0 12px;
  color: #7c3aed;
  background: rgba(124, 58, 237, 0.06);
}

.toolbar-btn.ai:hover {
  background: rgba(124, 58, 237, 0.12);
  border-color: #7c3aed;
}

.toolbar-btn.ai.primary {
  background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
  color: #fff;
  border-color: transparent;
  box-shadow: 0 2px 6px rgba(124, 58, 237, 0.3);
}

.toolbar-btn.ai.primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(124, 58, 237, 0.4);
}

.toolbar-btn.ai.primary:active {
  transform: translateY(0);
}

:host(.dark) .toolbar-btn {
  color: #94a3b8;
}

:host(.dark) .toolbar-btn:hover {
  background: rgba(255, 255, 255, 0.08);
  border-color: rgba(255, 255, 255, 0.2);
  color: #e5e7eb;
}

:host(.dark) .toolbar-btn.action:hover {
  color: var(--memo-accent);
  border-color: var(--memo-accent);
}

:host(.dark) .toolbar-btn.ai {
  color: #c4b5fd;
  background: rgba(124, 58, 237, 0.15);
}

:host(.dark) .toolbar-btn.ai:hover {
  background: rgba(124, 58, 237, 0.25);
  border-color: #a855f7;
}

/* Memo hint line */
.memo-hint {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 2px;
  margin-bottom: 6px;
}

.hint-text {
  font: 400 11px/1.3 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #64748b;
}

.hint-divider {
  color: #cbd5e1;
  font-size: 8px;
}

.hint-shortcut {
  font: 400 11px/1.3 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #64748b;
}

.hint-shortcut kbd {
  display: inline-block;
  padding: 2px 5px;
  font: 500 10px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #475569;
  background: #f1f5f9;
  border: 1px solid #e2e8f0;
  border-radius: 4px;
  box-shadow: 0 1px 0 #cbd5e1;
}

:host(.dark) .hint-text,
:host(.dark) .hint-shortcut {
  color: #94a3b8;
}

:host(.dark) .hint-divider {
  color: rgba(255, 255, 255, 0.2);
}

:host(.dark) .hint-shortcut kbd {
  color: #e5e7eb;
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.15);
  box-shadow: 0 1px 0 rgba(0, 0, 0, 0.3);
}

/* Label */
.label {
  display: flex;
  align-items: center;
  gap: 6px;
  font: 600 11px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #64748b;
  margin-bottom: 10px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
}

.label::before {
  content: '>';
  color: var(--memo-accent);
  font-weight: 700;
}

:host(.dark) .label {
  color: #94a3b8;
}

:host(.dark) .label::before {
  color: var(--memo-accent);
}

/* Input */
.input {
  display: block;
  width: 100%;
  padding: 12px 14px;
  font: 400 14px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #0f172a;
  background: #fff;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  outline: none;
  transition: border-color 0.15s, box-shadow 0.15s, background 0.15s;
  box-sizing: border-box;
}

.input::placeholder {
  color: #94a3b8;
}

.input:hover {
  border-color: #cbd5e1;
  background: #fafafa;
}

.input:focus {
  border-color: var(--memo-accent);
  background: #fff;
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
}

:host(.dark) .input {
  background: rgba(15, 23, 42, 0.6);
  border-color: rgba(255, 255, 255, 0.12);
  color: #e5e7eb;
}

:host(.dark) .input::placeholder {
  color: #64748b;
}

:host(.dark) .input:hover {
  border-color: rgba(255, 255, 255, 0.2);
  background: rgba(15, 23, 42, 0.8);
}

:host(.dark) .input:focus {
  border-color: var(--memo-accent);
  background: rgba(15, 23, 42, 0.9);
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.15);
}

/* Textarea */
.textarea {
  display: block;
  width: 100%;
  min-height: 140px;
  padding: 14px 16px;
  font: 400 14px/1.7 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #0f172a;
  background: #fff;
  border: 1px solid #e2e8f0;
  border-radius: 10px;
  outline: none;
  resize: vertical;
  transition: border-color 0.15s, box-shadow 0.15s, background 0.15s;
  box-sizing: border-box;
}

.textarea::placeholder {
  color: #94a3b8;
}

.textarea:hover {
  border-color: #cbd5e1;
  background: #fafafa;
}

.textarea:focus {
  border-color: var(--memo-accent);
  background: #fff;
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
}

:host(.dark) .textarea {
  background: rgba(15, 23, 42, 0.6);
  border-color: rgba(255, 255, 255, 0.12);
  color: #e5e7eb;
}

:host(.dark) .textarea::placeholder {
  color: #64748b;
}

:host(.dark) .textarea:hover {
  border-color: rgba(255, 255, 255, 0.2);
  background: rgba(15, 23, 42, 0.8);
}

:host(.dark) .textarea:focus {
  border-color: var(--memo-accent);
  background: rgba(15, 23, 42, 0.9);
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.15);
}

/* Button - TUI (Terminal UI) style */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 9px 16px;
  font: 500 13px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #0f172a;
  background: transparent;
  border: 1px solid #cbd5e1;
  border-radius: 0; /* Sharp corners for TUI look */
  cursor: pointer;
  transition: all 0.15s ease;
  white-space: nowrap;
  box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.1);
}

.btn:hover {
  border-color: var(--memo-accent);
  color: var(--memo-accent);
  transform: translate(-1px, -1px);
  box-shadow: 3px 3px 0px rgba(16, 185, 129, 0.2);
}

.btn:active {
  transform: translate(2px, 2px);
  box-shadow: none;
  background: var(--memo-accent);
  color: #022c22;
  border-color: var(--memo-accent);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.btn.secondary {
  background: transparent;
  color: #475569;
  border: 1px dashed #cbd5e1;
  box-shadow: none;
}

.btn.secondary:hover {
  border-color: var(--memo-accent);
  border-style: solid;
  color: var(--memo-accent);
}

:host(.dark) .btn {
  background: transparent;
  color: var(--memo-accent);
  border: 1px solid var(--memo-accent);
  box-shadow: 2px 2px 0px rgba(16, 185, 129, 0.3);
}

:host(.dark) .btn:hover {
  background: rgba(16, 185, 129, 0.1);
  transform: translate(-1px, -1px);
  box-shadow: 3px 3px 0px rgba(16, 185, 129, 0.4);
}

:host(.dark) .btn:active {
  background: var(--memo-accent);
  color: #022c22;
  transform: translate(2px, 2px);
  box-shadow: none;
}

:host(.dark) .btn.secondary {
  background: transparent;
  color: #94a3b8;
  border: 1px dashed rgba(255, 255, 255, 0.2);
  box-shadow: none;
}

:host(.dark) .btn.secondary:hover {
  border-color: var(--memo-accent);
  border-style: solid;
  color: var(--memo-accent);
}

/* Row */
.row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

/* Small text */
.small {
  font: 400 12px/1.4 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #64748b;
}

.muted {
  opacity: 0.7;
}

:host(.dark) .small {
  color: #94a3b8;
}

/* Footer - Improved layout */
.footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 16px;
  border-top: 1px solid var(--memo-border);
  flex-shrink: 0;
  background: rgba(248, 250, 252, 0.5);
}

:host(.dark) .footer {
  border-top-color: var(--memo-border-dark);
  background: rgba(30, 41, 59, 0.3);
}

/* Status bar with dot indicator */
.status-bar {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  background: #f1f5f9;
  border-radius: 20px;
  min-width: 70px;
}

.status-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--memo-accent);
  animation: pulse-dot 2s ease-in-out infinite;
}

@keyframes pulse-dot {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

.status-text {
  font: 500 11px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #64748b;
}

:host(.dark) .status-bar {
  background: rgba(255, 255, 255, 0.08);
}

:host(.dark) .status-text {
  color: #94a3b8;
}

/* Footer actions */
.footer-actions {
  display: flex;
  align-items: center;
  gap: 6px;
}

.footer-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
  padding: 8px 12px;
  font: 500 12px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #475569;
  background: transparent;
  border: 1px solid #cbd5e1;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.12s ease;
}

.footer-btn:hover {
  background: #f8fafc;
  border-color: var(--memo-accent);
  color: var(--memo-accent);
  transform: translateY(-1px); /* Subtle lift on hover */
}

.footer-btn:active {
  background: var(--memo-accent);
  color: #022c22;
  border-color: var(--memo-accent);
  transform: translateY(0);
}

.footer-btn .btn-icon {
  font-size: 14px;
}

.footer-btn .btn-label {
  font-size: 11px;
}

.footer-btn.danger {
  color: #dc2626;
  border-color: rgba(220, 38, 38, 0.3);
}

.footer-btn.danger:hover {
  background: rgba(220, 38, 38, 0.08);
  border-color: #dc2626;
}

.footer-btn.danger:active {
  background: #dc2626;
  color: #fff;
}

:host(.dark) .footer-btn {
  color: #94a3b8;
  border-color: rgba(255, 255, 255, 0.15);
}

:host(.dark) .footer-btn:hover {
  background: rgba(255, 255, 255, 0.08);
  border-color: var(--memo-accent);
  color: var(--memo-accent);
}

:host(.dark) .footer-btn:active {
  background: var(--memo-accent);
  color: #022c22;
  border-color: var(--memo-accent);
}

:host(.dark) .footer-btn.danger {
  color: #f87171;
  border-color: rgba(248, 113, 113, 0.3);
}

:host(.dark) .footer-btn.danger:hover {
  background: rgba(248, 113, 113, 0.12);
  border-color: #f87171;
}

/* ========================================
   CATALYST PANEL - Improved UX
   ======================================== */
.catalyst-panel {
  padding: 12px 16px;
  background: linear-gradient(135deg, rgba(124, 58, 237, 0.08) 0%, rgba(168, 85, 247, 0.04) 100%);
  border-top: 1px solid rgba(124, 58, 237, 0.2);
  animation: catalyst-slide-in 0.2s ease-out;
}

@keyframes catalyst-slide-in {
  from {
    opacity: 0;
    transform: translateY(-8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

:host(.dark) .catalyst-panel {
  background: linear-gradient(135deg, rgba(124, 58, 237, 0.15) 0%, rgba(168, 85, 247, 0.08) 100%);
  border-top-color: rgba(124, 58, 237, 0.3);
}

.catalyst-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 10px;
}

.catalyst-icon {
  font-size: 16px;
}

.catalyst-title {
  font: 600 13px/1 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #7c3aed;
}

:host(.dark) .catalyst-title {
  color: #c4b5fd;
}

.catalyst-input {
  width: 100%;
  padding: 12px 14px;
  font: 400 14px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  background: #fff;
  border: 1px solid rgba(124, 58, 237, 0.25);
  border-radius: 8px;
  margin-bottom: 12px;
  outline: none;
  transition: border-color 0.15s, box-shadow 0.15s;
  box-sizing: border-box;
}

.catalyst-input::placeholder {
  color: #a78bfa;
}

.catalyst-input:hover {
  border-color: rgba(124, 58, 237, 0.4);
}

.catalyst-input:focus {
  border-color: #7c3aed;
  box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.12);
}

:host(.dark) .catalyst-input {
  background: rgba(15, 23, 42, 0.7);
  border-color: rgba(124, 58, 237, 0.35);
  color: #e5e7eb;
}

:host(.dark) .catalyst-input::placeholder {
  color: #8b5cf6;
}

:host(.dark) .catalyst-input:hover {
  border-color: rgba(124, 58, 237, 0.5);
}

:host(.dark) .catalyst-input:focus {
  border-color: #a855f7;
  box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.2);
}

.catalyst-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}

.catalyst-run {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
  color: #fff;
  border-color: transparent;
  box-shadow: 0 2px 8px rgba(124, 58, 237, 0.3);
}

.catalyst-run:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(124, 58, 237, 0.4);
}

.catalyst-run:active {
  transform: translateY(0);
}

.catalyst-run-icon {
  font-size: 10px;
}

/* Catalyst loading state */
.catalyst-panel.loading .catalyst-run {
  pointer-events: none;
  opacity: 0.7;
}

.catalyst-panel.loading .catalyst-run-icon {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* Toast - Improved styling */
.toast {
  position: absolute;
  left: 50%;
  bottom: 80px;
  transform: translateX(-50%) translateY(10px);
  padding: 12px 18px;
  font: 500 13px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #fff;
  background: #0f172a;
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s, transform 0.2s;
  z-index: 10;
  max-width: calc(100% - 32px);
  text-align: center;
}

.toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

:host(.dark) .toast {
  background: #1e293b;
  border-color: rgba(255, 255, 255, 0.15);
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
}

/* Split layout for preview */
.split {
  display: flex;
  gap: 12px;
  height: 100%;
}

.split-left,
.split-right {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
}

.split-left .textarea,
.split-right .textarea {
  flex: 1;
}

/* Preview layout bar */
.preview-layout-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 14px;
  padding: 8px 12px;
  background: #fff;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
}

:host(.dark) .preview-layout-bar {
  background: rgba(15, 23, 42, 0.6);
  border-color: rgba(255, 255, 255, 0.1);
}

.layout-toggle {
  display: flex;
  gap: 2px;
  padding: 3px;
  background: #e2e8f0;
  border-radius: 6px;
}

:host(.dark) .layout-toggle {
  background: rgba(255, 255, 255, 0.1);
}

.layout-btn {
  padding: 6px 14px;
  font: 600 12px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #64748b;
  background: transparent;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.12s ease;
}

.layout-btn:hover {
  color: #0f172a;
}

.layout-btn.active,
.layout-btn[aria-pressed="true"] {
  background: #fff;
  color: #0f172a;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

:host(.dark) .layout-btn {
  color: #94a3b8;
}

:host(.dark) .layout-btn:hover {
  color: #e2e8f0;
}

:host(.dark) .layout-btn.active,
:host(.dark) .layout-btn[aria-pressed="true"] {
  background: var(--memo-accent);
  color: #022c22;
  box-shadow: 0 1px 4px rgba(16, 185, 129, 0.3);
}

.preview-pane-toggle {
  display: none;
  gap: 2px;
  padding: 3px;
  background: #e2e8f0;
  border-radius: 6px;
}

.preview-pane-toggle[data-visible="true"] {
  display: flex;
}

:host(.dark) .preview-pane-toggle {
  background: rgba(255, 255, 255, 0.1);
}

.preview-pane-toggle button {
  padding: 6px 14px;
  font: 600 12px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: #64748b;
  background: transparent;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.12s ease;
}

.preview-pane-toggle button:hover {
  color: #0f172a;
}

.preview-pane-toggle button[aria-selected="true"] {
  background: #fff;
  color: #0f172a;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

:host(.dark) .preview-pane-toggle button {
  color: #94a3b8;
}

:host(.dark) .preview-pane-toggle button:hover {
  color: #e2e8f0;
}

:host(.dark) .preview-pane-toggle button[aria-selected="true"] {
  background: var(--memo-accent);
  color: #022c22;
  box-shadow: 0 1px 4px rgba(16, 185, 129, 0.3);
}

/* Preview split layout modes */
#previewSplit[data-layout="split"] .split-left,
#previewSplit[data-layout="split"] .split-right {
  display: flex;
}

#previewSplit[data-layout="tab"] .split-left,
#previewSplit[data-layout="tab"] .split-right {
  display: none;
}

#previewSplit[data-layout="tab"][data-active-pane="editor"] .split-left {
  display: flex;
}

#previewSplit[data-layout="tab"][data-active-pane="preview"] .split-right {
  display: flex;
}

/* Markdown preview */
.preview-md {
  flex: 1;
  padding: 16px;
  background: #fff;
  border: 1px solid #e2e8f0;
  border-radius: 10px;
  overflow-y: auto;
  font: 400 14px/1.7 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #0f172a;
}

.preview-md:empty::before {
  content: '미리보기가 여기에 표시됩니다...';
  color: #94a3b8;
  font-style: italic;
}

:host(.dark) .preview-md {
  background: rgba(15, 23, 42, 0.6);
  border-color: rgba(255, 255, 255, 0.1);
  color: #e5e7eb;
}

:host(.dark) .preview-md:empty::before {
  color: #64748b;
}

.preview-md h1, .preview-md h2, .preview-md h3,
.preview-md h4, .preview-md h5, .preview-md h6 {
  margin: 16px 0 8px;
  font-weight: 600;
  line-height: 1.3;
}

.preview-md h1 { font-size: 20px; }
.preview-md h2 { font-size: 18px; }
.preview-md h3 { font-size: 16px; }
.preview-md p { margin: 8px 0; }
.preview-md ul, .preview-md ol { margin: 8px 0; padding-left: 24px; }
.preview-md li { margin: 4px 0; }

.preview-md code {
  padding: 2px 6px;
  font: 13px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 5px;
}

:host(.dark) .preview-md code {
  background: rgba(255, 255, 255, 0.1);
}

.preview-md pre {
  margin: 12px 0;
  padding: 12px;
  background: #0f172a;
  color: #e5e7eb;
  border-radius: 10px;
  overflow-x: auto;
}

.preview-md pre code {
  padding: 0;
  background: none;
  font-size: 13px;
}

.preview-md pre .line { display: block; }
.preview-md pre .kw { color: #c084fc; }
.preview-md pre .str { color: #4ade80; }
.preview-md pre .num { color: #fbbf24; }
.preview-md pre .fn { color: #60a5fa; }
.preview-md pre .cm { color: #64748b; font-style: italic; }

.preview-md a {
  color: var(--memo-accent);
  text-decoration: underline;
  text-underline-offset: 2px;
}

:host(.dark) .preview-md a {
  color: #60a5fa;
}

.preview-md blockquote {
  margin: 12px 0;
  padding: 10px 14px;
  border-left: 3px solid var(--memo-accent);
  background: rgba(59, 130, 246, 0.06);
  color: #475569;
  border-radius: 0 8px 8px 0;
}

:host(.dark) .preview-md blockquote {
  background: rgba(96, 165, 250, 0.1);
  color: #94a3b8;
}

.preview-md img {
  max-width: 100%;
  height: auto;
  border-radius: 8px;
  margin: 8px 0;
}

/* Fullscreen mode */
:host(.memo-full) .panel {
  width: 100vw !important;
  height: 100vh !important;
  height: 100dvh !important;
  max-width: 100vw !important;
  max-height: 100vh !important;
  max-height: 100dvh !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  border-radius: 0;
}

/* ========================================
   MOBILE STYLES - Bottom Sheet Design
   ======================================== */
@media (max-width: 640px) {
  .panel {
    /* 전체 화면 높이 사용, safe area만 고려 */
    width: 100% !important;
    max-width: 100% !important;
    height: calc(100dvh - env(safe-area-inset-bottom, 0px)) !important;
    max-height: calc(100dvh - env(safe-area-inset-bottom, 0px)) !important;
    left: 0 !important;
    right: 0 !important;
    top: auto !important;
    bottom: 0 !important;
    transform: translateY(100%);
    border-radius: 20px 20px 0 0;
    overflow: hidden;
    transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
    box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.15);
    /* 핵심: flex column 레이아웃 */
    display: flex;
    flex-direction: column;
  }

  .panel.open {
    transform: translateY(0);
    display: flex;
    flex-direction: column;
  }

  /* Drag handle */
  .header::before {
    content: '';
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    width: 36px;
    height: 4px;
    background: rgba(0, 0, 0, 0.12);
    border-radius: 2px;
  }

  :host(.dark) .header::before {
    background: rgba(255, 255, 255, 0.2);
  }

  .header {
    position: relative;
    flex-shrink: 0;
    padding: 22px 16px 14px;
    gap: 10px;
    cursor: default;
  }

  .header .title {
    font-size: 16px;
    font-weight: 600;
  }

  .tabs {
    flex-shrink: 0;
    padding: 8px 16px;
    gap: 6px;
    background: transparent;
  }

  .tab {
    padding: 10px 18px;
    font-size: 14px;
    border-radius: 24px;
  }

  /* 본문 영역: 스크롤 담당 */
  .body {
    flex: 1;
    min-height: 0; /* flex 내에서 스크롤 동작을 위해 필수 */
    padding: 16px;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* Memo toolbar mobile */
  .memo-toolbar {
    padding: 6px;
    gap: 2px;
    border-radius: 10px;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }

  .memo-toolbar::-webkit-scrollbar {
    display: none;
  }

  .toolbar-btn {
    min-width: 36px;
    height: 36px;
    padding: 0 6px;
  }

  .toolbar-btn .label {
    display: none;
  }

  .toolbar-btn.ai {
    padding: 0 10px;
  }

  .toolbar-btn.ai .label {
    display: inline;
  }

  .toolbar-divider {
    height: 24px;
    margin: 0 4px;
  }

  .toolbar-spacer {
    min-width: 4px;
  }

  /* Memo hint mobile */
  .memo-hint {
    flex-wrap: wrap;
    gap: 4px;
  }

  .hint-shortcut {
    display: none;
  }

  .hint-divider:last-of-type {
    display: none;
  }

  /* 폼 전체를 중앙에 정렬하는 래퍼 */
  .body > .section,
  .body > .split,
  .body > .preview-layout-bar,
  .body > .row,
  .body > #catalystBox {
    max-width: 640px;
    width: 100%;
    margin-left: auto;
    margin-right: auto;
    box-sizing: border-box;
  }

  /* 편집기/미리보기 필드 공통 박스 */
  .label {
    display: block;
    width: 100%;
    margin-bottom: 8px;
  }

  .textarea {
    width: 100%;
    resize: none;
    min-height: 140px;
    font-size: 16px; /* Prevent iOS zoom */
    box-sizing: border-box;
  }

  .input {
    width: 100%;
    font-size: 16px; /* Prevent iOS zoom */
    padding: 12px;
    box-sizing: border-box;
  }

  /* Split layout을 세로 1컬럼으로 변경 */
  .split {
    flex-direction: column;
    gap: 16px;
    height: auto;
    max-width: 640px;
    margin-left: auto;
    margin-right: auto;
    width: 100%;
  }

  .split-left,
  .split-right {
    flex: none;
    width: 100%;
    display: flex;
    flex-direction: column;
  }

  .split-left .textarea,
  .split-right .textarea,
  .split-left .preview-md,
  .split-right .preview-md {
    width: 100%;
    min-height: 160px;
  }

  /* 미리보기 영역도 동일한 너비/정렬 */
  .preview-md {
    width: 100%;
    box-sizing: border-box;
  }

  /* Footer mobile - grid layout */
  .footer {
    flex-shrink: 0;
    padding: 10px 12px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
    gap: 8px;
    background: transparent;
    flex-direction: column;
    align-items: stretch;
  }

  .status-bar {
    width: 100%;
    justify-content: center;
    padding: 6px 12px;
  }

  .footer-actions {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 6px;
    width: 100%;
  }

  .footer-btn {
    flex-direction: column;
    gap: 2px;
    padding: 10px 4px;
    min-width: 0;
    border-radius: 8px;
  }

  .footer-btn .btn-icon {
    font-size: 16px;
  }

  .footer-btn .btn-label {
    font-size: 9px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Catalyst panel mobile */
  .catalyst-panel {
    padding: 12px;
  }

  .catalyst-actions {
    flex-direction: column;
  }

  .catalyst-actions .btn {
    width: 100%;
  }

  .btn {
    padding: 10px 14px;
    font-size: 13px;
    border-radius: 8px;
    box-sizing: border-box;
  }

  /* 레이아웃 토글 바 */
  .preview-layout-bar {
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
  }
}

/* 더 좁은 모바일 (480px 이하) */
@media (max-width: 480px) {
  .panel {
    border-radius: 16px 16px 0 0;
  }

  .header {
    padding: 20px 12px 12px;
  }

  .tabs {
    padding: 6px 12px;
  }

  .tab {
    padding: 8px 14px;
    font-size: 13px;
  }

  .body {
    padding: 12px;
  }

  .memo-toolbar {
    padding: 4px;
  }

  .toolbar-btn {
    min-width: 32px;
    height: 32px;
  }

  .toolbar-divider {
    margin: 0 2px;
  }

  .footer {
    padding: 8px 10px;
    padding-bottom: calc(8px + env(safe-area-inset-bottom, 0px));
  }

  .footer-actions {
    grid-template-columns: repeat(6, 1fr);
    gap: 4px;
  }

  .footer-btn {
    padding: 8px 2px;
  }

  .footer-btn .btn-icon {
    font-size: 14px;
  }

  .footer-btn .btn-label {
    display: none; /* Hide labels on very small screens */
  }

  .btn {
    padding: 10px 12px;
    font-size: 12px;
  }

  /* 메모 툴바 버튼들 - 모바일에서 줄바꿈 허용 */
  .section > .row {
    flex-wrap: wrap;
    justify-content: flex-start;
    gap: 6px;
  }

  .section > .row .btn.secondary {
    padding: 6px 8px;
    font-size: 11px;
    min-width: auto;
  }

  /* 텍스트 영역 */
  .textarea {
    min-height: 120px;
  }

  /* 분할 뷰: 완전히 세로로 */
  .split {
    gap: 12px;
  }

  .split-left,
  .split-right {
    min-height: auto;
  }

  .split-left .textarea,
  .split-right .textarea,
  .split-left .preview-md,
  .split-right .preview-md {
    min-height: 140px;
  }
}

/* ========================================
   HISTORY OVERLAY
   ======================================== */
.history-overlay {
  position: fixed;
  inset: 0;
  z-index: 2147483647;
  background: rgba(2, 6, 23, 0.6);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  display: flex;
  flex-direction: column;
}

.history-overlay .history-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid #e5e7eb;
}

:host(.dark) .history-overlay .history-toolbar {
  background: rgba(15, 23, 42, 0.9);
  border-bottom-color: rgba(255, 255, 255, 0.1);
  color: #e5e7eb;
}

.history-overlay canvas {
  flex: 1;
  width: 100%;
  height: calc(100% - 48px);
  display: block;
  cursor: grab;
}

.history-overlay canvas.grabbing {
  cursor: grabbing;
}

.history-tooltip {
  position: fixed;
  z-index: 2147483647;
  background: #0f172a;
  color: #fff;
  font: 12px/1.45 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.3);
  max-width: 280px;
  pointer-events: none;
  word-break: break-word;
}

:host(.dark) .history-tooltip {
  background: #1e293b;
  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5);
}

/* History bottom info panel */
.history-info {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 2147483647;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-top: 1px solid #e5e7eb;
  box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.12);
  padding: 12px 16px;
  padding-bottom: calc(12px + env(safe-area-inset-bottom));
  animation: ai-memo-slide-up 180ms ease-out both;
}

@keyframes ai-memo-slide-up {
  from {
    transform: translateY(10px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.history-info-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.history-info-toolbar .left {
  min-width: 0;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.history-info-title {
  font: 600 15px/1.2 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #0f172a;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.history-info-meta {
  font: 12px/1.2 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #64748b;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.history-toolbar .right {
  display: flex;
  gap: 8px;
}

.history-toolbar .btn.icon-btn span {
  font-size: 16px;
  line-height: 1;
}

@media (max-width: 768px) {
  .history-toolbar .right {
    gap: 6px;
  }

  .btn.icon-btn {
    width: 36px;
    height: 36px;
    font-size: 14px;
  }
}

.history-info-body {
  margin-top: 10px;
  max-height: min(35vh, 300px);
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  background: #f8fafc;
  border: 1px solid #e5e7eb;
  border-radius: 10px;
  padding: 10px;
}

/* grouped events list */
.history-info-list {
  list-style: none;
  margin: 0;
  padding: 0;
}

.history-info-list li {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 4px;
  border-bottom: 1px solid rgba(148, 163, 184, 0.15);
}

.history-info-list li:last-child {
  border-bottom: none;
}

.history-info-list .dt {
  font: 12px/1.2 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #64748b;
  min-width: 140px;
}

.history-info-list .sep {
  color: #cbd5e1;
}

.history-info-list .lbl {
  font: 13px/1.3 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  color: #0f172a;
}

/* key-value details */
.history-info-kv b {
  color: #475569;
  font-weight: 600;
  margin-right: 4px;
}

:host(.dark) .history-info {
  background: rgba(15, 23, 42, 0.95);
  border-top-color: rgba(255, 255, 255, 0.1);
  box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.4);
}

:host(.dark) .history-info-title {
  color: #f1f5f9;
}

:host(.dark) .history-info-meta {
  color: #94a3b8;
}

:host(.dark) .history-info-body {
  background: rgba(30, 41, 59, 0.6);
  border-color: rgba(255, 255, 255, 0.1);
}

:host(.dark) .history-info-list .dt {
  color: #94a3b8;
}

:host(.dark) .history-info-list .lbl {
  color: #e5e7eb;
}

:host(.dark) .history-info .btn.secondary {
  background: transparent;
  color: #94a3b8;
  border-color: rgba(255, 255, 255, 0.15);
}

/* Markdown content inside bottom info panel */
.history-info-body h1, .history-info-body h2, .history-info-body h3,
.history-info-body h4, .history-info-body h5, .history-info-body h6 {
  margin: 10px 0 6px;
  line-height: 1.2;
  font-weight: 600;
  font-size: 14px;
}

.history-info-body p {
  margin: 6px 0;
}

.history-info-body ul, .history-info-body ol {
  margin: 6px 0;
  padding-left: 18px;
}

.history-info-body a {
  color: var(--memo-accent);
  text-decoration: underline;
}

.history-info-body img {
  max-width: 100%;
  height: auto;
  border-radius: 8px;
  border: 1px solid #e5e7eb;
}

.history-info-body code {
  background: rgba(0, 0, 0, 0.05);
  padding: 2px 4px;
  border-radius: 4px;
}

.history-info-body pre {
  background: #0f172a;
  color: #e5e7eb;
  padding: 10px;
  border-radius: 8px;
  overflow: auto;
}

:host(.dark) .history-info-body a {
  color: #60a5fa;
}

:host(.dark) .history-info-body img {
  border-color: rgba(255, 255, 255, 0.1);
}

:host(.dark) .history-info-body code {
  background: rgba(255, 255, 255, 0.1);
}

:host(.dark) .history-info-body pre {
  background: #0b1020;
}

/* ========================================
   BLOCK SELECTION MODE
   ======================================== */
body.ai-memo-block-select-active {
  cursor: copy;
}

.panel.selecting-block {
  pointer-events: none;
  opacity: 0.8;
  transition: opacity 200ms ease-in-out;
}

#ai-memo-highlighter {
  position: absolute;
  z-index: 2147483646;
  background-color: rgba(59, 130, 246, 0.12);
  border: 2px solid rgba(59, 130, 246, 0.6);
  border-radius: 6px;
  pointer-events: none;
  transition: top 100ms ease, left 100ms ease, width 100ms ease, height 100ms ease;
  will-change: top, left, width, height;
}

.footer button:last-child {
  margin-right: 0;
}

/* ========================================
   TERMINAL THEME
   Cyber-minimalism design with glowing effects
   ======================================== */
:host(.terminal) {
  --memo-accent: #50fa7b; /* Terminal green */
  --memo-accent-hover: #69ff94;
  --memo-glow: 0 0 12px rgba(80, 250, 123, 0.4);
  --memo-border-terminal: rgba(80, 250, 123, 0.2);
}

:host(.terminal) .panel {
  background: rgba(10, 10, 15, 0.98);
  border-color: var(--memo-border-terminal);
  box-shadow: 0 0 40px rgba(80, 250, 123, 0.08), 0 20px 50px rgba(0, 0, 0, 0.5);
  position: relative;
}

/* CRT Scanline effect - subtle horizontal lines for retro monitor feel */
:host(.terminal) .panel::before {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(
    to bottom,
    rgba(18, 16, 16, 0) 50%,
    rgba(0, 0, 0, 0.08) 50%
  );
  background-size: 100% 4px;
  pointer-events: none;
  z-index: 10;
  border-radius: inherit;
}

:host(.terminal) .header {
  border-bottom-color: var(--memo-border-terminal);
  background: rgba(10, 10, 15, 0.9);
}

/* Terminal window buttons (traffic lights) - Fixed position */
:host(.terminal) .header::after {
  content: '';
  position: absolute;
  left: 16px;
  top: 22px; /* Fixed position instead of 50% */
  width: 48px;
  height: 12px;
  background: 
    radial-gradient(circle at 6px 6px, #ff5f56 5px, transparent 5px),
    radial-gradient(circle at 24px 6px, #ffbd2e 5px, transparent 5px),
    radial-gradient(circle at 42px 6px, #27c93f 5px, transparent 5px);
}

:host(.terminal) .header .title {
  color: var(--memo-accent);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  text-shadow: 0 0 8px rgba(80, 250, 123, 0.5);
  padding-left: 56px;
}

:host(.terminal) .header .title::before {
  content: '>_ ';
  opacity: 0.7;
}

:host(.terminal) .header .close:hover {
  background: rgba(80, 250, 123, 0.15);
  color: var(--memo-accent);
}

/* Terminal tabs */
:host(.terminal) .tabs {
  border-bottom-color: var(--memo-border-terminal);
  background: rgba(10, 10, 15, 0.6);
}

:host(.terminal) .tab {
  color: rgba(80, 250, 123, 0.6);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  border-radius: 0;
  border: 1px solid transparent;
}

:host(.terminal) .tab:hover {
  background: rgba(80, 250, 123, 0.1);
  color: var(--memo-accent);
  border-color: var(--memo-border-terminal);
}

:host(.terminal) .tab.active {
  background: rgba(80, 250, 123, 0.15);
  color: var(--memo-accent);
  border: 1px solid var(--memo-border-terminal);
  text-shadow: 0 0 6px rgba(80, 250, 123, 0.4);
}

/* Terminal input/textarea */
:host(.terminal) .input,
:host(.terminal) .textarea {
  background: rgba(5, 5, 10, 0.8);
  border-color: var(--memo-border-terminal);
  color: #d1d5db; /* Softer text color for better readability */
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  caret-color: var(--memo-accent); /* Neon green cursor */
}

:host(.terminal) .input:focus,
:host(.terminal) .textarea:focus {
  border-color: var(--memo-accent);
  box-shadow: 0 0 0 3px rgba(80, 250, 123, 0.12); /* Reduced glow for better focus */
}

:host(.terminal) .input::placeholder,
:host(.terminal) .textarea::placeholder {
  color: rgba(80, 250, 123, 0.35);
}

/* Terminal selection highlight */
:host(.terminal) .input::selection,
:host(.terminal) .textarea::selection {
  background: rgba(80, 250, 123, 0.3);
  color: #fff;
}

/* Terminal buttons */
:host(.terminal) .btn {
  background: transparent;
  color: var(--memo-accent);
  border: 1px solid var(--memo-border-terminal);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  box-shadow: 2px 2px 0px rgba(80, 250, 123, 0.2);
}

:host(.terminal) .btn:hover {
  background: rgba(80, 250, 123, 0.1);
  border-color: var(--memo-accent);
  box-shadow: 3px 3px 0px rgba(80, 250, 123, 0.3), var(--memo-glow);
  transform: translate(-1px, -1px);
}

:host(.terminal) .btn:active {
  background: var(--memo-accent);
  color: #052e16;
  box-shadow: none;
  transform: translate(2px, 2px);
}

:host(.terminal) .btn.secondary {
  border: 1px dashed var(--memo-border-terminal);
  color: rgba(80, 250, 123, 0.7);
}

:host(.terminal) .btn.secondary:hover {
  border-style: solid;
  border-color: var(--memo-accent);
  color: var(--memo-accent);
}

/* Terminal toolbar */
:host(.terminal) .memo-toolbar {
  background: rgba(5, 5, 10, 0.8);
  border-color: var(--memo-border-terminal);
}

:host(.terminal) .toolbar-btn {
  color: rgba(80, 250, 123, 0.7);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
}

:host(.terminal) .toolbar-btn:hover {
  background: rgba(80, 250, 123, 0.15);
  border-color: var(--memo-border-terminal);
  color: var(--memo-accent);
}

:host(.terminal) .toolbar-divider {
  background: var(--memo-border-terminal);
}

:host(.terminal) .toolbar-btn.ai {
  color: #bd93f9;
  background: rgba(189, 147, 249, 0.1);
}

:host(.terminal) .toolbar-btn.ai:hover {
  background: rgba(189, 147, 249, 0.2);
  border-color: #bd93f9;
}

:host(.terminal) .toolbar-btn.ai.primary {
  background: linear-gradient(135deg, #bd93f9 0%, #ff79c6 100%);
  color: #1a1a2e;
  box-shadow: 0 2px 8px rgba(189, 147, 249, 0.4);
}

:host(.terminal) .toolbar-btn.ai.primary:hover {
  box-shadow: 0 4px 16px rgba(189, 147, 249, 0.5);
}

/* Terminal footer */
:host(.terminal) .footer {
  border-top-color: var(--memo-border-terminal);
  background: rgba(10, 10, 15, 0.6);
}

:host(.terminal) .status-bar {
  background: rgba(80, 250, 123, 0.1);
  border: 1px solid var(--memo-border-terminal);
  border-radius: 0;
}

:host(.terminal) .status-dot {
  background: var(--memo-accent);
  box-shadow: 0 0 6px var(--memo-accent);
}

:host(.terminal) .status-text {
  color: var(--memo-accent);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
}

:host(.terminal) .footer-btn {
  color: rgba(80, 250, 123, 0.7);
  border-color: var(--memo-border-terminal);
  border-radius: 0;
}

:host(.terminal) .footer-btn:hover {
  background: rgba(80, 250, 123, 0.1);
  border-color: var(--memo-accent);
  color: var(--memo-accent);
}

:host(.terminal) .footer-btn:active {
  background: var(--memo-accent);
  color: #052e16;
}

:host(.terminal) .footer-btn.danger {
  color: #ff5555;
  border-color: rgba(255, 85, 85, 0.3);
}

:host(.terminal) .footer-btn.danger:hover {
  background: rgba(255, 85, 85, 0.15);
  border-color: #ff5555;
}

/* Terminal preview */
:host(.terminal) .preview-md {
  background: rgba(5, 5, 10, 0.8);
  border-color: var(--memo-border-terminal);
  color: #d1d5db; /* Softer text for better readability */
}

:host(.terminal) .preview-md:empty::before {
  color: rgba(80, 250, 123, 0.35);
}

/* Only apply glow to headings, not body text */
:host(.terminal) .preview-md h1,
:host(.terminal) .preview-md h2,
:host(.terminal) .preview-md h3 {
  color: var(--memo-accent);
  text-shadow: 0 0 8px rgba(80, 250, 123, 0.4);
}

:host(.terminal) .preview-md h4,
:host(.terminal) .preview-md h5,
:host(.terminal) .preview-md h6 {
  color: rgba(80, 250, 123, 0.85);
}

:host(.terminal) .preview-md a {
  color: var(--memo-accent);
  text-shadow: 0 0 4px rgba(80, 250, 123, 0.3);
}

:host(.terminal) .preview-md code {
  background: rgba(80, 250, 123, 0.1);
  color: var(--memo-accent);
}

:host(.terminal) .preview-md pre {
  background: #0a0a0f;
  border: 1px solid var(--memo-border-terminal);
}

:host(.terminal) .preview-md blockquote {
  border-left-color: var(--memo-accent);
  background: rgba(80, 250, 123, 0.05);
  color: #b8bcc4; /* Softer quote text */
}

/* Terminal layout bar */
:host(.terminal) .preview-layout-bar {
  background: rgba(5, 5, 10, 0.8);
  border-color: var(--memo-border-terminal);
}

:host(.terminal) .layout-toggle {
  background: rgba(80, 250, 123, 0.1);
  border-radius: 0;
}

:host(.terminal) .layout-btn {
  color: rgba(80, 250, 123, 0.6);
  border-radius: 0;
}

:host(.terminal) .layout-btn:hover {
  color: var(--memo-accent);
}

:host(.terminal) .layout-btn.active,
:host(.terminal) .layout-btn[aria-pressed="true"] {
  background: var(--memo-accent);
  color: #052e16;
  box-shadow: 0 0 8px rgba(80, 250, 123, 0.4);
}

:host(.terminal) .preview-pane-toggle {
  background: rgba(80, 250, 123, 0.1);
  border-radius: 0;
}

:host(.terminal) .preview-pane-toggle button {
  color: rgba(80, 250, 123, 0.6);
  border-radius: 0;
}

:host(.terminal) .preview-pane-toggle button:hover {
  color: var(--memo-accent);
}

:host(.terminal) .preview-pane-toggle button[aria-selected="true"] {
  background: var(--memo-accent);
  color: #052e16;
  box-shadow: 0 0 8px rgba(80, 250, 123, 0.4);
}

/* Terminal catalyst panel */
:host(.terminal) .catalyst-panel {
  background: linear-gradient(135deg, rgba(189, 147, 249, 0.1) 0%, rgba(255, 121, 198, 0.05) 100%);
  border-top-color: rgba(189, 147, 249, 0.3);
}

:host(.terminal) .catalyst-title {
  color: #bd93f9;
  text-shadow: 0 0 6px rgba(189, 147, 249, 0.4);
}

:host(.terminal) .catalyst-input {
  background: rgba(5, 5, 10, 0.8);
  border-color: rgba(189, 147, 249, 0.3);
  color: #e5e7eb;
}

:host(.terminal) .catalyst-input::placeholder {
  color: rgba(189, 147, 249, 0.5);
}

:host(.terminal) .catalyst-input:focus {
  border-color: #bd93f9;
  box-shadow: 0 0 0 3px rgba(189, 147, 249, 0.15), 0 0 12px rgba(189, 147, 249, 0.3);
}

:host(.terminal) .catalyst-run {
  background: linear-gradient(135deg, #bd93f9 0%, #ff79c6 100%);
  color: #1a1a2e;
  box-shadow: 0 2px 12px rgba(189, 147, 249, 0.4);
}

:host(.terminal) .catalyst-run:hover {
  box-shadow: 0 4px 20px rgba(189, 147, 249, 0.5);
}

/* Terminal toast */
:host(.terminal) .toast {
  background: rgba(10, 10, 15, 0.95);
  border: 1px solid var(--memo-border-terminal);
  color: var(--memo-accent);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  box-shadow: 0 0 20px rgba(80, 250, 123, 0.2);
}

/* Terminal labels */
:host(.terminal) .label {
  color: var(--memo-accent);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
}

:host(.terminal) .label::before {
  content: '$';
  color: var(--memo-accent);
  text-shadow: 0 0 4px rgba(80, 250, 123, 0.4);
}

/* Terminal hint */
:host(.terminal) .hint-text,
:host(.terminal) .hint-shortcut {
  color: rgba(80, 250, 123, 0.6);
}

:host(.terminal) .hint-shortcut kbd {
  color: var(--memo-accent);
  background: rgba(80, 250, 123, 0.1);
  border-color: var(--memo-border-terminal);
  box-shadow: 0 1px 0 rgba(80, 250, 123, 0.2);
}

/* Terminal history overlay */
:host(.terminal) .history-overlay .history-toolbar {
  background: rgba(10, 10, 15, 0.95);
  border-bottom-color: var(--memo-border-terminal);
}

:host(.terminal) .history-info {
  background: rgba(10, 10, 15, 0.98);
  border-top-color: var(--memo-border-terminal);
  box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(80, 250, 123, 0.05);
}

:host(.terminal) .history-info-title {
  color: var(--memo-accent);
  text-shadow: 0 0 6px rgba(80, 250, 123, 0.4);
}

:host(.terminal) .history-info-meta {
  color: rgba(80, 250, 123, 0.6);
}

:host(.terminal) .history-info-body {
  background: rgba(5, 5, 10, 0.8);
  border-color: var(--memo-border-terminal);
}

:host(.terminal) .history-info-list .dt {
  color: rgba(80, 250, 123, 0.6);
}

:host(.terminal) .history-info-list .lbl {
  color: var(--memo-accent);
}

:host(.terminal) .history-tooltip {
  background: rgba(10, 10, 15, 0.98);
  border-color: var(--memo-border-terminal);
  color: var(--memo-accent);
  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(80, 250, 123, 0.1);
}

/* Terminal scrollbar */
:host(.terminal) .body::-webkit-scrollbar-thumb,
:host(.terminal) .textarea::-webkit-scrollbar-thumb,
:host(.terminal) .preview-md::-webkit-scrollbar-thumb {
  background: rgba(80, 250, 123, 0.2);
}

:host(.terminal) .body::-webkit-scrollbar-thumb:hover,
:host(.terminal) .textarea::-webkit-scrollbar-thumb:hover,
:host(.terminal) .preview-md::-webkit-scrollbar-thumb:hover {
  background: rgba(80, 250, 123, 0.35);
}

:host(.terminal) .body,
:host(.terminal) .textarea,
:host(.terminal) .preview-md {
  scrollbar-color: rgba(80, 250, 123, 0.2) transparent;
}

/* Terminal block highlighter */
:host(.terminal) ~ #ai-memo-highlighter {
  background-color: rgba(80, 250, 123, 0.1);
  border-color: var(--memo-accent);
  box-shadow: 0 0 12px rgba(80, 250, 123, 0.3);
}


/* ========================================================================== */
/* Versions Overlay                                                           */
/* ========================================================================== */

.versions-overlay {
  position: fixed;
  inset: 0;
  z-index: 100000;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(4px);
}

.versions-panel {
  background: var(--memo-bg, #fff);
  border: 1px solid var(--memo-border, #e5e7eb);
  border-radius: 12px;
  width: min(90vw, 400px);
  max-height: 70vh;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
  animation: versions-slide-in 0.2s ease-out;
}

@keyframes versions-slide-in {
  from {
    opacity: 0;
    transform: translateY(-20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.versions-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 16px;
  border-bottom: 1px solid var(--memo-border, #e5e7eb);
  font-size: 14px;
  color: var(--memo-text, #1f2937);
}

.versions-header .btn-close {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 18px;
  color: var(--memo-muted, #9ca3af);
  padding: 4px 8px;
  border-radius: 4px;
  transition: all 0.15s ease;
}

.versions-header .btn-close:hover {
  background: var(--memo-hover, #f3f4f6);
  color: var(--memo-text, #1f2937);
}

.versions-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
  min-height: 100px;
}

.versions-empty {
  text-align: center;
  padding: 40px 20px;
  color: var(--memo-muted, #9ca3af);
  font-size: 13px;
  line-height: 1.6;
}

.version-item {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 12px;
  border: 1px solid var(--memo-border, #e5e7eb);
  border-radius: 8px;
  margin-bottom: 8px;
  transition: all 0.15s ease;
}

.version-item:hover {
  background: var(--memo-hover, #f9fafb);
  border-color: var(--memo-accent, #10b981);
}

.version-info {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.version-number {
  font-weight: 600;
  color: var(--memo-accent, #10b981);
  font-size: 13px;
}

.version-date {
  font-size: 11px;
  color: var(--memo-muted, #9ca3af);
}

.version-meta {
  display: flex;
  gap: 8px;
  font-size: 11px;
  color: var(--memo-muted, #9ca3af);
}

.version-summary {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 200px;
}

.version-restore {
  align-self: flex-end;
  padding: 6px 14px;
  font-size: 12px;
  background: var(--memo-accent, #10b981);
  color: #fff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.version-restore:hover {
  filter: brightness(1.1);
  transform: translateY(-1px);
}

.versions-footer {
  padding: 10px 16px;
  border-top: 1px solid var(--memo-border, #e5e7eb);
  font-size: 11px;
  color: var(--memo-muted, #9ca3af);
  text-align: center;
}

/* Dark mode versions */
:host(.dark) .versions-panel {
  background: var(--memo-bg-dark, #1f2937);
  border-color: var(--memo-border-dark, #374151);
}

:host(.dark) .versions-header {
  border-bottom-color: var(--memo-border-dark, #374151);
  color: var(--memo-text-dark, #f9fafb);
}

:host(.dark) .versions-header .btn-close {
  color: var(--memo-muted-dark, #6b7280);
}

:host(.dark) .versions-header .btn-close:hover {
  background: rgba(255, 255, 255, 0.1);
  color: var(--memo-text-dark, #f9fafb);
}

:host(.dark) .version-item {
  border-color: var(--memo-border-dark, #374151);
}

:host(.dark) .version-item:hover {
  background: rgba(255, 255, 255, 0.05);
}

:host(.dark) .versions-footer {
  border-top-color: var(--memo-border-dark, #374151);
}

/* Terminal theme versions */
:host(.terminal) .versions-panel {
  background: rgba(10, 10, 15, 0.98);
  border-color: var(--memo-border-terminal, rgba(80, 250, 123, 0.2));
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5), 0 0 30px rgba(80, 250, 123, 0.1);
}

:host(.terminal) .versions-header {
  border-bottom-color: var(--memo-border-terminal);
  color: var(--memo-accent, #50fa7b);
}

:host(.terminal) .versions-header .btn-close {
  color: rgba(80, 250, 123, 0.5);
}

:host(.terminal) .versions-header .btn-close:hover {
  background: rgba(80, 250, 123, 0.1);
  color: var(--memo-accent);
}

:host(.terminal) .version-item {
  border-color: var(--memo-border-terminal);
  background: rgba(5, 5, 10, 0.5);
}

:host(.terminal) .version-item:hover {
  background: rgba(80, 250, 123, 0.05);
  border-color: var(--memo-accent);
}

:host(.terminal) .version-number {
  color: var(--memo-accent);
  text-shadow: 0 0 6px rgba(80, 250, 123, 0.4);
}

:host(.terminal) .version-date,
:host(.terminal) .version-meta {
  color: rgba(80, 250, 123, 0.5);
}

:host(.terminal) .version-restore {
  background: transparent;
  border: 1px solid var(--memo-accent);
  color: var(--memo-accent);
}

:host(.terminal) .version-restore:hover {
  background: rgba(80, 250, 123, 0.1);
  box-shadow: 0 0 10px rgba(80, 250, 123, 0.3);
}

:host(.terminal) .versions-footer {
  border-top-color: var(--memo-border-terminal);
  color: rgba(80, 250, 123, 0.5);
}

```

### ai-memo.js

**Path:** `frontend/public/ai-memo/ai-memo.js`

```javascript
'use strict';
(() => {
  if (customElements.get('ai-memo-pad')) return;

  const LS = {
    get(key, fallback) {
      try {
        const v = localStorage.getItem(key);
        return v == null ? fallback : JSON.parse(v);
      } catch (_) {
        return fallback;
      }
    },
    set(key, val) {
      try {
        localStorage.setItem(key, JSON.stringify(val));
      } catch (_) {}
    },
  };

  const KEYS = {
    isOpen: 'aiMemo.isOpen',
    position: 'aiMemo.position',
    mode: 'aiMemo.mode',
    memo: 'aiMemo.content',
    apiKey: 'aiMemo.apiKey',
    adminToken: 'aiMemo.adminToken',
    inlineEnabled: 'aiMemo.inline.enabled',
    devHtml: 'aiMemo.dev.html',
    devCss: 'aiMemo.dev.css',
    devJs: 'aiMemo.dev.js',
    proposalMd: 'aiMemo.proposalMd',
    fontSize: 'aiMemo.fontSize',
    closeAfterInject: 'aiMemo.closeAfterInject',
    events: 'aiMemo.events',
    layoutMode: 'aiMemo.layoutMode',
    previewPane: 'aiMemo.previewPane'
  };

  const NOISY_EVENT_TYPES = new Set([
    'history_open',
    'history_close',
    'history_reset',
    'download_history',
    'history_import',
    'layout_change',
    'preview_pane',
    'toggle_inline',
    'toggle_close_after_inject',
    'reset_position',
    'toggle_fullscreen',
    'catalyst_open',
    'catalyst_close',
    'catalyst_cancel',
    'enter_block_select'
  ]);

  // 기본값 설정
  const DEFAULT_API_URL = 'https://api.nodove.com';
  const DEFAULT_REPO_URL = 'https://github.com/choisimo/blog';
  const BLOCK_SELECTORS = 'p, pre, code, blockquote, ul, ol, li, table, thead, tbody, tr, th, td, figure, figcaption, h1, h2, h3, h4, h5, h6, section, article, main';

  class AIMemoPad extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
      this.state = {
        isOpen: !!LS.get(KEYS.isOpen, false),
        position: LS.get(KEYS.position, { x: null, y: null }),
        mode: LS.get(KEYS.mode, 'memo'),
        memo: LS.get(KEYS.memo, ''),
        inlineEnabled: !!LS.get(KEYS.inlineEnabled, true),
        closeAfterInject: !!LS.get(KEYS.closeAfterInject, false),
        devHtml: LS.get(KEYS.devHtml, '<div>Hello AI Memo 👋</div>'),
        devCss: LS.get(
          KEYS.devCss,
          'body { font-family: system-ui, sans-serif; padding: 12px; }'
        ),
        devJs: LS.get(KEYS.devJs, 'console.log("Hello from user JS");'),
        proposalMd: LS.get(KEYS.proposalMd, ''),
        fontSize: LS.get(KEYS.fontSize, 13),
        events: LS.get(KEYS.events, []),
        layoutMode: LS.get(KEYS.layoutMode, 'split'),
        previewPane: LS.get(KEYS.previewPane, 'editor')
      };
      this.root = null; // shadow root container
      this._originalLoaded = false;
      this.isBlockSelectMode = false;
      this.highlightedBlock = null;
      this._turndown = null;
      this._prevCursor = '';
      this._boundBlockHighlight = this.handleBlockHighlight.bind(this);
      this._boundBlockCapture = this.handleBlockCapture.bind(this);
      this._boundBlockKeydown = this.handleBlockKeydown.bind(this);
      this.$previewSplit = null;
      this.$layoutSplit = null;
      this.$layoutTabs = null;
      this.$previewPaneToggle = null;
      this.$previewPaneButtons = [];

      if (window.TurndownService) {
        this._turndown = new window.TurndownService();
      } else {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/turndown/dist/turndown.js';
        script.onload = () => {
          if (window.TurndownService) {
            this._turndown = new window.TurndownService();
          }
        };
        document.head.appendChild(script);
      }

      // Output channel ensures UI writes stay scoped to shadow DOM
      this.out = {
        getStatus: () => {
          const statusText = this.shadowRoot?.querySelector('.status-text');
          return statusText ? statusText.textContent || '' : '';
        },
        setStatus: (text) => {
          try {
            const statusText = this.shadowRoot?.querySelector('.status-text');
            if (statusText) statusText.textContent = String(text ?? '');
          } catch (_) {}
        },
        tempStatus: (text, restoreTo, delay = 1400) => {
          try {
            const statusText = this.shadowRoot?.querySelector('.status-text');
            const prev = typeof restoreTo === 'string' ? restoreTo : (statusText?.textContent || 'Ready');
            if (statusText) statusText.textContent = String(text ?? '');
            clearTimeout(this._statusTimer);
            this._statusTimer = setTimeout(() => { try { if (statusText) statusText.textContent = prev; } catch (_) {} }, delay);
          } catch (_) {}
        },
        toast: (msg) => { try { const t = this.$toast; if (!t) return; t.textContent = String(msg || ''); t.classList.add('show'); clearTimeout(this._toastTimer); this._toastTimer = setTimeout(() => t.classList.remove('show'), 1600); } catch (_) {} },
        append: (block) => {
          try {
            const cur = this.$memo?.value || '';
            const next = cur + String(block || '');
            if (this.$memo) this.$memo.value = next;
            if (this.$memoEditor) this.$memoEditor.value = next;
            if (this.$memoPreview) this.renderMarkdownToPreview(next);
            if (this.$memo) this.$memo.dispatchEvent(new Event('input', { bubbles: true }));
            return next;
          } catch (_) { return null; }
        },
        renderAIDetails: (details) => {
          try {
            const aiDetails = this.$aiDetails;
            if (!aiDetails) return;
            aiDetails.innerHTML = '';
            const title = document.createElement('h3');
            title.textContent = 'AI Q&A Details';
            aiDetails.appendChild(title);
            const ul = document.createElement('ul');
            Object.keys(details).forEach(key => {
              const li = document.createElement('li');
              li.textContent = `${key}: ${details[key]}`;
              ul.appendChild(li);
            });
            aiDetails.appendChild(ul);
          } catch (_) {}
        }
      };
    }

    connectedCallback() {
      this.render();
      this.bind();
      this.applyThemeFromPage();
      this.restore();
      // If first mount and isOpen, ensure visibility
      this.updateOpen();
      this.updateMode();
      window.addEventListener(
        'aiMemo:log',
        this._onExternalLog
      );
    }

    disconnectedCallback() {
      window.removeEventListener(
        'aiMemo:log',
        this._onExternalLog
      );
    }

    applyThemeFromPage() {
      const update = () => {
        const isDark = document.documentElement.classList.contains('dark');
        const isTerminal = document.documentElement.classList.contains('terminal');
        this.classList.toggle('dark', isDark);
        this.classList.toggle('terminal', isTerminal);
        if (this.$historyOverlay && this.$historyOverlay.style.display !== 'none') {
          this.scheduleHistoryDraw();
        }
      };
      update();
      const mo = new MutationObserver(update);
      mo.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class'],
      });
    }

    clamp(x, y) {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rect = this.$panel.getBoundingClientRect();
      // Use actual dimensions or fallback to default panel size (400x520)
      const w = rect.width > 0 ? rect.width : Math.min(400, vw - 32);
      const h = rect.height > 0 ? rect.height : Math.min(520, vh - 100);
      // Stricter check: if position would place panel mostly off-screen, return null
      // Panel must have at least 50% visible or be within reasonable bounds
      const minVisible = 100; // at least 100px must be visible
      if (x < -w + minVisible || x > vw - minVisible || y < -h + minVisible || y > vh - minVisible) {
        return { x: null, y: null };
      }
      // Clamp to keep panel fully within viewport with padding
      const padding = 12;
      const nx = Math.max(padding, Math.min(vw - w - padding, x));
      const ny = Math.max(padding, Math.min(vh - h - padding, y));
      return { x: nx, y: ny };
    }

    // Deprecated: prefer using this.out.toast(msg) directly to keep output scoped within the shadow DOM
    toast(msg) { try { this.out.toast(msg); } catch (_) {} }

    getArticleText() {
      // Try common containers, fall back to body text
      const trySel = sel => document.querySelector(sel)?.innerText?.trim();
      const candidates = [
        'article',
        'main',
        'article.prose',
        '.prose',
        '#content',
      ];
      for (const sel of candidates) {
        const v = trySel(sel);
        if (v && v.length > 40) return v;
      }
      return (document.body?.innerText || '').trim();
    }

    async summarizeWithGemini() {
      const article = this.getArticleText();
      const memo = this.$memo.value || '';
      const limit = (s, max = 8000) =>
        s && s.length > max ? `${s.slice(0, max)}\n…(truncated)` : s;
      const instructions = [
        '다음 페이지 본문과 나의 메모를 바탕으로 핵심 요약을 작성해 주세요.',
        '- 한국어로 간결한 불릿 포인트 5~10개로 정리',
        '- 중요 개념/용어는 강조',
        '- 필요한 경우 간단한 예시 코드 포함',
      ].join('\n');

      const btn = this.$aiSummary;
      const prevStatus = this.out.getStatus();
      const statusDot = this.shadowRoot?.querySelector('.status-dot');
      
      try {
        btn.disabled = true;
        if (statusDot) statusDot.style.background = '#7c3aed';
        this.out.setStatus('AI 요약 중…');
        
        const backend = window.__APP_CONFIG?.apiBaseUrl || window.APP_CONFIG?.apiBaseUrl || DEFAULT_API_URL;
        const endpoint = `${backend.replace(/\/$/, '')}/api/v1/ai/summarize`;
        const res = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            input: [
              '[페이지 본문]',
              limit(article, 6000),
              '',
              '[나의 메모]',
              limit(memo, 2000),
            ].join('\n'),
            instructions,
          }),
        });
        if (!res.ok) {
          const t = await res.text().catch(() => '');
          throw new Error(`요약 실패(${res.status}) ${t.slice(0, 200)}`);
        }
        const data = await res.json();
        const out = (data?.data?.summary || data?.summary || '').toString();
        if (!out) throw new Error('응답 파싱 실패');

        const stamp = new Date().toLocaleString();
        const block = `\n\n[AI 요약 @ ${stamp}]\n${out.trim()}\n`;
        this.out.append(block);
        this.out.toast('AI 요약이 메모에 추가되었습니다.');
        if (statusDot) statusDot.style.background = 'var(--memo-accent)';
        this.out.setStatus('완료');
        this.logEvent({ type: 'ai_summary_done', label: 'ok' });
      } catch (err) {
        console.error('Gemini summarize error:', err);
        if (statusDot) statusDot.style.background = '#dc2626';
        this.out.setStatus('오류');
        this.out.toast(err?.message || '요약 중 오류가 발생했습니다.');
        this.logEvent({ type: 'ai_summary_error', label: err?.message || 'error' });
      } finally {
        btn.disabled = false;
        setTimeout(() => {
          if (statusDot) statusDot.style.background = 'var(--memo-accent)';
          this.out.setStatus(prevStatus || 'Ready');
        }, 1400);
      }
    }


    async runCatalyst(promptText) {
      const prompt = (promptText || this.$catalystInput?.value || '').trim();
      if (!prompt) { this.out.toast('Catalyst 프롬프트를 입력하세요.'); return; }
      const article = this.getArticleText();
      const memo = this.$memo.value || '';
      const limit = (s, max = 8000) => s && s.length > max ? `${s.slice(0, max)}\n…(truncated)` : s;
      const instructions = [
        '사용자 프롬프트를 "촉매"로 사용해 글의 새로운 관점을 제시하세요.',
        '- 한국어로 작성하고, 구조적인 소제목과 간결한 문장을 사용',
        '- 필요 시 불릿 목록, 표, 간단한 코드 예시를 포함',
        `- 사용자 프롬프트: "${prompt.replace(/` + "`" + `/g, '\\`')}"`
      ].join('\n');

      const btn = this.$catalystRun || this.$catalystBtn; 
      const inputEl = this.$catalystInput;
      const catalystPanel = this.$catalystBox;
      const prev = this.out.getStatus();
      
      try {
        // Set loading state
        if (btn) btn.disabled = true;
        if (inputEl) inputEl.disabled = true;
        if (catalystPanel) catalystPanel.classList.add('loading');
        
        // Update status with loading indicator
        const statusDot = this.shadowRoot?.querySelector('.status-dot');
        if (statusDot) statusDot.style.background = '#7c3aed';
        this.out.setStatus('Catalyst 생성 중…');
        
        const backend = window.__APP_CONFIG?.apiBaseUrl || window.APP_CONFIG?.apiBaseUrl || DEFAULT_API_URL;
        const endpoint = `${backend.replace(/\/$/, '')}/api/v1/ai/summarize`;
        const res = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            input: [
              '[페이지 본문]',
              limit(article, 6000),
              '',
              '[현재 메모]',
              limit(memo, 2000),
            ].join('\n'),
            instructions,
          }),
        });
        if (!res.ok) {
          const t = await res.text().catch(() => '');
          throw new Error(`Catalyst 실패(${res.status}) ${t.slice(0, 200)}`);
        }
        const data = await res.json();
        const out = (data?.data?.summary || data?.summary || '').toString();
        if (!out) throw new Error('응답 파싱 실패');

        const stamp = new Date().toLocaleString();
        const block = `\n\n## ${prompt}\n[위 관점 @ ${stamp}]\n${out.trim()}\n`;
        this.out.append(block);
        this.out.toast('Catalyst 결과가 메모에 추가되었습니다.');
        this.logEvent({ type: 'catalyst_run', label: prompt });
        if (this.$catalystInput) this.$catalystInput.value = '';
        if (this.$catalystBox) this.$catalystBox.style.display = 'none';
        if (this.$catalystInput) this.$catalystInput.disabled = false;
        
        // Success status
        if (statusDot) statusDot.style.background = 'var(--memo-accent)';
        this.out.setStatus('완료');
      } catch (err) {
        console.error('Catalyst error:', err);
        const statusDot = this.shadowRoot?.querySelector('.status-dot');
        if (statusDot) statusDot.style.background = '#dc2626';
        this.out.setStatus('오류');
        this.out.toast(err?.message || 'Catalyst 생성 중 오류가 발생했습니다.');
      } finally {
        if (btn) btn.disabled = false;
        if (inputEl) inputEl.disabled = false;
        if (catalystPanel) catalystPanel.classList.remove('loading');
        setTimeout(() => { 
          const statusDot = this.shadowRoot?.querySelector('.status-dot');
          if (statusDot) statusDot.style.background = 'var(--memo-accent)';
          this.out.setStatus(prev || 'Ready'); 
        }, 1400);
      }
    }

    // ========================================================================
    // Cloud Sync & Versioning
    // ========================================================================

    getUserId() {
      // Use a persistent user ID (could be enhanced with auth)
      let userId = LS.get('aiMemo.userId', null);
      if (!userId) {
        userId = 'user-' + crypto.randomUUID();
        LS.set('aiMemo.userId', userId);
      }
      return userId;
    }

    getApiBase() {
      // Priority: runtime config > localStorage > default
      // This should match frontend/src/utils/apiBase.ts logic
      
      // 1) Runtime injected config (window.APP_CONFIG)
      const w = typeof window !== 'undefined' ? window : null;
      const fromRuntime = w?.APP_CONFIG?.apiBaseUrl || w?.__APP_CONFIG?.apiBaseUrl;
      if (typeof fromRuntime === 'string' && fromRuntime) return fromRuntime;

      // 2) localStorage override (developer convenience)
      try {
        const v = LS.get('aiMemo.backendUrl');
        if (typeof v === 'string' && v) return v;
      } catch {
        // ignore
      }

      // 3) Localhost detection
      const host = location.host;
      if (host.includes('localhost') || host.includes('127.0.0.1')) {
        return 'http://localhost:8787';
      }

      // 4) Default production URL
      return DEFAULT_API_URL;
    }

    async syncToCloud() {
      const content = (this.$memo?.value || '').trim();
      if (!content) {
        this.out.toast('메모가 비어 있습니다.');
        return;
      }

      const userId = this.getUserId();
      const apiBase = this.getApiBase();

      this.out.setStatus('동기화 중...');
      const syncBtn = this.$memoSync;
      if (syncBtn) syncBtn.disabled = true;

      try {
        const res = await fetch(`${apiBase}/api/v1/memos/${encodeURIComponent(userId)}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            content,
            createVersion: true,
            changeSummary: `Manual sync at ${new Date().toLocaleString()}`
          })
        });

        const data = await res.json();

        if (!data.ok) {
          throw new Error(data.error?.message || 'Sync failed');
        }

        this.out.toast(`클라우드에 저장됨 (v${data.data?.version || '?'})`);
        this.logEvent({ type: 'cloud_sync', label: 'success', version: data.data?.version });
      } catch (err) {
        console.error('Sync error:', err);
        this.out.toast(err?.message || '동기화 실패');
      } finally {
        if (syncBtn) syncBtn.disabled = false;
        this.out.setStatus('Ready');
      }
    }

    async openVersions() {
      if (!this.$versionsOverlay || !this.$versionsList) return;

      this.$versionsOverlay.style.display = 'flex';
      this.$versionsList.innerHTML = '<div class="versions-empty">로딩 중...</div>';
      this.logEvent({ type: 'versions_open' });

      const userId = this.getUserId();
      const apiBase = this.getApiBase();

      try {
        const res = await fetch(`${apiBase}/api/v1/memos/${encodeURIComponent(userId)}/versions?limit=20`);
        const data = await res.json();

        if (!data.ok || !data.data?.versions?.length) {
          this.$versionsList.innerHTML = '<div class="versions-empty">저장된 버전이 없습니다.<br><small>동기화 버튼을 눌러 클라우드에 저장하세요.</small></div>';
          return;
        }

        const versions = data.data.versions;
        this.$versionsList.innerHTML = versions.map(v => `
          <div class="version-item" data-version="${v.version}">
            <div class="version-info">
              <span class="version-number">v${v.version}</span>
              <span class="version-date">${new Date(v.createdAt).toLocaleString()}</span>
            </div>
            <div class="version-meta">
              <span class="version-size">${Math.round(v.contentLength / 1024 * 10) / 10}KB</span>
              ${v.changeSummary ? `<span class="version-summary">${v.changeSummary}</span>` : ''}
            </div>
            <button class="version-restore" data-version="${v.version}">복원</button>
          </div>
        `).join('');

        // Add restore click handlers
        this.$versionsList.querySelectorAll('.version-restore').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const version = parseInt(btn.dataset.version);
            if (version) this.restoreVersion(version);
          });
        });

      } catch (err) {
        console.error('Versions error:', err);
        this.$versionsList.innerHTML = '<div class="versions-empty">버전 로딩 실패</div>';
      }
    }

    closeVersions() {
      if (this.$versionsOverlay) {
        this.$versionsOverlay.style.display = 'none';
      }
      this.logEvent({ type: 'versions_close' });
    }

    async restoreVersion(version) {
      if (!confirm(`버전 ${version}을(를) 복원할까요?\n현재 메모가 덮어씌워집니다.`)) return;

      const userId = this.getUserId();
      const apiBase = this.getApiBase();

      this.out.setStatus('복원 중...');

      try {
        // First get the version content
        const getRes = await fetch(`${apiBase}/api/v1/memos/${encodeURIComponent(userId)}/versions/${version}`);
        const getData = await getRes.json();

        if (!getData.ok || !getData.data?.version?.content) {
          throw new Error('버전 데이터를 가져올 수 없습니다.');
        }

        // Apply to memo
        const content = getData.data.version.content;
        if (this.$memo) this.$memo.value = content;
        if (this.$memoEditor) this.$memoEditor.value = content;
        this.state.memo = content;
        LS.set(KEYS.memo, content);

        if (this.$memoPreview) {
          this.scheduleRenderPreview(content);
        }

        // Call restore endpoint to create a new version
        const restoreRes = await fetch(`${apiBase}/api/v1/memos/${encodeURIComponent(userId)}/restore/${version}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        const restoreData = await restoreRes.json();

        this.closeVersions();
        this.out.toast(`버전 ${version} 복원됨`);
        this.logEvent({ type: 'version_restore', label: `v${version}`, newVersion: restoreData.data?.version });
      } catch (err) {
        console.error('Restore error:', err);
        this.out.toast(err?.message || '복원 실패');
      } finally {
        this.out.setStatus('Ready');
      }
    }

    applyFontSize(size) {
      const fs = Math.max(10, Math.min(20, parseInt(size || 13, 10)));
      const root = this.shadowRoot;
      if (!root) return;
      const targets = [this.$memo, this.$memoEditor, this.$memoPreview];
      targets.forEach(t => {
        if (!t) return;
        t.style.fontSize = `${fs}px`;
        if (t.tagName === 'TEXTAREA') t.style.lineHeight = '1.6';
      });
    }

    // Convert Markdown to sanitized HTML string
    markdownToHtml(src) {
      let s = String(src || '');

      // escape HTML
      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

      // collect tokens for code to avoid further markdown transforms inside
      const tokens = [];
      const tokenize = html => {
        tokens.push(html);
        return `@@TOKEN${tokens.length - 1}@@`;
      };

      // fenced code blocks ```lang\n...\n```
      s = s.replace(/```([\w-]*)\n([\s\S]*?)```/g, (m, lang, code) => {
        const c = code.replace(/\n$/, '').replace(/&/g, '&amp;').replace(/</g, '&lt;');
        return tokenize(`<pre><code class="lang-${lang || 'text'}">${c}</code></pre>`);
      });

      // inline code `...`
      s = s.replace(/`([^`]+)`/g, (m, code) => {
        const c = code.replace(/&/g, '&amp;').replace(/</g, '&lt;');
        return tokenize(`<code>${c}</code>`);
      });

      // headings
      s = s.replace(/^######\s+(.*)$/gm, '<h6>$1</h6>')
           .replace(/^#####\s+(.*)$/gm, '<h5>$1</h5>')
           .replace(/^####\s+(.*)$/gm, '<h4>$1</h4>')
           .replace(/^###\s+(.*)$/gm, '<h3>$1</h3>')
           .replace(/^##\s+(.*)$/gm, '<h2>$1</h2>')
           .replace(/^#\s+(.*)$/gm, '<h1>$1</h1>');

      // url sanitizer
      const sanitizeUrl = (url) => {
        try {
          const raw = (url || '').trim();
          if (!raw) return '#';
          // allow only http(s), mailto, tel; support relative links
          const hasScheme = /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(raw);
          const u = hasScheme ? new URL(raw) : new URL(raw, location.href);
          const p = u.protocol.toLowerCase();
          if (p === 'http:' || p === 'https:' || p === 'mailto:' || p === 'tel:') return u.href;
          return '#';
        } catch (_) {
          return '#';
        }
      };

      // images ![alt](url)
      s = s.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (m, alt, url) => {
        const safe = sanitizeUrl(url);
        const a = String(alt || '').replace(/"/g, '&quot;');
        return `<img alt="${a}" src="${safe}" loading="lazy" referrerpolicy="no-referrer" />`;
      });

      // links [text](url)
      s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m, text, url) => {
        const safe = sanitizeUrl(url);
        return `<a href="${safe}" target="_blank" rel="noopener noreferrer">${text}</a>`;
      });

      // bold/italic (naive)
      s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
           .replace(/\*([^*]+)\*/g, '<em>$1</em>');

      // lists
      s = s.replace(/^(?:- |\* )(.*)$/gm, '<li>$1</li>');
      s = s.replace(/(<li>.*<\/li>\n?)+/g, m => `<ul>${m}</ul>`);
      // ordered lists
      s = s.replace(/^\d+\. (.*)$/gm, '<li>$1</li>');
      s = s.replace(/(<li>.*<\/li>\n?)+/g, m => m.includes('<ul>') ? m : `<ol>${m}</ol>`);

      // blockquotes
      s = s.replace(/^>\s?(.*)$/gm, '<blockquote>$1<\/blockquote>');

      // paragraphs (split by double newlines)
      s = s.split(/\n{2,}/).map(block => {
        if (/^<h\d|<pre|<ul>|<ol>|<blockquote>|<img|<p>|<a /.test(block.trim())) return block;
        return `<p>${block.replace(/\n/g, '<br/>')}</p>`;
      }).join('\n');

      // restore tokens
      s = s.replace(/@@TOKEN(\d+)@@/g, (m, i) => tokens[+i] || '');

      return s;
    }

    // Enhance <pre><code> blocks: add line numbers and simple syntax colors
    enhanceCodeBlocks() {
      if (!this.$memoPreview) return;
      const blocks = this.$memoPreview.querySelectorAll('pre > code');
      blocks.forEach(codeEl => {
        const cls = codeEl.className || '';
        const m = cls.match(/lang-([\w-]+)/);
        const lang = (m && m[1] || 'text').toLowerCase();
        const raw = codeEl.textContent || '';
        const escapeHtml = (s) => s.replace(/&/g, '&amp;').replace(/</g, '&lt;');

        const highlightLine = (line) => {
          let out = escapeHtml(line);
          const apply = (regex, wrap) => {
            out = out.replace(regex, wrap);
          };

          const word = (list) => new RegExp(`\\b(?:${list.join('|')})\\b`, 'g');
          const fnName = /\b([A-Za-z_][A-Za-z0-9_]*)\s*(?=\()/g;

          if (lang === 'js' || lang === 'ts' || lang === 'javascript' || lang === 'typescript' || lang === 'c' || lang === 'cpp' || lang === 'java') {
            // split comment part
            const idx = out.indexOf('//');
            let head = idx >= 0 ? out.slice(0, idx) : out;
            let tail = idx >= 0 ? out.slice(idx) : '';
            // strings
            head = head
              .replace(/"([^"\\]|\\.)*"/g, '<span class="str">$&</span>')
              .replace(/'([^'\\]|\\.)*'/g, '<span class="str">$&</span>')
              .replace(/`([^`\\]|\\.)*`/g, '<span class="str">$&</span>');
            // numbers
            head = head.replace(/\b\d+(?:\.\d+)?\b/g, '<span class="num">$&</span>');
            // keywords
            const kws = word(['const','let','var','function','return','if','else','for','while','do','switch','case','break','continue','class','extends','new','try','catch','finally','throw','await','async','yield','import','from','export','default','in','of','this','super','true','false','null','undefined']);
            head = head.replace(kws, '<span class="kw">$&</span>');
            // function names
            head = head.replace(fnName, (m, g1) => `<span class="fn">${g1}</span>`);
            if (tail) tail = `<span class="cm">${tail}</span>`;
            out = head + tail;
          } else if (lang === 'py' || lang === 'python') {
            const hash = out.indexOf('#');
            let head = hash >= 0 ? out.slice(0, hash) : out;
            let tail = hash >= 0 ? out.slice(hash) : '';
            head = head
              .replace(/"([^"\\]|\\.)*"/g, '<span class="str">$&</span>')
              .replace(/'([^'\\]|\\.)*'/g, '<span class="str">$&</span>');
            head = head.replace(/\b\d+(?:\.\d+)?\b/g, '<span class="num">$&</span>');
            const kws = word(['def','return','if','elif','else','for','while','try','except','finally','with','as','class','import','from','pass','break','continue','True','False','None','in','is','not','and','or','lambda','yield']);
            head = head.replace(kws, '<span class="kw">$&</span>');
            head = head.replace(fnName, (m, g1) => `<span class="fn">${g1}</span>`);
            if (tail) tail = `<span class="cm">${tail}</span>`;
            out = head + tail;
          } else if (lang === 'json') {
            out = out
              .replace(/"([^"\\]|\\.)*"(?=\s*:)/g, '<span class="kw">$&</span>')
              .replace(/"([^"\\]|\\.)*"/g, '<span class="str">$&</span>')
              .replace(/\b\d+(?:\.\d+)?\b/g, '<span class="num">$&</span>')
              .replace(/\b(true|false|null)\b/g, '<span class="kw">$1</span>');
          } else if (lang === 'bash' || lang === 'sh' || lang === 'shell') {
            const hash = out.indexOf('#');
            let head = hash >= 0 ? out.slice(0, hash) : out;
            let tail = hash >= 0 ? out.slice(hash) : '';
            head = head.replace(/"([^"\\]|\\.)*"/g, '<span class="str">$&</span>').replace(/'([^'\\]|\\.)*'/g, '<span class="str">$&</span>');
            const kws = word(['if','then','fi','for','do','done','case','esac','function','in','elif','else','return','local','export']);
            head = head.replace(kws, '<span class="kw">$&</span>');
            if (tail) tail = `<span class="cm">${tail}</span>`;
            out = head + tail;
          }
          return out;
        };

        const lines = raw.split('\n');
        const html = lines.map(l => `<span class="line">${highlightLine(l)}</span>`).join('\n');
        codeEl.innerHTML = html;
      });
    }

    // Render preview and enhance code blocks
    renderMarkdownToPreview(src) {
      if (!this.$memoPreview) return;
      const html = this.markdownToHtml(src);
      this.$memoPreview.innerHTML = html;
      this.enhanceCodeBlocks();
    }

    applyLayoutMode(mode) {
      if (!this.$previewSplit) return;
      const layout = mode === 'tab' ? 'tab' : 'split';
      this.$previewSplit.setAttribute('data-layout', layout);
      if (layout === 'split') {
        this.$previewSplit.setAttribute('data-active-pane', 'editor');
      }
      if (this.$layoutSplit && this.$layoutTabs) {
        this.$layoutSplit.classList.toggle('active', layout === 'split');
        this.$layoutSplit.setAttribute('aria-pressed', layout === 'split' ? 'true' : 'false');
        this.$layoutTabs.classList.toggle('active', layout === 'tab');
        this.$layoutTabs.setAttribute('aria-pressed', layout === 'tab' ? 'true' : 'false');
      }
      if (this.$previewPaneToggle) {
        this.$previewPaneToggle.dataset.visible = layout === 'tab' ? 'true' : 'false';
      }
      this.state.layoutMode = layout;
      LS.set(KEYS.layoutMode, layout);
    }

    applyPreviewPane(pane) {
      if (!this.$previewSplit) return;
      const next = pane === 'preview' ? 'preview' : 'editor';
      this.$previewSplit.setAttribute('data-active-pane', next);
      if (Array.isArray(this.$previewPaneButtons)) {
        this.$previewPaneButtons.forEach(btn => {
          const active = btn.dataset.pane === next;
          btn.setAttribute('aria-selected', active ? 'true' : 'false');
        });
      }
      this.state.previewPane = next;
      LS.set(KEYS.previewPane, next);
      if (next === 'preview' && this.$memoPreview) {
        this.scheduleRenderPreview(this.$memoEditor?.value || this.$memo?.value || '');
      }
    }


    // debounce preview rendering to keep typing smooth
    scheduleRenderPreview(src) {
      clearTimeout(this._renderTimer);
      this._renderTimer = setTimeout(() => this.renderMarkdownToPreview(src), 100);
    }

    getArticleHtml() {
      const el =
        document.querySelector('article') || document.querySelector('main');
      return el ? el.outerHTML : '';
    }

    getContext() {
      return {
        article: {
          title: document.title,
          url: location.href,
          text: this.getArticleText(),
          html: this.getArticleHtml(),
        },
        memo: { content: this.$memo?.value || '' },
      };
    }

    buildSrcdoc(html, css, js, inlineRunner = false) {
      const escapeScript = s => (s || '').replace(/<\/(script)/gi, '<\\/$1');
      const runnerInline = `\n<script>\n'use strict';\n(()=>{\n  window.context = {};\n  window.addEventListener('message', (e)=>{\n    const d=e?.data; if(!d) return;\n    if(d.type==='init'&&d.context){ window.context = d.context; if(typeof window.onContextReady==='function'){ try{ window.onContextReady(); }catch(_){} } }\n  });\n})();\n<\/script>`;
      const runnerTag = inlineRunner
        ? runnerInline
        : `\n<script src="/ai-memo/runner.js"><\/script>`;
      return `<!doctype html>\n<html>\n<head>\n<meta charset="utf-8"/>\n<style>\n${css || ''}\n</style>\n</head>\n<body>\n${html || ''}\n${runnerTag}\n<script>\ntry{\n${escapeScript(js || '')}\n}catch(e){ console.error(e); }\n<\/script>\n</body>\n</html>`;
    }

    runPreview() {
      const html = this.$devHtml?.value || '';
      const css = this.$devCss?.value || '';
      const js = this.$devJs?.value || '';
      if (!this.$preview) return;
      const srcdoc = this.buildSrcdoc(html, css, js, false);
      this.$preview.srcdoc = srcdoc;
      this.out.tempStatus('미리보기 갱신', 'Ready');
      const send = () => {
        try {
          this.$preview.contentWindow.postMessage(
            { type: 'init', context: this.getContext() },
            '*'
          );
        } catch (_) {}
      };
      this.$preview.addEventListener('load', () => setTimeout(send, 30), {
        once: true,
      });
    }

    downloadFeature() {
      const html = this.$devHtml.value;
      const css = this.$devCss.value;
      const js = this.$devJs.value;
      const file = this.buildSrcdoc(html, css, js, true);
      const blob = new Blob([file], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'feature.html';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      this.out.toast('feature.html 다운로드');
    }

    openIssue() {
      const repo = DEFAULT_REPO_URL;
      const title = encodeURIComponent('Feature Proposal: AI Memo Extension');
      const bodyContent = [
        '### 설명',
        'AI 메모 개발 모드에서 제작한 기능 제안입니다. 아래 코드를 참고해 주세요.',
        '',
        '#### HTML',
        '```html',
        (this.$devHtml.value || '').slice(0, 5000),
        '```',
        '',
        '#### CSS',
        '```css',
        (this.$devCss.value || '').slice(0, 5000),
        '```',
        '',
        '#### JS',
        '```js',
        (this.$devJs.value || '').slice(0, 5000),
        '```',
        '',
        `페이지: ${location.href}`,
      ].join('\n');
      const body = encodeURIComponent(bodyContent);
      const issuesUrl = `${repo.replace(/\/?$/, '')}/issues/new?title=${title}&body=${body}`;
      window.open(issuesUrl, '_blank', 'noopener');
    }

    render() {
      const doc = document.createElement('div');
      doc.innerHTML = `
        <link rel="stylesheet" href="/ai-memo/ai-memo.css" />
        <div class="bottom-app-bar"></div>
        <div id="launcher" class="launcher button" title="AI Memo" aria-label="AI Memo">📝</div>
        <div id="historyLauncher" class="launcher history button" title="History" aria-label="History">📖</div>
        <div id="historyOverlay" class="history-overlay" style="display:none;">
          <div class="history-toolbar">
            <div class="left">
              <strong>Web of Curiosity</strong>
              <span class="small" style="margin-left:8px; opacity:0.8;">Scroll: zoom • Drag: pan • Click: pin • Double-click post: open</span>
            </div>
            <div class="right">
              <button id="historyExport" class="btn secondary">내보내기</button>
              <button id="historyImport" class="btn secondary">가져오기</button>
              <button id="historyReset" class="btn secondary">초기화</button>
              <button id="historyClose" class="btn">닫기</button>
            </div>
          </div>
          <canvas id="historyCanvas"></canvas>
        </div>
        <div id="versionsOverlay" class="versions-overlay" style="display:none;">
          <div class="versions-panel">
            <div class="versions-header">
              <strong>버전 기록</strong>
              <button id="versionsClose" class="btn-close" aria-label="닫기">✕</button>
            </div>
            <div id="versionsList" class="versions-list">
              <div class="versions-empty">로딩 중...</div>
            </div>
            <div class="versions-footer">
              <span class="versions-info">클라우드에 저장된 버전을 복원할 수 있습니다.</span>
            </div>
          </div>
        </div>
        <div id="panel" class="panel">
          <div id="drag" class="header">
            <div class="title">떠다니는 AI 메모</div>
            <div class="spacer"></div>
            <div id="close" class="close" aria-label="닫기">✕</div>
          </div>
          <div class="tabs">
            <div class="tab" data-tab="memo">메모</div>
            <div class="tab" data-tab="preview">미리보기</div>
            <div class="tab" data-tab="dev">새 버전 제안</div>
            <div class="tab" data-tab="settings">설정</div>
          </div>
          <div id="memoBody" class="body">
            <div class="section">
              <div class="memo-toolbar">
                <div class="toolbar-group format-group" role="toolbar" aria-label="서식">
                  <button id="memoBold" class="toolbar-btn" title="Bold (Ctrl+B)" aria-label="Bold"><span class="icon">B</span></button>
                  <button id="memoItalic" class="toolbar-btn" title="Italic (Ctrl+I)" aria-label="Italic"><span class="icon italic">I</span></button>
                  <button id="memoCode" class="toolbar-btn" title="Inline code" aria-label="Inline code"><span class="icon mono">{}</span></button>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-group heading-group" role="toolbar" aria-label="제목">
                  <button id="memoH1" class="toolbar-btn" title="제목 1 (#)" aria-label="Heading 1"><span class="icon">H1</span></button>
                  <button id="memoH2" class="toolbar-btn" title="제목 2 (##)" aria-label="Heading 2"><span class="icon">H2</span></button>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-group list-group" role="toolbar" aria-label="목록">
                  <button id="memoUl" class="toolbar-btn" title="글머리 기호 (-)" aria-label="Bullet list"><span class="icon">•─</span></button>
                  <button id="memoOl" class="toolbar-btn" title="번호 목록 (1.)" aria-label="Numbered list"><span class="icon">1.</span></button>
                </div>
                <div class="toolbar-spacer"></div>
                <div class="toolbar-group action-group" role="toolbar" aria-label="동작">
                  <button id="addSelection" class="toolbar-btn action" type="button" title="선택한 텍스트 추가" aria-label="선택 추가"><span class="icon">✂</span><span class="label">선택</span></button>
                  <button id="addBlock" class="toolbar-btn action" type="button" title="블록 선택 모드" aria-label="블록 추가"><span class="icon">▢</span><span class="label">블록</span></button>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-group ai-group" role="toolbar" aria-label="AI 기능">
                  <button id="aiSummary" class="toolbar-btn ai" type="button" title="AI로 요약 생성" aria-label="AI 요약"><span class="icon">✦</span><span class="label">요약</span></button>
                  <button id="catalyst" class="toolbar-btn ai primary" type="button" title="Catalyst 프롬프트" aria-label="Catalyst"><span class="icon">⚡</span><span class="label">Catalyst</span></button>
                </div>
              </div>
              <div class="memo-hint">
                <span class="hint-text">Markdown 지원</span>
                <span class="hint-divider">•</span>
                <span class="hint-shortcut"><kbd>Alt</kbd>+<kbd>M</kbd> 토글</span>
                <span class="hint-divider">•</span>
                <span class="hint-shortcut"><kbd>/</kbd> 명령어</span>
              </div>
              <textarea id="memo" class="textarea" style="min-height:300px; height:300px;" placeholder="여기에 메모를 작성하세요...&#10;&#10;Tip: / 를 입력하면 서식 메뉴가 열립니다"></textarea>
            </div>
          </div>

          <div id="previewBody" class="body">
            <div class="preview-layout-bar">
              <div class="layout-toggle" role="group" aria-label="레이아웃 전환">
                <button id="layoutSplit" class="layout-btn" type="button" data-layout="split" aria-pressed="false">분할</button>
                <button id="layoutTabs" class="layout-btn" type="button" data-layout="tab" aria-pressed="false">탭</button>
              </div>
              <div id="previewPaneToggle" class="preview-pane-toggle" role="tablist" aria-label="미리보기 전환" data-visible="false">
                <button type="button" data-pane="editor" role="tab" aria-selected="false">편집</button>
                <button type="button" data-pane="preview" role="tab" aria-selected="false">미리보기</button>
              </div>
            </div>
            <div class="split" id="previewSplit" data-layout="split" data-active-pane="editor">
              <div class="split-left" data-pane="editor">
                <label class="label" for="memoEditor">편집기</label>
                <textarea id="memoEditor" class="textarea" placeholder="여기에 메모를 작성하세요"></textarea>
              </div>
              <div class="split-right" data-pane="preview">
                <label class="label">미리보기</label>
                <div id="memoPreview" class="preview-md"></div>
              </div>
            </div>
          </div>

          <div id="devBody" class="body">
            <div class="section">
              <div class="label">원본 글</div>
              <div id="originalPath" class="small" style="opacity:0.8"></div>
            </div>
            <div class="section">
              <label class="label" for="proposalMd">새 버전 마크다운</label>
              <textarea id="proposalMd" class="textarea" spellcheck="false" placeholder="원문을 불러오거나 이곳에 수정된 마크다운을 붙여넣으세요"></textarea>
              <div class="row" style="margin-top:8px; gap:8px;">
                <button id="loadOriginalMd" class="btn secondary">원문 불러오기</button>
                <button id="proposeNewVersion" class="btn">PR 생성 제안</button>
              </div>
            </div>
            <div class="small muted" style="margin-top:6px;">
              - 원문을 불러온 후 필요한 수정을 하고 PR을 생성하세요. PR에는 원본과의 관계가 frontmatter의 derivedFrom으로 표시됩니다.
            </div>
            <div class="section">
              <a id="prLink" class="small" target="_blank" rel="noopener" style="display:none;">PR 열기 →</a>
            </div>
          </div>

          <div id="settingsBody" class="body">
            <div class="section">
              <label class="label" for="inlineEnabled">문단 끝 ✨ 인라인 확장</label>
              <div class="row">
                <input id="inlineEnabled" type="checkbox" aria-label="문단 끝 인라인 확장" />
                <div class="small" style="opacity:0.8">글 본문 단락 끝에 ✨ 아이콘을 표시하고 아래로 결과를 펼칩니다.</div>
              </div>
            </div>
             <div class="section">
               <label class="label" for="closeAfterInject">주입 후 창 닫기</label>
               <div class="row">
                 <input id="closeAfterInject" type="checkbox" aria-label="생각 노드 주입 후 창 닫기" />
                 <div class="small" style="opacity:0.8">그래프에 주입이 완료되면 메모 패널을 닫습니다.</div>
               </div>
             </div>
             <div class="section">
               <label class="label" for="fontSize">폰트 크기</label>
               <select id="fontSize" class="input">
                 <option value="12">12</option>
                 <option value="13" selected>13</option>
                 <option value="14">14</option>
                 <option value="16">16</option>
               </select>
             </div>
             <div class="section">
               <label class="label">패널 위치</label>
               <div class="row" style="gap:10px; align-items:flex-start;">
                 <button id="resetPosition" class="btn secondary" type="button">위치 초기화</button>
                 <div class="small" style="opacity:0.8">
                   화면이 작거나 패널이 보이지 않을 때 기본 위치로 되돌립니다.
                 </div>
               </div>
             </div>
          </div>
          <div id="catalystBox" class="catalyst-panel" style="display:none;">
             <div class="catalyst-header">
               <span class="catalyst-icon">⚡</span>
               <span class="catalyst-title">Catalyst</span>
             </div>
             <input id="catalystInput" class="input catalyst-input" placeholder="어떻게 확장해볼까요? 예: 사용 사례 관점에서 다시 보기" maxlength="160" />
             <div class="catalyst-actions">
               <button id="catalystCancel" class="btn secondary">취소</button>
               <button id="catalystRun" class="btn catalyst-run"><span class="catalyst-run-icon">▶</span> 생성</button>
             </div>
          </div>
          <div class="footer">
            <div id="status" class="status-bar">
              <span class="status-dot"></span>
              <span class="status-text">Ready</span>
            </div>
            <div class="footer-actions">
              <button id="memoSync" class="footer-btn" type="button" title="클라우드 동기화" aria-label="클라우드 동기화">
                <span class="btn-icon">☁</span>
                <span class="btn-label">동기화</span>
              </button>
              <button id="memoVersions" class="footer-btn" type="button" title="버전 기록" aria-label="버전 기록">
                <span class="btn-icon">⏱</span>
                <span class="btn-label">버전</span>
              </button>
              <button id="memoToGraph" class="footer-btn" type="button" title="그래프에 추가" aria-label="그래프에 추가">
                <span class="btn-icon">◉</span>
                <span class="btn-label">그래프</span>
              </button>
              <button id="download" class="footer-btn" type="button" title="다운로드" aria-label="다운로드">
                <span class="btn-icon">↓</span>
                <span class="btn-label">저장</span>
              </button>
              <button id="memoFull" class="footer-btn" type="button" title="전체화면" aria-label="전체화면">
                <span class="btn-icon">⛶</span>
                <span class="btn-label">확대</span>
              </button>
              <button id="memoClear" class="footer-btn danger" type="button" title="지우기" aria-label="지우기">
                <span class="btn-icon">✕</span>
                <span class="btn-label">지우기</span>
              </button>
            </div>
          </div>
          <div id="toast" class="toast"></div>
        </div>
      `;
      this.shadowRoot.appendChild(doc);
      // Ensure fixed positioning even if stylesheet hasn't loaded yet (or fails)
      this.injectCriticalStyles();
      // Robustly ensure full styles get applied in browsers that ignore <link> in shadow DOM
      this.ensureStylesLoaded();

      // cache
      this.$launcher = this.shadowRoot.getElementById('launcher');
      this.$panel = this.shadowRoot.getElementById('panel');
      this.$historyLauncher = this.shadowRoot.getElementById('historyLauncher');
      this.$historyOverlay = this.shadowRoot.getElementById('historyOverlay');
      this.$historyCanvas = this.shadowRoot.getElementById('historyCanvas');
      this.$historyClose = this.shadowRoot.getElementById('historyClose');
      this.$historyReset = this.shadowRoot.getElementById('historyReset');
      this.$historyExport = this.shadowRoot.getElementById('historyExport');
      this.$historyImport = this.shadowRoot.getElementById('historyImport');
      this.$drag = this.shadowRoot.getElementById('drag');
      this.$close = this.shadowRoot.getElementById('close');
      this.$tabs = Array.from(this.shadowRoot.querySelectorAll('.tab'));
      this.$memoBody = this.shadowRoot.getElementById('memoBody');
      this.$previewBody = this.shadowRoot.getElementById('previewBody');
      this.$devBody = this.shadowRoot.getElementById('devBody');
      this.$settingsBody = this.shadowRoot.getElementById('settingsBody');
      this.$memo = this.shadowRoot.getElementById('memo');
      this.$memoEditor = this.shadowRoot.getElementById('memoEditor');
      this.$memoPreview = this.shadowRoot.getElementById('memoPreview');
      this.$previewSplit = this.shadowRoot.getElementById('previewSplit');
      this.$layoutSplit = this.shadowRoot.getElementById('layoutSplit');
      this.$layoutTabs = this.shadowRoot.getElementById('layoutTabs');
      this.$previewPaneToggle = this.shadowRoot.getElementById('previewPaneToggle');
      this.$previewPaneButtons = Array.from(
        this.shadowRoot.querySelectorAll('#previewPaneToggle button')
      );
      this.$fontSize = this.shadowRoot.getElementById('fontSize');
      this.$inlineEnabled = this.shadowRoot.getElementById('inlineEnabled');
      this.$closeAfterInject = this.shadowRoot.getElementById('closeAfterInject');
      this.$resetPosition = this.shadowRoot.getElementById('resetPosition');
      this.$memoBold = this.shadowRoot.getElementById('memoBold');
      this.$memoItalic = this.shadowRoot.getElementById('memoItalic');
      this.$memoCode = this.shadowRoot.getElementById('memoCode');
      this.$memoH1 = this.shadowRoot.getElementById('memoH1');
      this.$memoH2 = this.shadowRoot.getElementById('memoH2');
      this.$memoUl = this.shadowRoot.getElementById('memoUl');
      this.$memoOl = this.shadowRoot.getElementById('memoOl');
      this.$memoFull = this.shadowRoot.getElementById('memoFull');

      this.$memoClear = this.shadowRoot.getElementById('memoClear');
      this.$addBlock = this.shadowRoot.getElementById('addBlock');

      this.$originalPath = this.shadowRoot.getElementById('originalPath');
      this.$proposalMd = this.shadowRoot.getElementById('proposalMd');
      this.$loadOriginalMd = this.shadowRoot.getElementById('loadOriginalMd');
      this.$proposeNewVersion =
        this.shadowRoot.getElementById('proposeNewVersion');
      this.$prLink = this.shadowRoot.getElementById('prLink');
      this.$status = this.shadowRoot.getElementById('status');
      this.$addSel = this.shadowRoot.getElementById('addSelection');
      this.$memoToGraph = this.shadowRoot.getElementById('memoToGraph');
      this.$aiSummary = this.shadowRoot.getElementById('aiSummary');
      this.$catalystBtn = this.shadowRoot.getElementById('catalyst');
      this.$catalystBox = this.shadowRoot.getElementById('catalystBox');
      this.$catalystInput = this.shadowRoot.getElementById('catalystInput');
      this.$catalystRun = this.shadowRoot.getElementById('catalystRun');
      this.$catalystCancel = this.shadowRoot.getElementById('catalystCancel');
      this.$download = this.shadowRoot.getElementById('download');
      this.$toast = this.shadowRoot.getElementById('toast');
    }

    createBlockHighlighter() {
      if (document.getElementById('ai-memo-highlighter')) return;
      const overlay = document.createElement('div');
      overlay.id = 'ai-memo-highlighter';
      Object.assign(overlay.style, {
        display: 'none',
        position: 'absolute',
        zIndex: '2147483646',
        backgroundColor: 'rgba(99, 102, 241, 0.18)',
        border: '1.5px solid rgba(99, 102, 241, 0.7)',
        borderRadius: '6px',
        boxShadow: '0 0 0 3px rgba(255, 255, 255, 0.45)',
        pointerEvents: 'none',
        transition: 'top 120ms ease, left 120ms ease, width 120ms ease, height 120ms ease',
        willChange: 'top, left, width, height',
      });
      document.body.appendChild(overlay);
    }

    destroyBlockHighlighter() {
      const overlay = document.getElementById('ai-memo-highlighter');
      if (overlay) overlay.remove();
      this.highlightedBlock = null;
    }

    toggleBlockSelectMode(force) {
      const next = typeof force === 'boolean' ? force : !this.isBlockSelectMode;
      if (next === this.isBlockSelectMode) return;
      this.isBlockSelectMode = next;

      if (document.body) {
        document.body.classList.toggle('ai-memo-block-select-active', next);
        if (!next && this._prevCursor) {
          document.body.style.cursor = this._prevCursor;
          this._prevCursor = '';
        } else if (next) {
          this._prevCursor = document.body.style.cursor || '';
          document.body.style.cursor = 'crosshair';
        }
      }
      if (this.$panel) this.$panel.classList.toggle('selecting-block', next);

      if (next) {
        this.out.tempStatus('추가할 블록을 클릭하세요 (ESC 취소)', 'Ready', 2400);
        this.createBlockHighlighter();
        document.addEventListener('mousemove', this._boundBlockHighlight, { capture: true, passive: true });
        document.addEventListener('click', this._boundBlockCapture, true);
        document.addEventListener('keydown', this._boundBlockKeydown, true);
      } else {
        document.removeEventListener('mousemove', this._boundBlockHighlight, true);
        document.removeEventListener('click', this._boundBlockCapture, true);
        document.removeEventListener('keydown', this._boundBlockKeydown, true);
        this.destroyBlockHighlighter();
      }
    }

    handleBlockHighlight(event) {
      if (!this.isBlockSelectMode) return;
      this.createBlockHighlighter();
      const overlay = document.getElementById('ai-memo-highlighter');
      if (!overlay) return;

      overlay.style.display = 'none';
      const target = document.elementFromPoint(event.clientX, event.clientY);
      if (!target || target.closest('ai-memo-pad') || target.id === 'ai-memo-highlighter') {
        this.highlightedBlock = null;
        return;
      }

      const block = target.closest(BLOCK_SELECTORS);
      if (!block) {
        this.highlightedBlock = null;
        return;
      }

      this.highlightedBlock = block;
      const rect = block.getBoundingClientRect();
      overlay.style.display = 'block';
      overlay.style.top = `${rect.top + window.scrollY}px`;
      overlay.style.left = `${rect.left + window.scrollX}px`;
      overlay.style.width = `${rect.width}px`;
      overlay.style.height = `${rect.height}px`;
    }

    handleBlockCapture(event) {
      if (!this.isBlockSelectMode || !this.highlightedBlock) return;
      if ('button' in event && event.button !== 0) return;

      event.preventDefault();
      event.stopPropagation();

      if (!this._turndown) {
        this.out.toast('Markdown 변환기를 로드 중입니다. 잠시 후 다시 시도하세요.');
        this.toggleBlockSelectMode(false);
        return;
      }

      try {
        const html = this.highlightedBlock.outerHTML;
        const markdown = this._turndown.turndown(html || '');
        if (markdown.trim()) {
          this.out.append(`\n\n${markdown.trim()}\n`);
          this.out.toast('선택한 블록을 메모에 추가했습니다.');
          this.logEvent({ type: 'add_block', label: 'block', content: markdown.slice(0, 2000) });
        } else {
          this.out.toast('추가할 내용이 없습니다.');
        }
      } catch (err) {
        console.error('Block capture failed', err);
        this.out.toast('블록을 추가하지 못했습니다.');
      }

      this.toggleBlockSelectMode(false);
    }

    handleBlockKeydown(event) {
      if (!this.isBlockSelectMode) return;
      if (event.key === 'Escape') {
        event.preventDefault();
        this.out.tempStatus('블록 선택 모드를 종료합니다.', 'Ready', 1400);
        this.toggleBlockSelectMode(false);
      }
    }

    // Inject minimal critical styles as a safety net so the UI stays fixed and scoped
    injectCriticalStyles() {
      try {
        const panel = this.shadowRoot && this.shadowRoot.getElementById('panel');
        if (!panel) return;
        const cs = getComputedStyle(panel);
        // If the external CSS applied correctly, .panel should already be fixed
        if (cs && cs.position === 'fixed') return;
        // Otherwise, inject a minimal style fallback
        const style = document.createElement('style');
        style.setAttribute('data-ai-memo', 'critical');
        style.textContent = `
          :host { all: initial; }
          .launcher { position: fixed; right: 16px; bottom: 96px; z-index: 2147483647; }
          .launcher.history { bottom: 152px; }
          .panel { position: fixed; z-index: 2147483647; right: 16px; bottom: 160px; display: none; }
          .panel.open { display: flex; flex-direction: column; }
          .history-overlay { position: fixed; inset: 0; z-index: 2147483647; display: none; }
        `;
        this.shadowRoot.appendChild(style);
      } catch (_) {}
    }

    // Load and attach the full CSS into the shadow root if the external <link> failed
    ensureStylesLoaded() {
      try {
        const root = this.shadowRoot;
        const panel = root && root.getElementById('panel');
        if (!panel) return;
        const ok = () => getComputedStyle(panel).position === 'fixed';
        if (ok()) return; // already styled

        const attachText = (cssText) => {
          try {
            if (root.adoptedStyleSheets && 'replaceSync' in CSSStyleSheet.prototype) {
              const sheet = new CSSStyleSheet();
              sheet.replaceSync(cssText);
              root.adoptedStyleSheets = [...root.adoptedStyleSheets, sheet];
            } else {
              const style = document.createElement('style');
              style.textContent = cssText;
              root.appendChild(style);
            }
          } catch (_) {}
        };

        // Fetch CSS and inline it
        fetch('/ai-memo/ai-memo.css')
          .then((r) => (r.ok ? r.text() : ''))
          .then((txt) => { if (txt) attachText(txt); })
          .catch(() => {});
      } catch (_) {}
    }

    restore() {
      // content
      this.$memo.value = this.state.memo || '';
      if (this.$memoEditor) this.$memoEditor.value = this.state.memo || '';
      if (this.$inlineEnabled)
        this.$inlineEnabled.checked = !!this.state.inlineEnabled;
      if (this.$closeAfterInject)
        this.$closeAfterInject.checked = !!this.state.closeAfterInject;
      if (this.$fontSize) {
        const fs = parseInt(this.state.fontSize || 13, 10);
        this.$fontSize.value = String(fs);
        this.applyFontSize(fs);
      }

      // panel open
      this.$panel.classList.toggle('open', !!this.state.isOpen);

      // position - only apply if saved position is valid and within viewport
      if (this.state.position.x != null && this.state.position.y != null) {
        const { x, y } = this.clamp(
          this.state.position.x,
          this.state.position.y
        );
        // If clamp returns null, reset to CSS defaults (position was invalid)
        if (x == null || y == null) {
          this.state.position = { x: null, y: null };
          LS.set(KEYS.position, this.state.position);
          Object.assign(this.$panel.style, {
            left: '',
            top: '',
            right: '',
            bottom: '',
          });
        } else {
          Object.assign(this.$panel.style, {
            left: `${x}px`,
            top: `${y}px`,
            right: 'auto',
            bottom: 'auto',
          });
        }
      }

      // dev content
      if (this.$proposalMd)
        this.$proposalMd.value = this.state.proposalMd || '';

      // announce aria labels for important actions (a11y)
      if (this.$memoToGraph) this.$memoToGraph.setAttribute('aria-label', '그래프에 추가');
      if (this.$aiSummary) this.$aiSummary.setAttribute('aria-label', 'AI 요약');
      if (this.$download) this.$download.setAttribute('aria-label', '메모 다운로드');

      // mode
      this.$tabs.forEach(t =>
        t.classList.toggle('active', t.dataset.tab === this.state.mode)
      );
      this.updateMode();
     }

     // ===== History: event logging & overlay =====
     logEvent(evt) {
       try {
         if (!evt || (evt.type && NOISY_EVENT_TYPES.has(evt.type))) return null;
         const info = this.getCurrentPostInfo();
         const base = {
           t: Date.now(),
           page: { url: location.href, title: document.title, post: info || null },
         };
         const rec = Object.assign(base, evt || {});
         if (!rec.label && rec.type) {
           rec.label = rec.type;
         }
         
         // Always read fresh from LS to avoid overwriting with stale state
         let currentEvents = LS.get(KEYS.events, []);
         if (!Array.isArray(currentEvents)) currentEvents = [];
         
         currentEvents.push(rec);
         if (currentEvents.length > 500) currentEvents = currentEvents.slice(currentEvents.length - 500);
         
         this.state.events = currentEvents;
         LS.set(KEYS.events, currentEvents);
         return rec;
       } catch (_) { return null; }
     }

       openHistory() {
         if (!this.$historyOverlay || !this.$historyCanvas) return;
         this.$historyOverlay.style.display = 'block';
         this._hist = this._hist || { scale: 1, tx: 0, ty: 0, dragging: false };
         this._hist.hoverId = null; this._hist.pinnedId = null;
         this.resizeHistoryCanvas();
         this.drawHistory();
         this.attachHistoryInteractions();
         this.hideHistoryTooltip();
         this.closeHistoryInfo();
         this.logEvent({ type: 'history_open', label: '히스토리 열기' });
       }
       closeHistory() {
         if (!this.$historyOverlay) return;
         this.$historyOverlay.style.display = 'none';
         this.detachHistoryInteractions();
         this.hideHistoryTooltip();
         this.closeHistoryInfo();
         if (this._hist) { this._hist.hoverId = null; this._hist.pinnedId = null; }
         this.logEvent({ type: 'history_close', label: '히스토리 닫기' });
       }

      resizeHistoryCanvas() {
        const c = this.$historyCanvas; if (!c) return;
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const w = window.innerWidth; const h = window.innerHeight;
        c.width = Math.floor(w * dpr); c.height = Math.floor(h * dpr);
        c.style.width = w + 'px'; c.style.height = h + 'px';
        const ctx = c.getContext('2d'); ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      animateHistoryTo(target, duration = 280) {
        if (!this._hist || !this.$historyCanvas) return;
        const start = { tx: this._hist.tx, ty: this._hist.ty, scale: this._hist.scale };
        const ease = (t) => (t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);
        if (this._histAnim) cancelAnimationFrame(this._histAnim);
        const t0 = performance.now();
        const step = (now) => {
          const p = Math.min(1, (now - t0) / duration);
          const k = ease(p);
          this._hist.tx = start.tx + (target.tx - start.tx) * k;
          this._hist.ty = start.ty + (target.ty - start.ty) * k;
          this._hist.scale = start.scale + (target.scale - start.scale) * k;
          this.drawHistory();
          if (p < 1) this._histAnim = requestAnimationFrame(step);
        };
        this._histAnim = requestAnimationFrame(step);
      }

      centerHistoryOn(node, { animate = true } = {}) {
        const c = this.$historyCanvas; if (!c || !node) return;
        const rect = c.getBoundingClientRect();
        const cx = rect.width / 2; const cy = rect.height / 2;
        const ns = Math.max(1, this._hist?.scale || 1);
        const tx = cx - node.x * ns;
        const ty = cy - node.y * ns;
         if (animate) this.animateHistoryTo({ tx, ty, scale: ns }, 280);
         else { this._hist.tx = tx; this._hist.ty = ty; this._hist.scale = ns; this.scheduleHistoryDraw(); }
      }

     attachHistoryInteractions() {
       if (this._histBound) return; this._histBound = true;
       this._hist = this._hist || { scale: 1, tx: 0, ty: 0, dragging: false, lx:0, ly:0 };
       const c = this.$historyCanvas; if (!c) return;
        const onResize = () => { this.resizeHistoryCanvas(); this.scheduleHistoryDraw(); };
         const onWheel = (e) => {
           e.preventDefault();
           const { offsetX, offsetY, deltaY } = e;
           // store latest mouse position for hover sync
           this._hist.mouseX = e.clientX; this._hist.mouseY = e.clientY;
           const factor = deltaY < 0 ? 1.1 : 0.9;
           const { scale, tx, ty } = this._hist;
           const x = (offsetX - tx) / scale; const y = (offsetY - ty) / scale;
           const ns = Math.max(0.3, Math.min(3, scale * factor));
           this._hist.scale = ns;
           this._hist.tx = offsetX - x * ns; this._hist.ty = offsetY - y * ns;
           this.scheduleHistoryDraw();
           // keep tooltip synced (convert client -> canvas -> world)
           if (this._hist.mouseX != null && this._hist.mouseY != null) {
             const rect = c.getBoundingClientRect();
             const mx = this._hist.mouseX - rect.left; const my = this._hist.mouseY - rect.top;
             const g = this._histGraph || this.layoutGraph(this.buildGraph());
             const xw = (mx - this._hist.tx) / ns; const yw = (my - this._hist.ty) / ns;
             const hit = this.hitTestHistoryNode(g, xw, yw);
             this._hist.hoverId = hit ? hit.id : null;
             this.updateHistoryTooltip(hit, this._hist.mouseX, this._hist.mouseY);
           }
         };
        const onDown = (e) => {
          this._hist.dragging = true; this._hist.lx = e.clientX; this._hist.ly = e.clientY;
          c.classList.add('grabbing');
          this.hideHistoryTooltip();
        };
        const onMove = (e) => {
          this._hist.mouseX = e.clientX; this._hist.mouseY = e.clientY;
          if (this._hist.dragging) {
            const dx = e.clientX - this._hist.lx; const dy = e.clientY - this._hist.ly; this._hist.lx = e.clientX; this._hist.ly = e.clientY; this._hist.tx += dx; this._hist.ty += dy; this.scheduleHistoryDraw();
          } else {
            // hover detection when not dragging
            const rect = c.getBoundingClientRect();
            const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
            const x = (mx - this._hist.tx) / (this._hist.scale||1);
            const y = (my - this._hist.ty) / (this._hist.scale||1);
            const g = this._histGraph || this.layoutGraph(this.buildGraph());
            const hit = this.hitTestHistoryNode(g, x, y);
            if (!this._hist?.pinnedId) {
              const prev = this._hist.hoverId;
              this._hist.hoverId = hit ? hit.id : null;
              if (prev !== this._hist.hoverId) this.drawHistory();
            }
            this.updateHistoryTooltip(hit, e.clientX, e.clientY);
            c.style.cursor = hit ? 'pointer' : 'grab';
          }
        };
        const onUp = () => { this._hist.dragging = false; c.classList.remove('grabbing'); };
       const onKey = (e) => { if (e.key === 'Escape') this.closeHistory(); };
       c.addEventListener('wheel', onWheel, { passive: false });
       c.addEventListener('pointerdown', onDown);
       window.addEventListener('pointermove', onMove);
       window.addEventListener('pointerup', onUp);
       window.addEventListener('resize', onResize);
       window.addEventListener('keydown', onKey);
         const onClick = (e) => {
          const rect = c.getBoundingClientRect();
          const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
          const x = (mx - this._hist.tx) / (this._hist.scale||1);
          const y = (my - this._hist.ty) / (this._hist.scale||1);
          const g = this._histGraph || this.layoutGraph(this.buildGraph());
          const hit = this.hitTestHistoryNode(g, x, y);
          if (!hit) return;
          // pin selection and show info
          this._hist.pinnedId = hit.id;
          this.updateHistoryInfo(hit, true);
          if (hit.kind === 'post' || hit.kind === 'post_node') {
            // smooth center on node
            this.centerHistoryOn(hit, { animate: true });
          }
          this.drawHistory();
        };
        const onDblClick = (e) => {
          const rect = c.getBoundingClientRect();
          const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
          const x = (mx - this._hist.tx) / (this._hist.scale||1);
          const y = (my - this._hist.ty) / (this._hist.scale||1);
          const g = this._histGraph || this.layoutGraph(this.buildGraph());
          const hit = this.hitTestHistoryNode(g, x, y);
          if (hit && (hit.kind === 'post' || hit.kind === 'post_node')) {
            const p = hit.meta?.post;
            if (p) {
              const href = `#/blog/${p.year}/${p.slug}`;
              try { window.location.hash = href.replace(/^#/, ''); }
              catch (_) { window.location.href = href; }
              this.closeHistory();
            }
          }
        };
         c.addEventListener('click', onClick);
         c.addEventListener('dblclick', onDblClick);
         this.$historyClose?.addEventListener('click', () => this.closeHistory());
          this.$historyReset?.addEventListener('click', () => { if (!confirm('히스토리 기록을 모두 삭제할까요?')) return; this.state.events = []; LS.set(KEYS.events, []); if (this._hist) { this._hist.hoverId = null; this._hist.pinnedId = null; } this.hideHistoryTooltip(); this.closeHistoryInfo(); this.drawHistory(); this.out.toast('기록을 초기화했습니다.'); this.logEvent({ type: 'history_reset', label: '히스토리 초기화' }); });
         this.$historyExport?.addEventListener('click', () => {
           try {
             const data = { exportedAt: new Date().toISOString(), events: this.state.events || [] };
             const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
             const url = URL.createObjectURL(blob);
             const a = document.createElement('a');
             a.href = url; a.download = 'ai-memo-history.json';
             document.body.appendChild(a); a.click(); a.remove();
             URL.revokeObjectURL(url);
             this.out.toast('히스토리를 내보냈습니다.');
             this.logEvent({ type: 'download_history', label: '히스토리 내보내기' });
           } catch (_) { this.out.toast('내보내기에 실패했습니다.'); }
         });
         this.$historyImport?.addEventListener('click', () => {
           try {
             const input = document.createElement('input');
             input.type = 'file';
             input.accept = 'application/json,.json';
             input.style.display = 'none';
             document.body.appendChild(input);
             input.addEventListener('change', async () => {
               try {
                 const file = input.files && input.files[0];
                 if (!file) return; const text = await file.text();
                 const parsed = JSON.parse(text);
                 const events = Array.isArray(parsed?.events) ? parsed.events : (Array.isArray(parsed) ? parsed : []);
                 if (!Array.isArray(events)) throw new Error('올바른 형식이 아닙니다.');
                 // sanitize and cap
                 const cleaned = events.filter(e => e && typeof e === 'object' && typeof e.t === 'number');
                 this.state.events = cleaned.slice(-500);
                 LS.set(KEYS.events, this.state.events);
                 this.drawHistory();
                 this.out.toast('히스토리를 가져왔습니다.');
                 this.logEvent({ type: 'history_import', label: '히스토리 가져오기' });
               } catch (err) {
                 console.error('history import error:', err);
                 this.out.toast('가져오기에 실패했습니다.');
               } finally {
                 input.remove();
               }
             }, { once: true });
             input.click();
           } catch (_) {
             this.out.toast('가져오기 시작에 실패했습니다.');
           }
         });
         this._histHandlers = { onWheel, onDown, onMove, onUp, onResize, onKey, onClick, onDblClick };
     }

      detachHistoryInteractions() {
        if (!this._histBound) return; this._histBound = false;
        const c = this.$historyCanvas; if (!c) return;
        const h = this._histHandlers || {};
        c.removeEventListener('wheel', h.onWheel);
        c.removeEventListener('pointerdown', h.onDown);
        c.removeEventListener('click', h.onClick);
        c.removeEventListener('dblclick', h.onDblClick);
        window.removeEventListener('pointermove', h.onMove);
        window.removeEventListener('pointerup', h.onUp);
        window.removeEventListener('resize', h.onResize);
        window.removeEventListener('keydown', h.onKey);
        this._histHandlers = null;
        this.hideHistoryTooltip();
      }

       buildGraph() {
         const events = Array.isArray(this.state.events) ? this.state.events : [];
         const postMap = new Map();
         const nodes = []; const edges = [];
         const keyOfPost = (p) => p ? `${p.year}/${p.slug}` : 'unknown';
         const addNode = (id, kind, label, meta) => { nodes.push({ id, kind, label, meta }); };
         const addEdge = (a, b, w=1) => { edges.push({ a, b, w }); };
         // current post
         const info = this.getCurrentPostInfo();
         if (info) {
           const pid = `post:${keyOfPost(info)}`;
           if (!postMap.has(pid)) { postMap.set(pid, true); addNode(pid, 'post', document.title, { post: info }); }
         }
         // group duplicate events by (postKey,type,label) with count
         const grouped = new Map();
         for (const ev of events) {
           if (!ev?.page?.post) continue;
           const postKey = keyOfPost(ev.page.post);
           const t = ev.type || 'event';
           const l = ev.label || t;
           const k = `${postKey}|${t}|${l}`;
           const g = grouped.get(k) || { count: 0, any: null, post: ev.page.post };
           g.count += 1; g.any = g.any || ev; grouped.set(k, g);
         }
         for (const [k, g] of grouped) {
           const pid = `post:${keyOfPost(g.post)}`;
           if (!postMap.has(pid)) { postMap.set(pid, true); addNode(pid, 'post', (g.any?.page?.title) || pid, { post: g.post }); }
           const baseId = `ev:${g.any.t}`;
           const nid = `${baseId}:${g.count}`;
           const label = g.count > 1 ? `${g.any.label || g.any.type} ×${g.count}` : (g.any.label || g.any.type || 'event');
           addNode(nid, g.any.type || 'event', label, { ev: g.any, count: g.count });
           addEdge(pid, nid, Math.min(1, 0.3 + 0.1 * g.count));
         }
         // sort nodes for stable rendering (posts under, events above)
         nodes.sort((a,b)=> (a.kind==='post'&&b.kind!=='post') ? -1 : (a.kind!=='post'&&b.kind==='post') ? 1 : (a.id > b.id ? 1 : -1));
         return { nodes, edges };
       }

      layoutGraph(graph) {
        const { nodes, edges } = graph; const C = { postR: 36, evR: 16 };
        const byKind = (k) => nodes.filter(n => n.kind === k || (k==='event' && n.kind!=='post'));
        const posts = byKind('post'); const events = nodes.filter(n => n.kind!=='post');
        const cx = window.innerWidth/2, cy = window.innerHeight/2;
        posts.forEach((n,i)=>{ n.x = cx + (i- (posts.length-1)/2)*140; n.y = cy; n.r = C.postR; });
        // place events around their post in small rings
        const postPos = new Map(posts.map(p => [p.meta.post.year+'/'+p.meta.post.slug, p]));
        const groups = new Map();
        for (const n of events) {
          const p = (n.meta?.ev?.page?.post) || (this.getCurrentPostInfo() || null);
          const key = p ? p.year+'/'+p.slug : 'unknown';
          if (!groups.has(key)) groups.set(key, []);
          groups.get(key).push(n);
        }
        for (const [key, arr] of groups) {
          const pnode = postPos.get(key); if (!pnode) continue;
          arr.forEach((n,i)=>{
            const ang = (i/arr.length)*Math.PI*2; const rad = 96 + (i%4)*20;
            n.x = pnode.x + Math.cos(ang)*rad; n.y = pnode.y + Math.sin(ang)*rad; n.r = C.evR;
          });
        }
        return graph;
      }

      hitTestHistoryNode(graph, x, y) {
        for (let i = graph.nodes.length - 1; i >= 0; i--) {
          const n = graph.nodes[i];
          const r = n.r || 16;
          const dx = x - n.x;
          const dy = y - n.y;
          if (n.kind === 'thought') {
            const w = r * 2.6; const h = r * 1.6;
            if (Math.abs(dx) <= w / 2 && Math.abs(dy) <= h / 2) return n;
          } else if (n.kind === 'ai_summary_done' || n.kind === 'catalyst_run') {
            if (Math.abs(dx) + Math.abs(dy) <= r) return n;
          } else {
            if (dx * dx + dy * dy <= r * r) return n;
          }
        }
        return null;
      }

      scheduleHistoryDraw() { if (this._histDrawReq) return; this._histDrawReq = requestAnimationFrame(() => { this._histDrawReq = null; this.drawHistory(); }); }

      drawHistory() {
        const c = this.$historyCanvas; if (!c) return; const ctx = c.getContext('2d');
        const { scale, tx, ty } = this._hist || { scale:1, tx:0, ty:0 };
        ctx.save(); ctx.clearRect(0,0,c.width,c.height); ctx.translate(tx, ty); ctx.scale(scale, scale);
        const graph = this.layoutGraph(this.buildGraph());
        this._histGraph = graph;

        const isDark = this.classList.contains('dark');
        const theme = isDark ? {
          edge: 'rgba(148,163,184,0.45)',
          postFill: '#0f172a',
          postStroke: 'rgba(255,255,255,0.08)',
          postLabel: '#e5e7eb',
          thoughtFill: '#fef08a',
          thoughtStroke: 'rgba(250,204,21,0.6)',
          thoughtLabel: '#713f12',
          aiFill: '#c4b5fd',
          aiStroke: 'rgba(124,58,237,0.6)',
          aiLabel: '#eae4ff',
          eventFill: '#60a5fa',
          eventStroke: 'rgba(96,165,250,0.4)',
          eventLabel: '#0b1220',
          hiDefault: '#93c5fd',
          hiPost: '#fcd34d',
          hiThought: '#f59e0b',
          hiAI: '#c084fc',
          connector: 'rgba(148,163,184,0.5)'
        } : {
          edge: 'rgba(100,116,139,0.6)',
          postFill: '#111827',
          postStroke: 'rgba(0,0,0,0.2)',
          postLabel: '#ffffff',
          thoughtFill: '#fef08a',
          thoughtStroke: 'rgba(250,204,21,0.6)',
          thoughtLabel: '#713f12',
          aiFill: '#c4b5fd',
          aiStroke: 'rgba(124,58,237,0.6)',
          aiLabel: '#1f1147',
          eventFill: '#1d4ed8',
          eventStroke: 'rgba(29,78,216,0.3)',
          eventLabel: '#0b1020',
          hiDefault: '#93c5fd',
          hiPost: '#fcd34d',
          hiThought: '#f59e0b',
          hiAI: '#c084fc',
          connector: 'rgba(148,163,184,0.5)'
        };

        // helpers for shapes
        const drawDiamond = (x, y, r, fill, stroke, lw=2) => {
          ctx.beginPath();
          ctx.moveTo(x, y - r);
          ctx.lineTo(x + r, y);
          ctx.lineTo(x, y + r);
          ctx.lineTo(x - r, y);
          ctx.closePath();
          ctx.fillStyle = fill; ctx.strokeStyle = stroke; ctx.lineWidth = lw; ctx.fill(); ctx.stroke();
        };
        const drawRoundedRect = (cx, cy, w, h, rad, fill, stroke, lw=2) => {
          const x = cx - w/2, y = cy - h/2; const r = Math.min(rad, w/2, h/2);
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + w, y, r);
          ctx.closePath();
          ctx.fillStyle = fill; ctx.strokeStyle = stroke; ctx.lineWidth = lw; ctx.fill(); ctx.stroke();
        };

        // draw edges and nodes with theme-aware styles
        const byId = Object.create(null);
        for (const n of graph.nodes) byId[n.id] = n;

        const hoveredId = (this._hist && (this._hist.pinnedId || this._hist.hoverId)) || null;

        // edges first (under nodes)
        ctx.lineCap = 'round';
        for (const e of graph.edges) {
          const a = byId[e.a];
          const b = byId[e.b];
          if (!a || !b) continue;
          const isActive = hoveredId && (hoveredId === a.id || hoveredId === b.id);
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.strokeStyle = isActive ? theme.connector : theme.edge;
          ctx.lineWidth = isActive ? 2.4 : 1.4;
          ctx.stroke();
        }

        // node helpers
        const drawCircle = (x, y, r, fill, stroke, lw = 2) => {
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fillStyle = fill;
          ctx.strokeStyle = stroke;
          ctx.lineWidth = lw;
          ctx.fill();
          ctx.stroke();
        };
        const strokeRoundedRect = (cx, cy, w, h, rad, color, lw=4) => {
          const x = cx - w/2, y = cy - h/2; const r = Math.min(rad, w/2, h/2);
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + w, y, r);
          ctx.closePath();
          ctx.strokeStyle = color; ctx.lineWidth = lw; ctx.stroke();
        };

        // nodes
        for (const n of graph.nodes) {
          const r = n.r || 16;
          let fill = theme.eventFill;
          let stroke = theme.eventStroke;
          if (n.kind === 'post') { fill = theme.postFill; stroke = theme.postStroke; }
          else if (n.kind === 'thought') { fill = theme.thoughtFill; stroke = theme.thoughtStroke; }
          else if (n.kind === 'ai_summary_done' || n.kind === 'catalyst_run') { fill = theme.aiFill; stroke = theme.aiStroke; }

          if (n.kind === 'thought') {
            const w = r * 2.6, h = r * 1.6;
            drawRoundedRect(n.x, n.y, w, h, 10, fill, stroke, 2);
          } else if (n.kind === 'ai_summary_done' || n.kind === 'catalyst_run') {
            drawDiamond(n.x, n.y, r, fill, stroke, 2);
          } else {
            drawCircle(n.x, n.y, r, fill, stroke, 2);
          }
        }

        // labels
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const truncate = (s, max) => (s && s.length > max) ? s.slice(0, max - 1) + '…' : (s || '');
        for (const n of graph.nodes) {
          const r = n.r || 16;
          let color = theme.eventLabel;
          let font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          let y = n.y;
          if (n.kind === 'post') { color = theme.postLabel; font = 'bold 13px system-ui, -apple-system, Segoe UI, Roboto, sans-serif'; }
          else if (n.kind === 'thought') { color = theme.thoughtLabel; }
          else if (n.kind === 'ai_summary_done' || n.kind === 'catalyst_run') { color = theme.aiLabel; }

          ctx.fillStyle = color;
          ctx.font = font;
          const label = n.kind === 'post' ? truncate(n.label, 28) : truncate(n.label, 22);
          ctx.fillText(label, n.x, y);
        }

        // highlight pinned/hovered and emphasize connectors
        const hilite = (node) => {
          if (!node) return;
          const color = (node.kind === 'post') ? theme.hiPost : (node.kind === 'thought') ? theme.hiThought : ((node.kind === 'ai_summary_done' || node.kind === 'catalyst_run') ? theme.hiAI : theme.hiDefault);
          // emphasize connectors
          ctx.save();
          ctx.strokeStyle = color;
          ctx.lineWidth = 3.2;
          ctx.globalAlpha = 0.95;
          for (const e of graph.edges) {
            if (e.a === node.id || e.b === node.id) {
              const a = byId[e.a]; const b = byId[e.b];
              if (!a || !b) continue;
              ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
            }
          }
          ctx.restore();

          // halo around node
          const r = node.r || 16;
          ctx.save();
          ctx.strokeStyle = color;
          ctx.globalAlpha = 0.6;
          if (node.kind === 'thought') {
            const w = r * 2.6 + 12; const h = r * 1.6 + 10;
            strokeRoundedRect(node.x, node.y, w, h, 12, color, 6);
          } else if (node.kind === 'ai_summary_done' || node.kind === 'catalyst_run') {
            const rr = r + 8;
            ctx.beginPath();
            ctx.moveTo(node.x, node.y - rr);
            ctx.lineTo(node.x + rr, node.y);
            ctx.lineTo(node.x, node.y + rr);
            ctx.lineTo(node.x - rr, node.y);
            ctx.closePath();
            ctx.lineWidth = 6; ctx.stroke();
          } else {
            ctx.beginPath(); ctx.arc(node.x, node.y, r + 8, 0, Math.PI * 2); ctx.lineWidth = 6; ctx.stroke();
          }
          ctx.restore();
        };

        const pinned = this._hist?.pinnedId && graph.nodes.find(n => n.id === this._hist.pinnedId);
        if (pinned) hilite(pinned); else if (this._hist && this._hist.hoverId) { const hn = graph.nodes.find(n => n.id === this._hist.hoverId); hilite(hn); }
        ctx.restore();
      }

      updateOpen() {
        const isOpen = this.$panel.classList.contains('open');
        LS.set(KEYS.isOpen, isOpen);
        this.state.isOpen = isOpen;
        
        // When opening, verify position is valid for current viewport
        if (isOpen) {
          requestAnimationFrame(() => {
            const rect = this.$panel.getBoundingClientRect();
            const { x, y } = this.clamp(rect.left, rect.top);
            if (x == null || y == null) {
              // Reset to CSS defaults if position is invalid
              Object.assign(this.$panel.style, {
                left: '',
                top: '',
                right: '',
                bottom: '',
              });
              this.state.position = { x: null, y: null };
              LS.set(KEYS.position, { x: null, y: null });
            }
          });
        }
      }

      updateHistoryTooltip(node, clientX, clientY) {
        if (!node) return this.hideHistoryTooltip();
        let tip = this.$historyTooltip;
         if (!tip) {
           tip = document.createElement('div');
           tip.className = 'history-tooltip';
           tip.style.opacity = '0';
           tip.style.transition = 'opacity 120ms ease';
           this.$historyTooltip = tip;
           this.shadowRoot.appendChild(tip);
           requestAnimationFrame(()=>{ tip.style.opacity = '1'; });
         }
         const lines = [];
         if (node.kind === 'post') {
           const p = node.meta?.post;
           lines.push(`Post: ${node.label}`);
           if (p) lines.push(`${p.year}/${p.slug}`);
            lines.push('Click: pin • Double-click: open');
          } else {
            const ev = node.meta?.ev;
            const pg = ev?.page;
            lines.push(`Event: ${node.label}`);
            if (node.meta?.count && node.meta.count > 1) lines.push(`Count: ${node.meta.count}`);
            if (ev?.type) lines.push(`Type: ${ev.type}`);
            if (ev?.t) {
              try { lines.push(new Date(ev.t).toLocaleString()); } catch (_) {}
            }
            if (pg?.title) lines.push(`Page: ${pg.title}`);
            if (pg?.post) { const p = pg.post; lines.push(`Post: ${p.year}/${p.slug}`); }
            if (node.kind === 'thought' && ev?.content) {
              const snip = String(ev.content).replace(/\s+/g, ' ').trim().slice(0, 100);
              if (snip) lines.push(`“${snip}${ev.content.length > 100 ? '…' : ''}”`);
            }
          }
        tip.textContent = lines.join(' • ');
        tip.style.left = Math.round(clientX + 12) + 'px';
        tip.style.top = Math.round(clientY + 12) + 'px';
        return tip;
      }

      hideHistoryTooltip() {
        if (this.$historyTooltip) { this.$historyTooltip.remove(); this.$historyTooltip = null; }
      }

      // Bottom info panel for pinned node
      updateHistoryInfo(node, pinned = true) {
        if (!node) return this.closeHistoryInfo();
        let box = this.$historyInfo;
        if (!box) {
          box = document.createElement('div');
          box.className = 'history-info';
          box.innerHTML = `
            <div class="history-info-toolbar">
              <div class="left">
                <div class="history-info-title"></div>
                <div class="history-info-meta"></div>
              </div>
              <div class="right">
                <button class="btn secondary" data-action="open" style="display:none;">열기</button>
                <button class="btn" data-action="unpin">고정 해제</button>
              </div>
            </div>
            <div class="history-info-body"></div>
          `;
          this.$historyInfo = box;
          this.shadowRoot.appendChild(box);
          // actions
          box.querySelector('[data-action="unpin"]').addEventListener('click', () => {
            if (this._hist) this._hist.pinnedId = null; this.closeHistoryInfo(); this.drawHistory();
          });
          box.querySelector('[data-action="open"]').addEventListener('click', () => {
            const n = this._histGraph?.nodes?.find(nn => nn.id === this._hist?.pinnedId) || node;
            if (n && (n.kind === 'post' || n.kind === 'post_node')) {
              const p = n.meta?.post; if (p) { const href = `#/blog/${p.year}/${p.slug}`; try { window.location.hash = href.replace(/^#/, ''); } catch (_) { window.location.href = href; } this.closeHistory(); }
            }
          });
        }
        const titleEl = box.querySelector('.history-info-title');
        const metaEl = box.querySelector('.history-info-meta');
        const bodyEl = box.querySelector('.history-info-body');
        const openBtn = box.querySelector('[data-action="open"]');

        if (node.kind === 'post') {
          const p = node.meta?.post;
          titleEl.textContent = node.label || `${p?.year}/${p?.slug}`;
          metaEl.textContent = p ? `${p.year}/${p.slug}` : '';
          openBtn.style.display = '';
          // list events for this post
          const key = p ? `${p.year}/${p.slug}` : '';
          const rows = (this.state.events || []).filter(ev => ev?.page?.post && `${ev.page.post.year}/${ev.page.post.slug}` === key)
            .sort((a,b)=> (a.t||0) - (b.t||0))
            .map(ev => {
              const dt = new Date(ev.t).toLocaleString();
              const lbl = ev.label || ev.type;
              return `<li><span class="dt">${dt}</span><span class="sep">•</span><span class="lbl">${lbl}</span></li>`;
            }).join('');
          bodyEl.innerHTML = rows ? `<ul class="history-info-list">${rows}</ul>` : '<div class="small">이 글과 연결된 이벤트가 없습니다.</div>';
        } else if (node.kind === 'thought') {
          const ev = node.meta?.ev || {};
          const firstLine = (ev.label || '').trim();
          titleEl.textContent = firstLine || 'Thought';
          const p = ev?.page?.post; const when = ev.t ? new Date(ev.t).toLocaleString() : '';
          metaEl.textContent = [when, p ? `${p.year}/${p.slug}` : null].filter(Boolean).join(' • ');
          openBtn.style.display = 'none';
          const content = (ev.content || '').toString();
          bodyEl.innerHTML = content ? `<div class="history-info-kv"><div><b>내용</b>${this.markdownToHtml(content)}</div></div>` : '<div class="small">내용 없음</div>';
        } else {
          const ev = node.meta?.ev || {};
          titleEl.textContent = ev.label || ev.type || '이벤트';
          const p = ev?.page?.post; const when = ev.t ? new Date(ev.t).toLocaleString() : '';
          metaEl.textContent = [when, p ? `${p.year}/${p.slug}` : null, ev.type ? `type: ${ev.type}` : null].filter(Boolean).join(' • ');
          openBtn.style.display = 'none';
          bodyEl.innerHTML = '<div class="small">연결 정보</div>';
        }
        return box;
      }

      closeHistoryInfo() {
        if (this.$historyInfo) { this.$historyInfo.remove(); this.$historyInfo = null; }
      }


     updateMode() {
      const active = this.shadowRoot.querySelector('.tab.active');
      const mode = active ? active.dataset.tab : 'memo';
      LS.set(KEYS.mode, mode);
      this.state.mode = mode;
      const previewMode = mode === 'preview';
      if (this.$panel) this.$panel.classList.toggle('preview-mode', previewMode);
      this.classList.toggle('preview-mode', previewMode);
      if (mode === 'dev') {
        this.maybeLoadOriginalMarkdown();
      }
      if (this.$memoBody) this.$memoBody.classList.toggle('active', mode === 'memo');
      if (this.$previewBody) this.$previewBody.classList.toggle('active', mode === 'preview');
      if (this.$devBody) this.$devBody.classList.toggle('active', mode === 'dev');
      if (this.$settingsBody) this.$settingsBody.classList.toggle('active', mode === 'settings');
      this.applyLayoutMode(this.state.layoutMode);
      if (previewMode && this.$memoEditor && this.$memoPreview) {
        this.$memoEditor.value = this.$memo.value || '';
        this.applyPreviewPane(this.state.previewPane);
        this.scheduleRenderPreview(this.$memoEditor.value);
      }
    }

     bind() {
       // launcher
       this.$launcher.addEventListener('click', () => {
         this.$panel.classList.toggle('open');
         this.updateOpen();
       });

       // history overlay toggle
       if (this.$historyLauncher && this.$historyOverlay) {
         this.$historyLauncher.addEventListener('click', () => {
           const vis = this.$historyOverlay.style.display !== 'none';
           if (vis) this.closeHistory(); else this.openHistory();
         });
       }

      // close
      this.$close.addEventListener('click', () => {
        this.$panel.classList.remove('open');
        this.updateOpen();
        this.closeHistory();
      });

      // tabs
      this.$tabs.forEach(tab =>
        tab.addEventListener('click', () => {
          this.$tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          this.updateMode();
        })
      );

      if (this.$layoutSplit)
        this.$layoutSplit.addEventListener('click', () => {
          this.applyLayoutMode('split');
          this.applyPreviewPane('editor');
          this.logEvent({ type: 'layout_change', mode: 'split' });
        });

      if (this.$layoutTabs)
        this.$layoutTabs.addEventListener('click', () => {
          this.applyLayoutMode('tab');
          this.applyPreviewPane(this.state.previewPane || 'editor');
          this.logEvent({ type: 'layout_change', mode: 'tab' });
        });

      if (Array.isArray(this.$previewPaneButtons)) {
        this.$previewPaneButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const pane = btn.dataset.pane || 'editor';
            this.applyPreviewPane(pane);
            this.logEvent({ type: 'preview_pane', pane });
          });
        });
      }

      // input persistence
       const saveMemo = () => {
         this.state.memo = this.$memo.value;
         LS.set(KEYS.memo, this.state.memo);
         if (this.$memoEditor && this.$memoEditor.value !== this.state.memo) {
           this.$memoEditor.value = this.state.memo;
         }
          if (this.$memoPreview) {
            this.scheduleRenderPreview(this.state.memo);
          }
          this.out.tempStatus('저장됨', 'Ready', 900);
       };

      this.$memo.addEventListener('input', saveMemo);
      this.$memo.addEventListener('change', saveMemo);
      if (this.$memoEditor) {
        const saveAndRender = () => {
          this.state.memo = this.$memoEditor.value;
          LS.set(KEYS.memo, this.state.memo);
          this.scheduleRenderPreview(this.state.memo);
          if (this.$memo.value !== this.state.memo) this.$memo.value = this.state.memo;
          this.out.tempStatus('저장됨', 'Ready', 900);
        };
        this.$memoEditor.addEventListener('input', saveAndRender);
        this.$memoEditor.addEventListener('change', saveAndRender);

        // scroll sync: editor -> preview
        const sync = () => {
          if (!this.$memoPreview) return;
          const ta = this.$memoEditor;
          const ratio = ta.scrollTop / (ta.scrollHeight - ta.clientHeight || 1);
          const target = (this.$memoPreview.scrollHeight - this.$memoPreview.clientHeight) * ratio;
          this.$memoPreview.scrollTop = target;
        };
        this.$memoEditor.addEventListener('scroll', () => requestAnimationFrame(sync));
      }
       if (this.$inlineEnabled) {
         const onToggleInline = () => {
           const val = !!this.$inlineEnabled.checked;
           this.state.inlineEnabled = val;
           LS.set(KEYS.inlineEnabled, val);
            this.out.toast(`인라인 ✨ ${val ? '켜짐' : '꺼짐'}`);
            this.logEvent({ type: 'toggle_inline', label: val ? 'on' : 'off' });
         };
        this.$inlineEnabled.addEventListener('change', onToggleInline);
        this.$inlineEnabled.addEventListener('input', onToggleInline);
      }
      if (this.$closeAfterInject) {
        const onToggleClose = () => {
          const val = !!this.$closeAfterInject.checked;
          this.state.closeAfterInject = val;
          LS.set(KEYS.closeAfterInject, val);
           this.out.toast(`주입 후 창 닫기 ${val ? '켜짐' : '꺼짐'}`);
           this.logEvent({ type: 'toggle_close_after_inject', label: val ? 'on' : 'off' });
        };
        this.$closeAfterInject.addEventListener('change', onToggleClose);
        this.$closeAfterInject.addEventListener('input', onToggleClose);
      }
      if (this.$resetPosition) {
        this.$resetPosition.addEventListener('click', () => {
          try {
            this.state.position = { x: null, y: null };
            LS.set(KEYS.position, this.state.position);
          } catch (_) {}
          if (this.$panel) {
            Object.assign(this.$panel.style, {
              left: '',
              top: '',
              right: '',
              bottom: '',
            });
          }
          this.out.toast('패널 위치를 기본값으로 되돌렸어요.');
          this.logEvent({ type: 'reset_position', label: 'settings' });
        });
      }
      if (this.$proposalMd) {
        const persistProposal = () => {
          this.state.proposalMd = this.$proposalMd.value;
          LS.set(KEYS.proposalMd, this.state.proposalMd);
        };
        this.$proposalMd.addEventListener('input', persistProposal);
        this.$proposalMd.addEventListener('change', persistProposal);
      }

       // memo toolbar helpers
       const getActiveTextarea = () => {
         const active = this.shadowRoot.activeElement || document.activeElement;
         if (active === this.$memoEditor) return this.$memoEditor;
         return this.$memo;
       };
       const surround = (prefix, suffix = prefix) => {
         const ta = getActiveTextarea();
         const { selectionStart: s, selectionEnd: e, value } = ta;
         if (s == null || e == null) return;
         const before = value.slice(0, s);
         const selection = value.slice(s, e) || '텍스트';
         const after = value.slice(e);
         const next = `${before}${prefix}${selection}${suffix}${after}`;
         ta.value = next;
         ta.focus();
         const caret = (before + prefix + selection + suffix).length;
         ta.setSelectionRange(caret, caret);
         ta.dispatchEvent(new Event('input', { bubbles: true }));
       };
       const linePrefix = pfx => {
         const ta = getActiveTextarea();
         const { selectionStart: s, selectionEnd: e, value } = ta;
         const start = value.lastIndexOf('\n', s - 1) + 1;
         const end = value.indexOf('\n', e);
         const last = end === -1 ? value.length : end;
         const body = value.slice(start, last);
         const prefix = body.startsWith(pfx + ' ') ? '' : `${pfx} `;
         const next = value.slice(0, start) + prefix + body + value.slice(last);
         ta.value = next;
         ta.focus();
         const caret = start + (prefix ? prefix.length : 0);
         ta.setSelectionRange(caret, caret);
         ta.dispatchEvent(new Event('input', { bubbles: true }));
       };
        this.$memoBold?.addEventListener('click', () => surround('**'));
        this.$memoItalic?.addEventListener('click', () => surround('*'));
        this.$memoCode?.addEventListener('click', () => surround('`'));
        this.$memoH1?.addEventListener('click', () => linePrefix('#'));
        this.$memoH2?.addEventListener('click', () => linePrefix('##'));
        this.$memoUl?.addEventListener('click', () => linePrefix('-'));
        this.$memoOl?.addEventListener('click', () => linePrefix('1.'));
         this.$memoFull?.addEventListener('click', () => {
           const entering = !this.classList.contains('memo-full');
           this.classList.toggle('memo-full');
            this.out.toast(entering ? '전체화면' : '일반 모드');
            this.logEvent({ type: 'toggle_fullscreen', label: entering ? 'enter' : 'exit' });
           if (this.$memoPreview) this.renderMarkdownToPreview(this.$memoEditor?.value || this.$memo?.value || '');
         });

       this.$memoClear?.addEventListener('click', () => {
         if (confirm('메모를 모두 지울까요?')) {
           this.$memo.value = '';
           this.$memo.dispatchEvent(new Event('input', { bubbles: true }));
         }
       });

      // Cloud sync button
      this.$memoSync = this.shadowRoot.getElementById('memoSync');
      this.$memoSync?.addEventListener('click', () => this.syncToCloud());

      // Versions button
      this.$memoVersions = this.shadowRoot.getElementById('memoVersions');
      this.$versionsOverlay = this.shadowRoot.getElementById('versionsOverlay');
      this.$versionsList = this.shadowRoot.getElementById('versionsList');
      this.$versionsClose = this.shadowRoot.getElementById('versionsClose');

      this.$memoVersions?.addEventListener('click', () => this.openVersions());
      this.$versionsClose?.addEventListener('click', () => this.closeVersions());

      // Close versions on overlay click
      this.$versionsOverlay?.addEventListener('click', (e) => {
        if (e.target === this.$versionsOverlay) this.closeVersions();
      });

      // selection add
      this.$addSel.addEventListener('click', () => {
        const sel = window.getSelection();
        const text = sel && sel.toString().trim();
          if (!text) {
            this.out.toast('\uc120\ud0dd\ub41c \ud14d\uc2a4\ud2b8\uac00 \uc5c6\uc2b5\ub2c8\ub2e4.');
            return;
          }
        const now = new Date();
        const entry = `\n> ${text}\n\u0014 ${now.toLocaleString()}\n`;
        this.out.append(entry);
        this.out.toast('\uc120\ud0dd \ub0b4\uc6a9\uc744 \ucd94\uac00\ud588\uc2b5\ub2c8\ub2e4.');
        this.logEvent({ type: 'selection', label: '\uc120\ud0dd \ucd94\uac00', content: text });
      });

      // block add (enter block selection mode)
      if (this.$addBlock) {
        this.$addBlock.addEventListener('click', () => {
          this.logEvent({ type: 'enter_block_select', label: '\ube14\ub85d \ucd94\uac00' });
          this.toggleBlockSelectMode(true);
        });
      }


      // memo -> graph thought injection
      if (this.$memoToGraph) {
        this.$memoToGraph.addEventListener('click', () => {
          const raw = (this.$memo.value || '').trim();
           if (!raw) { this.out.toast('메모가 비어 있습니다.'); return; }
          const firstLine = raw.split(/\r?\n/).find(l => l.trim().length > 0) || '';
          const labelBase = (firstLine || raw).replace(/^\s*#+\s*/, '');
          const label = labelBase.slice(0, 60) + (labelBase.length > 60 ? '…' : '');

          // duplicate guard: check last 20 thought events for same content
          const recent = (this.state.events || []).slice(-50).reverse();
          const dup = recent.find(ev => ev && ev.type === 'thought' && (ev.content || '').trim() === raw);
          if (dup) {
            const ok = confirm('동일한 내용의 생각이 이미 그래프에 있습니다. 다시 추가할까요?');
            if (!ok) { this.out.toast('주입을 취소했습니다.'); return; }
          }

          // build metadata
          const info = this.getCurrentPostInfo();
          const anchor = this.getCurrentAnchor();
          const id = Math.random().toString(36).slice(2) + Date.now().toString(36);
          const meta = { ver: 2, id, source: 'memo', anchor };

          this.logEvent({ type: 'thought', label, content: raw, meta });
           this.out.toast('메모를 그래프에 추가했습니다.');
          if (this.$historyOverlay && this.$historyOverlay.style.display !== 'none') {
            this.drawHistory();
          }
          if (this.state.closeAfterInject) {
            this.$panel.classList.remove('open');
            this.updateOpen();
          }
        });
      }

      // Catalyst UI
      if (this.$catalystBtn) {
        this.$catalystBtn.addEventListener('click', () => {
          if (!this.$catalystBox) return;
          const visible = this.$catalystBox.style.display !== 'none';
          this.$catalystBox.style.display = visible ? 'none' : 'flex';
          this.logEvent({ type: visible ? 'catalyst_close' : 'catalyst_open', label: visible ? 'close' : 'open' });
          if (!visible) {
            setTimeout(() => this.$catalystInput?.focus(), 0);
          }
        });
      }
      if (this.$catalystCancel) {
         this.$catalystCancel.addEventListener('click', () => {
           if (this.$catalystInput) this.$catalystInput.value = '';
           if (this.$catalystBox) this.$catalystBox.style.display = 'none';
           this.logEvent({ type: 'catalyst_cancel', label: 'cancel' });
         });
      }
      if (this.$catalystRun) {
         this.$catalystRun.addEventListener('click', () => this.runCatalyst());
         this.$catalystInput?.addEventListener('input', () => {
           const v = this.$catalystInput.value || '';
           if (v.length > 160) this.$catalystInput.value = v.slice(0,160);
         });
      }
      if (this.$catalystInput) {
        this.$catalystInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); this.runCatalyst(); }
          if (e.key === 'Escape') { e.preventDefault(); this.$catalystCancel?.click(); }
        });
      }

      // unified download menu
      if (this.$download) {
        this.$download.addEventListener('click', () => {
          const sel = document.createElement('select');
          sel.innerHTML = '<option value="txt">일반 텍스트 (.txt)</option><option value="md">Markdown (.md)</option><option value="html">HTML (.html)</option>';
          sel.style.position = 'absolute';
          sel.style.right = '12px';
          sel.style.bottom = '44px';
          sel.style.zIndex = '2147483647';
          sel.style.padding = '6px';
          sel.style.borderRadius = '6px';
          sel.style.border = '1px solid #e5e7eb';
          sel.style.background = '#fff';
          this.$panel.appendChild(sel);
          const cleanup = () => sel.remove();
          sel.addEventListener('change', () => {
            const type = sel.value;
            const md = this.$memo.value || '';
            if (type === 'txt') {
              const blob = new Blob([md], { type: 'text/plain;charset=utf-8' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url; a.download = 'memo.txt'; document.body.appendChild(a); a.click(); a.remove();
              URL.revokeObjectURL(url);
              this.out.toast('memo.txt 다운로드');
            } else if (type === 'md') {
              const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url; a.download = 'memo.md'; document.body.appendChild(a); a.click(); a.remove();
              URL.revokeObjectURL(url);
              this.out.toast('memo.md 다운로드');
            } else if (type === 'html') {
              const body = this.markdownToHtml(md);
              const html = '<!doctype html><meta charset="utf-8"/><title>Memo</title><body style="font: 14px/1.6 system-ui, sans-serif; padding: 24px; max-width: 760px; margin: auto;">' + body + '</body>';
              const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url; a.download = 'memo.html'; document.body.appendChild(a); a.click(); a.remove();
              URL.revokeObjectURL(url);
              this.out.toast('memo.html 다운로드');
            }
            cleanup();
          });
          const onBlur = () => cleanup();
          sel.addEventListener('blur', onBlur);
          setTimeout(() => sel.focus(), 0);
        });
      }

       // AI summary
      this.$aiSummary.addEventListener('click', () => {
        this.logEvent({ type: 'ai_summary', label: 'AI 요약' });
        this.summarizeWithGemini();
      });

      // track key actions
      if (this.$download) {
        this.$download.addEventListener('click', () => this.logEvent({ type: 'download_memo', label: '메모 다운로드' }));
      }
       this.$historyLauncher?.addEventListener('click', () => this.logEvent({ type: 'open_history', label: '히스토리 토글' }));


      // font size
      if (this.$fontSize) {
         const onFs = () => {
           const fs = parseInt(this.$fontSize.value || '13', 10);
           this.applyFontSize(fs);
           LS.set(KEYS.fontSize, fs);
           this.state.fontSize = fs;
           this.logEvent({ type: 'change_font_size', label: String(fs) });
         };
        this.$fontSize.addEventListener('change', onFs);
        this.$fontSize.addEventListener('input', onFs);
      }

      // Proposal actions
      if (this.$loadOriginalMd)
        this.$loadOriginalMd.addEventListener('click', () =>
          this.maybeLoadOriginalMarkdown(true)
        );
      if (this.$proposeNewVersion)
        this.$proposeNewVersion.addEventListener('click', () =>
          this.proposeNewVersion()
        );

      // drag move
      const onPointerMove = e => {
        if (!this._drag.active) return;
        const dx = e.clientX - this._drag.startX;
        const dy = e.clientY - this._drag.startY;
        const { x, y } = this.clamp(
          this._drag.origX + dx,
          this._drag.origY + dy
        );
        Object.assign(this.$panel.style, {
          left: `${x}px`,
          top: `${y}px`,
          right: 'auto',
          bottom: 'auto',
        });
      };
      const onPointerUp = e => {
        if (!this._drag.active) return;
        this._drag.active = false;
        document.removeEventListener('pointermove', onPointerMove);
        document.removeEventListener('pointerup', onPointerUp);
        // persist position
        const rect = this.$panel.getBoundingClientRect();
        LS.set(KEYS.position, { x: rect.left, y: rect.top });
      };
      this.$drag.addEventListener('pointerdown', e => {
        if (e.button !== 0) return;
        const rect = this.$panel.getBoundingClientRect();
        this._drag = {
          active: true,
          startX: e.clientX,
          startY: e.clientY,
          origX: rect.left,
          origY: rect.top,
        };
        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerup', onPointerUp);
      });

      // viewport clamp on resize
      window.addEventListener('resize', () => {
        if (!this.$panel.classList.contains('open')) return;
        const rect = this.$panel.getBoundingClientRect();
        const { x, y } = this.clamp(rect.left, rect.top);
        if (x == null || y == null) {
          // Reset to CSS defaults if position is invalid
          Object.assign(this.$panel.style, {
            left: '',
            top: '',
            right: '',
            bottom: '',
          });
          LS.set(KEYS.position, { x: null, y: null });
        } else {
          Object.assign(this.$panel.style, {
            left: `${x}px`,
            top: `${y}px`,
            right: 'auto',
            bottom: 'auto',
          });
          LS.set(KEYS.position, { x, y });
        }
      });

       // keyboard: Esc to close + editor shortcuts
        window.addEventListener('keydown', e => {
         if (e.key === 'Escape' && this.$panel.classList.contains('open')) {
           this.$panel.classList.remove('open');
           this.updateOpen();
         }
         if (e.altKey && (e.key === 'm' || e.key === 'M')) {
           this.$panel.classList.toggle('open');
           this.updateOpen();
         }
         // common editor shortcuts when panel open
         const activeEl = this.shadowRoot.activeElement || document.activeElement;
         const isMemo = activeEl === this.$memo;
         const isEditor = activeEl === this.$memoEditor;
         if (this.$panel.classList.contains('open') && (isMemo || isEditor)) {
           const meta = e.metaKey || e.ctrlKey;
           if (meta && e.key.toLowerCase() === 'b') { e.preventDefault(); surround('**'); }
           if (meta && e.key.toLowerCase() === 'i') { e.preventDefault(); surround('*'); }
           if (meta && e.key === '`') { e.preventDefault(); surround('`'); }
         }
       });

       // indent/outdent with Tab/Shift+Tab inside memo
        const tabIndentHandler = (ta, e) => {
          if (e.key === 'Tab') {
            e.preventDefault();
            const { selectionStart: s, selectionEnd: epos, value } = ta;
            if (e.shiftKey) {
              const start = value.lastIndexOf('\n', s - 1) + 1;
              const line = value.slice(start, epos);
              let removed = 0;
              let newLine = line;
              if (newLine.startsWith('  ')) { newLine = newLine.slice(2); removed = 2; }
              else if (newLine.startsWith('- ')) { newLine = newLine.slice(2); removed = 2; }
              else if (newLine.startsWith('1. ')) { newLine = newLine.slice(3); removed = 3; }
              const next = value.slice(0, start) + newLine + value.slice(epos);
              ta.value = next;
              const ns = Math.max(s - removed, start);
              ta.setSelectionRange(ns, ns);
            } else {
              const before = value.slice(0, s);
              const after = value.slice(epos);
              ta.value = before + '  ' + after;
              const ns = s + 2;
              ta.setSelectionRange(ns, ns);
            }
            ta.dispatchEvent(new Event('input', { bubbles: true }));
          }
        };
       this.$memo.addEventListener('keydown', e => tabIndentHandler(this.$memo, e));
       if (this.$memoEditor) this.$memoEditor.addEventListener('keydown', e => tabIndentHandler(this.$memoEditor, e));

       // close tooltip softly
       const tipFadeOut = () => { if (this.$historyTooltip) { this.$historyTooltip.style.opacity = '0'; setTimeout(()=> this.hideHistoryTooltip(), 140); } };
       window.addEventListener('pointerdown', tipFadeOut);
       window.addEventListener('scroll', tipFadeOut, { passive: true });

       // basic auto-close for brackets/quotes
       const autoClose = (ta, e) => {
         const map = { '(': ')', '[': ']', '{': '}', '"': '"', "'": "'", '`': '`' };
         const close = map[e.key];
         if (!close) return;
         e.preventDefault();
         const { selectionStart: s, selectionEnd: epos, value } = ta;
         const before = value.slice(0, s);
         const after = value.slice(epos);
         ta.value = before + e.key + close + after;
         const ns = s + 1;
         ta.setSelectionRange(ns, ns);
         ta.dispatchEvent(new Event('input', { bubbles: true }));
       };
       const autoCloseKeys = new Set(['(', '[', '{', '"', "'", '`']);
       const onKeydownAuto = (ta) => (e) => {
         if (autoCloseKeys.has(e.key) && !(e.ctrlKey||e.metaKey||e.altKey)) return autoClose(ta, e);
       };
       this.$memo.addEventListener('keydown', onKeydownAuto(this.$memo));
       if (this.$memoEditor) this.$memoEditor.addEventListener('keydown', onKeydownAuto(this.$memoEditor));

       // slash command menu (minimal)
       const openSlashMenu = (ta) => {
         const menu = document.createElement('div');
         menu.style.position = 'absolute';
         menu.style.right = '12px';
         menu.style.bottom = '44px';
         menu.style.zIndex = '2147483647';
         menu.style.background = '#fff';
         menu.style.border = '1px solid #e5e7eb';
         menu.style.borderRadius = '8px';
         menu.style.padding = '6px';
         menu.style.boxShadow = '0 8px 20px rgba(0,0,0,0.12)';
          const items = [
            { k: 'h1', label: '제목 1', apply: () => { insertPrefix('# '); this.logEvent({ type: 'slash_menu', label: 'h1' }); } },
            { k: 'h2', label: '제목 2', apply: () => { insertPrefix('## '); this.logEvent({ type: 'slash_menu', label: 'h2' }); } },
            { k: 'quote', label: '인용구', apply: () => { insertPrefix('> '); this.logEvent({ type: 'slash_menu', label: 'quote' }); } },
            { k: 'code', label: '코드 블록', apply: () => { surround('```\n', '\n```'); this.logEvent({ type: 'slash_menu', label: 'code' }); } },
            { k: 'ul', label: '글머리 기호', apply: () => { insertPrefix('- '); this.logEvent({ type: 'slash_menu', label: 'ul' }); } },
            { k: 'ol', label: '번호 목록', apply: () => { insertPrefix('1. '); this.logEvent({ type: 'slash_menu', label: 'ol' }); } },
          ];
         menu.innerHTML = items.map((it,i)=>`<div data-i="${i}" style="padding:4px 8px; cursor:pointer;">${it.label}</div>`).join('');
         this.$panel.appendChild(menu);
         const cleanup = () => menu.remove();
         menu.addEventListener('click', (e) => {
           const t = e.target.closest('[data-i]');
           if (!t) return;
           const i = +t.dataset.i;
           items[i].apply();
           cleanup();
         });
         setTimeout(()=> menu.focus?.(),0);

         const surround = (prefix, suffix=prefix) => {
           const { selectionStart: s, selectionEnd: epos, value } = ta;
           const before = value.slice(0, s);
           const selection = value.slice(s, epos) || '';
           const after = value.slice(epos);
           const next = before + prefix + selection + suffix + after;
           ta.value = next; const ns = (before + prefix + selection).length; ta.setSelectionRange(ns, ns); ta.dispatchEvent(new Event('input', { bubbles: true }));
         };
         const insertPrefix = (p) => {
           const { selectionStart: s, value } = ta;
           const start = value.lastIndexOf('\n', s - 1) + 1;
           ta.setRangeText(p, start, start, 'end');
           ta.dispatchEvent(new Event('input', { bubbles: true }));
         };
          this.logEvent({ type: 'open_slash_menu', label: 'slash' });
          return cleanup;
       };
       const attachSlashHandler = (ta) => {
         let cleanup = null;
         ta.addEventListener('keydown', (e) => {
           if (e.key === '/' && !(e.ctrlKey||e.metaKey||e.altKey)) {
             const { selectionStart: s, value } = ta;
             const prevChar = s > 0 ? value.charAt(s-1) : '\n';
             if (prevChar === '\n') {
               setTimeout(()=>{ cleanup = openSlashMenu(ta); },0);
             }
           }
           if (e.key === 'Escape' && cleanup) { cleanup(); cleanup = null; }
         });
       };
       attachSlashHandler(this.$memo);
       if (this.$memoEditor) attachSlashHandler(this.$memoEditor);

     }

    getCurrentPostInfo() {
      // Supports routes: #/blog/:year/:slug and /blog/:year/:slug (or 'post')
      const fromHash = () => {
        const h = (location.hash || '').replace(/^#/, '');
        const m = h.match(/^\/?(blog|post)\/(\d{4})\/([^\/?#]+)/);
        if (m) return { type: m[1], year: m[2], slug: m[3] };
        return null;
      };
      const fromPath = () => {
        const p = location.pathname || '';
        const m = p.match(/^\/?(blog|post)\/(\d{4})\/([^\/?#]+)/);
        if (m) return { type: m[1], year: m[2], slug: m[3] };
        return null;
      };
      return fromHash() || fromPath();
    }

    getCurrentAnchor() {
      try {
        const scope = document.querySelector('article') ||
          document.querySelector('main') ||
          document.querySelector('article.prose') ||
          document.querySelector('.prose') ||
          document.getElementById('content') ||
          document.body;
        if (!scope) return null;

        const toAnchor = (h) => {
          let id = (h.id || '').trim();
          if (!id) {
            const a = h.querySelector('a[href^="#"]');
            if (a) {
              const href = (a.getAttribute('href') || '').trim();
              if (href.startsWith('#') && href.length > 1) {
                try { id = decodeURIComponent(href.slice(1)); } catch (_) { id = href.slice(1); }
              }
            }
          }
          return id ? { el: h, id } : null;
        };

        let anchors = Array.from(scope.querySelectorAll('h1,h2,h3,h4,h5,h6'))
          .map(toAnchor)
          .filter(Boolean);

        if (anchors.length === 0) {
          anchors = Array.from(scope.querySelectorAll('[id]'))
            .filter(el => el.id && el.id.length > 0)
            .map(el => ({ el, id: el.id }));
        }
        if (anchors.length === 0) return null;

        anchors.forEach(a => { a.top = a.el.getBoundingClientRect().top; });

        const threshold = Math.round(window.innerHeight * 0.33);
        let candidate = anchors
          .filter(a => a.top <= threshold)
          .sort((a, b) => b.top - a.top)[0];
        if (!candidate) {
          candidate = anchors
            .filter(a => a.top > 0)
            .sort((a, b) => a.top - b.top)[0];
        }
        if (!candidate) candidate = anchors[0];

        const id = (candidate && candidate.id || '').trim();
        return id ? `#${id}` : null;
      } catch (_) {
        return null;
      }
    }

    buildOriginalMarkdownPath(info) {
      if (!info) return null;
      const { year, slug } = info;
      return `/posts/${year}/${slug}.md`;
    }

    async maybeLoadOriginalMarkdown(force = false) {
      const prev = this.out.getStatus();
      try {
        const info = this.getCurrentPostInfo();
        if (!info) {
          if (this.$originalPath)
            this.$originalPath.textContent =
              '현재 페이지가 블로그 글 상세가 아닙니다.';
          return;
        }
        const mdPath = this.buildOriginalMarkdownPath(info);
        if (this.$originalPath) this.$originalPath.textContent = `${mdPath}`;

        if (this._originalLoaded && !force) return;

        const origin = location.origin;
        const url = `${origin}${mdPath}`;
        this.out.setStatus('원문 불러오는 중…');
        const res = await fetch(url);
        if (!res.ok) throw new Error(`원문 로드 실패(${res.status})`);
        const text = await res.text();
        if (this.$proposalMd) {
          if (force || !this.$proposalMd.value) {
            this.$proposalMd.value = text;
            this.state.proposalMd = text;
            LS.set(KEYS.proposalMd, text);
            this.out.toast(
              '원문을 불러왔습니다. 내용을 편집한 뒤 PR을 생성하세요.'
            );
          }
        }
        this._originalLoaded = true;
        this.out.setStatus('완료');
      } catch (err) {
        console.error('maybeLoadOriginalMarkdown error:', err);
        this.out.setStatus('오류');
        this.out.toast(err?.message || '원문을 불러오지 못했습니다.');
      } finally {
        setTimeout(() => { this.out.setStatus(prev || 'Ready'); }, 1400);
      }
    }

    async proposeNewVersion() {
      const prev = this.out.getStatus();
      try {
        const backend = window.__APP_CONFIG?.apiBaseUrl || window.APP_CONFIG?.apiBaseUrl || DEFAULT_API_URL;
        const info = this.getCurrentPostInfo();
        if (!info) {
          this.out.toast('현재 페이지에서 글 정보를 찾을 수 없습니다.');
          return;
        }
        const md = (this.$proposalMd?.value || '').trim();
        if (!md) {
          this.out.toast('제안할 마크다운이 비어 있습니다.');
          return;
        }

        const mdPath = this.buildOriginalMarkdownPath(info);
        const endpoint = `${backend.replace(/\/$/, '')}/api/v1/admin/propose-new-version`;

        const payload = {
          original: {
            year: info.year,
            slug: info.slug,
            path: mdPath,
            url: `${location.origin}/#/blog/${info.year}/${info.slug}`,
          },
          markdown: md,
          sourcePage: location.href,
        };

        if (this.$proposeNewVersion) this.$proposeNewVersion.disabled = true;
        this.out.setStatus('PR 생성 요청 중…');
        const adminToken = LS.get(KEYS.adminToken, '');
        const headers = { 'Content-Type': 'application/json' };
        if (adminToken) headers['Authorization'] = `Bearer ${adminToken}`;
        const res = await fetch(endpoint, {
          method: 'POST',
          headers,
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const t = await res.text().catch(() => '');
          throw new Error(`요청 실패(${res.status}) ${t.slice(0, 200)}`);
        }
        const data = await res.json().catch(() => ({}));
        const prUrl = data.prUrl || data.url || data.html_url;
        if (prUrl && this.$prLink) {
          this.$prLink.href = prUrl;
          this.$prLink.style.display = '';
        }
        this.out.toast(prUrl ? 'PR이 생성되었습니다.' : '요청이 완료되었습니다.');
        this.out.setStatus('완료');
      } catch (err) {
        console.error('proposeNewVersion error:', err);
        this.out.setStatus('오류');
        this.out.toast(err?.message || 'PR 생성 요청에 실패했습니다.');
      } finally {
        setTimeout(() => { this.out.setStatus(prev || 'Ready'); }, 1400);
        if (this.$proposeNewVersion) this.$proposeNewVersion.disabled = false;
      }
    }
  }

  customElements.define('ai-memo-pad', AIMemoPad);

  // Ensure single instance mounted
  const mountOnce = () => {
    if (document.body && !document.querySelector('ai-memo-pad')) {
      const el = document.createElement('ai-memo-pad');
      document.body.appendChild(el);
    }
  };
  if (document.readyState === 'loading')
    document.addEventListener('DOMContentLoaded', mountOnce);
  else mountOnce();
})();
```

### runner.js

**Path:** `frontend/public/ai-memo/runner.js`

```javascript
'use strict';
// Minimal iframe sandbox runtime for Dev Mode (placeholder for now)
// Receives context via postMessage and exposes to window.context
(() => {
  window.context = {};
  window.addEventListener('message', e => {
    const data = e?.data;
    if (!data) return;
    if (data.type === 'init' && data.context) {
      window.context = data.context;
      if (typeof window.onContextReady === 'function') {
        try {
          window.onContextReady();
        } catch (_) {}
      }
    }
  });
})();

```

---

## frontend/public/posts

### posts-manifest.json

**Path:** `frontend/public/posts/posts-manifest.json`

```json
{
  "total": 133,
  "items": [
    {
      "path": "/posts/2025/k8s-overview.md",
      "year": "2025",
      "slug": "k8s-overview",
      "title": "쿠버네티스 기본 구조",
      "description": "전통적 배포 방식부터 쿠버네티스 에코시스템까지, 개념을 정리하는 글",
      "snippet": "전통적 배포 방식부터 쿠버네티스 에코시스템까지, 개념을 정리하는 글",
      "date": "2025-12-02",
      "tags": [
        "Kubernetes",
        "DevOps",
        "Cloud Native",
        "컨테이너 오케스트레이션"
      ],
      "category": "Kubernetes",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/k8s/k8s-deployment-era-traditional-virtualized-container.png",
      "url": "/blog/2025/k8s-overview"
    },
    {
      "path": "/posts/2025/AnimalsMind.md",
      "year": "2025",
      "slug": "AnimalsMind",
      "title": "우리는 DNA의 꼭두각시인가: 이성의 붕괴와 야성적 충동의 역설에 대한 생각",
      "description": "애덤 스미스의 이성적 인간관에 대한 반박부터 케인스와 민스키의 야성적 충동, 그리고 진화심리학적 관점까지. 인간 본성의 모순에 대한 생각",
      "snippet": "애덤 스미스의 이성적 인간관에 대한 반박부터 케인스와 민스키의 야성적 충동, 그리고 진화심리학적 관점까지. 인간 본성의 모순에 대한 생각",
      "date": "2025-12-01",
      "tags": [
        "Philosophy",
        "Economics",
        "Psychology",
        "Minsky",
        "Evolution"
      ],
      "category": "Essays",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/AnimalsMind"
    },
    {
      "path": "/posts/2025/algorithm_solv.md",
      "year": "2025",
      "slug": "algorithm_solv",
      "title": "알고리즘의 역발상 관점",
      "description": "피보나치 수열, 행렬 곱셈, 그리디 알고리즘, 문자열 검색, P vs NP까지 — 컴퓨터 과학의 고전 알고리즘을 역발상 관점으로 정리",
      "snippet": "피보나치 수열, 행렬 곱셈, 그리디 알고리즘, 문자열 검색, P vs NP까지 — 컴퓨터 과학의 고전 알고리즘을 역발상 관점으로 정리",
      "date": "2025-11-29",
      "tags": [
        "알고리즘",
        "동적 프로그래밍",
        "그리디",
        "문자열 알고리즘",
        "P vs NP"
      ],
      "category": "Computer Science",
      "author": "Admin",
      "readingTime": "8 min read",
      "published": true,
      "coverImage": "/images/2025/algoritm_solv/algorithm-solve-dp-fibonacci.png",
      "url": "/blog/2025/algorithm_solv"
    },
    {
      "path": "/posts/2025/AI-api-server-temporary-dev.md",
      "year": "2025",
      "slug": "AI-api-server-temporary-dev",
      "title": "Kafka와 LLM 서버 사이에 버퍼 존을 둔 AI 서버 설계기",
      "description": "Kafka와 LLM 서버 사이에 작은 버퍼 존을 두고 Gateway와 Buffer Worker를 나누어 설계한 이유, 그리고 이를 Kafka 토픽·메시지 스키마·docker-compose로 구체화해 가는 과정을 정리했다",
      "snippet": "Kafka와 LLM 서버 사이에 작은 버퍼 존을 두고 Gateway와 Buffer Worker를 나누어 설계한 이유, 그리고 이를 Kafka 토픽·메시지 스키마·docker-compose로 구체화해 가는 과정을 정리했다",
      "date": "2025-11-20",
      "tags": [
        "Kafka",
        "LLM",
        "RAG",
        "Gateway",
        "백엔드아키텍처"
      ],
      "category": "Backend",
      "author": "Admin",
      "readingTime": "8 min read",
      "published": true,
      "coverImage": "/images/2025/AI-server.png",
      "url": "/blog/2025/AI-api-server-temporary-dev"
    },
    {
      "path": "/posts/2025/nat-gateway-bottleneck-journal.md",
      "year": "2025",
      "slug": "nat-gateway-bottleneck-journal",
      "title": "네트워크 병목과 NAT 게이트웨이의 한계: 한 CS 학생의 속마음",
      "description": "프라이빗 서브넷과 퍼블릭 서브넷, NAT Gateway와 IGW가 등장하는 전형적인 VPC 그림을 보던 수업 시간. 모두가 보안을 이야기할 때, 내 눈에는 그 구조가 거대한 깔때기 실험처럼 보였다. 이 글은 그 순간 머릿속에서 떠오른 병목에 대한 질문과 직관을 그대로 옮긴 기록이다.",
      "snippet": "프라이빗 서브넷과 퍼블릭 서브넷, NAT Gateway와 IGW가 등장하는 전형적인 VPC 그림을 보던 수업 시간. 모두가 보안을 이야기할 때, 내 눈에는 그 구조가 거대한 깔때기 실험처럼 보였다. 이 글은 그 순간 머릿속에서 떠오른 병목에 대한 질문과 직관을 그대로 옮긴 기록이다.",
      "date": "2025-11-19",
      "tags": [
        "NAT",
        "클라우드네트워크",
        "VPC",
        "프라이빗서브넷",
        "병목"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "coverImage": "/images/2025/natgateway.png",
      "url": "/blog/2025/nat-gateway-bottleneck-journal"
    },
    {
      "path": "/posts/2025/future-tech-six-insights.md",
      "year": "2025",
      "slug": "future-tech-six-insights",
      "title": "제가 뇌를 리셋하게 만든 미래 기술 문서에서 발견한 6가지 깨달음",
      "description": "미래 기술 문서들 속에서 발견한 6가지 통찰과 인간 역할의 재정의를 공유합니다.",
      "snippet": "미래 기술 문서들 속에서 발견한 6가지 통찰과 인간 역할의 재정의를 공유합니다.",
      "date": "2025-11-04",
      "tags": [
        "AI",
        "DevOps",
        "Future",
        "Infrastructure",
        "Self-Evolving Systems"
      ],
      "category": "Tech Essay",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/future-map.jpg",
      "url": "/blog/2025/future-tech-six-insights"
    },
    {
      "path": "/posts/2025/sorting-algorithms-pseudocode-analysis.md",
      "year": "2025",
      "slug": "sorting-algorithms-pseudocode-analysis",
      "title": "정렬 알고리즘 수도 코드 완전 해부: 라인별 분석",
      "description": "버블 정렬부터 힙 정렬까지, 핵심 수도 코드를 한 줄씩 뜯어보며 왜 그런 로직이 필요한지 한국어로 상세하게 분석합니다.",
      "snippet": "버블 정렬부터 힙 정렬까지, 핵심 수도 코드를 한 줄씩 뜯어보며 왜 그런 로직이 필요한지 한국어로 상세하게 분석합니다.",
      "date": "2025-11-02",
      "tags": [
        "정렬",
        "알고리즘",
        "수도코드",
        "학습노트"
      ],
      "category": "알고리즘",
      "author": "Admin",
      "readingTime": "7 min read",
      "published": true,
      "url": "/blog/2025/sorting-algorithms-pseudocode-analysis"
    },
    {
      "path": "/posts/2025/path-new-friend-essay.md",
      "year": "2025",
      "slug": "path-new-friend-essay",
      "title": "PATH에 새 친구를 초대하는 방법",
      "description": "심볼릭 링크가 말을 안 듣던 날, PATH를 다시 다듬으며 정리한 나만의 에세이.",
      "snippet": "심볼릭 링크가 말을 안 듣던 날, PATH를 다시 다듬으며 정리한 나만의 에세이.",
      "date": "2025-11-01",
      "tags": [
        "PATH",
        "리눅스",
        "환경설정",
        "터미널",
        "작업자동화"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/path-new-friend-essay"
    },
    {
      "path": "/posts/2025/sorting-algorithms-masterclass.md",
      "year": "2025",
      "slug": "sorting-algorithms-masterclass",
      "title": "정렬 알고리즘 완전 정복: 버블 정렬부터 힙 정렬까지",
      "description": "버블 정렬부터 힙 정렬까지, 핵심 비유와 수도 코드, Java 구현으로 정렬 알고리즘을 완전 정복합니다.",
      "snippet": "버블 정렬부터 힙 정렬까지, 핵심 비유와 수도 코드, Java 구현으로 정렬 알고리즘을 완전 정복합니다.",
      "date": "2025-11-01",
      "tags": [
        "정렬",
        "알고리즘",
        "Java"
      ],
      "category": "알고리즘",
      "author": "Admin",
      "readingTime": "7 min read",
      "published": true,
      "url": "/blog/2025/sorting-algorithms-masterclass"
    },
    {
      "path": "/posts/2025/wine-clipboard-bridge-journal.md",
      "year": "2025",
      "slug": "wine-clipboard-bridge-journal",
      "title": "Wayland 위에서 Wine 카카오톡이 복붙을 잃어버린 날",
      "description": "EndeavourOS에서 Wine 카카오톡과 호스트 사이 복붙이 끊겼던 사건을 기록하며, 왜 그런지 그리고 어떻게 우회했는지 정리했다.",
      "snippet": "EndeavourOS에서 Wine 카카오톡과 호스트 사이 복붙이 끊겼던 사건을 기록하며, 왜 그런지 그리고 어떻게 우회했는지 정리했다.",
      "date": "2025-10-31",
      "tags": [
        "Wine",
        "Wayland",
        "클립보드",
        "Hyprland",
        "wl-clipboard"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "url": "/blog/2025/wine-clipboard-bridge-journal"
    },
    {
      "path": "/posts/2025/java-concurrency-journal.md",
      "year": "2025",
      "slug": "java-concurrency-journal",
      "title": "스레드 덤프와 데드락 다이어그램, 자바 동시성의 밤을 기록하다",
      "description": "Thread, synchronized, ExecutorService, ForkJoinPool을 오가며 레이스와 데드락을 추적했던 내 1인칭 동시성 일기",
      "snippet": "Thread, synchronized, ExecutorService, ForkJoinPool을 오가며 레이스와 데드락을 추적했던 내 1인칭 동시성 일기",
      "date": "2025-10-27",
      "tags": [
        "Java",
        "Concurrency",
        "Thread",
        "ExecutorService",
        "락"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/fataldeadlock.png",
      "url": "/blog/2025/java-concurrency-journal"
    },
    {
      "path": "/posts/2025/java-memory-model-journal.md",
      "year": "2025",
      "slug": "java-memory-model-journal",
      "title": "Happens-before를 붙잡기까지, 자바 메모리 모델을 해부한 내 여정",
      "description": "JMM 명세와 volatile, synchronized, reorder의 경계를 파헤치며 가시성과 순서를 이해한 개발자의 기록",
      "snippet": "JMM 명세와 volatile, synchronized, reorder의 경계를 파헤치며 가시성과 순서를 이해한 개발자의 기록",
      "date": "2025-10-27",
      "tags": [
        "Java",
        "메모리모델",
        "volatile",
        "HappensBefore",
        "JMM"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/java-memory-model-journal"
    },
    {
      "path": "/posts/2025/java-stream-api-journal.md",
      "year": "2025",
      "slug": "java-stream-api-journal",
      "title": "람다와 파이프라인 사이, 스트림 API에 빠져들던 밤",
      "description": "람다 표현식과 스트림 파이프라인을 처음 만났을 때의 놀람, 컬렉터와 병렬 스트림 튜닝까지 기록한 1인칭 에세이",
      "snippet": "람다 표현식과 스트림 파이프라인을 처음 만났을 때의 놀람, 컬렉터와 병렬 스트림 튜닝까지 기록한 1인칭 에세이",
      "date": "2025-10-27",
      "tags": [
        "Java",
        "StreamAPI",
        "Lambda",
        "FunctionalProgramming",
        "병렬스트림"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/java-stream-api-journal"
    },
    {
      "path": "/posts/2025/shell-powertools-journal.md",
      "year": "2025",
      "slug": "shell-powertools-journal",
      "title": "awk와 sed, 그리고 xargs에 빚진 작은 승리들",
      "description": "파이프라인 하나로 서버를 살린 순간을 떠올리며, 내가 사랑하는 세 가지 쉘 친구들을 일기처럼 적어 봤습니다.",
      "snippet": "파이프라인 하나로 서버를 살린 순간을 떠올리며, 내가 사랑하는 세 가지 쉘 친구들을 일기처럼 적어 봤습니다.",
      "date": "2025-10-27",
      "tags": [
        "awk",
        "sed",
        "xargs",
        "리눅스쉘",
        "자동화"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2025/shell-powertools-journal"
    },
    {
      "path": "/posts/2025/java-gc-journal.md",
      "year": "2025",
      "slug": "java-gc-journal",
      "title": "Stop-the-world의 숨결을 들으며, GC와 화해한 나의 기록",
      "description": "Serial, CMS, G1을 거치며 힙 덤프와 함께 밤을 지새운 개발자가 GC의 진화와 전략을 되돌아본 일기",
      "snippet": "Serial, CMS, G1을 거치며 힙 덤프와 함께 밤을 지새운 개발자가 GC의 진화와 전략을 되돌아본 일기",
      "date": "2025-10-26",
      "tags": [
        "Java",
        "GarbageCollection",
        "JVM",
        "G1",
        "메모리관리"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/java-gc-journal"
    },
    {
      "path": "/posts/2025/grub-kernel-error-journal.md",
      "year": "2025",
      "slug": "grub-kernel-error-journal",
      "title": "'You need to load the kernel first'와 함께한 새벽의 구조 요청",
      "description": "pacman -Syu 한 번 눌렀을 뿐인데 부팅이 멈췄다면? 새벽에 겪은 GRUB 구출기를 일기처럼 정리했습니다.",
      "snippet": "pacman -Syu 한 번 눌렀을 뿐인데 부팅이 멈췄다면? 새벽에 겪은 GRUB 구출기를 일기처럼 정리했습니다.",
      "date": "2025-10-25",
      "tags": [
        "Arch Linux",
        "GRUB",
        "부팅오류",
        "시스템복구",
        "에세이"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/kernelfault.png",
      "url": "/blog/2025/grub-kernel-error-journal"
    },
    {
      "path": "/posts/2025/java-generics-journal.md",
      "year": "2025",
      "slug": "java-generics-journal",
      "title": "타입 변수와 야생의 캐스팅: 제네릭을 길들이던 내 기록",
      "description": "로 타입과 ClassCastException에 질려, 제네릭이 도입되던 현장을 지켜보며 타입 안정성을 붙잡은 개발자 일기",
      "snippet": "로 타입과 ClassCastException에 질려, 제네릭이 도입되던 현장을 지켜보며 타입 안정성을 붙잡은 개발자 일기",
      "date": "2025-10-25",
      "tags": [
        "Java",
        "Generics",
        "타입시스템",
        "Erasure",
        "컬렉션"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/java-generics-journal"
    },
    {
      "path": "/posts/2025/6g-sentient-future-journal.md",
      "year": "2025",
      "slug": "6g-sentient-future-journal",
      "title": "6G 연구소의 밤, 지각 있는 네트워크를 그리는 상상",
      "description": "테라헤르츠 실험과 지능형 표면, AI 네이티브 아키텍처, 통신-감지 통합을 넘나들며 6G의 미래를 환상과 현실 사이에서 탐구한 기록",
      "snippet": "테라헤르츠 실험과 지능형 표면, AI 네이티브 아키텍처, 통신-감지 통합을 넘나들며 6G의 미래를 환상과 현실 사이에서 탐구한 기록",
      "date": "2025-10-24",
      "tags": [
        "6G",
        "테라헤르츠",
        "RIS",
        "AI네이티브",
        "JCS"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/6g-sentient-future-journal"
    },
    {
      "path": "/posts/2025/proxmox-thin-provision.md",
      "year": "2025",
      "slug": "proxmox-thin-provision",
      "title": "ZFS 풀 앞에서 멈춰 선 Proxmox, 그 밤의 기록",
      "description": "1.85TB 디스크를 추가하려다 ZFS가 '공간 없음'을 외친 밤. 스냅샷과 예약 공간 사이에서 배운 얇은 줄타기 경험담",
      "snippet": "1.85TB 디스크를 추가하려다 ZFS가 '공간 없음'을 외친 밤. 스냅샷과 예약 공간 사이에서 배운 얇은 줄타기 경험담",
      "date": "2025-10-24",
      "tags": [
        "Proxmox",
        "ZFS",
        "Thin Provision",
        "가상화",
        "스토리지"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/proxmox-thin-provision"
    },
    {
      "path": "/posts/2025/5g-intelligent-fabric-journal.md",
      "year": "2025",
      "slug": "5g-intelligent-fabric-journal",
      "title": "5G 기지국 그림자에서, 슬라이스와 에지가 만든 새로운 질서",
      "description": "URLLC, 슬라이스, 에지 노드를 직접 구축하며 5G가 사람과 기계를 동시에 품어내는 과정을 기록했다",
      "snippet": "URLLC, 슬라이스, 에지 노드를 직접 구축하며 5G가 사람과 기계를 동시에 품어내는 과정을 기록했다",
      "date": "2025-10-23",
      "tags": [
        "5G",
        "네트워크슬라이싱",
        "에지컴퓨팅",
        "URLLC",
        "제로트러스트"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/5g-intelligent-fabric-journal"
    },
    {
      "path": "/posts/2025/linux-device-mount-journal.md",
      "year": "2025",
      "slug": "linux-device-mount-journal",
      "title": "언마운트 이후에도 /dev/sda1이 남아있는 이유를 이해한 밤",
      "description": "장치 파일과 마운트의 차이를 헤맸던 날, 그리고 USB 허브의 SD 카드를 다시 인식시키기까지의 기록",
      "snippet": "장치 파일과 마운트의 차이를 헤맸던 날, 그리고 USB 허브의 SD 카드를 다시 인식시키기까지의 기록",
      "date": "2025-10-23",
      "tags": [
        "mount",
        "umount",
        "장치파일",
        "USB",
        "네트워킹"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/notunmounted.png",
      "url": "/blog/2025/linux-device-mount-journal"
    },
    {
      "path": "/posts/2025/java-static-polymorphism-masterclass.md",
      "year": "2025",
      "slug": "java-static-polymorphism-masterclass",
      "title": "static 키워드와 다형성으로 밤을 지새운 어느 개발자의 기록",
      "description": "정적 영역과 힙 사이에서 헤매던 날, 다형성의 그림자와 씨름한 새벽, 그리고 equals를 다시 쓰며 깨달은 객체지향의 본질",
      "snippet": "정적 영역과 힙 사이에서 헤매던 날, 다형성의 그림자와 씨름한 새벽, 그리고 equals를 다시 쓰며 깨달은 객체지향의 본질",
      "date": "2025-10-22",
      "tags": [
        "Java",
        "static",
        "Polymorphism",
        "OOP 심화",
        "JVM 메모리"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2025/java-static-polymorphism-masterclass"
    },
    {
      "path": "/posts/2025/lte-cloud-native-journal.md",
      "year": "2025",
      "slug": "lte-cloud-native-journal",
      "title": "4G 신호와 클라우드 콘솔 사이, 앱 경제를 실감한 나의 하루",
      "description": "LTE 필드 테스트와 데이터센터 자동화가 교차하던 2010년대, 앱 경제와 클라우드 네트워크를 동시에 길들인 개발자의 기록",
      "snippet": "LTE 필드 테스트와 데이터센터 자동화가 교차하던 2010년대, 앱 경제와 클라우드 네트워크를 동시에 길들인 개발자의 기록",
      "date": "2025-10-22",
      "tags": [
        "4G",
        "LTE",
        "클라우드컴퓨팅",
        "SDN",
        "NFV",
        "IPv6"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/lte-cloud-native-journal"
    },
    {
      "path": "/posts/2025/broadband-cdn-transition-journal.md",
      "year": "2025",
      "slug": "broadband-cdn-transition-journal",
      "title": "ADSL 불빛과 CDN 랙 사이에서 보낸 2000년대의 밤",
      "description": "DSL 모뎀의 깜박임, 아카마이 캐시의 열기, 3G 기지국의 소음 속에서 상시 접속 시대를 맞이한 나의 기록",
      "snippet": "DSL 모뎀의 깜박임, 아카마이 캐시의 열기, 3G 기지국의 소음 속에서 상시 접속 시대를 맞이한 나의 기록",
      "date": "2025-10-21",
      "tags": [
        "광대역",
        "CDN",
        "3G",
        "NAT",
        "TLS"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/broadband-cdn-transition-journal"
    },
    {
      "path": "/posts/2025/java-oop-superchallenge.md",
      "year": "2025",
      "slug": "java-oop-superchallenge",
      "title": "JVM 메모리 지도 들고 자바 OOP 문제를 풀어본 기록",
      "description": "정적 초기화 블록에서 시작해 super()로 끝나는 여섯 가지  문제들. 그 밤의 디버깅 노트를 그대로 옮겨 붙였습니다.",
      "snippet": "정적 초기화 블록에서 시작해 super()로 끝나는 여섯 가지  문제들. 그 밤의 디버깅 노트를 그대로 옮겨 붙였습니다.",
      "date": "2025-10-21",
      "tags": [
        "Java",
        "JVM 메모리",
        "static",
        "다형성",
        "상속",
        "instanceof"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2025/java-oop-superchallenge"
    },
    {
      "path": "/posts/2025/java-through-my-bytecode-journal.md",
      "year": "2025",
      "slug": "java-through-my-bytecode-journal",
      "title": "바이트코드 기차를 타고 자바 세계를 일주한 날",
      "description": "Write once, run anywhere라는 간판을 붙인 자바의 철도를 따라가며, JDK에서 GC까지 몸소 느꼈던 이야기와 살아 있는 코드 메모",
      "snippet": "Write once, run anywhere라는 간판을 붙인 자바의 철도를 따라가며, JDK에서 GC까지 몸소 느꼈던 이야기와 살아 있는 코드 메모",
      "date": "2025-10-20",
      "tags": [
        "Java",
        "JVM",
        "자료형",
        "연산자",
        "객체지향"
      ],
      "category": "Java",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "coverImage": "/images/2025/javatrain.png",
      "url": "/blog/2025/java-through-my-bytecode-journal"
    },
    {
      "path": "/posts/2025/web-commercialization-journal.md",
      "year": "2025",
      "slug": "web-commercialization-journal",
      "title": "모자이크를 띄운 날, 월드 와이드 웹이 손에 들어왔다",
      "description": "웹 브라우저와 DNS, BGP가 열어젖힌 1990년대 인터넷의 폭발을 현장에서 지켜본 나의 기록",
      "snippet": "웹 브라우저와 DNS, BGP가 열어젖힌 1990년대 인터넷의 폭발을 현장에서 지켜본 나의 기록",
      "date": "2025-10-20",
      "tags": [
        "월드와이드웹",
        "모자이크",
        "NSFNET",
        "BGP",
        "CIDR"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/web-commercialization-journal"
    },
    {
      "path": "/posts/2025/algorithms-through-my-eyes.md",
      "year": "2025",
      "slug": "algorithms-through-my-eyes",
      "title": "알고리즘 수업 노트를 다시 펼쳐 보며",
      "description": "기초 알고리즘 수업 노트를 다시 펼쳐 보며...",
      "snippet": "기초 알고리즘 수업 노트를 다시 펼쳐 보며...",
      "date": "2025-10-19",
      "tags": [
        "알고리즘",
        "복잡도",
        "분할정복",
        "동적계획법",
        "탐욕법"
      ],
      "category": "Computer Science",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "url": "/blog/2025/algorithms-through-my-eyes"
    },
    {
      "path": "/posts/2025/tcpip-revolution-journal.md",
      "year": "2025",
      "slug": "tcpip-revolution-journal",
      "title": "TCP/IP 깃발 아래, 내가 본 인터넷의 탄생",
      "description": "NCP에서 TCP/IP로 전환하던 플래그 데이의 긴장과 감동을 되살린 개발자의 일기",
      "snippet": "NCP에서 TCP/IP로 전환하던 플래그 데이의 긴장과 감동을 되살린 개발자의 일기",
      "date": "2025-10-19",
      "tags": [
        "TCPIP",
        "인터넷역사",
        "플래그데이",
        "프로토콜디자인",
        "인터네트워킹"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "coverImage": "/images/2025/deadlock.png",
      "url": "/blog/2025/tcpip-revolution-journal"
    },
    {
      "path": "/posts/2025/algorithm-mental-simulator.md",
      "year": "2025",
      "slug": "algorithm-mental-simulator",
      "title": "알고리즘을 메모리 영화관에서 돌려보는 밤",
      "description": "Big-O는 교통수단, 병합 정렬은 지도 조각, 해시는 주소 직통. 시뮬레이터형 두뇌로 재생한 알고리즘 18편의 심화 문제와 비유",
      "snippet": "Big-O는 교통수단, 병합 정렬은 지도 조각, 해시는 주소 직통. 시뮬레이터형 두뇌로 재생한 알고리즘 18편의 심화 문제와 비유",
      "date": "2025-10-18",
      "tags": [
        "알고리즘",
        "시간복잡도",
        "정렬",
        "탐색트리",
        "해시",
        "DP",
        "Greedy"
      ],
      "category": "Computer Science",
      "author": "Admin",
      "readingTime": "6 min read",
      "published": true,
      "url": "/blog/2025/algorithm-mental-simulator"
    },
    {
      "path": "/posts/2025/arpanet-resilience-journal.md",
      "year": "2025",
      "slug": "arpanet-resilience-journal",
      "title": "스푸트니크의 그림자 아래, 내가 본 ARPANET의 첫 호흡",
      "description": "냉전의 긴장 속에서 태어난 ARPANET을 따라가며, 패킷 교환과 IMP가 가져온 혁신을 밤새 되짚은 나의 기록",
      "snippet": "냉전의 긴장 속에서 태어난 ARPANET을 따라가며, 패킷 교환과 IMP가 가져온 혁신을 밤새 되짚은 나의 기록",
      "date": "2025-10-18",
      "tags": [
        "ARPANET",
        "패킷교환",
        "인터넷역사",
        "ColdWar",
        "네트워크아키텍처"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "coverImage": "/images/2025/nuclear.png",
      "url": "/blog/2025/arpanet-resilience-journal"
    },
    {
      "path": "/posts/2025/BST-think01.md",
      "year": "2025",
      "slug": "BST-think01",
      "title": "BST TreeInsertion 횟수 구하기 고민한 내용 정리",
      "description": "BST 트리 호출 횟수 구하기를 보다가 떠오른 최적화 방안 생각 정리",
      "snippet": "BST 트리 호출 횟수 구하기를 보다가 떠오른 최적화 방안 생각 정리",
      "date": "2025-10-17",
      "tags": [
        "Machine Learning",
        "BST",
        "최적화",
        "줌인"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/BST-think01"
    },
    {
      "path": "/posts/2025/Limitation-Of-Transformer.md",
      "year": "2025",
      "slug": "Limitation-Of-Transformer",
      "title": "트랜스포머의 한계에 대하여: 바텀업을 넘어 하향식으로",
      "description": "트랜스포머가 왜 강하고 왜 비켜가야 하는지, PIM·RAG·압축·NAS를 오가며 고찰한 기록.",
      "snippet": "트랜스포머가 왜 강하고 왜 비켜가야 하는지, PIM·RAG·압축·NAS를 오가며 고찰한 기록.",
      "date": "2025-10-17",
      "tags": [
        "Transformer",
        "RAG",
        "PIM",
        "Inference",
        "Training",
        "LayerFusion",
        "Quantization",
        "Pruning",
        "Distillation",
        "NAS",
        "TopDown",
        "BottomUp"
      ],
      "category": "AI",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2025/Limitation-Of-Transformer"
    },
    {
      "path": "/posts/2025/QuantumShadow.md",
      "year": "2025",
      "slug": "QuantumShadow",
      "title": "보이지 않는 나는 양자 상태인가?: 물리적 현실과 심리학적 진실의 경계",
      "description": "물리학의 '결어긋남'은 우리 몸의 양자 상태를 부정하지만, '무의식'의 작동 원리를 설명하는 가장 완벽한 비유일지도 모릅니다.",
      "snippet": "물리학의 '결어긋남'은 우리 몸의 양자 상태를 부정하지만, '무의식'의 작동 원리를 설명하는 가장 완벽한 비유일지도 모릅니다.",
      "date": "2025-10-17",
      "tags": [
        "양자역학",
        "칼융",
        "무의식",
        "결어긋남",
        "의식",
        "심리학"
      ],
      "category": "과학 & 철학",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/QuantumShadow"
    },
    {
      "path": "/posts/2025/QuantumSpaceInside.md",
      "year": "2025",
      "slug": "QuantumSpaceInside",
      "title": "나의 고독은 우주의 시작과 맞닿아 있었다",
      "description": "개인의 고독에 대한 내면 탐험이 어떻게 칼 융의 심리학과 양자역학을 거쳐, 결국 우주의 시작과 끝에 대한 거대한 통찰로 이어지는지에 대한 철학적 에세이.",
      "snippet": "개인의 고독에 대한 내면 탐험이 어떻게 칼 융의 심리학과 양자역학을 거쳐, 결국 우주의 시작과 끝에 대한 거대한 통찰로 이어지는지에 대한 철학적 에세이.",
      "date": "2025-10-17",
      "tags": [
        "칼융",
        "양자역학",
        "블랙홀",
        "순환우주론",
        "무의식",
        "철학적사유"
      ],
      "category": "철학 & 사유",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/QuantumSpaceInside"
    },
    {
      "path": "/posts/2025/ci-trigger-test.md",
      "year": "2025",
      "slug": "ci-trigger-test",
      "title": "CI Trigger Test",
      "description": "Non-visible post to exercise CI path filters.",
      "snippet": "Non-visible post to exercise CI path filters.",
      "date": "2025-10-17",
      "tags": [
        "ci",
        "workflow"
      ],
      "category": "Maintenance",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/ci-trigger-test"
    },
    {
      "path": "/posts/2025/network-evolution-intro-journal.md",
      "year": "2025",
      "slug": "network-evolution-intro-journal",
      "title": "네트워크 연표를 다시 걷기 전, 내가 세운 질문들",
      "description": "ARPANET부터 6G까지 다시 추적하기 전에, 지각 있는 연결 구조란 무엇인지 스스로에게 던진 질문을 정리한 나의 서문",
      "snippet": "ARPANET부터 6G까지 다시 추적하기 전에, 지각 있는 연결 구조란 무엇인지 스스로에게 던진 질문을 정리한 나의 서문",
      "date": "2025-10-17",
      "tags": [
        "네트워크역사",
        "인터넷진화",
        "서론",
        "에세이"
      ],
      "category": "Network",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/network-evolution-intro-journal"
    },
    {
      "path": "/posts/2025/spring-boot-realtime-communication.md",
      "year": "2025",
      "slug": "spring-boot-realtime-communication",
      "title": "SSE와 WebSocket 사이에서, 나의 실시간 통신 여정을 적다",
      "description": "JavaScript와 Spring Boot로 SSE와 WebSocket을 번갈아 구현하며 Redis와 Kafka를 저울질한 밤의 기록",
      "snippet": "JavaScript와 Spring Boot로 SSE와 WebSocket을 번갈아 구현하며 Redis와 Kafka를 저울질한 밤의 기록",
      "date": "2025-09-17",
      "tags": [
        "SSE",
        "WebSocket",
        "Redis",
        "Kafka",
        "실시간통신"
      ],
      "category": "Web",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "url": "/blog/2025/spring-boot-realtime-communication"
    },
    {
      "path": "/posts/2025/network-evolution-history.md",
      "year": "2025",
      "slug": "network-evolution-history",
      "title": "네트워크 발전의 역사: ARPANET에서 5G/6G까지",
      "description": "패킷 교환의 탄생부터 인터넷 표준화, 웹의 폭발적 성장, 모바일·클라우드·엣지, 그리고 5G/6G로 이어지는 네트워크 발전사를 핵심 이정표 중심으로 정리합니다.",
      "snippet": "패킷 교환의 탄생부터 인터넷 표준화, 웹의 폭발적 성장, 모바일·클라우드·엣지, 그리고 5G/6G로 이어지는 네트워크 발전사를 핵심 이정표 중심으로 정리합니다.",
      "date": "2025-08-31T00:00:00.000Z",
      "tags": [
        "network",
        "history",
        "internet",
        "5G",
        "6G",
        "protocols",
        "architecture"
      ],
      "category": "CS",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "coverImage": "/images/covers/network-history.jpg",
      "url": "/blog/2025/network-evolution-history"
    },
    {
      "path": "/posts/2025/hooks.md",
      "year": "2025",
      "slug": "hooks",
      "title": "리액트 hooks 훑어보기",
      "description": "# React Hooks 완벽 가이드\n\n## 개요\nReact의 Hooks는 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 기능입니다. React 16.8에서 처음 도입된 이 기능은 클래스형 컴포넌트를 사용하는 대신, 더 간결하고 이해하기 쉬운 코드를 작성할 수 있도록 도와줍니다. 이번 글에서는 React",
      "snippet": "# React Hooks 완벽 가이드\n\n## 개요\nReact의 Hooks는 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 기능입니다. React 16.8에서 처음 도입된 이 기능은 클래스형 컴포넌트를 사용하는 대신, 더 간결하고 이해하기 쉬운 코드를 작성할 수 있도록 도와줍니다. 이번 글에서는 React",
      "date": "2025-08-11",
      "tags": [],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/hooks"
    },
    {
      "path": "/posts/2024/blade-runner-philosophy.md",
      "year": "2024",
      "slug": "blade-runner-philosophy",
      "title": "블레이드 러너(Blade Runner, 1982) - 인간성의 경계를 묻는 철학적 걸작",
      "description": "# 블레이드 러너(Blade Runner, 1982) - 인간성의 경계를 묻는 철학적 걸작\n\n## 영화 개관과 감독의 비전\n\n**블레이드 러너**는 1982년 리들리 스콧 감독이 필립 K. 딕의 소설 『안드로이드는 전기양의 꿈을 꾸는가?』를 각색한 SF 누아르의 금자탑입니다. 개봉 당시 상업적으로는 실패했지만, 시간이 지나면서 **인간 존재의 본질에 대한.",
      "snippet": "# 블레이드 러너(Blade Runner, 1982) - 인간성의 경계를 묻는 철학적 걸작\n\n## 영화 개관과 감독의 비전\n\n**블레이드 러너**는 1982년 리들리 스콧 감독이 필립 K. 딕의 소설 『안드로이드는 전기양의 꿈을 꾸는가?』를 각색한 SF 누아르의 금자탑입니다. 개봉 당시 상업적으로는 실패했지만, 시간이 지나면서 **인간 존재의 본질에 대한.",
      "date": "2025-08-10",
      "tags": [
        "블레이드러너",
        "리들리스콧",
        "필립K딕",
        "레플리칸트",
        "인공지능",
        "데카르트",
        "하이데거",
        "니체",
        "베르그송",
        "레비나스",
        "보드리야르",
        "아도르노",
        "SF누아르",
        "인간성",
        "존재론"
      ],
      "category": "사고와 인식",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "url": "/blog/2024/blade-runner-philosophy"
    },
    {
      "path": "/posts/2024/jung-psychology-cinema.md",
      "year": "2024",
      "slug": "jung-psychology-cinema",
      "title": "칼 융 내면 성찰에 관련된 영화들",
      "description": "칼 융의 분석심리학에서 핵심 개념인 **개성화(Individuation)**는 개인이 그림자를 통합하고 집단무의식에서 진정한 자아를 분리해 온전한 인간이 되는 여정을 가리킵니다. 융이 강조한 **내면의 강인함**은 외부 기준이나 집단 압력에 굴복하지 않고 내면 목소리에 따르는 용기에서 비롯됩니다. 아래 영화들은 이러한 융의 철학을 깊이 있게 반영한 작품들입",
      "snippet": "칼 융의 분석심리학에서 핵심 개념인 **개성화(Individuation)**는 개인이 그림자를 통합하고 집단무의식에서 진정한 자아를 분리해 온전한 인간이 되는 여정을 가리킵니다. 융이 강조한 **내면의 강인함**은 외부 기준이나 집단 압력에 굴복하지 않고 내면 목소리에 따르는 용기에서 비롯됩니다. 아래 영화들은 이러한 융의 철학을 깊이 있게 반영한 작품들입",
      "date": "2025-08-10",
      "tags": [
        "칼융",
        "개성화",
        "분석심리학",
        "집단무의식",
        "그림자",
        "아니마",
        "동시성",
        "내면강인함",
        "자아실현",
        "데인저러스메소드",
        "세렌디피티",
        "매트릭스",
        "작은아씨들",
        "디센트"
      ],
      "category": "사고와 인식",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/jung-psychology-cinema"
    },
    {
      "path": "/posts/2024/proxmox-qdevice-voting-problem-guide.md",
      "year": "2024",
      "slug": "proxmox-qdevice-voting-problem-guide",
      "title": "Proxmox QDevice 투표 문제에 대해서",
      "description": "Proxmox 클러스터에서 QDevice가 투표권을 갖지 못하는 문제 트러블슈팅",
      "snippet": "Proxmox 클러스터에서 QDevice가 투표권을 갖지 못하는 문제 트러블슈팅",
      "date": "2025-08-10",
      "tags": [
        "Proxmox",
        "QDevice",
        "클러스터",
        "쿼럼",
        "Raspberry Pi",
        "고가용성"
      ],
      "category": "Proxmox",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2024/proxmox-qdevice-voting-problem-guide"
    },
    {
      "path": "/posts/2025/mole-observation-diary.md",
      "year": "2025",
      "slug": "mole-observation-diary",
      "title": "두더지에 대해서..",
      "description": "# 두더지 관찰 일기\n\n## 개요\n이번 일기는 내가 두더지를 관찰한 경험을 기록한 것입니다. 두더지는 생태계에서 중요한 역할을 하는 포유류로, 그들의 행동과 생태적 의미를 이해하는 것은 매우 흥미로운 일이었습니다. 이 일기에서는 두더지의 서식지, 행동, 그리고 관찰한 내용을 중심으로 작성하겠습니다.\n\n## 1일차: 준비 과정\n오늘은 두더지를 관찰하기 위해",
      "snippet": "# 두더지 관찰 일기\n\n## 개요\n이번 일기는 내가 두더지를 관찰한 경험을 기록한 것입니다. 두더지는 생태계에서 중요한 역할을 하는 포유류로, 그들의 행동과 생태적 의미를 이해하는 것은 매우 흥미로운 일이었습니다. 이 일기에서는 두더지의 서식지, 행동, 그리고 관찰한 내용을 중심으로 작성하겠습니다.\n\n## 1일차: 준비 과정\n오늘은 두더지를 관찰하기 위해",
      "date": "2025-08-10",
      "tags": [
        "두더지",
        "dothechi"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/mole-observation-diary"
    },
    {
      "path": "/posts/2025/integration-04-microservices-deployment.md",
      "year": "2025",
      "slug": "integration-04-microservices-deployment",
      "title": "마이크로서비스 배포 전략 (이벤트 기반)",
      "description": "준비 중: 이벤트 기반 MSA, 버전 전략, Observability, Rollout 패턴.",
      "snippet": "준비 중: 이벤트 기반 MSA, 버전 전략, Observability, Rollout 패턴.",
      "date": "2025-03-05",
      "tags": [
        "DevOps",
        "Microservices",
        "Deployment",
        "Kafka",
        "Kubernetes"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/integration-04-microservices-deployment"
    },
    {
      "path": "/posts/2025/integration-03-k8s-kafka.md",
      "year": "2025",
      "slug": "integration-03-k8s-kafka",
      "title": "Kubernetes에서 Kafka 운영 전략",
      "description": "준비 중: Strimzi/옵저버빌리티/스토리지/토픽 운영.",
      "snippet": "준비 중: Strimzi/옵저버빌리티/스토리지/토픽 운영.",
      "date": "2025-03-04",
      "tags": [
        "DevOps",
        "Kubernetes",
        "Kafka",
        "운영"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/integration-03-k8s-kafka"
    },
    {
      "path": "/posts/2025/integration-02-terraform-k8s.md",
      "year": "2025",
      "slug": "integration-02-terraform-k8s",
      "title": "Terraform으로 Kubernetes 클러스터 프로비저닝",
      "description": "준비 중: Terraform + K8s 클러스터 EKS/모듈 설계 패턴.",
      "snippet": "준비 중: Terraform + K8s 클러스터 EKS/모듈 설계 패턴.",
      "date": "2025-03-03",
      "tags": [
        "DevOps",
        "Terraform",
        "Kubernetes",
        "Integration"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/integration-02-terraform-k8s"
    },
    {
      "path": "/posts/2025/kubernetes-05-statefulset-storage.md",
      "year": "2025",
      "slug": "kubernetes-05-statefulset-storage",
      "title": "Kubernetes StatefulSet과 스토리지",
      "description": "준비 중: 상태 저장 워크로드, PV/PVC, Headless Service, 스토리지 클래스.",
      "snippet": "준비 중: 상태 저장 워크로드, PV/PVC, Headless Service, 스토리지 클래스.",
      "date": "2025-02-26",
      "tags": [
        "DevOps",
        "Kubernetes",
        "StatefulSet",
        "Storage"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/kubernetes-05-statefulset-storage"
    },
    {
      "path": "/posts/2025/kubernetes-04-configmap-secret.md",
      "year": "2025",
      "slug": "kubernetes-04-configmap-secret",
      "title": "Kubernetes ConfigMap & Secret 활용",
      "description": "준비 중: 환경 구성/민감정보 주입, 볼륨 마운트와 보안 고려.",
      "snippet": "준비 중: 환경 구성/민감정보 주입, 볼륨 마운트와 보안 고려.",
      "date": "2025-02-25",
      "tags": [
        "DevOps",
        "Kubernetes",
        "ConfigMap",
        "Secret"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/kubernetes-04-configmap-secret"
    },
    {
      "path": "/posts/2025/kubernetes-03-services-networking.md",
      "year": "2025",
      "slug": "kubernetes-03-services-networking",
      "title": "Kubernetes Service와 네트워킹",
      "description": "준비 중: ClusterIP, NodePort, LoadBalancer, Ingress, DNS 내부 구조.",
      "snippet": "준비 중: ClusterIP, NodePort, LoadBalancer, Ingress, DNS 내부 구조.",
      "date": "2025-02-24",
      "tags": [
        "DevOps",
        "Kubernetes",
        "Service",
        "Networking"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/kubernetes-03-services-networking"
    },
    {
      "path": "/posts/2025/FutureClouding.md",
      "year": "2025",
      "slug": "FutureClouding",
      "title": "격자를 부수다: 폰 노이만 아키텍처의 종말과 그리드 시스템의 한계",
      "description": "우리가 당연하게 여겼던 중앙화된 '그리드' 시스템의 환상을 깨고, 폰 노이만 아키텍처의 근본적 한계를 넘어 분산형 미래로 나아가는 길을 제시합니다.",
      "snippet": "우리가 당연하게 여겼던 중앙화된 '그리드' 시스템의 환상을 깨고, 폰 노이만 아키텍처의 근본적 한계를 넘어 분산형 미래로 나아가는 길을 제시합니다.",
      "date": "2025-02-21",
      "tags": [
        "폰노이만아키텍처",
        "그리드시스템",
        "분산컴퓨팅",
        "엣지컴퓨팅",
        "블록체인"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/FutureClouding"
    },
    {
      "path": "/posts/2025/kafka-04-topics-partitions.md",
      "year": "2025",
      "slug": "kafka-04-topics-partitions",
      "title": "Kafka 토픽·파티션·스토리지 관리",
      "description": "준비 중: 파티션 설계, 리밸런싱, retention/compaction 전략.",
      "snippet": "준비 중: 파티션 설계, 리밸런싱, retention/compaction 전략.",
      "date": "2025-02-18",
      "tags": [
        "DevOps",
        "Kafka",
        "Topic",
        "Partition"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/kafka-04-topics-partitions"
    },
    {
      "path": "/posts/2025/kafka-03-producer-consumer.md",
      "year": "2025",
      "slug": "kafka-03-producer-consumer",
      "title": "Kafka Producer/Consumer 실습과 신뢰성 패턴",
      "description": "준비 중: acks, retries, idempotent producer, consumer offset 전략.",
      "snippet": "준비 중: acks, retries, idempotent producer, consumer offset 전략.",
      "date": "2025-02-17",
      "tags": [
        "DevOps",
        "Kafka",
        "Producer",
        "Consumer"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": false,
      "url": "/blog/2025/kafka-03-producer-consumer"
    },
    {
      "path": "/posts/2025/ansible-04-roles.md",
      "year": "2025",
      "slug": "ansible-04-roles",
      "title": "Ansible Role 설계와 재사용성",
      "description": "Role 디렉터리를 생활 속 사례로 풀어내며 재사용성과 협업 패턴을 정리한 실습 에세이.",
      "snippet": "Role 디렉터리를 생활 속 사례로 풀어내며 재사용성과 협업 패턴을 정리한 실습 에세이.",
      "date": "2025-02-12",
      "tags": [
        "DevOps",
        "Ansible",
        "Role",
        "구조"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/ansible-04-roles"
    },
    {
      "path": "/posts/2025/ansible-03-playbook-examples.md",
      "year": "2025",
      "slug": "ansible-03-playbook-examples",
      "title": "Ansible Playbook 작성 실습 모음",
      "description": "첫 Playbook을 써 내려가며 겪은 시행착오와 재사용 패턴을 에세이처럼 풀어낸 실습 노트.",
      "snippet": "첫 Playbook을 써 내려가며 겪은 시행착오와 재사용 패턴을 에세이처럼 풀어낸 실습 노트.",
      "date": "2025-02-11",
      "tags": [
        "DevOps",
        "Ansible",
        "Playbook",
        "실습"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/ansible-03-playbook-examples"
    },
    {
      "path": "/posts/2025/ansible-02-inventory-basics.md",
      "year": "2025",
      "slug": "ansible-02-inventory-basics",
      "title": "Ansible Inventory 심화: 그룹/변수/패턴",
      "description": "Static/동적 인벤토리, 그룹 중첩, 변수 계층, 패턴 매칭, 환경 분리 전략까지 실전 정리",
      "snippet": "Static/동적 인벤토리, 그룹 중첩, 변수 계층, 패턴 매칭, 환경 분리 전략까지 실전 정리",
      "date": "2025-02-10",
      "tags": [
        "DevOps",
        "Ansible",
        "Inventory",
        "Pattern"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2025/ansible-02-inventory-basics"
    },
    {
      "path": "/posts/2025/terraform-04-variables-outputs.md",
      "year": "2025",
      "slug": "terraform-04-variables-outputs",
      "title": "Terraform 변수와 출력 고급 패턴",
      "description": "변수 타입/검증, locals, dynamic/for_each, map/object, 민감정보, 출력 패턴까지 실무형 레시피로 정리합니다.",
      "snippet": "변수 타입/검증, locals, dynamic/for_each, map/object, 민감정보, 출력 패턴까지 실무형 레시피로 정리합니다.",
      "date": "2025-02-04",
      "tags": [
        "DevOps",
        "Terraform",
        "Variables",
        "Outputs"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/terraform-04-variables-outputs"
    },
    {
      "path": "/posts/2025/terraform-03-state-management.md",
      "year": "2025",
      "slug": "terraform-03-state-management",
      "title": "Terraform 상태 관리와 모듈화",
      "description": "Terraform state 원격 백엔드, 잠금(lock), drift 감지, 워크스페이스 전략과 모듈화 베스트 프랙티스를 손에 잡히게 정리합니다.",
      "snippet": "Terraform state 원격 백엔드, 잠금(lock), drift 감지, 워크스페이스 전략과 모듈화 베스트 프랙티스를 손에 잡히게 정리합니다.",
      "date": "2025-02-03",
      "tags": [
        "DevOps",
        "Terraform",
        "State",
        "Module"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/terraform-03-state-management"
    },
    {
      "path": "/posts/2024/dark-city-existentialism.md",
      "year": "2024",
      "slug": "dark-city-existentialism",
      "title": "다크시티(Dark City, 1998) - 실존주의 철학으로 읽는 SF 걸작",
      "description": "# 다크시티(Dark City, 1998) - 실존주의 철학으로 읽는 SF 걸작\n\n## 영화 개관\n\n**다크시티**는 1998년 알렉스 프로야스 감독이 선보인 SF 누아르 영화로, 매트릭스보다 1년 앞서 시뮬레이션 현실이라는 혁신적 개념을 다룬 숨겨진 걸작입니다. 하지만 이 영화의 진정한 가치는 단순한 SF적 상상력을 넘어, **실존주의 철학의 핵심 명제들",
      "snippet": "# 다크시티(Dark City, 1998) - 실존주의 철학으로 읽는 SF 걸작\n\n## 영화 개관\n\n**다크시티**는 1998년 알렉스 프로야스 감독이 선보인 SF 누아르 영화로, 매트릭스보다 1년 앞서 시뮬레이션 현실이라는 혁신적 개념을 다룬 숨겨진 걸작입니다. 하지만 이 영화의 진정한 가치는 단순한 SF적 상상력을 넘어, **실존주의 철학의 핵심 명제들",
      "date": "2025-01-24T07:30:00.000Z",
      "tags": [
        "다크시티",
        "실존주의",
        "사르트르",
        "키에르케고르",
        "카뮈",
        "하이데거",
        "니체",
        "SF누아르",
        "알렉스프로야스",
        "시뮬레이션현실",
        "자유의지",
        "정체성"
      ],
      "category": "General",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/dark-city-existentialism"
    },
    {
      "path": "/posts/2024/brazil-1985-review.md",
      "year": "2024",
      "slug": "brazil-1985-review",
      "title": "브라질(Brazil, 1985) - 현대 문명에 대한 철학적 절망과 저항의 서사",
      "description": "# 브라질(Brazil, 1985) - 현대 문명에 대한 철학적 절망과 저항의 서사\n\n## 영화 개관과 감독의 비전\n\n**브라질**은 1985년 테리 길리엄 감독이 선보인 디스토피아 SF 블랙 코미디로, 조지 오웰의 『1984』를 넘어서는 현대 문명 비판의 걸작입니다[1]. 길리엄은 이 작품을 통해 **관료제가 미쳐버린 산업 세계에 대한 평생의 분노**를",
      "snippet": "# 브라질(Brazil, 1985) - 현대 문명에 대한 철학적 절망과 저항의 서사\n\n## 영화 개관과 감독의 비전\n\n**브라질**은 1985년 테리 길리엄 감독이 선보인 디스토피아 SF 블랙 코미디로, 조지 오웰의 『1984』를 넘어서는 현대 문명 비판의 걸작입니다[1]. 길리엄은 이 작품을 통해 **관료제가 미쳐버린 산업 세계에 대한 평생의 분노**를",
      "date": "2025-01-24T06:30:00.000Z",
      "tags": [
        "테리 길리엄",
        "브라질",
        "디스토피아",
        "블랙코미디",
        "SF영화",
        "관료제",
        "카프카",
        "철학적영화",
        "1985년",
        "프랑크푸르트학파",
        "감시사회",
        "현대문명비판"
      ],
      "category": "General",
      "author": "Admin",
      "readingTime": "5 min read",
      "published": true,
      "url": "/blog/2024/brazil-1985-review"
    },
    {
      "path": "/posts/2025/BankRuptIn1929.md",
      "year": "2025",
      "slug": "BankRuptIn1929",
      "title": "왜 Bank of America는 있는데, Bank of United States는 없을까?",
      "description": "1929년 뉴욕 퀸즈에서 한 은행 앞에 몰린 예금자 행렬은 미국 금융사의 결정적 장면으로 남았다. 이름만 보면 국립은행처럼 신뢰를 줬던 Bank of United States는 단 며칠 사이에 무너졌고, 그 여파는 대공황을 더욱 깊게 만들었다. 이 글은 1929년 정점에서 1933년 바닥까지, 기업의 재무 데이터를 따라가며 생존과 몰락의 서사를 재구성한다.",
      "snippet": "1929년 뉴욕 퀸즈에서 한 은행 앞에 몰린 예금자 행렬은 미국 금융사의 결정적 장면으로 남았다. 이름만 보면 국립은행처럼 신뢰를 줬던 Bank of United States는 단 며칠 사이에 무너졌고, 그 여파는 대공황을 더욱 깊게 만들었다. 이 글은 1929년 정점에서 1933년 바닥까지, 기업의 재무 데이터를 따라가며 생존과 몰락의 서사를 재구성한다.",
      "date": "2025-01-20",
      "tags": [
        "대공황",
        "기업사",
        "재무데이터",
        "은행위기",
        "생존전략"
      ],
      "category": "History",
      "author": "Admin",
      "readingTime": "9 min read",
      "published": true,
      "url": "/blog/2025/BankRuptIn1929"
    },
    {
      "path": "/posts/2025/integration-01-devops-pipeline.md",
      "year": "2025",
      "slug": "integration-01-devops-pipeline",
      "title": "DevOps 통합 실습: Terraform · Ansible · Kubernetes · Kafka",
      "description": "네 가지 도구를 연결해 인프라 프로비저닝→설정 자동화→클러스터 구성→Kafka+마이크로서비스 배포까지 단일 파이프라인 시나리오.",
      "snippet": "네 가지 도구를 연결해 인프라 프로비저닝→설정 자동화→클러스터 구성→Kafka+마이크로서비스 배포까지 단일 파이프라인 시나리오.",
      "date": "2025-01-20",
      "tags": [
        "DevOps",
        "Terraform",
        "Ansible",
        "Kubernetes",
        "Kafka",
        "Pipeline"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/integration-01-devops-pipeline"
    },
    {
      "path": "/posts/2025/kubernetes-02-pods-deployments.md",
      "year": "2025",
      "slug": "kubernetes-02-pods-deployments",
      "title": "Kubernetes Pod와 Deployment 핵심 실습",
      "description": "단일/멀티 컨테이너 Pod, Deployment 생성·스케일·롤링 업데이트·롤백·레이블·셀렉터·Probe까지 실무 핵심 정리.",
      "snippet": "단일/멀티 컨테이너 Pod, Deployment 생성·스케일·롤링 업데이트·롤백·레이블·셀렉터·Probe까지 실무 핵심 정리.",
      "date": "2025-01-17",
      "tags": [
        "DevOps",
        "Kubernetes",
        "Pod",
        "Deployment",
        "실습"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/kubernetes-02-pods-deployments"
    },
    {
      "path": "/posts/2025/QuantumLayerLLM.md",
      "year": "2025",
      "slug": "QuantumLayerLLM",
      "title": "양자 얽힘으로 AI의 애매모호함 해결하기: 양자 기계 학습의 미래",
      "description": "양자역학의 얽힘 원리를 활용해 딥러닝 레이어 간 애매모호함을 해결하는 혁명적 접근법",
      "snippet": "양자역학의 얽힘 원리를 활용해 딥러닝 레이어 간 애매모호함을 해결하는 혁명적 접근법",
      "date": "2025-01-16",
      "tags": [
        "양자컴퓨팅",
        "AI",
        "양자기계학습",
        "QML",
        "양자얽힘"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/QuantumLayerLLM"
    },
    {
      "path": "/posts/2025/kubernetes-01-cluster-setup.md",
      "year": "2025",
      "slug": "kubernetes-01-cluster-setup",
      "title": "Kubernetes 로컬 클러스터 설치 (minikube·kind·Docker Desktop)",
      "description": "minikube, kind, Docker Desktop 세 가지 방법으로 로컬 K8s 클러스터 구성하고 kubectl 기본 명령을 익힌다.",
      "snippet": "minikube, kind, Docker Desktop 세 가지 방법으로 로컬 K8s 클러스터 구성하고 kubectl 기본 명령을 익힌다.",
      "date": "2025-01-16",
      "tags": [
        "DevOps",
        "Kubernetes",
        "Cluster",
        "minikube",
        "kind"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/kubernetes-01-cluster-setup"
    },
    {
      "path": "/posts/2025/kafka-02-installation-setup.md",
      "year": "2025",
      "slug": "kafka-02-installation-setup",
      "title": "Kafka 로컬 설치: Docker & 네이티브",
      "description": "Docker Compose로 3 Broker 클러스터 구성과 네이티브 설치 두 가지 방식 비교, 기본 명령어/Topic/Consumer Group 실습.",
      "snippet": "Docker Compose로 3 Broker 클러스터 구성과 네이티브 설치 두 가지 방식 비교, 기본 명령어/Topic/Consumer Group 실습.",
      "date": "2025-01-15",
      "tags": [
        "DevOps",
        "Kafka",
        "설치",
        "Docker",
        "실습"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2025/kafka-02-installation-setup"
    },
    {
      "path": "/posts/2025/kafka-01-concepts-architecture.md",
      "year": "2025",
      "slug": "kafka-01-concepts-architecture",
      "title": "Kafka 핵심 개념과 아키텍처",
      "description": "Topic, Partition, Broker, Replication, Producer/Consumer와 Consumer Group까지 Kafka 구조를 시각적으로 이해.",
      "snippet": "Topic, Partition, Broker, Replication, Producer/Consumer와 Consumer Group까지 Kafka 구조를 시각적으로 이해.",
      "date": "2025-01-14",
      "tags": [
        "DevOps",
        "Kafka",
        "Streaming",
        "아키텍처",
        "초급"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/kafka-01-concepts-architecture"
    },
    {
      "path": "/posts/2025/ansible-01-installation-setup.md",
      "year": "2025",
      "slug": "ansible-01-installation-setup",
      "title": "Ansible 설치와 첫 Inventory 구성",
      "description": "패키지 설치부터 SSH 키, Inventory 작성, Ad-hoc 명령(ping, shell) 실행까지 Ansible 입문 필수 흐름.",
      "snippet": "패키지 설치부터 SSH 키, Inventory 작성, Ad-hoc 명령(ping, shell) 실행까지 Ansible 입문 필수 흐름.",
      "date": "2025-01-13",
      "tags": [
        "DevOps",
        "Ansible",
        "자동화",
        "Inventory",
        "초급"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/ansible-01-installation-setup"
    },
    {
      "path": "/posts/2025/terraform-02-aws-ec2-example.md",
      "year": "2025",
      "slug": "terraform-02-aws-ec2-example",
      "title": "Terraform로 AWS EC2 배포 실습",
      "description": "VPC, Subnet, Security Group, EC2, User Data까지 포함한 AWS 웹 서버 인프라를 Terraform으로 단계별 구성.",
      "snippet": "VPC, Subnet, Security Group, EC2, User Data까지 포함한 AWS 웹 서버 인프라를 Terraform으로 단계별 구성.",
      "date": "2025-01-10",
      "tags": [
        "DevOps",
        "Terraform",
        "AWS",
        "EC2",
        "실습"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/terraform-02-aws-ec2-example"
    },
    {
      "path": "/posts/2025/terraform-01-basic-setup.md",
      "year": "2025",
      "slug": "terraform-01-basic-setup",
      "title": "Terraform 기본 설정과 첫 리소스",
      "description": "Terraform 설치부터 첫 local_file 리소스 생성까지 필수 워크플로우(init, plan, apply, destroy)를 단계별로 정리.",
      "snippet": "Terraform 설치부터 첫 local_file 리소스 생성까지 필수 워크플로우(init, plan, apply, destroy)를 단계별로 정리.",
      "date": "2025-01-09",
      "tags": [
        "DevOps",
        "Terraform",
        "IaC",
        "초급",
        "실습"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/terraform-01-basic-setup"
    },
    {
      "path": "/posts/2025/devops-toolchain-overview.md",
      "year": "2025",
      "slug": "devops-toolchain-overview",
      "title": "DevOps 시리즈 개요: Terraform · Ansible · Kafka · Kubernetes",
      "description": "DevOps 시리즈 전체 구조와 학습 로드맵을 한눈에 정리한 개요 글.",
      "snippet": "DevOps 시리즈 전체 구조와 학습 로드맵을 한눈에 정리한 개요 글.",
      "date": "2025-01-08",
      "tags": [
        "DevOps",
        "Terraform",
        "Ansible",
        "Kafka",
        "Kubernetes",
        "Series"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/devops-toolchain-overview"
    },
    {
      "path": "/posts/2025/latest.md",
      "year": "2025",
      "slug": "latest",
      "title": "최신 게시글",
      "description": "",
      "snippet": "",
      "date": "2025-01-07",
      "tags": [],
      "category": "기술",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2025/latest"
    },
    {
      "path": "/posts/2025/middle-east-ai-conflicts.md",
      "year": "2025",
      "slug": "middle-east-ai-conflicts",
      "title": "중동 지역 AI 도입으로 생긴 새로운 갈등들을 보면서 드는 생각",
      "description": "중동 지역의 AI 기술 도입이 어떤 새로운 갈등 구조를 만들어내고 있는지 분석해본 내용",
      "snippet": "중동 지역의 AI 기술 도입이 어떤 새로운 갈등 구조를 만들어내고 있는지 분석해본 내용",
      "date": "2025-01-04",
      "tags": [
        "중동",
        "AI",
        "지정학",
        "기술패권",
        "디지털권위주의",
        "사이버보안"
      ],
      "category": "Technology",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/middle-east-ai-conflicts"
    },
    {
      "path": "/posts/2025/AdversialNeuron.md",
      "year": "2025",
      "slug": "AdversialNeuron",
      "title": "AdversialNeuron",
      "description": "# Adversarial Neuron Ablation for Variant-Sensitive Genomic Embeddings\n\n**nodove**\n\n---\n\n## Abstract\n\nGenomic language models (gLMs) have shown remarkable capability in learning compressed representat",
      "snippet": "# Adversarial Neuron Ablation for Variant-Sensitive Genomic Embeddings\n\n**nodove**\n\n---\n\n## Abstract\n\nGenomic language models (gLMs) have shown remarkable capability in learning compressed representat",
      "date": "2025-01-01",
      "tags": [],
      "category": "General",
      "author": "Admin",
      "readingTime": "11 min read",
      "published": true,
      "url": "/blog/2025/AdversialNeuron"
    },
    {
      "path": "/posts/2025/memory-management-study.md",
      "year": "2025",
      "slug": "memory-management-study",
      "title": "메모리 관리 공부하다가 깨달은 페이징 시스템의 진짜 장점",
      "description": "운영체제 메모리 관리를 공부하면서 페이징과 스와핑이 왜 필요했는지 이해한 과정",
      "snippet": "운영체제 메모리 관리를 공부하면서 페이징과 스와핑이 왜 필요했는지 이해한 과정",
      "date": "2025-01-01",
      "tags": [
        "메모리관리",
        "페이징",
        "MMU",
        "스와핑",
        "운영체제"
      ],
      "category": "Computer Science",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/memory-management-study"
    },
    {
      "path": "/posts/2024/react-native-springboot-mongodb-diary-app.md",
      "year": "2024",
      "slug": "react-native-springboot-mongodb-diary-app",
      "title": "React Native + Spring Boot + MongoDB로 일기 앱 만들기",
      "description": "React Native 클라이언트와 Spring Boot 백엔드, Python AI 서버를 연동해서 일기 앱을 만든 경험",
      "snippet": "React Native 클라이언트와 Spring Boot 백엔드, Python AI 서버를 연동해서 일기 앱을 만든 경험",
      "date": "2024-12-28",
      "tags": [
        "React Native",
        "Spring Boot",
        "MongoDB",
        "Python",
        "AI",
        "일기앱"
      ],
      "category": "개발",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/react-native-springboot-mongodb-diary-app"
    },
    {
      "path": "/posts/2025/git-submodule-guide.md",
      "year": "2025",
      "slug": "git-submodule-guide",
      "title": "Git 서브모듈, 진짜 쓸 만한 걸까?",
      "description": "Git 서브모듈을 실제 프로젝트에서 써본 후기와 실용적인 사용법 정리",
      "snippet": "Git 서브모듈을 실제 프로젝트에서 써본 후기와 실용적인 사용법 정리",
      "date": "2024-12-25",
      "tags": [
        "Git",
        "서브모듈",
        "버전관리",
        "개발도구",
        "프로젝트관리"
      ],
      "category": "개발",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/git-submodule-guide"
    },
    {
      "path": "/posts/2024/knapsack.md",
      "year": "2024",
      "slug": "knapsack",
      "title": "배낭 문제 (Knapsack Problem)",
      "description": "0-1 배낭 문제와 무한 배낭 문제를 동적 계획법으로 해결하는 다양한 방법을 학습합니다.",
      "snippet": "0-1 배낭 문제와 무한 배낭 문제를 동적 계획법으로 해결하는 다양한 방법을 학습합니다.",
      "date": "2024-12-21",
      "tags": [
        "Knapsack",
        "배낭문제",
        "동적계획법",
        "최적화"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/knapsack"
    },
    {
      "path": "/posts/2024/prime-numbers.md",
      "year": "2024",
      "slug": "prime-numbers",
      "title": "소수 판별과 소인수분해 알고리즘",
      "description": "효율적인 소수 판별과 소인수분해를 위한 다양한 수학 알고리즘들을 학습합니다.",
      "snippet": "효율적인 소수 판별과 소인수분해를 위한 다양한 수학 알고리즘들을 학습합니다.",
      "date": "2024-12-17",
      "tags": [
        "소수",
        "에라토스테네스의체",
        "소인수분해",
        "밀러라빈"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/prime-numbers"
    },
    {
      "path": "/posts/2024/firebase-hosting-guide.md",
      "year": "2024",
      "slug": "firebase-hosting-guide",
      "title": "Flutter 웹앱을 Firebase에 무료로 배포하기",
      "description": "Flutter 웹앱을 Firebase Hosting에 배포하는 방법을 실제 경험을 바탕으로 단계별 설명",
      "snippet": "Flutter 웹앱을 Firebase Hosting에 배포하는 방법을 실제 경험을 바탕으로 단계별 설명",
      "date": "2024-12-14",
      "tags": [
        "Flutter",
        "Firebase",
        "Hosting",
        "웹배포",
        "개발"
      ],
      "category": "개발",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/firebase-hosting-guide"
    },
    {
      "path": "/posts/2024/dfs.md",
      "year": "2024",
      "slug": "dfs",
      "title": "깊이 우선 탐색 (DFS, Depth-First Search)",
      "description": "깊이 우선 탐색(DFS) 알고리즘의 원리와 구현, 다양한 응용 문제 해결법을 학습합니다.",
      "snippet": "깊이 우선 탐색(DFS) 알고리즘의 원리와 구현, 다양한 응용 문제 해결법을 학습합니다.",
      "date": "2024-12-11",
      "tags": [
        "DFS",
        "그래프",
        "탐색",
        "재귀",
        "스택"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/dfs"
    },
    {
      "path": "/posts/2024/lis.md",
      "year": "2024",
      "slug": "lis",
      "title": "최장 증가 부분 수열 (LIS, Longest Increasing Subsequence)",
      "description": "최장 증가 부분 수열(LIS) 문제를 동적 계획법과 이분 탐색으로 효율적으로 해결하는 방법을 학습합니다.",
      "snippet": "최장 증가 부분 수열(LIS) 문제를 동적 계획법과 이분 탐색으로 효율적으로 해결하는 방법을 학습합니다.",
      "date": "2024-12-08",
      "tags": [
        "LIS",
        "동적계획법",
        "이분탐색",
        "부분수열"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/lis"
    },
    {
      "path": "/posts/2024/binary-search.md",
      "year": "2024",
      "slug": "binary-search",
      "title": "이진 탐색(Binary Search) 완전 정복",
      "description": "정렬된 배열에서 O(log n) 시간에 원소를 찾는 이진 탐색의 모든 것",
      "snippet": "정렬된 배열에서 O(log n) 시간에 원소를 찾는 이진 탐색의 모든 것",
      "date": "2024-12-05",
      "tags": [
        "이진탐색",
        "탐색",
        "분할정복",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/binary-search"
    },
    {
      "path": "/posts/2024/os-study-notes.md",
      "year": "2024",
      "slug": "os-study-notes",
      "title": "운영체제 공부하면서 헷갈렸던 핵심 개념들 정리",
      "description": "운영체제 공부하면서 반복해서 헷갈렸던 개념들을 정리해본 개인 노트",
      "snippet": "운영체제 공부하면서 반복해서 헷갈렸던 개념들을 정리해본 개인 노트",
      "date": "2024-12-01",
      "tags": [
        "OS",
        "CPU 스케줄링",
        "메모리 관리",
        "교착상태",
        "공부 노트"
      ],
      "category": "Computer Science",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/os-study-notes"
    },
    {
      "path": "/posts/2025/QueryDSL.md",
      "year": "2025",
      "slug": "QueryDSL",
      "title": "SpringBoot 3.x.x + QueryDSL 6.x.x 사용기",
      "description": "스프링부트 3.x.x 버전에 QueryDSL 6.x.x 최신 버전 사용 방법",
      "snippet": "스프링부트 3.x.x 버전에 QueryDSL 6.x.x 최신 버전 사용 방법",
      "date": "2024-11-27",
      "tags": [
        "QueryDSL",
        "스프링부트",
        "springboot+queryDSL",
        "쿼리DSL",
        "openfeign.querydsl",
        "querydsl fork",
        "queryDSL openfeign"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2025/QueryDSL"
    },
    {
      "path": "/posts/2025/ai-models-for-coding.md",
      "year": "2025",
      "slug": "ai-models-for-coding",
      "title": "코딩용 AI 모델, 어떤 걸 써야 할까?",
      "description": "개발자 입장에서 GPT, Claude, Gemini 등 주요 AI 모델들을 실제로 써보고 비교해본 후기",
      "snippet": "개발자 입장에서 GPT, Claude, Gemini 등 주요 AI 모델들을 실제로 써보고 비교해본 후기",
      "date": "2024-11-23",
      "tags": [
        "AI",
        "개발",
        "GPT",
        "Claude",
        "Gemini",
        "코딩"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/ai-models-for-coding"
    },
    {
      "path": "/posts/2024/gemini-gui-dev-tool-idea.md",
      "year": "2024",
      "slug": "gemini-gui-dev-tool-idea",
      "title": "Gemini-CLI를 GUI로? 비개발자도 쓸 수 있는 AI 개발도구 아이디어",
      "description": "Gemini-CLI를 Flutter로 감싸서 비개발자도 쉽게 앱을 만들 수 있는 도구를 만들면 어떨까?",
      "snippet": "Gemini-CLI를 Flutter로 감싸서 비개발자도 쉽게 앱을 만들 수 있는 도구를 만들면 어떨까?",
      "date": "2024-11-19",
      "tags": [
        "Gemini-CLI",
        "Flutter",
        "GUI",
        "AI개발도구",
        "앱개발",
        "아이디어"
      ],
      "category": "Development",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/gemini-gui-dev-tool-idea"
    },
    {
      "path": "/posts/2024/algorithm-atelier-binary-search.md",
      "year": "2024",
      "slug": "algorithm-atelier-binary-search",
      "title": "알고리즘 아틀리에: 이분 탐색 — 5단계 직관 학습",
      "description": "단조성 위에 세운 불변식과 범위 수축 — 답을 직접 찾지 말고 조건을 이분합니다.",
      "snippet": "단조성 위에 세운 불변식과 범위 수축 — 답을 직접 찾지 말고 조건을 이분합니다.",
      "date": "2024-11-18",
      "tags": [
        "이분탐색",
        "Binary Search",
        "단조성",
        "파라메트릭 서치",
        "알고리즘 아틀리에"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/algorithm-atelier-binary-search"
    },
    {
      "path": "/posts/2024/algorithm-atelier-dp.md",
      "year": "2024",
      "slug": "algorithm-atelier-dp",
      "title": "알고리즘 아틀리에: 동적 계획법(DP) — 5단계 직관 학습",
      "description": "반복되는 하위 문제와 최적 부분 구조를 비유로 깨닫고, 점화식→테이블→코드로 잇습니다.",
      "snippet": "반복되는 하위 문제와 최적 부분 구조를 비유로 깨닫고, 점화식→테이블→코드로 잇습니다.",
      "date": "2024-11-17",
      "tags": [
        "DP",
        "동적계획법",
        "메모이제이션",
        "점화식",
        "알고리즘 아틀리에"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/algorithm-atelier-dp"
    },
    {
      "path": "/posts/2024/algorithm-atelier-bfs.md",
      "year": "2024",
      "slug": "algorithm-atelier-bfs",
      "title": "알고리즘 아틀리에: BFS — 5단계 직관 학습",
      "description": "물결 비유로 시작해 큐 기반 레이어 탐색의 원리와 코드를 연결합니다.",
      "snippet": "물결 비유로 시작해 큐 기반 레이어 탐색의 원리와 코드를 연결합니다.",
      "date": "2024-11-16",
      "tags": [
        "BFS",
        "그래프",
        "최단경로(무가중치)",
        "큐",
        "알고리즘 아틀리에"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/algorithm-atelier-bfs"
    },
    {
      "path": "/posts/2024/algorithm-atelier-dijkstra.md",
      "year": "2024",
      "slug": "algorithm-atelier-dijkstra",
      "title": "알고리즘 아틀리에: 다익스트라 — 5단계 직관 학습",
      "description": "비유→원리→메커니즘→자료구조→코드로 다익스트라를 직관적으로 체득합니다.",
      "snippet": "비유→원리→메커니즘→자료구조→코드로 다익스트라를 직관적으로 체득합니다.",
      "date": "2024-11-15",
      "tags": [
        "다익스트라",
        "최단경로",
        "그래프",
        "우선순위 큐",
        "알고리즘 아틀리에"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/algorithm-atelier-dijkstra"
    },
    {
      "path": "/posts/2024/bfs.md",
      "year": "2024",
      "slug": "bfs",
      "title": "BFS (너비 우선 탐색) 완전 정복",
      "description": "큐를 이용한 레벨별 그래프 탐색과 최단 경로 알고리즘의 핵심",
      "snippet": "큐를 이용한 레벨별 그래프 탐색과 최단 경로 알고리즘의 핵심",
      "date": "2024-11-15",
      "tags": [
        "BFS",
        "그래프",
        "탐색",
        "최단경로",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/bfs"
    },
    {
      "path": "/posts/2024/arch-linux-gui-setup-experience.md",
      "year": "2024",
      "slug": "arch-linux-gui-setup-experience",
      "title": "아치 리눅스 설치하면서 깨달은 GUI 환경 선택의 중요성",
      "description": "아치 리눅스 설치 과정에서 데스크톱 환경을 선택하면서 느낀 점들과 각 환경의 특징",
      "snippet": "아치 리눅스 설치 과정에서 데스크톱 환경을 선택하면서 느낀 점들과 각 환경의 특징",
      "date": "2024-11-12",
      "tags": [
        "ArchLinux",
        "UEFI",
        "KDE",
        "GNOME",
        "i3wm",
        "Hyprland",
        "리눅스설치"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/arch-linux-gui-setup-experience"
    },
    {
      "path": "/posts/2024/kmp.md",
      "year": "2024",
      "slug": "kmp",
      "title": "KMP 알고리즘 (Knuth-Morris-Pratt)",
      "description": "KMP 알고리즘을 통해 문자열 패턴 매칭을 효율적으로 수행하는 방법과 실패 함수의 원리를 학습합니다.",
      "snippet": "KMP 알고리즘을 통해 문자열 패턴 매칭을 효율적으로 수행하는 방법과 실패 함수의 원리를 학습합니다.",
      "date": "2024-11-08",
      "tags": [
        "KMP",
        "문자열매칭",
        "패턴매칭",
        "실패함수"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/kmp"
    },
    {
      "path": "/posts/2024/rabin-karp.md",
      "year": "2024",
      "slug": "rabin-karp",
      "title": "라빈-카프 알고리즘 (Rabin-Karp Algorithm)",
      "description": "라빈-카프 알고리즘을 통해 해싱을 활용한 효율적인 문자열 패턴 매칭과 롤링 해시 기법을 학습합니다.",
      "snippet": "라빈-카프 알고리즘을 통해 해싱을 활용한 효율적인 문자열 패턴 매칭과 롤링 해시 기법을 학습합니다.",
      "date": "2024-11-05",
      "tags": [
        "Rabin-Karp",
        "해싱",
        "문자열매칭",
        "롤링해시"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/rabin-karp"
    },
    {
      "path": "/posts/2024/arch-linux-uefi-guide.md",
      "year": "2024",
      "slug": "arch-linux-uefi-guide",
      "title": "아치 리눅스 설치하고 예쁘게 꾸미기",
      "description": "아치 리눅스 UEFI 설치부터 데스크톱 꾸미기까지 실제 경험을 바탕으로 정리",
      "snippet": "아치 리눅스 UEFI 설치부터 데스크톱 꾸미기까지 실제 경험을 바탕으로 정리",
      "date": "2024-11-01",
      "tags": [
        "Linux",
        "Arch Linux",
        "UEFI",
        "데스크톱 환경",
        "커스터마이징"
      ],
      "category": "시스템",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/arch-linux-uefi-guide"
    },
    {
      "path": "/posts/2024/quick-sort.md",
      "year": "2024",
      "slug": "quick-sort",
      "title": "퀵 정렬(Quick Sort) 완전 정복",
      "description": "분할 정복을 이용한 최고 성능의 정렬 알고리즘, 퀵 정렬의 모든 것",
      "snippet": "분할 정복을 이용한 최고 성능의 정렬 알고리즘, 퀵 정렬의 모든 것",
      "date": "2024-10-27",
      "tags": [
        "퀵정렬",
        "정렬",
        "분할정복",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/quick-sort"
    },
    {
      "path": "/posts/2025/dijkstra.md",
      "year": "2025",
      "slug": "dijkstra",
      "title": "다익스트라 알고리즘 (Dijkstra's Algorithm)",
      "description": "다익스트라 알고리즘을 통해 가중 그래프에서의 최단 경로를 효율적으로 찾는 방법을 학습합니다.",
      "snippet": "다익스트라 알고리즘을 통해 가중 그래프에서의 최단 경로를 효율적으로 찾는 방법을 학습합니다.",
      "date": "2024-10-25",
      "tags": [
        "Dijkstra",
        "최단경로",
        "우선순위큐",
        "그래프"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2025/dijkstra"
    },
    {
      "path": "/posts/2024/queue.md",
      "year": "2024",
      "slug": "queue",
      "title": "큐(Queue) 완전 정복",
      "description": "FIFO 구조의 큐 자료구조 개념부터 우선순위 큐까지 완벽 가이드",
      "snippet": "FIFO 구조의 큐 자료구조 개념부터 우선순위 큐까지 완벽 가이드",
      "date": "2024-10-22",
      "tags": [
        "큐",
        "자료구조",
        "FIFO",
        "BFS",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/queue"
    },
    {
      "path": "/posts/2024/stack.md",
      "year": "2024",
      "slug": "stack",
      "title": "스택(Stack) 완전 정복",
      "description": "LIFO 구조의 스택 자료구조 개념부터 실전 활용까지 완벽 가이드",
      "snippet": "LIFO 구조의 스택 자료구조 개념부터 실전 활용까지 완벽 가이드",
      "date": "2024-10-15",
      "tags": [
        "스택",
        "자료구조",
        "LIFO",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/stack"
    },
    {
      "path": "/posts/2025/python-ai-chatbot-development.md",
      "year": "2025",
      "slug": "python-ai-chatbot-development",
      "title": "Python으로 AI 챗봇 만들기",
      "description": "OpenAI API를 활용하여 실용적인 AI 챗봇을 구현하는 과정을 단계별로 설명합니다.",
      "snippet": "OpenAI API를 활용하여 실용적인 AI 챗봇을 구현하는 과정을 단계별로 설명합니다.",
      "date": "2024-10-11",
      "tags": [
        "Python",
        "AI",
        "Chatbot",
        "OpenAI"
      ],
      "category": "AI/ML",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2025/python-ai-chatbot-development"
    },
    {
      "path": "/posts/2024/react-nextjs-modern-web-development.md",
      "year": "2024",
      "slug": "react-nextjs-modern-web-development",
      "title": "React와 Next.js로 모던 웹 개발하기",
      "description": "최신 React 기능과 Next.js의 장점을 활용한 웹 개발 방법론을 소개합니다.",
      "snippet": "최신 React 기능과 Next.js의 장점을 활용한 웹 개발 방법론을 소개합니다.",
      "date": "2024-10-08",
      "tags": [
        "React",
        "Next.js",
        "JavaScript",
        "Frontend"
      ],
      "category": "Web Development",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/react-nextjs-modern-web-development"
    },
    {
      "path": "/posts/2024/docker-kubernetes-guide.md",
      "year": "2024",
      "slug": "docker-kubernetes-guide",
      "title": "Docker와 Kubernetes 삽질기",
      "description": "컨테이너 기술의 핵심인 Docker와 오케스트레이션 도구 Kubernetes 활용법을 다룹니다.",
      "snippet": "컨테이너 기술의 핵심인 Docker와 오케스트레이션 도구 Kubernetes 활용법을 다룹니다.",
      "date": "2024-10-04",
      "tags": [
        "Docker",
        "Kubernetes",
        "DevOps",
        "Container"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/docker-kubernetes-guide"
    },
    {
      "path": "/posts/2024/opensource-schedule-management-analysis.md",
      "year": "2024",
      "slug": "opensource-schedule-management-analysis",
      "title": "비개발자를 위한 오픈소스 스케줄 관리 도구 완전 분석",
      "description": "레딧 사용자 만족도가 높은 비개발자용 스케줄 관리 오픈소스 도구들을 Docker 컨테이너 기반으로 심층 분석합니다.",
      "snippet": "레딧 사용자 만족도가 높은 비개발자용 스케줄 관리 오픈소스 도구들을 Docker 컨테이너 기반으로 심층 분석합니다.",
      "date": "2024-10-01",
      "tags": [
        "스케줄 관리",
        "Docker",
        "오픈소스",
        "Easy!Appointments",
        "Cal.com",
        "Plane"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "4 min read",
      "published": true,
      "url": "/blog/2024/opensource-schedule-management-analysis"
    },
    {
      "path": "/posts/2024/7.md",
      "year": "2024",
      "slug": "7",
      "title": "인텔 486: 컴퓨팅의 혁명",
      "description": "개인용 컴퓨팅을 변화시킨 인텔 486 마이크로프로세서에 대한 역사적인 고찰.",
      "snippet": "개인용 컴퓨팅을 변화시킨 인텔 486 마이크로프로세서에 대한 역사적인 고찰.",
      "date": "2024-09-27",
      "tags": [
        "인텔",
        "486",
        "컴퓨팅 역사"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "coverImage": "/images/2025/intelDX2.png",
      "url": "/blog/2024/7"
    },
    {
      "path": "/posts/2024/week3-4.md",
      "year": "2024",
      "slug": "week3-4",
      "title": "3-4주차: 정렬 및 탐색 기법",
      "description": "핵심 정렬 알고리즘과 이진 탐색을 마스터하여 효율적인 데이터 처리의 기초를 다진다",
      "snippet": "핵심 정렬 알고리즘과 이진 탐색을 마스터하여 효율적인 데이터 처리의 기초를 다진다",
      "date": "2024-09-23",
      "tags": [
        "정렬",
        "탐색",
        "이진탐색",
        "시간복잡도",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week3-4"
    },
    {
      "path": "/posts/2024/multimodal-recommendation-system-research.md",
      "year": "2024",
      "slug": "multimodal-recommendation-system-research",
      "title": "웹 기반 다중 모달 추천 시스템 연구",
      "description": "텍스트, 이미지, 영상 데이터를 종합적으로 처리하는 하이브리드 추천 시스템의 알고리즘 설계와 구현 방법에 대한 심화 연구입니다.",
      "snippet": "텍스트, 이미지, 영상 데이터를 종합적으로 처리하는 하이브리드 추천 시스템의 알고리즘 설계와 구현 방법에 대한 심화 연구입니다.",
      "date": "2024-09-20",
      "tags": [
        "추천 시스템",
        "다중 모달",
        "Word2Vec",
        "CNN",
        "LSTM",
        "협업 필터링",
        "딥러닝"
      ],
      "category": "AI",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/multimodal-recommendation-system-research"
    },
    {
      "path": "/posts/2024/week15-16.md",
      "year": "2024",
      "slug": "week15-16",
      "title": "15-16주차: 고급 DP 및 기타 주제",
      "description": "비트마스크 DP와 트리 DP의 고급 기법을 마스터하고, 문자열 알고리즘의 기초를 다진다",
      "snippet": "비트마스크 DP와 트리 DP의 고급 기법을 마스터하고, 문자열 알고리즘의 기초를 다진다",
      "date": "2024-09-17",
      "tags": [
        "고급DP",
        "비트마스크",
        "트리DP",
        "KMP",
        "문자열알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week15-16"
    },
    {
      "path": "/posts/2024/week7-8.md",
      "year": "2024",
      "slug": "week7-8",
      "title": "7-8주차: 동적 계획법(DP) 기초",
      "description": "최적 부분 구조와 중복 부분 문제를 이용한 효율적 문제 해결 기법을 마스터한다",
      "snippet": "최적 부분 구조와 중복 부분 문제를 이용한 효율적 문제 해결 기법을 마스터한다",
      "date": "2024-09-13",
      "tags": [
        "동적계획법",
        "DP",
        "메모이제이션",
        "최적화",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week7-8"
    },
    {
      "path": "/posts/2024/week5-6.md",
      "year": "2024",
      "slug": "week5-6",
      "title": "5-6주차: 재귀와 분할 정복",
      "description": "재귀적 사고를 통한 문제 해결과 분할 정복 패러다임의 강력함을 경험한다",
      "snippet": "재귀적 사고를 통한 문제 해결과 분할 정복 패러다임의 강력함을 경험한다",
      "date": "2024-09-09",
      "tags": [
        "재귀",
        "분할정복",
        "하노이탑",
        "피보나치",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/week5-6"
    },
    {
      "path": "/posts/2024/nanopi-neo3-ubuntu-setup-guide.md",
      "year": "2024",
      "slug": "nanopi-neo3-ubuntu-setup-guide",
      "title": "NanoPi Neo3 우분투 설정 및 네트워크 구성 완벽 가이드",
      "description": "NanoPi Neo3에 우분투 설치 후 로그인부터 고정 IP 설정까지 완벽한 설정 가이드를 제공합니다.",
      "snippet": "NanoPi Neo3에 우분투 설치 후 로그인부터 고정 IP 설정까지 완벽한 설정 가이드를 제공합니다.",
      "date": "2024-09-05",
      "tags": [
        "NanoPi Neo3",
        "Ubuntu",
        "NetworkManager",
        "ARM SBC",
        "IoT",
        "고정 IP"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/nanopi-neo3-ubuntu-setup-guide"
    },
    {
      "path": "/posts/2024/tmux-session-management-guide.md",
      "year": "2024",
      "slug": "tmux-session-management-guide",
      "title": "tmux 세션 관리 완벽 가이드",
      "description": "tmux 터미널 멀티플렉서의 기본 사용법과 세션이 사라지는 문제 해결 방법을 자세히 설명합니다.",
      "snippet": "tmux 터미널 멀티플렉서의 기본 사용법과 세션이 사라지는 문제 해결 방법을 자세히 설명합니다.",
      "date": "2024-09-02",
      "tags": [
        "tmux",
        "터미널",
        "세션 관리",
        "Linux",
        "멀티플렉서"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/tmux-session-management-guide"
    },
    {
      "path": "/posts/2024/9.md",
      "year": "2024",
      "slug": "9",
      "title": "Nginx 설정 파일 구조 및 작성 방법",
      "description": "Nginx 설정 파일(conf)의 구조와 작성 방법에 대한 가이드.",
      "snippet": "Nginx 설정 파일(conf)의 구조와 작성 방법에 대한 가이드.",
      "date": "2024-08-29",
      "tags": [
        "Nginx",
        "Configuration",
        "Web Server"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/9"
    },
    {
      "path": "/posts/2024/week13-14.md",
      "year": "2024",
      "slug": "week13-14",
      "title": "13-14주차: 탐욕법 & 분리 집합",
      "description": "탐욕 알고리즘의 핵심 원리를 이해하고, Union-Find 자료구조로 효율적인 집합 관리를 마스터한다",
      "snippet": "탐욕 알고리즘의 핵심 원리를 이해하고, Union-Find 자료구조로 효율적인 집합 관리를 마스터한다",
      "date": "2024-08-25",
      "tags": [
        "탐욕법",
        "그리디",
        "크루스칼",
        "프림",
        "Union-Find",
        "MST"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week13-14"
    },
    {
      "path": "/posts/2024/rsync-custom-ssh-port-guide.md",
      "year": "2024",
      "slug": "rsync-custom-ssh-port-guide",
      "title": "Rsync 커스텀 SSH 포트 사용법 완벽 가이드",
      "description": "Rsync를 사용할 때 기본 SSH 포트가 아닌 커스텀 포트를 지정하는 올바른 방법을 상세히 설명합니다.",
      "snippet": "Rsync를 사용할 때 기본 SSH 포트가 아닌 커스텀 포트를 지정하는 올바른 방법을 상세히 설명합니다.",
      "date": "2024-08-21",
      "tags": [
        "rsync",
        "SSH",
        "파일 동기화",
        "백업",
        "Linux"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/rsync-custom-ssh-port-guide"
    },
    {
      "path": "/posts/2024/6.md",
      "year": "2024",
      "slug": "6",
      "title": "마지막 시간",
      "description": "시간, 속죄, 그리고 미래를 조종하는 모래시계에 대한 이야기.",
      "snippet": "시간, 속죄, 그리고 미래를 조종하는 모래시계에 대한 이야기.",
      "date": "2024-08-14",
      "tags": [
        "판타지",
        "시간여행"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/6"
    },
    {
      "path": "/posts/2024/3.md",
      "year": "2024",
      "slug": "3",
      "title": "컴공총론정리",
      "description": "컴공 총론 개론",
      "snippet": "컴공 총론 개론",
      "date": "2024-08-10",
      "tags": [],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "coverImage": "/images/2024/process.png",
      "url": "/blog/2024/3"
    },
    {
      "path": "/posts/2024/1.md",
      "year": "2024",
      "slug": "1",
      "title": "[Hugo] .Summary 사용법",
      "description": "Hugo-library .Summary 사용법에 관한 포스트입니다.",
      "snippet": "Hugo-library .Summary 사용법에 관한 포스트입니다.",
      "date": "2024-08-07",
      "tags": [],
      "category": "기술",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "coverImage": "https://github.com/user-attachments/assets/42e76be2-9749-47c2-92a4-a14ea5f91237",
      "url": "/blog/2024/1"
    },
    {
      "path": "/posts/2024/8.md",
      "year": "2024",
      "slug": "8",
      "title": "세계 1차 대전에서 기관총의 영향",
      "description": "세계 1차 대전 동안 기관총이 전쟁 양상을 어떻게 변화시켰는지에 대한 탐구.",
      "snippet": "세계 1차 대전 동안 기관총이 전쟁 양상을 어떻게 변화시켰는지에 대한 탐구.",
      "date": "2024-08-04",
      "tags": [
        "세계 1차 대전",
        "기관총",
        "역사"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/8"
    },
    {
      "path": "/posts/2024/week1-2.md",
      "year": "2024",
      "slug": "week1-2",
      "title": "1-2주차: 기초 수학 및 자료구조 복습",
      "description": "알고리즘 학습의 첫 걸음, 이산수학과 기본 자료구조를 탄탄히 다지는 시간",
      "snippet": "알고리즘 학습의 첫 걸음, 이산수학과 기본 자료구조를 탄탄히 다지는 시간",
      "date": "2024-08-01",
      "tags": [
        "알고리즘",
        "자료구조",
        "이산수학",
        "배열",
        "스택",
        "큐"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/week1-2"
    },
    {
      "path": "/posts/2024/database-containerization-guide.md",
      "year": "2024",
      "slug": "database-containerization-guide",
      "title": "데이터베이스 및 애플리케이션 컨테이너화 설치 가이드",
      "description": "MySQL, PostgreSQL, Redis, RabbitMQ, Kavita 등 주요 데이터베이스와 애플리케이션의 Docker 컨테이너화 및 호스트 설치 방법을 SSL/TLS 설정과 함께 소개합니다.",
      "snippet": "MySQL, PostgreSQL, Redis, RabbitMQ, Kavita 등 주요 데이터베이스와 애플리케이션의 Docker 컨테이너화 및 호스트 설치 방법을 SSL/TLS 설정과 함께 소개합니다.",
      "date": "2024-07-29",
      "tags": [
        "MySQL",
        "PostgreSQL",
        "Redis",
        "RabbitMQ",
        "Kavita",
        "SSL",
        "TLS",
        "Container"
      ],
      "category": "Database",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2024/database-containerization-guide"
    },
    {
      "path": "/posts/2024/week11-12.md",
      "year": "2024",
      "slug": "week11-12",
      "title": "11-12주차: 고급 자료구조 및 최단경로",
      "description": "힙과 우선순위 큐를 마스터하고, 다익스트라와 벨만-포드 최단경로 알고리즘을 정복한다",
      "snippet": "힙과 우선순위 큐를 마스터하고, 다익스트라와 벨만-포드 최단경로 알고리즘을 정복한다",
      "date": "2024-07-25",
      "tags": [
        "힙",
        "우선순위큐",
        "다익스트라",
        "벨만포드",
        "최단경로"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week11-12"
    },
    {
      "path": "/posts/2024/changedetection-io-guide.md",
      "year": "2024",
      "slug": "changedetection-io-guide",
      "title": "ChangeDetection.io 완벽 활용 가이드",
      "description": "웹페이지 변경 감지 서비스 ChangeDetection.io의 Duration Time 설정과 Discord 웹훅 연동을 통한 효율적인 모니터링 방법을 소개합니다.",
      "snippet": "웹페이지 변경 감지 서비스 ChangeDetection.io의 Duration Time 설정과 Discord 웹훅 연동을 통한 효율적인 모니터링 방법을 소개합니다.",
      "date": "2024-07-21",
      "tags": [
        "웹 모니터링",
        "자동화",
        "Discord",
        "Webhook",
        "ChangeDetection"
      ],
      "category": "DevOps",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/changedetection-io-guide"
    },
    {
      "path": "/posts/2024/vim-split-window-guide.md",
      "year": "2024",
      "slug": "vim-split-window-guide",
      "title": "Vim 분할 창 사용법과 파일 간 전환 방법",
      "description": "Vim에서 vertical split view를 사용하여 여러 파일을 동시에 편집하고 파일 간 전환하는 방법을 소개합니다.",
      "snippet": "Vim에서 vertical split view를 사용하여 여러 파일을 동시에 편집하고 파일 간 전환하는 방법을 소개합니다.",
      "date": "2024-07-17",
      "tags": [
        "Vim",
        "편집기",
        "분할 창",
        "Linux",
        "단축키"
      ],
      "category": "Editor",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/vim-split-window-guide"
    },
    {
      "path": "/posts/2024/linux-networkmanager-static-ip.md",
      "year": "2024",
      "slug": "linux-networkmanager-static-ip",
      "title": "NetworkManager를 사용한 Linux Static IP 설정 완벽 가이드",
      "description": "NetworkManager를 활용하여 다양한 Linux 배포판에서 고정 IP를 설정하는 방법을 상세히 설명합니다.",
      "snippet": "NetworkManager를 활용하여 다양한 Linux 배포판에서 고정 IP를 설정하는 방법을 상세히 설명합니다.",
      "date": "2024-07-14",
      "tags": [
        "NetworkManager",
        "Static IP",
        "nmcli",
        "nmtui",
        "Ubuntu",
        "CentOS",
        "Rocky Linux"
      ],
      "category": "Linux",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/linux-networkmanager-static-ip"
    },
    {
      "path": "/posts/2024/week9-10.md",
      "year": "2024",
      "slug": "week9-10",
      "title": "9-10주차: 그래프 이론 기초",
      "description": "그래프의 표현 방법과 BFS, DFS 탐색 알고리즘을 완벽하게 마스터한다",
      "snippet": "그래프의 표현 방법과 BFS, DFS 탐색 알고리즘을 완벽하게 마스터한다",
      "date": "2024-07-10",
      "tags": [
        "그래프",
        "BFS",
        "DFS",
        "탐색",
        "알고리즘"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/week9-10"
    },
    {
      "path": "/posts/2024/4.md",
      "year": "2024",
      "slug": "4",
      "title": "hugo 외부 이미지 사용하기",
      "description": "hugo 외부 이미지 사용하기",
      "snippet": "hugo 외부 이미지 사용하기",
      "date": "2024-07-06",
      "tags": [],
      "category": "기술",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "coverImage": "https://images.unsplash.com/photo-1727200452521-ee63ae8682a8?w=1400&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxmZWF0dXJlZC1waG90b3MtZmVlZHw1Mnx8fGVufDB8fHx8fA%3D%3D",
      "url": "/blog/2024/4"
    },
    {
      "path": "/posts/2024/5.md",
      "year": "2024",
      "slug": "5",
      "title": "조용한 속삭임",
      "description": "잊혀진 마을에서 들려오는 신비한 속삭임에 대한 이야기.",
      "snippet": "잊혀진 마을에서 들려오는 신비한 속삭임에 대한 이야기.",
      "date": "2024-07-02",
      "tags": [
        "소설",
        "미스터리"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "url": "/blog/2024/5"
    },
    {
      "path": "/posts/2024/coding-test-guide.md",
      "year": "2024",
      "slug": "coding-test-guide",
      "title": "코딩테스트 완벽 대비 전략",
      "description": "대기업 코딩테스트 합격을 위한 실전 준비 가이드와 핵심 문제 유형별 공략법",
      "snippet": "대기업 코딩테스트 합격을 위한 실전 준비 가이드와 핵심 문제 유형별 공략법",
      "date": "2024-06-28",
      "tags": [
        "코딩테스트",
        "취업",
        "알고리즘",
        "프로그래밍",
        "면접"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/coding-test-guide"
    },
    {
      "path": "/posts/2024/2.md",
      "year": "2024",
      "slug": "2",
      "title": "김치캣과 요약문 실험기",
      "description": "블로그 요약 기능을 테스트하며 만난 길고양이 김치캣의 기록.",
      "snippet": "블로그 요약 기능을 테스트하며 만난 길고양이 김치캣의 기록.",
      "date": "2024-06-25",
      "tags": [
        "블로그",
        "Hugo",
        "기록"
      ],
      "category": "기술",
      "author": "Admin",
      "readingTime": "2 min read",
      "published": true,
      "coverImage": "https://github.com/user-attachments/assets/64b064ef-d713-4e7e-90a8-b9c83ae0e1c8",
      "url": "/blog/2024/2"
    },
    {
      "path": "/posts/2024/ai-personalized-learning-system.md",
      "year": "2024",
      "slug": "ai-personalized-learning-system",
      "title": "AI 기반 맞춤형 학습 시스템 프로젝트",
      "description": "인간의 기억 메커니즘과 과학적 학습법을 AI 기술과 결합하여 개인화된 학습 경험을 제공하는 혁신적인 교육 시스템 설계.",
      "snippet": "인간의 기억 메커니즘과 과학적 학습법을 AI 기술과 결합하여 개인화된 학습 경험을 제공하는 혁신적인 교육 시스템 설계.",
      "date": "2024-06-08",
      "tags": [
        "AI 교육",
        "맞춤형 학습",
        "간격 반복",
        "인출 연습",
        "이중부호화",
        "학습 시스템"
      ],
      "category": "AI",
      "author": "Admin",
      "readingTime": "7 min read",
      "published": true,
      "url": "/blog/2024/ai-personalized-learning-system"
    },
    {
      "path": "/posts/2024/algorithm-guide.md",
      "year": "2024",
      "slug": "algorithm-guide",
      "title": "알고리즘 학습 가이드",
      "description": "효과적인 알고리즘 공부 방법과 실전 팁을 제공합니다",
      "snippet": "효과적인 알고리즘 공부 방법과 실전 팁을 제공합니다",
      "date": "2024-06-05",
      "tags": [
        "알고리즘",
        "학습법",
        "코딩테스트",
        "자료구조"
      ],
      "category": "Algorithm",
      "author": "Admin",
      "readingTime": "3 min read",
      "published": true,
      "url": "/blog/2024/algorithm-guide"
    },
    {
      "path": "/posts/2024/_index.md",
      "year": "2024",
      "slug": "_index",
      "title": "영화",
      "description": "영화 리뷰와 분석, 철학적 사고를 담은 시네마 에세이",
      "snippet": "영화 리뷰와 분석, 철학적 사고를 담은 시네마 에세이",
      "date": "2024-01-01",
      "tags": [],
      "category": "General",
      "author": "Admin",
      "readingTime": "1 min read",
      "published": true,
      "url": "/blog/2024/_index"
    }
  ],
  "generatedAt": "2025-12-26T07:57:25.815Z",
  "years": [
    "2025",
    "2024"
  ],
  "format": 2
}

```

---

## frontend/public/posts/2024

### 1.md

**Path:** `frontend/public/posts/2024/1.md`

```markdown
---
title: "[Hugo] .Summary 사용법"
date: "2024-08-07"
category: "기술"
tags: []
excerpt: "Hugo-library .Summary 사용법에 관한 포스트입니다."
readTime: "3분"
---

하루 종일 Hugo 테마를 붙잡고 씨름했던 날이 있었다. 메인 페이지에는 깔끔한 카드가 뜨는데, 정작 내가 쓴 글은 첫 문장부터 줄줄이 노출되어 버렸다. 덕분에 새벽까지 노트북 앞에서 커피만 리필했다. 그때 처음 눈에 들어온 키워드가 바로 `.Summary`였다. "딱 필요한 만큼만 보여주고 나머지는 읽음 표시 뒤로 넘길 수 없을까?"라는 간절함이 시작이었다.

문서를 들춰보며 알게 된 해결책은 생각보다 단순했다. 본문에서 요약을 끊고 싶은 위치에 `<!--more-->`를 삽입하면 되었다. 다음날 아침, 출근 전 서둘러 저장 버튼을 누르던 순간, 메인 페이지에 깔끔하게 잘린 문단을 보고 숨이 탁 트이는 기분이 들었다. 한동안 그 짧은 요약문을 매만지느라 제목보다도 더 오랜 시간을 들였을 정도다.

```
본문에서 "<!--more-->"를 표시한 지점 바로 앞까지만 Summary로 노출된다.
템플릿에서는 "{{ .Summary }}"를 이용해 리스트나 카드에 요약문을 배치할 수 있다.
```

요약이 생긴 이후로는 글쓰기 리듬도 바뀌었다. 서두를 의식적으로 다듬게 되고, 독자가 클릭하고 싶게 만드는 한두 문장을 고르는 재미가 생겼다. 업무 일지를 정리할 때도 "이 대목까지 보여주고, 나머지는 클릭 후 읽게 하자"라는 생각을 하니 구조가 확 달라졌다. 결국 `.Summary`는 단순한 기능이 아니라, 글쓰기를 다시 배우게 만든 장치였다.

![.Summary 사용](https://github.com/user-attachments/assets/42e76be2-9749-47c2-92a4-a14ea5f91237)

지금도 새로운 글을 올릴 때면, `<!--more-->`를 어디에 둘까 잠시 고민한다. 때로는 서너 문장 쓰기도 전에 그 지점을 정할 때도 있고, 다 쓰고 나서야 겨우 하나를 골라낼 때도 있다. 하지만 어느 쪽이든, Hugo의 `.Summary` 덕분에 처음 방문한 사람에게도 내 글의 정수를 전할 수 있다는 확신이 든다. 그 확신이 블로그를 계속 이어가게 만드는 작은 동력이다.
```

### 2.md

**Path:** `frontend/public/posts/2024/2.md`

```markdown
---
title: "김치캣과 요약문 실험기"
date: "2024-06-25"
category: "기술"
tags: ['블로그', 'Hugo', '기록']
excerpt: "블로그 요약 기능을 테스트하며 만난 길고양이 김치캣의 기록."
readTime: "3분"
---

블로그 카드에 요약만 깔끔하게 노출해 보겠다고 분주하던 오후, 사무실 마당으로 한 마리 고양이가 슬쩍 다가왔다. 동료들과 우리는 그 녀석을 "김치캣"이라 부르는데, 어찌나 당당한지 문이 열릴 때마다 먼저 들어올 기세였다. 노트북을 들고 서둘러 밖으로 나가자, 김치캣은 모니터 앞을 뱅뱅 돌며 내가 무얼 하고 있는지 살피는 듯했다. 그 낯선 기척 덕분인지, 단순한 기술 실험도 꽤 즐거운 사건으로 변했다.

결국 김치캣을 무릎 위에 올려두고 Hugo의 `.Summary` 설정을 다시 뜯어보기로 했다. "글이 길어도, 첫 단락은 꼭 읽히도록 만들자."라는 목표는 같았다. 하지만 실제로 `<!--more-->`를 어디에 둘지 결정하는 일은 생각보다 감각적인 작업이었다. 김치캣의 턱 밑을 긁어주면서, "요약은 밑줄 긋듯 핵심만 남겨야 하는구나" 하고 중얼거렸다. 그 순간, 블로그 운영이 단순한 설정의 문제가 아니라 내가 어떤 이야기를 먼저 들려주고 싶은지 묻는 과정이라는 걸 깨달았다.

<!--more-->

![cat](https://github.com/user-attachments/assets/64b064ef-d713-4e7e-90a8-b9c83ae0e1c8)

설정 파일을 저장하고 새로고침을 눌렀을 때, 카드에는 딱 두 단락만이 보여졌다. 김치캣은 그 순간 모니터에 비친 자신의 모습을 보며 꼬리를 살짝 흔들었다. 나 역시 은근한 자부심이 올라오는 걸 느꼈다. 고양이와 함께 만든 요약문은 생각보다 더 부드럽고 읽기 쉬웠다. 한 번 정리한 이후에는 글을 쓸 때마다 "이 이야기를 처음 들려줄 때, 어떤 장면부터 보여줄까?"라는 질문을 자연스럽게 던지게 되었다.

이제는 새로운 글을 작성할 때마다 김치캣과의 오후를 떠올린다. 달콤한 간식 냄새와 키보드 타건 소리 사이에서, 나는 여전히 요약과 본문 사이의 균형을 찾는 중이다. 그리고 그 과정이야말로 블로그를 꾸준히 이어가게 만드는 동력이 된다. 기분 좋은 바람이 불어오는 날, 다시 한 번 김치캣과 함께 마당으로 나가 요약문을 다듬어 보고 싶다.
```

### 3.md

**Path:** `frontend/public/posts/2024/3.md`

```markdown
---
title: "컴공총론정리"
date: "2024-08-10"
category: "기술"
tags: []
excerpt: "컴공 총론 개론"
readTime: "4분"
---

시험을 앞둔 여름밤, 학교 도서관의 형광등 빛이 희미하게 떨리고 있었다. 컴퓨터공학 개론서를 펼쳐놓은 채 친구들과 문제를 맞춰 보던 와중, 나는 문득 운영체제가 사람 관계와 닮았다는 생각을 했다. 누군가는 실행 중이고, 누군가는 잠시 기다리다 다시 무대에 오르는 식으로 말이다.

<!--more-->

## 프로세스 상태를 이해한다는 것

![command top](../../images/2024/process.png)
처음 프로세스 상태 다이어그램을 외우려 할 때는 그저 화살표의 방향만 뒤쫓았다. 그러다 콘솔창에서 리눅스 `top` 명령어를 돌려보니, 내가 키보드를 두드리는 순간에도 수십 개의 프로세스가 "준비", "실행", "대기" 상태를 오가며 숨 쉬고 있었다. 강의실에서 그리던 도표가 실시간으로 살아 움직이는 광경을 보니, 책 속의 개념이 갑자기 피부로 와닿았다.

![process 상태](https://github.com/user-attachments/assets/4682dcc7-88b0-4d63-832a-8cf561be9a82)

## 스케줄링이 만들어낸 작은 드라마

다중 프로그래밍 환경에서 CPU를 배분하는 작업은 결국 누가 먼저 무대에 오를지를 정하는 일이다. 과제를 하다가 FCFS(First-Come, First-Served)를 시험했을 때는, 어릴 적 줄서기에서 새치기 당했던 기억이 떠올랐다. 먼저 도착한 프로세스가 순서를 지키는 단순한 방식은 깔끔하지만, 너무 긴 작업 하나가 전체 흐름을 막아버릴 때가 있다.

반면 라운드 로빈 스케줄링은 발표회에 초대된 친구들이 차례로 마이크를 돌려 쓰는 모습과 닮았다. 짧은 시간 할당량(quantum) 동안 CPU를 사용하는 동안에는 주인공이 되지만, 시간을 넘기면 다시 줄 끝으로 돌아가야 한다. 나도 협업 프로젝트를 할 때 "이번엔 내가, 다음엔 네가" 하며 시간을 쪼개 쓰던 경험이 있어서인지, 이 알고리즘이 유난히 인간적으로 느껴졌다. 물론, 너무 잦은 컨텍스트 스위칭 때문에 모두가 지쳐버릴 수도 있다는 경고도 잊지 않았다.

## 메모리 할당과 노트 정리의 공통점

밤새 필기를 정리하다 보면, 공책 한 장을 어떻게 나눌지 고민하곤 했다. 운영체제는 주기억장치를 분할하여 프로세스를 적재한다. `최초 적합`, `최적 적합` 같은 전략은 결국 "어디에 이 메모를 붙여야 공간이 덜 낭비될까"를 묻는 일과 다르지 않았다. 실제 서버에서 메모리 사용량이 급증하던 날, 로그를 훑어보며 "내가 메모장을 너무 무작정 붙여댄 건 아닐까" 하는 생각에 웃음이 나왔다.

## 가상 메모리와 나의 밤샘 회상

가상 메모리는 시험에도 자주 등장하는 단골 손님이다. 처음엔 "당장 필요한 것만 주기억장치에 올리고 나머지는 보조기억장치에 두라"는 말이 추상적으로 느껴졌다. 그런데 새벽 두 시, 팀 프로젝트에 쫓겨서도 모든 내용을 머릿속에 올려둘 수는 없었다. 결국 필요한 함수와 자료구조만 따로 정리해두고, 나머지는 상황이 닥치면 꺼내 쓰는 방식으로 버텼다. 페이징을 구현해 놓은 운영체제를 닮은 셈이다.

페이지 교체 알고리즘을 외울 때는 실없는 농담도 했다. "FIFO는 먼저 들어온 기억부터 잊어버리는 우리 뇌와 닮았고, LRU는 최근에 안 본 것을 가장 먼저 잊어버리지 않나?" 하는 식이다. 시험을 준비하며 그렇게 개념에 이야기를 붙여두니, 막상 답안을 쓸 때마다 그 밤의 공기가 떠올랐다.

---

교과서 한 구석에 적어둔 메모에는 지금도 이렇게 쓰여 있다. "운영체제는 결국 자원을 나누어 쓰는 방법에 관한 이야기다. 사람 사이에서도, 코드 사이에서도." 시험이 끝난 뒤 친구들과 허탈하게 웃으며 내려온 도서관 계단에서, 나는 기술이 삶과 만나는 지점을 처음으로 또렷하게 보았다.
```

### 4.md

**Path:** `frontend/public/posts/2024/4.md`

```markdown
---
title: "hugo 외부 이미지 사용하기"
date: "2024-07-06"
category: "기술"
tags: []
excerpt: "hugo 외부 이미지 사용하기"
readTime: "3분"
---

![post_4_main_image](https://images.unsplash.com/photo-1727200452521-ee63ae8682a8?w=1400&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxmZWF0dXJlZC1waG90b3MtZmVlZHw1Mnx8fGVufDB8fHx8fA%3D%3D)

외부 이미지를 블로그에 들여오기 시작한 것은, 텍스트만으로는 도저히 전해지지 않는 순간을 포착하고 싶어서였다. 어느 날 퇴근길 지하철에서 Unsplash 앱을 스크롤하다가, 꼭 이 장면을 글에 쓰고 싶다는 욕구가 들었다. 고요한 산 속을 지나가는 아침 안개, 휴일 오후 커피잔의 따뜻한 김. 그 사진들을 존중하면서도 내 이야기 속에 자연스럽게 녹여 넣는 방법을 찾고 싶었다.

<!--more-->

Hugo에서 외부 이미지를 쓰는 일은 생각보다 간단했다. `<img>` 태그를 직접 다루는 대신 마크다운 문법으로 링크만 정확히 붙이면 된다. 그래도 처음에는 URL에 붙은 긴 파라미터가 영 낯설어서, 노트에 하나하나 적어 가며 익혔다.

```
![이미지이름](이미지 href를 사용한다)
```

Unsplash 이미지를 붙여 놓고 새로고침을 할 때마다, 내가 쓰는 글의 분위기가 눈앞에서 조금씩 달라지는 걸 목격했다. 빛의 방향과 색감, 프레임 속 인물의 표정이 문장에 미묘한 감정을 더한다는 사실을 체감했다. 그렇게 몇 장의 이미지를 고르고 나니, 결국 글을 쓰는 과정도 하나의 큐레이션 작업이라는 깨달음을 얻었다.

![post_4_image1](https://images.unsplash.com/photo-1727783903555-6a9ba6a7b6e0?w=1400&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxmZWF0dXJlZC1waG90b3MtZmVlZHw2Mnx8fGVufDB8fHx8fA%3D%3D)

![post_4_image2](https://images.unsplash.com/photo-1725714835400-db392bfa6e5e?w=600&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1yZWxhdGVkfDI3fHx8ZW58MHx8fHx8)

![post_4_image3](https://plus.unsplash.com/premium_photo-1700135091041-2c755a97689e?w=600&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1yZWxhdGVkfDQyfHx8ZW58MHx8fHx8)

사진을 고르고 붙이는 과정은 마치 친구에게 여행 이야기를 들려주며 사진첩을 함께 넘기는 기분과 닮았다. 다음 글을 준비할 때도, 다시 Unsplash를 뒤적거리며 내 문장과 어울리는 빛을 찾아 헤맨다. 결국 외부 이미지를 쓰는 일은 단순한 기능 활용을 넘어, 글에 온도를 더하는 작은 의식이 되었다.
```

### 5.md

**Path:** `frontend/public/posts/2024/5.md`

```markdown
---
title: "조용한 속삭임"
date: "2024-07-02"
category: "기술"
tags: ['소설', '미스터리']
excerpt: "잊혀진 마을에서 들려오는 신비한 속삭임에 대한 이야기."
readTime: "4분"
---

엘더쉐이드는 지도에서조차 희미하게 남은 마을이었다. 학교에서 돌아오던 길, 버스 창밖으로 보이던 폐가와 비탈길, 그리고 사람들이 서로 마주치면 습관처럼 낮춰 말하던 모습이 내 기억 속에 고스란히 남아 있다. 침묵은 이 마을의 공기였다. 여름밤에도 창문을 활짝 열어두고, 밤새 너울거리던 여름벌레의 울음 대신 들리는 건 낮게 깔린 속삭임뿐이었다.

속삭임을 처음 들은 건 열두 살 때였다. 마당에 놓아둔 빨랫줄이 바람도 없이 흔들리던 밤, 나는 두 귀를 틀어막았지만, 그 목소리는 머릿속 어딘가에서 올라왔다. 마치 오래된 친척이 먼 곳에서 부르는 것처럼 낮고 절절했다. "돌표식 너머로 오지 마." 어른들은 늘 그렇게 말했지만, 말 못할 호기심이 그 금기를 조금씩 무너뜨렸다.

어느 날, 친구 엘라라와 나는 해가 오래 전에 지고 난 뒤에도 숲 가장자리를 서성거렸다. 나무껍질은 축축했고, 발 아래는 물기를 머금은 흙이 폭신하게 꺼졌다. 속삭임은 처음보다 더 가까이 다가와 있었고, 우리가 서로의 손을 꼭 붙잡고 있어도 떨림을 멈출 수 없을 만큼 선명했다. "우리를 기억해 줘." 이 말이 들릴 때마다, 마을의 오래된 역사가 새어 나오는 느낌이었다.

돌표식 너머로 발을 들이자, 숲은 우리를 조용히 감싸 안았다. 나무들은 키를 낮추고 가지를 한 곳으로 모아 길을 열어줬다. 언젠가 이곳에서 누군가 사라졌다는 이야기를 들었지만, 지금 우리를 부르는 목소리는 사납다기보다 애틋했다. 그 소리를 따라가다 보니, 안개가 걷힌 작은 공터가 나타났다. 달빛 한 줄기가 중앙의 돌 위로 조용히 떨어지고 있었고, 돌에는 익숙한 이름들이 빼곡히 새겨져 있었다. 오래전에 마을을 떠났거나, 그 존재가 기록에서 사라진 사람들의 이름이었다.

우리는 조심스럽게 돌 표면을 손끝으로 훑었다. 손이 닿는 순간 속삭임이 멈췄고, 대신 마음 한가운데로 뜨거운 울림이 밀려왔다. "우리를 잊지 마." 그 목소리는 마을 어른들이 억눌러 두었던 기억의 조각 같았다. 엘라라는 입술을 깨물며 조용히 고개를 끄덕였다. 그날 이후, 숲은 더 이상 두려움의 대상이 아니었다. 오히려 우리가 지켜야 할 약속의 장소가 되었다.

몇 년이 지나 도시로 떠난 뒤에도, 가끔 밤하늘을 올려다보면 엘더쉐이드의 안개가 떠오른다. 그때 들었던 속삭임이 내 마음 한구석을 톡톡 두드리는 것 같다. 우리는 여전히 서로의 이름을 부르며 기억해 주고 있을까? 언젠가 다시 마을로 돌아가면, 돌표식 앞에 촛불을 놓고 천천히 이름을 읽어주고 싶다. 침묵은 여전히 존재겠지만, 그 침묵 속에는 오래된 목소리들이 살아 숨 쉬고 있다는 걸 이제는 알기 때문이다.
```

### 6.md

**Path:** `frontend/public/posts/2024/6.md`

```markdown
---
title: "마지막 시간"
date: "2024-08-14"
category: "기술"
tags: ['판타지', '시간여행']
excerpt: "시간, 속죄, 그리고 미래를 조종하는 모래시계에 대한 이야기."
readTime: "5분"
---

사막의 여름은 저녁이 되어도 숨이 막힐 만큼 뜨겁다. 하늘이 붉게 사그라질 무렵, 끝없이 펼쳐진 모래 위로 전설 속 모래시계를 찾으려는 아릭의 그림자가 길게 늘어졌다. 어린 시절부터 들었던 이야기—시간의 주인이 남겨둔 모래시계를 손에 넣으면 과거를 되돌리고 미래를 바꿀 수 있다는 말—은 늘 허황되게만 느껴졌다. 하지만 사랑하는 이를 돌려보낸 이후로, 그는 그 전설에 매달릴 수밖에 없었다.

모래시계를 찾는 일은 한겨울 기억을 더듬는 일과 닮아 있었다. 잡힐 듯 잡히지 않는 감정의 흔적을 쫓다가, 결국 손끝에서 사라지는 아련함. 아릭은 매일 조금씩 사막의 다른 지점을 파고 또 팠다. 그의 손등에는 거친 모래 자국이 남았고, 어깨는 지칠 대로 지쳐 있었다. 그러던 어느 날 석양빛이 마지막 모래더미를 물들일 때, 낡은 천조각에 싸인 모래시계가 스르르 모습을 드러냈다.

그 모래시계는 우리가 흔히 아는 황금빛 모래가 아니었다. 밤을 닮은 검은 입자들이 느린 소용돌이를 만들며 서로 어우러졌다. 마치 시간이 그 안에서 숨을 고르는 듯한 모습이었다. 아릭은 손가락을 떨며 유리 표면을 만졌다. 차갑지도 뜨겁지도 않은 온기가 순간적으로 손끝을 타고올라 심장으로 내려앉았다. 그는 깊게 숨을 들이쉬고, 많은 것을 포기해야 할지 모른다는 직감과 함께 모래시계를 뒤집었다.

모래가 첫 알갱이부터 떨어지기 시작하자, 사막의 바람은 숨을 멈췄다. 하늘의 별빛이 순간 정지했고, 주변의 모든 소리가 한꺼번에 사라졌다. 아릭은 눈을 감았다가 다시 떴다. 어느새 세상은 그가 가장 간절히 바랐던 날로 되돌아가 있었다. 오래전 교차로, 가로등 불빛 아래에서 그녀가 서 있었다. 그는 그 자리에 뛰어들며 목이 메도록 이름을 불렀다.

하지만 행복한 재회는 오래가지 않았다. 모래시계 속 모래는 여전히 떨어지고 있었고, 시간이 지날수록 그 속도는 점점 빨라졌다. 그는 뒤늦게야 깨달았다. 과거를 건드리는 순간, 미래의 모래가 대신 빠져나간다는 사실을. 그녀의 손을 붙잡고 있자니, 자신의 손가락이 서서히 투명해지는 것이 눈에 들어왔다. 사랑하는 사람의 눈동자 속에 비친 자신이 점점 흐려지는 광경은 그 어떤 고통보다 뼈아팠다.

"미안해." 그는 마지막으로 그녀의 손을 꽉 잡았다. 그녀도 알았다는 듯 작게 고개를 끄덕였다. 두 사람 사이에는 이루지 못한 말이 수없이 맴돌았지만, 그들의 마지막 순간은 침묵으로 가득 찼다. 모래시계의 마무리 알갱이가 떨어질 즈음, 아릭은 다시 사막 한가운데로 돌아와 있었다. 시야를 가득 채우는 것은 더 이상 그녀가 아니라, 붉은 노을과 차가운 모래뿐이었다.

그가 미래를 잃었다는 사실을 깨닫기까지는 오랜 시간이 걸리지 않았다. 모래시계는 손에서 떨어져 깨지지도, 다시 모래를 채우지도 않았다. 그는 변하지 않는 사막과 함께 살아야 했다. 하지만 기묘하게도 후회만 남지는 않았다. 사랑을 되살린 한순간의 온기가 오히려 그의 남은 시간을 버텨낼 힘이 되었다. 그는 모래 위에 조용히 주저앉아, 다시 한 번 사막의 바람을 기다렸다. 언젠가 또 다른 여행자가 전설을 좇아 이곳을 찾을지도 모른다. 그때 아릭은 말해 줄 것이다. 시간은 되돌릴 수 있지만, 그 대가는 언제나 현재의 우리 자신이라는 것을.
```

### 7.md

**Path:** `frontend/public/posts/2024/7.md`

```markdown
---
title: "인텔 486: 컴퓨팅의 혁명"
date: "2024-09-27"
category: "기술"
tags: ['인텔', '486', '컴퓨팅 역사']
excerpt: "개인용 컴퓨팅을 변화시킨 인텔 486 마이크로프로세서에 대한 역사적인 고찰."
readTime: "2분"
---

![dx2-66](../../images/2025/intelDX2.png)
<citation>이미지 출처: Wikipedia (https://en.wikipedia.org/wiki/Intel_80486)</citation>

1980년대 후반의 개인용 컴퓨팅 시장은 새로운 도약을 기다리고 있었다. 마이크로프로세서 기술의 선두주자였던 인텔은 이러한 기대를 인텔 486 마이크로프로세서로 응답하며 1989년 역사적인 변곡점을 만들어 냈다. 이 칩은 단순한 성능 향상 이상의 의미를 지니며, 전반적인 아키텍처 설계와 효율성에서 개인용 컴퓨터의 가능성을 한층 확장했다.

인텔 386이 현대 컴퓨팅의 기반을 다졌다면, 486은 그 위에 혁신을 쌓아 올렸다. 무엇보다 부동소수점 연산 장치(FPU)를 CPU와 같은 다이에 통합해 연산 효율을 크게 끌어올렸고, 8KB 규모의 온칩 캐시를 도입해 데이터 접근 속도를 개선했다. 이러한 변화는 과학, 공학, 그래픽 작업과 같이 정밀한 계산을 요구하는 분야에서 체감 가능한 차이를 제공했다.

486의 파이프라이닝 구조는 이전 명령어가 완료되기 전 다음 명령어를 실행 구간에 투입해 처리량을 극대화했다. 동시에 32비트 아키텍처를 전면적으로 지원하며 더 큰 메모리 공간과 데이터 처리 능력을 보장했다. 운영체제는 이 덕분에 멀티태스킹을 보다 안정적으로 구현할 수 있었고, 사용자들은 한층 민첩해진 응답성을 경험할 수 있었다.

제품 라인업 또한 폭넓었다. 클럭 속도 20MHz부터 100MHz까지 다양한 모델이 제공되면서 가정용 PC부터 서버까지 폭넓은 시장을 커버했다. 도스 게임을 즐기는 사용자부터 복잡한 비즈니스 소프트웨어를 다루는 전문가까지, 486은 성능과 가격의 균형을 찾는 이들에게 매력적인 선택지였다. 이러한 설계 철학은 후속작인 인텔 펜티엄에 그대로 이어져, 486이 마련한 틀을 더욱 확장하게 된다.

1990년대 중반이 되자 인텔 486은 사실상의 표준으로 자리잡았다. 신뢰할 수 있는 멀티태스킹 능력과 향상된 그래픽 처리 덕분에 소프트웨어 개발자와 하드웨어 애호가 모두에게 사랑받았다. 비록 이후 세대의 프로세서가 등장하며 주류 자리에서 물러났지만, 486이 남긴 유산은 여전히 견고하다. 한 시대를 상징하는 기술적 진화의 기록이자, 오늘날 고성능 컴퓨팅 환경이 존재할 수 있도록 한 토대이기 때문이다.
```

### 8.md

**Path:** `frontend/public/posts/2024/8.md`

```markdown
---
title: "세계 1차 대전에서 기관총의 영향"
date: "2024-08-04"
category: "기술"
tags: ['세계 1차 대전', '기관총', '역사']
excerpt: "세계 1차 대전 동안 기관총이 전쟁 양상을 어떻게 변화시켰는지에 대한 탐구."
readTime: "5분"
---

세계 1차 대전의 전장을 처음 공부했을 때, 지도 위에 굵은 선으로 그어진 참호 라인이 어쩐지 미로처럼 보였다. 그러나 기록을 따라 읽어 내려갈수록 그 라인이 실은 공포와 절망의 흔적이었다는 사실을 깨달았다. 나는 당시 참호에서 들렸을 끝없는 기관총 소리를 상상해 보려 했지만, 아무리 머릿속에서 재현해도 그 완전한 공허함을 다 담을 수 없었다. 그 전쟁의 이름만으로도 가슴이 먹먹해지는 이유가 여기에 있었다.

<!--more-->

대전 이전의 전투 방식은 아직도 말발굽 소리와 대포의 굉음이 지배하던 시대였다. 볼트 액션 소총은 한 발을 쏜 뒤 재장전이 필요했고, 기병대는 개활지를 휩쓸며 전장의 분위기를 바꿀 수 있다고 믿었다. 그러나 기관총이 등장하면서, 이 모든 믿음이 한순간에 뒤집혔다. 맥심 기관총 한 대는 분당 500발 이상을 퍼부었다. 공격을 감행한 보병들은 몇 초 만에 무인지대에 쓰러졌고, 전진이라는 단어는 곧 무모함의 다른 이름이 되었다.

기관총이 만든 현실은 판에 박힌 교범을 무용지물로 만들었다. 교전 경험이 없었던 지휘관들은 미리 익힌 전술을 고집하며 병사들을 총탄 속으로 내몰았다. 참호전이 전역으로 확산된 것도 이 무기 때문이었다. 병사들은 좁은 흙벽 사이에서 몸을 움츠리고, 매일같이 비가 와도 진흙탕에서 잠을 청했다. 내가 프랑스 서부전선을 답사한 기록을 읽으며 가장 오래 붙들었던 부분은, 병사들이 참호에서 자신들의 이름을 작은 철판에 새기고 서로에게 건네던 장면이었다. 언제 다시 이름을 부를 수 있을지 알 수 없었기 때문이다.

1916년 솜 전투의 첫날, 영국군 57,000명이 사상당했다는 사실을 처음 들었을 때, 그 숫자는 그저 통계처럼 느껴졌다. 하지만 전투에 참여했던 병사가 남긴 편지에는 참혹한 현실이 담겨 있었다. "우리는 걸어 나갔지만, 몇 걸음도 채 떼지 못했다. 총탄은 비처럼 쏟아졌고, 옆에 있던 친구의 헬멧이 산산조각 나는 소리를 들었다." 기관총은 단순히 병력을 소모시키는 무기가 아니라, 전장에서 인간의 존엄을 처참히 무너뜨리는 존재였다.

기관총 소리를 견딘다는 건 단순한 체력 문제가 아니었다. 끊어지지 않는 총성은 병사들의 밤을 잠식했고, 낮은 참호의 벽을 타고 전해지는 진동은 그들의 손끝을 마비시켰다. 이후 PTSD로 불리게 된 "포탄 쇼크"는 바로 그 순간의 충격에서 비롯되었다. 어느 군의관은 병사들의 손을 잡아 주며 "괜찮아, 이제 그만 누워"라고 말했지만, 분대원들은 본능적으로 다시 참호 벽에 등을 붙이고 기관총 사격이 멈추기를 기다렸다. 전쟁이 끝나고도 그들의 귀에는 총성이 계속 맴돌았다고 한다.

전쟁이 끝나며 승전국과 패전국은 모두 기관총의 유산을 대면해야 했다. 이 무기는 전쟁을 속도의 경쟁에서 버티기와 생존의 싸움으로 바꿔 놓았다. 국경을 지키는 방식, 공격을 준비하는 전략, 병사를 훈련시키는 방법까지 모든 것이 재정의되었다. 전쟁기록관에서 실제 기관총을 마주했을 때, 나는 한동안 그 앞에서 발걸음을 떼지 못했다. 차갑게 윤이 나는 강철과 방아쇠는 과거의 슬픔을 담담히 안고 있었다.

오늘 우리가 다시 이 이야기를 되새기는 이유는 단순히 역사를 나열하기 위함이 아니다. 기관총이 만들어낸 참혹한 현실을 기억함으로써, 기술이 인간에게 어떤 책임을 요구하는지 잊지 않기 위해서다. 당시의 병사들이 남긴 희미한 기록 속에서, 나는 전쟁의 잔인함을 넘어 서로를 끝내 지켜 내고자 했던 마음을 읽는다. 그들의 이야기는 시대를 넘어 우리에게 묻는다. "새로운 기술 앞에서 우리는 어떤 선택을 할 것인가?"

이 질문에 답을 찾으려 할 때마다, 나는 다시 WWI의 전장을 떠올린다. 끝없이 이어진 참호, 지평선을 가리는 연기, 그리고 멈추지 않는 기관총 소리. 그 속에서 살아남은 사람들이 남긴 기억이야말로, 우리가 앞으로의 시대를 살아가는 데 필요한 경고이자 지침이다.
```

### 9.md

**Path:** `frontend/public/posts/2024/9.md`

```markdown
---
title: "Nginx 설정 파일 구조 및 작성 방법"
date: "2024-08-29"
category: "기술"
tags: ['Nginx', 'Configuration', 'Web Server']
excerpt: "Nginx 설정 파일(conf)의 구조와 작성 방법에 대한 가이드."
readTime: "6분"
---

처음으로 `nginx.conf` 파일을 열어본 날을 아직도 잊지 못한다. `/etc/nginx/` 디렉터리 안에서 `sudo vim nginx.conf`를 입력하고 한참을 멍하니 화면을 바라보았다. 수많은 중괄호와 세미콜론이 차곡차곡 정렬된 세계는 차갑고 딱딱해 보였지만, 어쩐지 잘 구성된 악보처럼 느껴지기도 했다. 그날 이후 나는 이 파일을 여러 번 열고 닫으며 내 서버의 숨결을 조율해 나갔다.

## 기본 구조를 몸에 익히다

설정 파일을 본격적으로 이해하기 전, 나는 먼저 이렇게 디렉터리 구조를 손으로 써 내려갔다.

```bash
/etc/nginx/
├── nginx.conf          # 메인 설정 파일
├── sites-available/    # 사용 가능한 가상 호스트 설정 파일
└── sites-enabled/      # 활성화된 가상 호스트 설정 파일 (심볼릭 링크로 연결됨)
```

이 간단한 구조도 처음에는 머릿속에서 바로 그려지지 않았다. 그러나 프로젝트의 도메인을 하나씩 추가해 가며 `sites-available`에 새 파일을 만들고, `sites-enabled`로 심볼릭 링크를 연결하는 과정을 반복하다 보니, 어느새 손끝으로 그 길을 기억하게 되었다. `ln -s` 명령 하나를 실행한 뒤 `systemctl reload nginx`를 입력할 때 느껴지는 긴장감은, 아직도 나를 집중하게 만든다.

## main context에서 느낀 리듬

메인 설정 파일을 펼쳐 보면, 크게 `events`와 `http` 블록이 눈에 들어온다. 나는 이 블록들을 마치 오케스트라의 지휘 파트처럼 생각한다.

```code
# Main context
user www-data;
worker_processes auto;
pid /run/nginx.pid;
events {
    worker_connections 1024;
}

# HTTP context
http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    sendfile on;
    keepalive_timeout 65;

    # Gzip 설정
    gzip on;

    # Server block
    server {
        listen 80;  # HTTP 포트
        server_name example.com www.example.com;

        # 로그 파일 경로
        access_log /var/log/nginx/example.access.log;
        error_log /var/log/nginx/example.error.log;

        # Location block
        location / {
            root /var/www/html;
            index index.html index.htm;
        }

        # 특정 경로에 대한 설정
        location /images/ {
            alias /var/www/images/;
        }

        # 리버스 프록시 설정
        location /api/ {
            proxy_pass http://localhost:3000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}

```

`worker_processes`를 `auto`로 두고, `worker_connections`를 조정하면서 트래픽이 몰릴 때 서버가 어떻게 반응하는지 지켜본 순간이 있었다. 로그 파일이 빠르게 쌓이는 모습을 보며, 내가 적어 둔 설정이 실제 사용자들의 요청과 만나고 있다는 사실이 실감났다. 프록시 헤더를 하나씩 맞춰 나갈 때면, 각 요청이 어떤 경로를 따라 애플리케이션까지 도달하는지 머릿속에서 시뮬레이션했다.

## SSL을 처음 열어 보던 밤

HTTPS를 적용하던 어느 밤, 인증서를 발급받고 난 뒤 설정 파일의 SSL 블록을 작성했다. 작은 오타 하나에 `nginx -t`가 실패할까 봐, 명령을 칠 때마다 손이 굳어지는 기분이었다.

```code
server {
    listen 443 ssl;
    server_name example.com;

    ssl_certificate /etc/nginx/ssl/example.com.crt;
    ssl_certificate_key /etc/nginx/ssl/example.com.key;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
        root /var/www/html;
        index index.html;
    }
}
```

설정을 저장하고 브라우저에서 자물쇠 아이콘이 나타났을 때, 새벽 공기가 갑자기 더 신선해지는 느낌이 들었다. 암호화된 연결 그 자체보다도, 내가 사용자와의 신뢰를 위해 한 걸음을 더 내디뎠다는 사실이 마음을 흔들었다.

## Redirect와 작은 디테일들

http에서 https로 리디렉트하는 설정을 추가할 때마다, 나는 누군가의 북마크에 여전히 남아 있을 `http://` 주소를 떠올린다. 그 요청이 다시 보안 연결로 부드럽게 넘어가도록 보장하는 일은 사소해 보여도 소중한 디테일이다.

```code
server {
    listen 80;
    server_name example.com www.example.com;
    return 301 https://$host$request_uri;
}
```

`return 301`을 설정한 뒤, 혹시라도 캐싱 문제가 생기지 않을까 싶어 매번 curl을 돌려 확인했다. 작은 확인 작업이지만, 이 과정 덕분에 나중에 문제를 예방할 수 있었다.

## 수정 후에는 반드시 검증

설정을 변경하고 나면 항상 아래 명령을 순서대로 실행한다. 한 번은 reload 대신 restart를 서둘러 실행했다가, 실수로 다운타임을 만들어버린 이후부터 생긴 습관이다. 정리해 보면 이렇다.

```code
# 설정 파일 문법 확인
sudo nginx -t

# 설정을 다시 불러오기 (다운타임 없이)
sudo systemctl reload nginx

# Nginx 재시작
sudo systemctl restart nginx

```

`nginx -t`에서 "syntax is ok"라는 메시지를 보면 마음이 놓인다. 성공적인 reload 이후에는 혹시 모를 캐시를 걱정하며 브라우저를 새로고침한다. 콘솔에 흐르는 로그를 바라보면서, 아직 더 나은 구조가 없는지 스스로에게 묻는다.

---

이제는 설정 파일을 업데이트할 때마다 그날의 경험을 간단히 기록해 둔다. 시행착오 속에서 익힌 작은 노하우들이 쌓이면, 다음 번에는 덜 헤매게 되기 때문이다. Nginx 설정을 다룬다는 것은 단순한 문법을 넘어, 서버를 둘러싼 흐름을 이해하고 삶의 리듬과 어쩐지 닮은 형태로 조율하는 일이라는 걸 조금씩 배워 가는 중이다.
```

### _index.md

**Path:** `frontend/public/posts/2024/_index.md`

```markdown
---
title: "영화"
description: "영화 리뷰와 분석, 철학적 사고를 담은 시네마 에세이"
cascade:
  show_breadcrumb: true
  commentable: true
  show_related: true
  share: true
  categories:
    - 영화
    - 철학
    - 예술
    - 문화
menu:
  main:
    parent: entertainment
    weight: 20
---

영화를 통해 철학과 예술, 인간의 본질에 대해 탐구합니다.

## 주요 테마

- **철학적 영화 분석**: 영화 속 철학적 메시지와 상징
- **심리학과 시네마**: 영화가 보여주는 인간 심리  
- **예술로서의 영화**: 시각적 서사와 미학적 가치
- **문화적 맥락**: 시대정신과 사회적 메시지

영화는 단순한 오락을 넘어 인간의 삶과 사회를 반영하는 거울입니다. 
각 작품이 담고 있는 깊은 의미와 메시지를 함께 탐구해보세요.
```

### ai-personalized-learning-system.md

**Path:** `frontend/public/posts/2024/ai-personalized-learning-system.md`

```markdown
---
title: "AI 기반 맞춤형 학습 시스템 프로젝트"
date: "2024-06-08"
category: "AI"
tags: ['AI 교육', '맞춤형 학습', '간격 반복', '인출 연습', '이중부호화', '학습 시스템']
excerpt: "인간의 기억 메커니즘과 과학적 학습법을 AI 기술과 결합하여 개인화된 학습 경험을 제공하는 혁신적인 교육 시스템 설계."
readTime: "6분"
---

## 왜 이 프로젝트를 시작했나?

솔직히 말하면, 시험 기간마다 밤새워 벼락치기하면서도 금세 까먹는 내 자신을 보며 '이게 맞나?' 싶었다. 특히 전공 수업에서 배운 내용들이 다음 학기가 되면 기억이 가물가물해지는 게 너무 답답했다.

그러다가 인지과학 수업에서 배운 '간격 반복 학습'이나 '인출 연습' 같은 걸 듣고 '아, 이런 방법들을 AI로 자동화할 수 있지 않을까?' 생각하게 됐다. 사실 처음엔 그냥 내가 쓸 공부 도구를 만들어보자는 심정이었는데, 생각해보니 이런 고민을 하는 사람이 나만은 아닐 거라는 생각이 들었다.

## 내가 구상한 시스템 핵심 아이디어

### 1. 진짜로 '기억에 남는' 학습을 위한 AI 엔진

사실 이런 학습법들은 예전부터 있었던 건데, 문제는 이걸 혼자서 꾸준히 실천하기가 정말 어렵다는 거였다.

#### 간격 반복 학습 - 이제 알아서 해줘!

가장 먼저 구현해보고 싶었던 게 간격 반복 학습이었다. 에빙하우스 망각 곡선 같은 걸 배우면서 '아, 진짜로 이걸 활용해서 공부하면 좋겠다'고 생각했는데, 막상 손으로 하려니까 너무 번거로웠다.

```python
class SpacedRepetitionEngine:
    def __init__(self):
        self.user_memory_patterns = {}
        self.review_scheduler = ReviewScheduler()
    
    def calculate_next_review(self, concept_id, user_performance):
        # 사용자별로 기억 패턴이 다르니까 개인화해서 계산
        if user_performance > 0.8:
            interval = self.increase_interval(concept_id)
        else:
            interval = self.decrease_interval(concept_id)
        return interval
```

처음엔 단순하게 '정답률 높으면 간격 늘리고, 낮으면 줄이자' 정도로 생각했는데, 실제로 구현해보니 개인차가 생각보다 크더라. 어떤 사람은 수학은 잘 기억하는데 영단어는 자꾸 까먹고, 또 어떤 사람은 그 반대이고...

#### 인출 연습 - 그냥 읽기만 하면 안 된다는 걸 깨달았다

대학교 와서 가장 크게 깨달은 게, 교과서 여러 번 읽는다고 해서 시험을 잘 보는 게 아니라는 거였다. 실제로 문제를 풀어봐야 하고, 내가 정말 이해했는지 스스로 확인해봐야 한다는 걸 늦게나마 알게 됐다.

그래서 시스템이 알아서 내가 공부한 내용을 바탕으로 문제를 만들어주면 어떨까 생각했다.

**내가 생각한 구현 방식:**
- 내가 공부한 내용을 분석해서 자동으로 문제 만들어주기
- 틀린 문제는 다시 나중에 다른 방식으로 출제하기
- 내가 자주 틀리는 패턴을 찾아서 그 부분 집중 공략하기

처음에는 '그냥 GPT API 쓰면 되겠지' 생각했는데, 막상 해보니 단순히 "이 내용으로 문제 만들어줘" 하면 퀄리티가 들쭉날쭉하더라. 그래서 문제 유형별로 다른 프롬프트를 써야겠다고 생각했다.

#### 이중부호화 - 글자만 보면 졸린다

솔직히 나는 글자만 빽빽한 교재를 보면 집중이 잘 안 된다. 그림이나 도표가 있으면 훨씬 이해가 잘 되는 편이다. 이중부호화이론이라는 게 있다는 걸 알고 나서 '아, 이래서 내가 시각 자료를 선호하는구나' 싶었다.

그래서 텍스트로 된 내용을 자동으로 다이어그램이나 플로우차트로 만들어주는 기능을 넣고 싶었다. 물론 완벽하게는 안 되겠지만, 적어도 핵심 개념들을 정리해서 보여주는 정도는 할 수 있을 것 같았다.

### 2. 과목별로 다른 AI 에이전트들

처음에는 '하나의 AI로 모든 과목을 다 커버하면 되지 않을까' 생각했는데, 막상 생각해보니 수학이랑 국어랑 영어는 공부하는 방식이 완전히 다르다는 걸 깨달았다.

#### 수학 전용 AI

수학은 단계별로 풀이 과정을 보여주는 게 정말 중요하다. 특히 내가 어디서 틀렸는지 정확히 짚어줘야 한다.

```python
class MathAI:
    def __init__(self):
        self.step_analyzer = StepAnalyzer()
        self.problem_generator = MathProblemMaker()
        # 내가 자주 틀리는 유형들을 기억해두기
        self.mistake_tracker = MistakeTracker()
    
    def analyze_solution(self, problem, my_answer):
        # 어디서 틀렸는지 단계별로 찾아보기
        steps = self.step_analyzer.break_down(problem)
        for i, step in enumerate(steps):
            if not self.check_step_correct(step, my_answer):
                return f"{i+1}번째 단계에서 실수: {step.explanation}"
```

수학은 정말 '과정'이 중요한 것 같다. 답만 맞추는 게 아니라 왜 그렇게 되는지 이해해야 하니까. 그래서 AI가 내 풀이 과정을 단계별로 체크해주고, 어디서 놓쳤는지 알려주면 좋겠다고 생각했다.

#### 언어 학습 AI

영어 공부할 때 가장 어려운 게 '내가 정말 이 표현을 자연스럽게 쓸 수 있나?' 하는 부분이었다. 문법은 맞는데 뭔가 어색한 문장을 만들어낼 때가 많았다.

그래서 소크라테스식 질문법이라는 걸 써서, AI가 내가 왜 그렇게 답했는지 되물어보면서 스스로 생각하게 만드는 방식을 넣어보고 싶었다.

#### 과학 AI

과학은 암기보다는 '왜 그럴까?'하는 궁금증이 중요한 것 같다. 교과서에 나온 법칙들을 그냥 외우는 게 아니라, 실생활 예시와 연결해서 이해할 수 있게 도와주는 AI를 만들고 싶었다.

### 3. 문제 만들어주는 시스템

#### PDF 같은 파일들 분석하기

사실 이 부분이 기술적으로 가장 어려웠다. 교수님이 올려주신 PPT나 PDF를 보고 거기서 핵심 내용을 뽑아내는 게 쉽지 않더라.

```python
class DocumentAnalyzer:
    def __init__(self):
        self.ocr_reader = OCREngine()  # 이미지에서 글자 뽑아내기
        self.text_processor = TextProcessor()  # 글 내용 분석하기
        self.keyword_finder = KeywordExtractor()  # 중요한 단어들 찾기
    
    def analyze_my_study_materials(self, file_path):
        # 일단 파일에서 텍스트 추출
        raw_text = self.extract_text_from_file(file_path)
        
        # 중요해 보이는 부분들 찾기 (제목, 굵은 글씨, 하이라이트 등)
        important_parts = self.find_key_concepts(raw_text)
        
        # 이걸로 문제 만들 수 있을지 판단
        return self.create_practice_questions(important_parts)
```

처음에는 OCR만 쓰면 될 줄 알았는데, 실제로 해보니 PDF 레이아웃이 복잡하면 글자 순서가 엉망으로 나오더라. 특히 2단 레이아웃이나 표가 있으면 더 심했다. 그래서 단순히 텍스트만 뽑는 게 아니라 문서 구조도 함께 파악해야겠다고 생각했다.

#### 자동 태깅 - 문제 분류하기

YOLO 같은 객체 인식 기술을 참고해서, 문제를 보고 자동으로 "이건 미분 문제야", "이건 독해 문제야" 하고 분류해주는 시스템을 만들고 싶었다. 사실 처음에는 간단할 줄 알았는데, 문제 유형이 생각보다 다양하고 애매한 경우도 많더라.

그래서 사용자 피드백을 받아서 점점 정확해지도록 하는 방식으로 접근했다. "이 문제가 난이도 3이 맞나요?" 하고 물어봐서, 그 답변을 바탕으로 시스템이 학습하게 하는 거다.

#### 맞춤형 시험 시스템

```python
class PersonalizedTestEngine:
    def __init__(self):
        self.weakness_analyzer = WeaknessAnalyzer()
        self.question_selector = SmartQuestionPicker()
        # 내 실력 레벨 추적하기
        self.skill_tracker = SkillLevelTracker()
    
    def make_test_for_me(self, subject, time_limit):
        # 내가 약한 부분 위주로 문제 선별
        weak_areas = self.weakness_analyzer.find_my_weak_spots()
        
        # 시간 안에 풀 수 있을 만큼 적당한 난이도로
        questions = self.question_selector.pick_optimal_questions(
            weak_areas, my_current_level, time_limit
        )
        return questions
```

## 실제로 써봤을 때의 경험

### 맞춤형 학습 자료 만들기

#### PDF 자동 생성 - 내 약점만 모은 문제집

가장 뿌듯했던 기능 중 하나가 이거였다. 시스템이 내가 자주 틀리는 유형들을 분석해서, 그것만 모은 맞춤형 문제집을 PDF로 만들어주는 거였다.

```python
from reportlab.pdfgen import canvas

class MyPersonalPDFMaker:
    def make_custom_workbook(self, my_weak_areas):
        # 내 이름으로 된 문제집 만들기
        pdf_name = f"nodove_맞춤_문제집_{today}.pdf"
        
        # 내가 자주 틀리는 문제들만 골라서 담기
        targeted_problems = self.pick_problems_for_my_weakness(my_weak_areas)
        
        # 예쁘게 레이아웃해서 PDF로 저장
        self.make_nice_looking_pdf(targeted_problems, pdf_name)
        return pdf_name
```

처음에 이걸 써봤을 때 정말 신기했다. '어? 이 문제들이 진짜 내가 약한 부분들이네?' 하는 생각이 들었다. 물론 완벽하지는 않았지만, 적어도 내가 직접 문제를 골라서 정리하는 것보다는 훨씬 효율적이었다.

#### 실수 패턴 분석 - 내가 왜 자꾸 틀리는지 알게 됐다

사실 이 기능이 가장 도움이 됐다. 단순히 "틀렸다" 하고 끝나는 게 아니라, 왜 틀렸는지 패턴을 찾아주니까.

예를 들어, 수학에서 내가 항상 부호 실수를 한다든지, 영어에서 관사를 빼먹는다든지... 이런 걸 데이터로 보여주니까 '아, 나는 이런 실수를 자주 하는구나' 하고 자각하게 되더라.

#### 개념 연결 맵 - 뭔가 다 연결되어 있다는 걸 깨달았다

마인드맵 형태로 개념들 사이의 관계를 보여주는 기능도 넣었다. 처음에는 '그냥 예쁘게 보이라고 만든 건가?' 싶었는데, 막상 써보니 진짜 도움이 됐다.

특히 물리 공부할 때, 운동량-에너지-힘 이런 개념들이 어떻게 연결되는지 시각적으로 보니까 훨씬 이해가 잘 됐다.

### 대화형 AI와 공부하기

#### AI 튜터와 대화하면서 공부하기

```python
class MyAITutor:
    def chat_with_me(self, my_question):
        # 바로 답 알려주지 말고 힌트부터 주기
        hints = self.generate_socratic_hints(my_question)
        
        # 내가 답을 찾아갈 수 있도록 도와주기
        if self.am_i_on_right_track(my_response):
            return "좋아! 그럼 다음 단계는 뭘까?"
        else:
            return "음, 다시 생각해볼까? 이런 건 어때?"
```

이 기능 만들 때 가장 어려웠던 게, AI가 너무 친절해서 답을 바로 알려주려고 하는 거였다. 소크라테스식 질문법이라는 게 '질문으로 답하기'인데, 이걸 자연스럽게 구현하는 게 생각보다 어려웠다.

그래도 제대로 작동할 때는 정말 좋았다. 마치 옆에서 선배가 "이건 어떻게 생각해?" 하고 물어보는 느낌이었다.

#### 피드백 시스템 - 단순히 맞다/틀렸다가 아니라

기존 문제집들은 그냥 "정답: ③" 이런 식으로 끝나는데, 내 시스템은 왜 그게 답인지, 내가 왜 틀렸는지까지 설명해주려고 했다.

특히 내가 선택한 오답이 왜 틀렸는지 구체적으로 알려주는 부분이 유용했다. "너는 A를 선택했는데, 이건 B를 고려하지 않았기 때문이야" 이런 식으로.

#### 내 학습 패턴 분석 - 데이터로 보는 나의 공부

```python
import matplotlib.pyplot as plt

class MyStudyAnalytics:
    def show_my_study_pattern(self):
        # 내가 언제 집중이 잘 되는지
        best_time = self.find_my_peak_hours()
        
        # 어떤 과목이 강한지/약한지  
        subject_scores = self.analyze_my_performance()
        
        # 앞으로 어떻게 발전할 것 같은지 예측
        predicted_growth = self.predict_my_improvement()
        
        self.make_pretty_charts(best_time, subject_scores, predicted_growth)
```

이 기능이 생각보다 재밌었다. 내가 보통 밤에 공부를 잘한다고 생각했는데, 데이터를 보니까 실제로는 오후 2-4시가 가장 집중이 잘 되더라. 이런 걸 알고 나니까 공부 시간을 조정하게 됐다.

## 기술적으로 어려웠던 부분들

### AI 모델 선택하고 연결하기

#### 여러 AI 모델 조합해서 쓰기

```python
import openai
from transformers import pipeline

class MultipleAIManager:
    def __init__(self):
        self.gpt_client = openai.Client()  # 일반적인 대화용
        self.math_model = pipeline('text-generation', model='microsoft/DialoGPT-medium')  # 수학 특화
        self.science_model = pipeline('text-generation', model='allenai/scibert_scivocab_uncased')  # 과학 특화
    
    def pick_right_ai_for_task(self, subject, task_type):
        if subject == 'math':
            return self.math_model
        elif subject == 'science':  
            return self.science_model
        else:
            return self.gpt_client  # 기본값
```

처음에는 GPT 하나로 모든 걸 해결하려고 했는데, 막상 해보니 과목별로 특화된 모델을 쓰는 게 훨씬 좋더라. 특히 수학 문제 해설할 때는 수학 전용 모델이 단계별 설명을 훨씬 잘했다.

하지만 여러 모델을 동시에 관리하는 게 생각보다 복잡했다. 각각 API 형식도 다르고, 응답 속도도 달라서 사용자가 기다리는 시간을 맞추는 게 어려웠다.

#### 이미지 분석 - OCR이 생각보다 까다로웠다

문서에서 텍스트 뽑아내는 게 간단할 줄 알았는데, 실제로는 정말 까다로웠다. 특히 수학 수식이나 그래프가 섞여 있으면 OCR이 제대로 인식을 못하더라.

```python
import cv2
import pytesseract

class DocumentReader:
    def read_complex_document(self, image_path):
        # 이미지 전처리 (노이즈 제거, 대비 조정 등)
        img = cv2.imread(image_path)
        processed_img = self.preprocess_image(img)
        
        # 텍스트 영역과 그래프/수식 영역 구분하기
        text_regions = self.find_text_areas(processed_img)
        formula_regions = self.find_formula_areas(processed_img)
        
        # 각각 다른 방식으로 처리
        text_content = pytesseract.image_to_string(text_regions)
        formula_content = self.analyze_formulas(formula_regions)
        
        return self.combine_results(text_content, formula_content)
```

결국 수식은 별도로 처리하는 방식으로 가야겠다고 생각했다. 그런데 이것도 완벽하지는 않아서, 사용자가 직접 수정할 수 있는 기능을 넣었다.

### 사용자 인터페이스 만들기

#### React로 파일 업로드 만들기

사용자가 쉽게 자료를 올릴 수 있게 드래그 앤 드롭 기능을 넣고 싶었다.

```javascript
const FileUploader = () => {
    const [uploadedFiles, setUploadedFiles] = useState([]);
    const [analysisResult, setAnalysisResult] = useState(null);
    
    const handleDrop = async (files) => {
        // 파일들을 서버로 보내서 분석하기
        const formData = new FormData();
        files.forEach(file => formData.append('study_materials', file));
        
        try {
            const response = await fetch('/api/analyze-my-documents', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            setAnalysisResult(result);
            
            // 사용자에게 "분석 완료!" 알려주기
            alert('자료 분석이 완료됐어요!');
        } catch (error) {
            alert('어? 뭔가 잘못됐네요. 다시 해볼까요?');
        }
    };
    
    return (
        <div 
            onDrop={handleDrop}
            className="upload-area"
        >
            여기에 PDF나 이미지를 끌어다 놓으세요!
            {analysisResult && <ResultDisplay data={analysisResult} />}
        </div>
    );
};
```

UI 만들 때 가장 신경 쓴 부분이 "사용하기 쉬워야 한다"는 거였다. 복잡한 설정 없이 그냥 파일만 끌어다 놓으면 알아서 분석해주도록 했다.

#### 학습 현황 대시보드

내 공부 상황을 한눈에 볼 수 있는 대시보드를 만들고 싶었다. 하지만 너무 복잡하면 오히려 헷갈릴 것 같아서, 정말 필요한 정보만 보여주려고 했다.

## 추가로 넣고 싶었던 기능들

### 친구들과 함께 공부하기

혼자 공부하는 것도 좋지만, 가끔은 친구들과 함께 하면 더 재밌을 것 같았다. 서로 문제집을 공유하거나, 같이 문제를 풀어보는 기능을 넣으면 어떨까 생각했다.

### 음성으로 공부하기

```python
import speech_recognition as sr
from gtts import gTTS

class VoiceStudyHelper:
    def listen_to_my_question(self):
        # 내가 말하는 걸 텍스트로 변환
        r = sr.Recognizer()
        with sr.Microphone() as source:
            audio = r.listen(source)
            
        try:
            question = r.recognize_google(audio, language='ko-KR')
            return self.process_voice_question(question)
        except:
            return "잘 안 들렸어요. 다시 말해주세요!"
    
    def speak_answer(self, answer_text):
        # AI 답변을 음성으로 들려주기
        tts = gTTS(text=answer_text, lang='ko')
        tts.save("answer.mp3")
        # mp3 파일 재생하기
```

특히 영어 공부할 때 발음 연습도 같이 할 수 있으면 좋겠다고 생각했다. 하지만 음성 인식 정확도가 아직 완벽하지 않아서, 나중에 기술이 더 발전하면 제대로 구현해보고 싶다.

### AI 공부 코치

단순히 문제만 내주는 게 아니라, 내 공부 습관까지 분석해서 조언해주는 AI 코치가 있으면 어떨까 생각했다.

"너는 보통 밤에 집중이 잘 안 되니까, 오후에 어려운 과목을 먼저 하는 게 어때?" 이런 식으로 말이다.

## 지금까지 해보고 느낀 점

사실 이 프로젝트를 시작할 때는 '그냥 내가 쓸 공부 도구 하나 만들어보자' 정도였는데, 막상 해보니 생각보다 복잡한 문제들이 많았다.

기술적인 부분도 어려웠지만, 가장 어려웠던 건 '정말로 도움이 되는 기능'과 '그냥 있으면 좋을 것 같은 기능'을 구분하는 거였다. 처음에는 이것저것 다 넣고 싶었는데, 실제로 써보니 정말 필요한 기능은 생각보다 많지 않더라.

간격 반복 학습이나 인출 연습 같은 과학적으로 검증된 방법들을 AI로 자동화하는 게 핵심이고, 나머지는 부가적인 기능이라는 걸 깨달았다.

그리고 무엇보다, 아무리 좋은 시스템이라도 결국 '꾸준히 쓰는 게' 가장 중요하다는 걸 느꼈다. 기술이 공부를 대신해주는 건 아니니까.

앞으로도 계속 개선해나가면서, 실제로 학습에 도움이 되는 도구로 발전시켜보고 싶다. 특히 다른 학생들도 함께 쓸 수 있게 해서, 서로의 피드백을 받으며 더 나은 시스템을 만들어가고 싶다.
```

### algorithm-atelier-bfs.md

**Path:** `frontend/public/posts/2024/algorithm-atelier-bfs.md`

```markdown
---
title: "알고리즘 아틀리에: BFS — 5단계 직관 학습"
date: "2024-11-16"
category: "Algorithm"
tags: ["BFS", "그래프", "최단경로(무가중치)", "큐", "알고리즘 아틀리에"]
excerpt: "물결 비유로 시작해 큐 기반 레이어 탐색의 원리와 코드를 연결합니다."
readTime: "6분"
---

# 알고리즘 아틀리에: BFS

## Block 1: 비유법으로 패턴 파악 (Analogy)

- Story: 호수에 돌을 던지면 동심원이 바깥으로 번집니다. 출발점에서 1칸, 2칸, 3칸… 같은 "거리 레벨"로 파동이 확장됩니다. 가장 먼저 닿는 시점이 곧 최단 이동 횟수입니다.
- Quiz — 핵심 원칙은?
  - A. 가장 멀리 보이는 지점을 먼저 간다 (오답)
  - B. 출발점에서 거리(간선 수)가 같은 정점들을 한 레벨씩 모두 방문한다 (정답)
  - C. 가중치가 작은 간선을 우선한다 (오답: 다익스트라 혼동)

## Block 2: 원리 이해 (Principle)

- Core Principle: BFS는 "간선 가중치가 동일(=1)"일 때 최단 경로를 보장한다. 같은 거리 레벨을 전부 처리한 후에 다음 레벨로 넘어가므로, 어떤 정점이 처음 방문되는 순간이 그 정점까지의 최소 이동 횟수다.
- 왜 성립하는가?
  - 레벨 단위로 파동처럼 확장하기 때문. 더 긴 레벨에서 더 짧은 경로가 나올 수 없다.

## Block 3: 세부 작동 방식 (Mechanism)

- 절차: 큐에 시작점을 넣고, pop하면서 이웃을 방문한다. 방문 시 거리[이웃] = 거리[현재]+1로 갱신한다. 이미 방문한 노드는 다시 큐에 넣지 않는다.
- 예측 퀴즈: 현재 레벨의 모든 노드를 처리했으면 다음에 큐에 들어갈 노드의 공통 특성은? → 거리 값이 동일한 다음 레벨.

## Block 4: 자료구조 연결 (Data Structure)

- 필수 도구: 큐(파이썬 deque). 선입선출이 레벨 순회를 자연스럽게 보장한다.
- 잘못된 선택: 스택(LIFO)을 쓰면 깊이 우선(DFS)으로 변해 레벨 보장이 깨진다.

## Block 5: 실제 코드 문제 (Application)

- 문제: 0/1이 아닌, 벽(1)과 빈칸(0)으로 구성된 격자에서 시작점→도착점까지 최소 이동 횟수를 구하라. 네 방향 이동, 격자 밖 불가.

```python
from collections import deque

def bfs_min_steps(grid, sx, sy, tx, ty):
    n, m = len(grid), len(grid[0])
    INF = 10**9
    dist = [[INF]*m for _ in range(n)]
    dist[sx][sy] = 0
    q = deque([(sx, sy)])
    DIRS = [(1,0),(-1,0),(0,1),(0,-1)]

    while q:
        x, y = q.popleft()
        if (x, y) == (tx, ty):
            return dist[x][y]
        for dx, dy in DIRS:
            nx, ny = x+dx, y+dy
            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:
                if dist[nx][ny] == INF:
                    dist[nx][ny] = dist[x][y] + 1
                    q.append((nx, ny))
    return -1
```

- Staged Hints
  - Hint 1: "물결"은 선입선출일 때만 아름답게 퍼집니다.
  - Hint 2: 처음 방문 순간 = 최단 이동 횟수.
  - Hint 3: 방문 체크(또는 거리 초기화)를 큐에 넣을 때 즉시 수행해야 중복 방문을 막을 수 있습니다.

- Test Case Visualization(개념)
  - 실패 케이스의 격자를 단계별 레벨 착색으로 재생해, 막힌 지점과 방문 순서를 시각적으로 확인합니다.

---

요약: BFS는 "거리 = 간선 수" 세계에서 최단을 보장하는 단순하지만 강력한 레벨 순회입니다. 큐의 힘을 믿으세요.

---

## Interactive Add‑ons

<div class="mcq" data-answer="B">
  <p><strong>퀴즈:</strong> BFS가 최단 이동 횟수를 보장하는 이유는?</p>
  <label><input type="radio" name="q-bfs-1" value="A"> 가장 멀리 보이는 곳부터 탐색</label><br>
  <label><input type="radio" name="q-bfs-1" value="B"> 같은 거리 레벨을 모두 처리한 뒤 다음 레벨로 진행</label><br>
  <label><input type="radio" name="q-bfs-1" value="C"> 간선 가중치가 작은 것을 우선</label><br>
  <button class="mcq-submit">확인</button>
  <div class="mcq-feedback" hidden></div>
</div>

<details style="margin-top: 1rem;"><summary>Hint 1</summary> 선입선출 큐가 레벨 순회를 보장합니다.</details>
<details><summary>Hint 2</summary> "처음 방문 순간"이 바로 최단 이동 횟수입니다.</details>
<details><summary>Hint 3</summary> 방문 체크는 큐에 넣을 때 즉시!</details>

<script>
(function(){
  document.querySelectorAll('.mcq').forEach(function(mcq){
    var answer = mcq.dataset.answer;
    var btn = mcq.querySelector('.mcq-submit');
    var fb = mcq.querySelector('.mcq-feedback');
    btn && btn.addEventListener('click', function(){
      var checked = mcq.querySelector('input[type=radio]:checked');
      fb.hidden = false;
      if(!checked){ fb.textContent='선택해주세요.'; fb.style.color='#b45309'; return; }
      if(checked.value === answer){ fb.textContent='정답! ✅'; fb.style.color='#065f46'; }
      else { fb.textContent='오답입니다. 다시 생각해보세요.'; fb.style.color='#991b1b'; }
    });
  });
})();
</script>

```

### algorithm-atelier-binary-search.md

**Path:** `frontend/public/posts/2024/algorithm-atelier-binary-search.md`

```markdown
---
title: "알고리즘 아틀리에: 이분 탐색 — 5단계 직관 학습"
date: "2024-11-18"
category: "Algorithm"
tags:
  [
    "이분탐색",
    "Binary Search",
    "단조성",
    "파라메트릭 서치",
    "알고리즘 아틀리에",
  ]
excerpt: "단조성 위에 세운 불변식과 범위 수축 — 답을 직접 찾지 말고 조건을 이분합니다."
readTime: "6분"
---

# 알고리즘 아틀리에: 이분 탐색

## Block 1: 비유법으로 패턴 파악 (Analogy)

- Story: 책을 반으로 갈라 번호를 맞추는 사서. 찾는 페이지가 중간보다 크면 왼쪽을 버리고, 작으면 오른쪽을 버린다. 매번 범위를 절반으로 줄인다.
- Quiz — 핵심 원칙은?
  - A. 가운데가 정답이다 (오답)
  - B. "참/거짓"이 단조롭게 변하는 조건을 두고, 그 경계 지점을 찾는다 (정답)
  - C. 무조건 정답 후보를 직접 비교한다 (오답)

## Block 2: 원리 이해 (Principle)

- Core Principle: 단조성(monotonicity)과 불변식(invariant). 구간 [lo, hi)에서 P(x)가 거짓→참으로 한 번만 변한다고 가정하면, 탐색 중 항상 정답이 구간 안에 남도록 분기한다.
- 왜 성립하는가?
  - 매 단계 절반 제거(로그 시간) + 불변식 유지(정답 제거 금지) 덕분. 정답은 언젠가 길이가 1인 구간에 고립된다.

## Block 3: 세부 작동 방식 (Mechanism)

- 패턴 코드(최소 참 찾기):

```python
def lower_bound_ok(min_x, max_x, ok):
    lo, hi = min_x, max_x  # [lo, hi)
    while lo < hi:
        mid = (lo + hi) // 2
        if ok(mid):
            hi = mid
        else:
            lo = mid + 1
    return lo  # 최소 참의 위치
```

- 예측 퀴즈: 경계 갱신 시 어느 쪽을 버려야 하나? → ok(mid)=True면 [mid, hi)를 버리고 [lo, mid]로 수축.

## Block 4: 자료구조 연결 (Data Structure)

- 필수 전제: 정렬 또는 단조 predicate. 정렬된 배열에서 값 찾기, 혹은 파라메트릭 서치(정답 값을 매개변수로 두고 검사 함수 ok(x)로 판단) 모두 동일 원리.

## Block 5: 실제 코드 문제 (Application)

- 문제(파라메트릭 서치): 작업량 배열 jobs와 기간 D가 주어질 때, 하루 처리 용량 cap를 최소화하여 D일 내 모두 처리 가능하게 하라. 하루에 cap만큼 처리 가능하며 다음 날로 이월 가능.

```python
def min_capacity(jobs, D):
    def ok(cap):
        days, cur = 1, 0
        for w in jobs:
            if w > cap:
                return False
            if cur + w <= cap:
                cur += w
            else:
                days += 1
                cur = w
        return days <= D

    lo, hi = 1, sum(jobs)  # [lo, hi]
    while lo < hi:
        mid = (lo + hi) // 2
        if ok(mid):
            hi = mid
        else:
            lo = mid + 1
    return lo
```

- Staged Hints
  - Hint 1: "정답 자체를 맞추지 말고, 가능/불가능을 빨리 가려라".
  - Hint 2: 불변식 — 정답은 항상 [lo, hi] 안에 남아야 한다.
  - Hint 3: 경계 조건(무한 루프 방지)과 overflow(언어별) 주의.

- Test Case Visualization(개념)
  - 각 mid에서 ok(mid) 결과를 타임라인으로 표시해, 경계가 어떻게 이동하는지 시각화한다.

---

요약: 이분 탐색은 "단조 predicate의 경계"를 로그 시간에 찾는 기술입니다. 문제를 ok(x)로 바꿔 생각하는 순간, 길이 보입니다.

---

## Interactive Add‑ons

<div class="mcq" data-answer="B">
  <p><strong>퀴즈:</strong> 이분 탐색의 본질은 무엇인가?</p>
  <label><input type="radio" name="q-bs-1" value="A"> 정답을 직접 맞춘다</label><br>
  <label><input type="radio" name="q-bs-1" value="B"> 단조 predicate의 경계를 찾는다</label><br>
  <label><input type="radio" name="q-bs-1" value="C"> 정답 후보를 모두 비교한다</label><br>
  <button class="mcq-submit">확인</button>
  <div class="mcq-feedback" hidden></div>
</div>

<details style="margin-top: 1rem;"><summary>Hint 1</summary> ok(x)로 바꿔 생각하세요: 가능/불가능.</details>
<details><summary>Hint 2</summary> 불변식: 정답은 항상 [lo, hi]에 남는다.</details>

<script>
(function(){
  document.querySelectorAll('.mcq').forEach(function(mcq){
    var answer = mcq.dataset.answer;
    var btn = mcq.querySelector('.mcq-submit');
    var fb = mcq.querySelector('.mcq-feedback');
    btn && btn.addEventListener('click', function(){
      var checked = mcq.querySelector('input[type=radio]:checked');
      fb.hidden = false;
      if(!checked){ fb.textContent='선택해주세요.'; fb.style.color='#b45309'; return; }
      if(checked.value === answer){ fb.textContent='정답! ✅'; fb.style.color='#065f46'; }
      else { fb.textContent='오답입니다. 다시 생각해보세요.'; fb.style.color='#991b1b'; }
    });
  });
})();
</script>

```

### algorithm-atelier-dijkstra.md

**Path:** `frontend/public/posts/2024/algorithm-atelier-dijkstra.md`

```markdown
---
title: "알고리즘 아틀리에: 다익스트라 — 5단계 직관 학습"
date: "2024-11-15"
category: "Algorithm"
tags: ["다익스트라", "최단경로", "그래프", "우선순위 큐", "알고리즘 아틀리에"]
excerpt: "비유→원리→메커니즘→자료구조→코드로 다익스트라를 직관적으로 체득합니다."
readTime: "7분"
---

# 알고리즘 아틀리에: 다익스트라

본 글은 PRD의 5단계 학습 여정(비유→원리→메커니즘→자료구조→코드)에 맞추어, "왜"에서 출발해 "어떻게"까지 연결되는 직관 학습을 제공합니다.

## Block 1: 비유법으로 패턴 파악 (Analogy)

- Interactive Story: 도시(가중치 그래프)에 불이 났습니다. 당신은 소방서(출발점)에서 가장 빨리 도착할 수 있는 길만을 따라 화재 범위를 좁혀야 합니다. 매 순간 "지금까지 누적 시간이 가장 짧은 교차로"를 먼저 확정하고, 그 이웃으로 탐색 범위를 넓혀갑니다.
- Multiple Choice Quiz — 핵심 원칙은?
  - A. 불난 곳과 물리적으로 더 가까워 보이는 교차로부터 탐색한다 (오답: 휴리스틱 혼동 — A\*)
  - B. 거치는 교차로 수가 가장 적은 길을 우선한다 (오답: BFS 혼동)
  - C. 출발점으로부터 "현재까지 누적된 시간"이 가장 짧은 지점부터 다음 길을 탐색한다 (정답)

## Block 2: 원리 이해 (Principle)

- Core Principle Statement: 다익스트라는 탐욕법(Greedy)에 기반하며, "이미 확정된 최단 경로"의 경계를 점진적으로 넓혀 나간다.
- 왜 성립하는가?
  - A 지점의 최단 거리가 10으로 확정됐다면, 다른 경로를 통해 A를 더 싸게 도달하는 길은 존재하지 않는다. 더 멀리 돌아와도 누적 가중치는 반드시 10 이상이기 때문이다. 이 불변식이 탐욕 선택의 정당성을 보장한다.
- Checkpoint Q: "가장 작은 누적 거리 노드"를 확정할 때, 그 노드로 더 짧게 들어오는 경로가 나중에 발견될 수 있을까?
  - A. 가능하다 B. 불가능하다(정답)

## Block 3: 세부 작동 방식 (Mechanism)

- Algorithm Visualizer(개념):
  1. 시작 노드의 거리를 0으로, 나머지는 ∞로 설정한다.
  2. 아직 확정되지 않은 노드 중, 최솟값(누적 거리)이 있는 노드를 꺼낸다.
  3. 그 노드의 모든 이웃에 대해 더 짧은 경로를 발견하면 거리 값을 갱신(relaxation)한다.
  4. 2~3을 반복한다.
- Interactive Simulation — 다음 선택은?
  - 정지 화면: 거리 테이블이 {A:0, B:5, C:8, D:∞, E:…}일 때 다음 방문 노드는? 정답: B (5가 가장 작음). 오답을 고르면 "D의 8보다 B의 5가 작습니다" 팝업.
- 실수 포인트
  - 방문 확정(visited)과 거리 갱신(relaxation)을 구분하지 않으면 중복 처리로 성능/정확도가 무너진다.

## Block 4: 자료구조 연결 (Data Structure)

- Performance Comparison(개념):
  - 배열(naive): 매 단계 최소 거리 노드 탐색에 O(V) — 전체 O(V^2)
  - 우선순위 큐 Min-Heap: 추출 O(log V), 감소-키 갱신(푸시) O(log V) — 전체 O((V+E) log V)
- Concept Matching — 요구사항→도구
  - "항상 가장 작은 누적 거리 후보를 즉시 꺼내고 싶다" → 우선순위 큐(Min-Heap)

## Block 5: 실제 코드 문제 (Application)

- 변형 문제
  - 문제: 어떤 노드를 지날 때마다 그 노드의 통행료 toll[v]가 추가로 듭니다. 시작 s에서 도착 t까지 (간선 가중치 + 노드 통행료)의 합을 최소화하세요.
  - 핵심: relaxation 시 비용을 w(u→v)+toll[v] 만큼 더해 누적 비용을 갱신한다. 시작 노드의 통행료는 상황에 따라 0으로 처리(문제 정의에 명시한다고 가정).

```python
import heapq
INF = 10**18

def dijkstra_with_toll(n, adj, toll, s, t):
    # adj[u] = list of (v, w)
    dist = [INF]*n
    dist[s] = 0
    pq = [(0, s)]  # (cost, node)

    while pq:
        cost, u = heapq.heappop(pq)
        if cost != dist[u]:
            continue
        if u == t:
            return cost
        for v, w in adj[u]:
            # 방문 시 v의 노드 통행료를 추가한다고 가정
            ncost = cost + w + (0 if v == s else toll[v])
            if ncost < dist[v]:
                dist[v] = ncost
                heapq.heappush(pq, (ncost, v))
    return dist[t]
```

- Staged Hints
  - Hint 1: 소방관 비유의 핵심 — "현재까지 가장 가까운 노드"부터 확정.
  - Hint 2: 이를 빠르게 하기 위한 도구는? → Min-Heap.
  - Hint 3: 변형의 본질은 비용 함수 수정(간선 + 노드 통행료). relaxation 식을 바꾸면 된다.

- Test Case Visualization(개념)
  - 제출이 실패한 입력을 시뮬레이터(거리 테이블/그래프 애니메이션)에 넣어, 어느 단계에서 잘못된 선택/갱신이 발생했는지 단계별로 추적한다.

---

마무리: 다익스트라는 "확정 경계"를 키우는 탐욕 + 우선순위 큐의 결합입니다. 원리를 먼저 붙잡고(왜), 그다음 자료구조와 구현(어떻게)을 결합하면 어떤 변형도 유연하게 대응할 수 있습니다.

---

## Interactive Add‑ons

<div class="mcq" data-answer="C">
  <p><strong>퀴즈:</strong> 최단 경로를 보장하기 위한 단 하나의 원칙은?</p>
  <label><input type="radio" name="q-dij-1" value="A"> 물리적으로 불난 곳과 더 가까워 보이는 교차로부터 탐색</label><br>
  <label><input type="radio" name="q-dij-1" value="B"> 거쳐가는 교차로 수가 가장 적은 길 우선</label><br>
  <label><input type="radio" name="q-dij-1" value="C"> 현재까지 누적 시간이 가장 짧은 지점부터 탐색</label><br>
  <button class="mcq-submit">확인</button>
  <div class="mcq-feedback" hidden></div>
</div>

<div class="pick-one" data-answer="B" style="margin-top: 1rem;">
  <p><strong>예측:</strong> 거리 테이블이 {A:0, B:5, C:8, D:∞}일 때 다음 방문 노드는?</p>
  <button data-value="A">A</button>
  <button data-value="B">B</button>
  <button data-value="C">C</button>
  <button data-value="D">D</button>
  <div class="pick-feedback" hidden></div>
</div>

<details style="margin-top: 1rem;"><summary>Hint 1</summary> "현재까지 가장 가까운 노드"부터 확정합니다.</details>
<details><summary>Hint 2</summary> 빠른 선택을 위해 Min‑Heap(우선순위 큐)을 사용합니다.</details>
<details><summary>Hint 3</summary> 변형은 비용 함수 수정(간선 + 노드 통행료)로 구현합니다.</details>

<script>
(function(){
  document.querySelectorAll('.mcq').forEach(function(mcq){
    var answer = mcq.dataset.answer;
    var btn = mcq.querySelector('.mcq-submit');
    var fb = mcq.querySelector('.mcq-feedback');
    btn && btn.addEventListener('click', function(){
      var checked = mcq.querySelector('input[type=radio]:checked');
      fb.hidden = false;
      if(!checked){ fb.textContent='선택해주세요.'; fb.style.color='#b45309'; return; }
      if(checked.value === answer){ fb.textContent='정답! ✅'; fb.style.color='#065f46'; }
      else { fb.textContent='오답입니다. 다시 생각해보세요.'; fb.style.color='#991b1b'; }
    });
  });
  document.querySelectorAll('.pick-one').forEach(function(box){
    var answer = box.dataset.answer;
    var fb = box.querySelector('.pick-feedback');
    box.querySelectorAll('button[data-value]').forEach(function(b){
      b.addEventListener('click', function(){
        fb.hidden = false;
        if(b.dataset.value === answer){ fb.textContent='정답! B의 5가 가장 작습니다.'; fb.style.color='#065f46'; }
        else { fb.textContent='오답. 최소 누적 거리를 확인하세요.'; fb.style.color='#991b1b'; }
      });
    });
  });
})();
</script>

```

### algorithm-atelier-dp.md

**Path:** `frontend/public/posts/2024/algorithm-atelier-dp.md`

```markdown
---
title: "알고리즘 아틀리에: 동적 계획법(DP) — 5단계 직관 학습"
date: "2024-11-17"
category: "Algorithm"
tags: ["DP", "동적계획법", "메모이제이션", "점화식", "알고리즘 아틀리에"]
excerpt: "반복되는 하위 문제와 최적 부분 구조를 비유로 깨닫고, 점화식→테이블→코드로 잇습니다."
readTime: "7분"
---

# 알고리즘 아틀리에: 동적 계획법(DP)

## Block 1: 비유법으로 패턴 파악 (Analogy)

- Story: 산행 중 갈림길마다 최적 경로 메모를 남기는 등산가. 같은 지점에 다시 왔을 때는 메모를 읽고 즉시 결정을 내립니다. "같은 하위 문제를 반복하지 말자"가 생존 전략입니다.
- Quiz — 핵심 원칙은?
  - A. 모든 갈림길을 끝까지 탐색한다(완전탐색) (오답)
  - B. 이미 해결한 하위 문제의 답을 저장하고 재사용한다(정답)
  - C. 현재 좋아 보이는 선택만 한다(탐욕, 오답)

## Block 2: 원리 이해 (Principle)

- Core Principle: DP는 "중복되는 하위 문제"와 "최적 부분 구조"가 있을 때, 상태(state)를 정의하고 점화식으로 연결해, 하위 해의 최적성이 상위 해의 최적성을 보장하도록 한다.
- 왜 성립하는가?
  - 같은 문제는 같은 답을 갖는다(참조 투명성). 또한 최적 부분 구조가 성립하면, 부분 최적의 조합이 전체 최적이 된다.

## Block 3: 세부 작동 방식 (Mechanism)

- 예시: 동전(coin set)으로 목표 금액을 만들 때 필요한 최소 동전 수(min coins).
  - 상태: dp[x] = 금액 x를 만드는 최소 동전 수
  - 초기값: dp[0] = 0, 나머지는 ∞
  - 점화식: dp[x] = min(dp[x-c] + 1) for c in coins if x>=c
  - 순회: bottom-up으로 x=1..target을 채운다(또는 top-down + memo)
- 예측 퀴즈: dp[x]를 갱신할 때 어떤 순회가 안전한가? → x를 1부터 증가시키며 각 코인으로 갱신.

## Block 4: 자료구조 연결 (Data Structure)

- 선택지: 1차원 배열(점화식이 앞선 상태만 필요할 때) vs 2차원 테이블(예: 배낭 문제)
- 구현 팁: top-down은 재귀 + dict/배열 메모, bottom-up은 반복문 + 배열. 상태 수와 전이 수에 따라 시간/공간을 평가한다.

## Block 5: 실제 코드 문제 (Application)

- 문제: 주어진 동전 집합으로 정확히 target 금액을 만드는 데 필요한 최소 동전 수를 구하라. 불가능하면 -1.

```python
def min_coins(coins, target):
    INF = 10**9
    dp = [INF]*(target+1)
    dp[0] = 0
    for x in range(1, target+1):
        for c in coins:
            if x >= c:
                dp[x] = min(dp[x], dp[x-c] + 1)
    return dp[target] if dp[target] < INF else -1
```

- Staged Hints
  - Hint 1: "같은 하위 문제를 또 풀지 말자" — 메모부터 떠올리기.
  - Hint 2: 상태 정의가 반이다. 무엇이 상태인가? 무엇이 전이인가?
  - Hint 3: 초기값과 불가능 상태(∞) 처리에 유의.

- Test Case Visualization(개념)
  - 테이블 채워지는 과정을 열지도로 재생해, 특정 금액에서 전이가 어떻게 이뤄졌는지 추적한다.

---

요약: DP는 "반복 금지 + 최적 부분 구조"를 코드화하는 기술입니다. 상태→점화식→순회 순으로 정리하면 문제는 스스로 풀립니다.

---

## Interactive Add‑ons

<div class="mcq" data-answer="B">
  <p><strong>퀴즈:</strong> DP가 필요한 전제 조건 두 가지는?</p>
  <label><input type="checkbox" name="q-dp-1" value="A"> 탐욕 선택 속성</label><br>
  <label><input type="checkbox" name="q-dp-1" value="B"> 중복되는 하위 문제</label><br>
  <label><input type="checkbox" name="q-dp-1" value="C"> 최적 부분 구조</label><br>
  <button class="chk-submit">확인</button>
  <div class="chk-feedback" hidden></div>
</div>

<details style="margin-top: 1rem;"><summary>Hint 1</summary> 같은 질문을 두 번 풀지 않는 전략.</details>
<details><summary>Hint 2</summary> 하위 해의 최적성이 상위 해의 최적성을 보장해야 합니다.</details>

<script>
(function(){
  document.querySelectorAll('.mcq').forEach(function(box){
    var btn = box.querySelector('.chk-submit');
    var fb = box.querySelector('.chk-feedback');
    btn && btn.addEventListener('click', function(){
      var checks = box.querySelectorAll('input[type=checkbox]:checked');
      var vals = Array.from(checks).map(function(x){return x.value});
      fb.hidden = false;
      var correct = vals.includes('B') && vals.includes('C') && !vals.includes('A');
      if(correct){ fb.textContent='정답! ✅ 중복 하위 문제 + 최적 부분 구조'; fb.style.color='#065f46'; }
      else { fb.textContent='오답. 두 조건을 모두 만족해야 합니다.'; fb.style.color='#991b1b'; }
    });
  });
})();
</script>

```

### algorithm-guide.md

**Path:** `frontend/public/posts/2024/algorithm-guide.md`

```markdown
---
title: "알고리즘 학습 가이드"
date: "2024-06-05"
category: "Algorithm"
tags: ['알고리즘', '학습법', '코딩테스트', '자료구조']
excerpt: "효과적인 알고리즘 공부 방법과 실전 팁을 제공합니다"
readTime: "2분"
---

# 알고리즘 공부, 어떻게 시작할까?

솔직히 처음에 알고리즘이라고 하면 너무 어려워 보였다. 특히 코딩테스트 준비할 때 '과연 내가 이걸 할 수 있을까?' 싶었다. 하지만 체계적으로 접근하니까 생각보다 할 만하더라.

## 내가 거쳐온 학습 단계들

### 1단계: 기초 다지기 (1-4주)
처음 한 달은 정말 기본기에만 집중했다.

- **자료구조 기본**: 배열, 리스트, 스택, 큐
  - 이것들은 진짜 기본 중의 기본이다. 나중에 모든 알고리즘에서 쓰이니까 확실히 해두자.
- **기본 알고리즘**: 정렬, 탐색
  - 버블정렬부터 시작해서 퀵정렬까지, 직접 구현해보면서 원리를 이해했다.
- **추천 문제**: BOJ 10871, 11720, 10845
  - 백준에서 이런 기본 문제들로 시작했다. 틀려도 괜찮다, 일단 해보는 게 중요하다.

### 2단계: 핵심 알고리즘 (5-12주)  
이 시기가 가장 힘들었다. 하지만 이걸 넘기면 확실히 실력이 늘어나는 걸 느꼈다.

- **재귀와 분할정복**: 하노이 탑, 병합정렬
  - 재귀는 처음엔 머리가 아팠다. 그런데 연습하다 보니 패턴이 보이더라.
- **동적계획법**: 피보나치, LIS, LCS
  - DP는 정말... 처음엔 왜 이렇게 푸는지 이해가 안 됐다. 하지만 문제를 많이 풀다 보니 '아, 이런 식으로 생각하는구나' 싶었다.
- **그래프 이론**: BFS, DFS, 최단경로
  - 그래프는 그림 그려가면서 하니까 이해가 잘 됐다.

### 3단계: 고급 주제 (13-16주)
여기까지 오면 웬만한 문제는 풀 수 있다는 자신감이 생긴다.

- **고급 DP**: 비트마스크, 트리 DP
- **문자열**: KMP, 라빈-카프
- **수학적 알고리즘**: 정수론, 조합론

## 내가 써본 학습 전략들

### 실제로 도움 됐던 공부법

1. **개념부터 확실히**: 이론을 이해하지 못하면 구현도 엉망이다
   - 블로그 글만 대충 읽지 말고, 왜 그렇게 작동하는지 이해하려고 노력했다.

2. **같은 유형 반복**: 비슷한 문제를 여러 번 풀어보자
   - DP 문제만 일주일 동안 팠더니 확실히 느낌이 왔다.

3. **다른 사람 코드 보기**: 내 풀이와 비교해보면 많이 배운다
   - 백준에서 맞힌 사람들 코드 보면서 '아, 이렇게도 풀 수 있구나' 했다.

4. **시간 재고 풀기**: 실제 시험처럼 연습하자
   - 처음엔 시간 신경 안 쓰고 풀었는데, 나중에 코테에서 시간 부족으로 고생했다.

### 도움 된 학습 자료들

- **온라인 저지**: 백준이 문제 수도 많고 난이도별로 잘 되어 있다
- **강의**: 프로그래머스 알고리즘 강의가 초보자한테 좋았다
- **책**: 『알고리즘 문제 해결 전략』은 나중에 읽어봤는데 깊이 있게 이해하는 데 도움 됐다

## 코딩테스트 실전 경험담

### 시간 관리가 제일 중요하다

처음 코테 볼 때는 첫 번째 문제에 너무 오래 매달렸다가 뒤 문제들을 못 풀었다.

```
내가 정한 시간 배분:
📝 문제 읽고 이해: 5분
💻 코드 짜기: 15-20분  
🧪 테스트케이스 확인: 5분
🔍 디버깅: 5분
```

### 자주 한 실수들 (진짜 많이 했다...)

- **배열 인덱스 실수**: `arr[n]` 하면 범위 벗어남... 이거 때문에 몇 번 틀렸는지
- **int 오버플로우**: 큰 수 계산할 때 long long 안 써서 답이 이상하게 나옴
- **시간복잡도 착각**: O(n²) 짜놓고 왜 시간초과인지 모르겠다고 했었다

## 레벨별 체크리스트 (내 기준)

### 초급 단계 (Bronze~Silver)
- [ ] 기본 자료구조를 직접 구현할 수 있다
- [ ] 정렬 알고리즘 5개 이상 외우지 말고 이해해서 짤 수 있다
- [ ] BFS/DFS 문제 보면 바로 알아볼 수 있다

### 중급 단계 (Gold)  
- [ ] DP 점화식을 스스로 만들 수 있다 (이게 진짜 어렵다)
- [ ] 다익스트라, 플로이드-워셜 같은 그래프 알고리즘 구현 가능
- [ ] 세그먼트 트리가 뭔지 안다 (쓸 줄은 몰라도)

### 고급 단계 (Platinum) - 여기는 아직 꿈...
- [ ] 비트마스크 DP 이해
- [ ] KMP 알고리즘 구현
- [ ] 기하 문제도 풀 수 있다

## 막혔을 때 디버깅하는 법

### 내가 자주 쓰는 디버깅 방법

```python
# 1. 간단한 입력으로 먼저 테스트
def debug_with_small_input():
    # 예상: [1, 2, 3]
    # 실제: [3, 1, 2] <- 어? 왜 이렇게 나오지?
    result = my_sorting_algorithm([3, 1, 2])
    print(f"결과: {result}")

# 2. 중간 과정 출력해서 어디서 틀렸는지 찾기
def debug_step_by_step():
    for i in range(n):
        print(f"{i}번째 단계: {current_state}")  # 이거 진짜 유용함
        # 알고리즘 실행
```

### 자주 만나는 버그들

1. **인덱스 실수**: `for i in range(n+1):` 했는데 `arr[i]` 에서 터짐
2. **변수 초기화 깜빡**: 전역변수 쓸 때 특히 조심해야 함
3. **얕은 복사 문제**: 2차원 배열 복사할 때 `[arr] * n` 하면 안 됨

---

알고리즘 공부는 진짜 꾸준함이 답인 것 같다. 하루에 한 문제씩이라도 계속 풀다 보면 어느 순간 '어? 이제 좀 보이네?' 하는 순간이 온다. 

포기하지 말고 계속 해보자! 처음엔 다들 어렵다. 나도 한동안은 Bronze 문제도 못 풀었으니까 😅
```

### arch-linux-gui-setup-experience.md

**Path:** `frontend/public/posts/2024/arch-linux-gui-setup-experience.md`

```markdown
---
title: "아치 리눅스 설치하면서 깨달은 GUI 환경 선택의 중요성"
date: "2024-11-12"
category: "Linux"
tags: ['ArchLinux', 'UEFI', 'KDE', 'GNOME', 'i3wm', 'Hyprland', '리눅스설치']
excerpt: "아치 리눅스 설치 과정에서 데스크톱 환경을 선택하면서 느낀 점들과 각 환경의 특징"
readTime: "4분"
---

아치 리눅스를 처음 설치할 때 가장 고민됐던 부분이 바로 **데스크톱 환경(DE) 선택**이었다. Windows나 Mac처럼 정해진 인터페이스가 아니라, 내가 직접 골라야 한다는 게 신선하면서도 부담스러웠다.

## 왜 GUI 환경 선택이 중요한가?

처음엔 "어차피 다 비슷하지 않을까?"라고 생각했는데, 실제로 써보니 완전히 달랐다. 

### 단순한 외관 문제가 아니다

데스크톱 환경을 선택하는 건 단순히 예쁜 화면을 고르는 게 아니라:
- **작업 흐름(workflow)** 결정
- **커스터마이징 철학** 선택  
- **시스템 리소스 사용량** 결정
- **학습 곡선의 가파름** 결정

아치 리눅스의 **DIY 정신**을 제대로 경험하려면 이 선택이 정말 중요하다.

## 주요 데스크톱 환경들의 특징

### KDE Plasma - 설정의 왕

**첫인상**: "어? 이거 Windows랑 비슷하네?"
**깊게 파보니**: "설정할 게 이렇게 많다고?!"

**장점**:
- GUI로 거의 모든 것 설정 가능
- KDE Store에서 테마 원클릭 설치
- 기능이 풍부하면서도 생각보다 가볍다
- Qt 기반이라 일관성 있는 디자인

**단점**:
- 설정 옵션이 너무 많아서 오히려 헷갈림
- 처음엔 어디서 뭘 바꿔야 할지 모르겠음

### GNOME - 애증의 미니멀리즘

**첫인상**: "깔끔하다! 근데 뭔가 부족한 느낌?"
**확장 기능 설치 후**: "아, 이래서 GNOME을 쓰는구나!"

**장점**:
- 기본 상태에서도 완성도 높은 디자인
- 터치 친화적 인터페이스
- 워크플로우가 독특하지만 익숙해지면 효율적

**단점**:  
- 기본 커스터마이징 옵션이 제한적
- 확장 기능에 의존해야 함
- "GNOME의 방식"에 적응해야 함

### XFCE - 가볍고 실용적

**첫인상**: "어? 이거 옛날 느낌인데?"
**써보니**: "가볍고 안정적이네!"

**장점**:
- 매우 가벼움
- 전통적인 인터페이스로 학습 곡선이 낮음
- 모듈러 구조로 필요한 것만 설치 가능

**단점**:
- 기본 테마가 좀 구식
- 최신 트렌드를 따라가지 못하는 느낌

## 창 관리자(WM)의 세계

데스크톱 환경이 부담스럽다면 **창 관리자**라는 선택지도 있다.

### i3wm - 키보드 워리어의 선택

**첫인상**: "마우스 없이 어떻게 쓰라고?!"
**적응 후**: "이게 더 빠르네?"

**장점**:
- 매우 가볍다
- 키보드만으로 모든 조작 가능
- 텍스트 파일로 모든 설정 관리
- 화면 공간 활용도 최대

**단점**:
- 학습 곡선이 매우 가파름
- 설정할 게 너무 많음 (상태바, 런처 등 별도 설치)

### Hyprland - 현대적인 타일링 WM

**첫인상**: "와, 이거 진짜 예쁘다!"
**설정 중**: "Wayland라서 일부 프로그램이 안 되네..."

**장점**:
- 타일링 + 현대적 시각 효과 (블러, 애니메이션)
- Wayland 네이티브
- 매우 매끄러운 동작

**단점**:
- Wayland 호환성 이슈
- 설정이 복잡함
- 상대적으로 새로운 프로젝트라 문서가 부족

## 실제 사용 경험담

### 첫 번째 시도: KDE Plasma

처음엔 "Windows랑 비슷해서 쉬울 것 같다"는 생각으로 KDE를 선택했다.

**좋았던 점**:
- 익숙한 인터페이스
- 테마 적용이 쉬움
- 필요한 프로그램들이 기본 제공

**아쉬웠던 점**:
- 너무 많은 설정 옵션에 압도됨
- "이걸 다 설정해야 하나?" 싶었음

### 두 번째 시도: i3wm

"진짜 아치 리눅스다운 경험을 해보자"는 마음으로 i3wm을 시도했다.

**도전 과정**:
1. 키바인딩 외우기 (3일)
2. 설정 파일 작성법 익히기 (1주)  
3. Polybar, Rofi 등 필수 도구 설치 (2주)
4. 만족스러운 환경 구축 (1개월)

**결과**: 정말 빠르고 효율적이지만, 학습 비용이 컸다.

### 현재 선택: Hyprland

지금은 Hyprland를 주력으로 사용 중이다.

**선택 이유**:
- i3wm의 효율성 + 현대적인 시각 효과
- Wayland의 미래 지향성
- 설정 파일 기반의 정밀한 제어

**현실적 문제들**:
- 일부 프로그램 호환성 이슈 (특히 스크린 공유)
- 설정에 시간이 많이 걸림

## X11 vs Wayland 딜레마

창 관리자를 선택하면서 **디스플레이 서버**도 고려해야 했다.

### X11의 장점
- 성숙한 생태계
- 거의 모든 프로그램 호환  
- 풍부한 도구들

### Wayland의 장점
- 현대적 아키텍처
- 보안성 향상
- 더 나은 성능 (이론적으로)

### 현실적 선택
지금은 과도기라서 **용도에 따라 선택**하는 게 좋은 것 같다:
- **안정성 우선**: X11 + i3wm
- **최신 기능 원함**: Wayland + Hyprland

## 선택 가이드

### 초보자라면
1. **KDE Plasma**: Windows 사용자
2. **GNOME**: Mac 사용자  
3. **XFCE**: 가벼운 환경 원하는 사람

### 중급자라면
1. **i3wm**: 키보드 중심 워크플로우
2. **Sway**: i3wm + Wayland
3. **Hyprland**: 타일링 + 예쁜 효과

### 고려사항
- **학습 시간**: DE < WM
- **리소스 사용량**: WM < DE
- **커스터마이징**: DE (GUI) vs WM (텍스트 파일)
- **호환성**: X11 > Wayland (현재)

## 나의 결론

아치 리눅스의 진짜 매력은 **선택의 자유**에 있다고 생각한다. 같은 커널을 쓰면서도 완전히 다른 경험을 할 수 있다는 게 신기했다.

### 개인적 추천
1. **처음에는 KDE나 GNOME**으로 시작해서 리눅스에 적응
2. **어느 정도 익숙해지면 i3wm** 같은 타일링 WM 시도
3. **Wayland는 호환성 확인 후** 도입

### 깨달은 점
- 완벽한 환경은 없다. 모든 건 **트레이드오프**
- **자신의 워크플로우**를 먼저 이해하고 환경을 선택해야 함
- 설정에 빠져서 **정작 해야 할 일을 못하는** 함정 주의

아치 리눅스 설치는 단순히 운영체제를 깔는 게 아니라, **자신만의 컴퓨팅 환경을 구축하는 과정**이었다. 시간은 오래 걸렸지만, 그만큼 시스템에 대한 이해도 깊어졌고, 진짜 '내 컴퓨터'라는 느낌을 받을 수 있었다.
```

### arch-linux-uefi-guide.md

**Path:** `frontend/public/posts/2024/arch-linux-uefi-guide.md`

```markdown
---
title: "아치 리눅스 설치하고 예쁘게 꾸미기"
date: "2024-11-01"
category: "시스템"
tags: ['Linux', 'Arch Linux', 'UEFI', '데스크톱 환경', '커스터마이징']
excerpt: "아치 리눅스 UEFI 설치부터 데스크톱 꾸미기까지 실제 경험을 바탕으로 정리"
readTime: "4분"
---

아치 리눅스를 처음 접하는 사람들이 가장 어려워하는 건 설치도 설치지만, 설치 후에 어떻게 예쁘게 꾸미느냐다. 직접 몇 번 설치해보고 시행착오를 겪으면서 정리한 내용을 공유해보려고 한다.

## 왜 아치 리눅스인가?

아치 리눅스의 매력은 "내가 원하는 대로" 시스템을 구성할 수 있다는 점이다. 우분투처럼 처음부터 모든 게 갖춰져 있는 게 아니라, 필요한 것만 골라서 설치할 수 있다. 

특히 데스크톱을 꾸미는 재미가 쏠쏠하다. KDE, GNOME 같은 무거운 환경부터 i3, Hyprland 같은 타일링 윈도우 매니저까지 선택의 폭이 넓다.

## 데스크톱 환경 선택하기

### 데스크톱 환경 (DE)

#### KDE Plasma
- **장점**: 설정 옵션이 엄청 많음, Windows 비슷한 인터페이스
- **단점**: 좀 무거움, 설정할 게 너무 많아서 헷갈림
- **추천 대상**: 윈도우에서 넘어온 사람, 화려한 걸 좋아하는 사람

실제로 써보니 KDE가 생각보다 가볍고, 커스터마이징 자유도가 정말 높다. 테마 스토어에서 클릭 몇 번으로 테마 적용하는 것도 편하다.

#### GNOME  
- **장점**: 깔끔하고 현대적, 터치에 최적화
- **단점**: 커스터마이징이 제한적, 확장 기능에 의존해야 함
- **추천 대상**: 맥 사용자, 미니멀한 걸 좋아하는 사람

GNOME은 기본 상태로도 충분히 예쁘다. 다만 세세한 설정을 바꾸려면 Tweaks나 확장 기능을 써야 한다.

#### XFCE
- **장점**: 가볍고 안정적, 전통적인 인터페이스
- **단점**: 좀 구식으로 보일 수 있음
- **추천 대상**: 저사양 컴퓨터, 안정성 중시하는 사람

### 윈도우 매니저 (WM)

#### i3wm
키보드로만 조작하는 타일링 윈도우 매니저. 익숙해지면 마우스 없이도 엄청 빠르게 작업할 수 있다. 다만 러닝 커브가 있어서 처음엔 좀 어렵다.

#### Hyprland  
최신 Wayland 기반 타일링 WM. 블러 효과, 둥근 모서리, 애니메이션 등 화려한 효과를 지원한다. 인스타에서 보는 그런 예쁜 리눅스 데스크톱 대부분이 이걸로 만든 것들이다.

## 실제 꾸미기 경험

### KDE Plasma 꾸미기

KDE를 선택했을 때 주로 하는 설정들:

1. **테마**: Sweet Mars나 Layan 테마가 인기
2. **아이콘**: Papirus가 제일 무난하고 완성도 높음  
3. **커서**: 기본 것도 괜찮지만 Volantes가 예쁨
4. **Kvantum**: Qt 앱들 테마 통일하려면 필수

시스템 설정에서 "새 테마 가져오기" 버튼 누르면 KDE 스토어에서 바로 다운받을 수 있어서 편하다.

### GNOME 꾸미기

GNOME은 좀 다르다:

1. **GNOME Tweaks** 필수 설치
2. **User Themes** 확장 기능 활성화  
3. GTK 테마와 Shell 테마 따로 설정
4. Gnome-Look.org에서 테마 다운로드

Orchis나 WhiteSur 테마가 예쁘다. 특히 WhiteSur는 macOS 비슷하게 만들어준다.

### 터미널 꾸미기

터미널을 많이 쓰니까 예쁘게 꾸미는 게 중요하다.

#### 터미널 에뮬레이터
- **Alacritty**: 빠르고 가벼움, 설정은 YAML 파일로
- **Kitty**: 기능 많음, 이미지도 표시 가능, 탭 기능 내장

개인적으로는 Kitty를 선호한다. 기능이 더 많고 설정도 편하다.

#### Shell 설정
Bash 대신 Zsh 쓰는 걸 추천한다:

```bash
# Zsh 설치하고 기본 셸로 변경
sudo pacman -S zsh
chsh -s /usr/bin/zsh

# Oh My Zsh 설치
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"

# Starship 프롬프트 설치  
sudo pacman -S starship
```

Nerd Fonts도 설치해야 아이콘들이 제대로 표시된다:

```bash
# 예: Hack Nerd Font
mkdir -p ~/.local/share/fonts
# Nerd Fonts 사이트에서 다운로드해서 압축 해제
fc-cache -fv
```

## 유용한 도구들

### 상태바
- **Polybar** (X11용): i3wm과 궁합이 좋음
- **Waybar** (Wayland용): Hyprland에서 주로 사용

### 앱 런처  
- **Rofi**: 테마 적용하기 쉽고 기능 많음
- **Ulauncher**: GUI로 설정 가능

### 시스템 모니터
- **Conky**: 데스크톱에 시스템 정보 표시
- 설정 복잡하지만 예쁘게 만들 수 있음

## Wayland vs X11

요즘 추세는 Wayland지만 아직 X11이 더 안정적이다.

**X11 선택하는 경우:**
- NVIDIA 그래픽카드 사용
- 화면 캡처, 색상 선택기 등 유틸리티 많이 사용
- 안정성 중시

**Wayland 선택하는 경우:**  
- 최신 기술 선호
- 화면 찢어짐 현상 싫어함
- 보안 중시

NVIDIA 사용자라면 아직은 X11이 더 편하다. Wayland에서는 nvidia-settings 같은 도구 기능이 제한되는 경우가 있다.

## 추천 설정 조합

### 입문자용 (KDE)
- **DE**: KDE Plasma
- **테마**: Layan  
- **아이콘**: Papirus
- **터미널**: Konsole + Zsh + Oh My Zsh
- **글꼴**: Inter (UI), JetBrains Mono (터미널)

### 중급자용 (GNOME)
- **DE**: GNOME  
- **GTK 테마**: Orchis Dark
- **아이콘**: Tela Circle
- **터미널**: Alacritty + Starship
- **확장기능**: User Themes, Dash to Panel

### 고급자용 (Hyprland)
- **WM**: Hyprland
- **상태바**: Waybar
- **런처**: Rofi/Wofi  
- **터미널**: Kitty
- **효과**: 블러, 둥근 모서리, 애니메이션

## 마무리

아치 리눅스 꾸미기는 시간은 오래 걸리지만 재밌다. 내 손으로 하나씩 설정해가면서 시스템에 대해 더 많이 알게 된다.

처음엔 KDE나 GNOME으로 시작해서 익숙해지면 i3나 Hyprland로 넘어가는 걸 추천한다. 

무엇보다 중요한 건 완벽한 설정은 없다는 것이다. 계속 바꾸고 시도해보면서 자신만의 환경을 만들어가는 게 아치의 매력이다.

참고로 r/unixporn 서브레딧 가면 다른 사람들이 꾸민 예쁜 데스크톱들 많이 볼 수 있다. 영감 얻기 좋다.
```

### bfs.md

**Path:** `frontend/public/posts/2024/bfs.md`

```markdown
---
title: "BFS (너비 우선 탐색) 완전 정복"
date: "2024-11-15"
category: "Algorithm"
tags: ['BFS', '그래프', '탐색', '최단경로', '알고리즘']
excerpt: "큐를 이용한 레벨별 그래프 탐색과 최단 경로 알고리즘의 핵심"
readTime: "11분"
---

# 🌊 BFS (너비 우선 탐색) 완전 정복

##  핵심 개념

BFS(Breadth-First Search)는 **큐(Queue)**를 사용하여 그래프를 **레벨별로 탐색**하는 알고리즘입니다. 시작 정점에서 가까운 정점부터 차례대로 방문하며, **가중치가 없는 그래프에서 최단 경로**를 찾는 데 사용됩니다.

### 알고리즘 동작 과정
1. **시작 정점 삽입**: 시작 정점을 큐에 넣고 방문 표시
2. **큐에서 정점 제거**: 큐의 앞에서 정점을 하나 꺼냄  
3. **인접 정점 탐색**: 꺼낸 정점의 모든 인접 정점 확인
4. **미방문 정점 추가**: 아직 방문하지 않은 인접 정점들을 큐에 추가
5. **반복**: 큐가 빌 때까지 2-4 과정 반복

##  시간복잡도

| 그래프 표현 | 시간복잡도 | 공간복잡도 |
|-------------|------------|------------|
| **인접 리스트** | O(V + E) | O(V) |
| **인접 행렬** | O(V²) | O(V) |

- V: 정점의 수, E: 간선의 수

##  완전한 구현 코드

### 1. 기본 BFS 구현
```python
from collections import deque

def bfs_basic(graph, start):
    """기본 BFS 구현"""
    visited = set()
    queue = deque([start])
    visited.add(start)
    result = []
    
    while queue:
        vertex = queue.popleft()
        result.append(vertex)
        
        # 인접한 정점들을 큐에 추가
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return result

# 그래프 예제 (인접 리스트)
graph_example = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

print("=== Basic BFS ===")
bfs_result = bfs_basic(graph_example, 'A')
print(f"BFS traversal from 'A': {bfs_result}")
```

### 2. 상세한 과정을 보여주는 BFS
```python
def bfs_detailed(graph, start):
    """BFS 탐색 과정을 상세히 출력"""
    visited = set()
    queue = deque([start])
    visited.add(start)
    level = 0
    
    print(f"Starting BFS from vertex '{start}'")
    print(f"Initial queue: {list(queue)}")
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        print(f"\n--- Level {level} ---")
        print(f"Queue at start of level: {list(queue)}")
        
        # 현재 레벨의 모든 정점 처리
        for _ in range(level_size):
            vertex = queue.popleft()
            current_level.append(vertex)
            
            print(f"Processing vertex '{vertex}'")
            print(f"  Neighbors: {graph[vertex]}")
            
            # 인접한 정점들 확인
            new_neighbors = []
            for neighbor in graph[vertex]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
                    new_neighbors.append(neighbor)
            
            if new_neighbors:
                print(f"  Added to queue: {new_neighbors}")
            else:
                print(f"  No new neighbors to add")
        
        print(f"Vertices processed at level {level}: {current_level}")
        print(f"Queue after level {level}: {list(queue)}")
        level += 1
    
    print(f"\nBFS completed! Total levels: {level}")

# 상세한 BFS 실행
print("=== Detailed BFS Process ===")
bfs_detailed(graph_example, 'A')
```

### 3. 최단 경로를 기록하는 BFS
```python
def bfs_shortest_path(graph, start, end):
    """두 정점 사이의 최단 경로 찾기"""
    if start == end:
        return [start]
    
    visited = set([start])
    queue = deque([(start, [start])])  # (현재 정점, 경로)
    
    while queue:
        vertex, path = queue.popleft()
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                new_path = path + [neighbor]
                
                if neighbor == end:
                    return new_path
                
                visited.add(neighbor)
                queue.append((neighbor, new_path))
    
    return None  # 경로가 없는 경우

def bfs_all_shortest_paths(graph, start):
    """시작 정점에서 모든 정점까지의 최단 경로"""
    distances = {start: 0}
    parents = {start: None}
    queue = deque([start])
    
    while queue:
        vertex = queue.popleft()
        
        for neighbor in graph[vertex]:
            if neighbor not in distances:
                distances[neighbor] = distances[vertex] + 1
                parents[neighbor] = vertex
                queue.append(neighbor)
    
    return distances, parents

def reconstruct_path(parents, start, end):
    """부모 정보로부터 경로 재구성"""
    if end not in parents:
        return None
    
    path = []
    current = end
    
    while current is not None:
        path.append(current)
        current = parents[current]
    
    return path[::-1]

# 최단 경로 테스트
print("\n=== Shortest Path BFS ===")
path = bfs_shortest_path(graph_example, 'A', 'F')
print(f"Shortest path from A to F: {path}")

distances, parents = bfs_all_shortest_paths(graph_example, 'A')
print(f"Distances from A: {distances}")

for vertex in graph_example:
    if vertex != 'A':
        path = reconstruct_path(parents, 'A', vertex)
        print(f"Path to {vertex}: {path} (distance: {distances[vertex]})")
```

### 4. 2D 그리드에서의 BFS
```python
def bfs_grid(grid, start, end):
    """2D 그리드에서 BFS로 최단 경로 찾기"""
    if not grid or not grid[0]:
        return -1
    
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 우, 하, 좌, 상
    
    queue = deque([(start[0], start[1], 0)])  # (x, y, distance)
    visited = set([start])
    
    while queue:
        x, y, dist = queue.popleft()
        
        if (x, y) == end:
            return dist
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if (0 <= nx < rows and 0 <= ny < cols and 
                grid[nx][ny] == 0 and (nx, ny) not in visited):
                visited.add((nx, ny))
                queue.append((nx, ny, dist + 1))
    
    return -1  # 경로가 없는 경우

def bfs_grid_with_path(grid, start, end):
    """경로까지 함께 반환하는 그리드 BFS"""
    if not grid or not grid[0]:
        return -1, []
    
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    queue = deque([(start[0], start[1], 0, [start])])  # (x, y, dist, path)
    visited = set([start])
    
    while queue:
        x, y, dist, path = queue.popleft()
        
        if (x, y) == end:
            return dist, path
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if (0 <= nx < rows and 0 <= ny < cols and 
                grid[nx][ny] == 0 and (nx, ny) not in visited):
                visited.add((nx, ny))
                queue.append((nx, ny, dist + 1, path + [(nx, ny)]))
    
    return -1, []

# 그리드 BFS 테스트
print("\n=== Grid BFS ===")
# 0: 이동 가능, 1: 벽
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
]

start_pos = (0, 0)
end_pos = (4, 4)

print("Maze (0: path, 1: wall):")
for row in maze:
    print(row)

distance = bfs_grid(maze, start_pos, end_pos)
print(f"Shortest distance from {start_pos} to {end_pos}: {distance}")

dist_with_path, path = bfs_grid_with_path(maze, start_pos, end_pos)
print(f"Path: {path}")
```

### 5. 레벨별 BFS (레벨 순회)
```python
def bfs_level_order(graph, start):
    """레벨별로 정점들을 그룹화하여 반환"""
    if not graph or start not in graph:
        return []
    
    visited = set([start])
    queue = deque([start])
    levels = []
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        for _ in range(level_size):
            vertex = queue.popleft()
            current_level.append(vertex)
            
            for neighbor in graph[vertex]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        levels.append(current_level)
    
    return levels

# 이진 트리에서의 레벨 순회
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def bfs_binary_tree(root):
    """이진 트리의 레벨 순회"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result

# 레벨별 BFS 테스트
print("\n=== Level Order BFS ===")
levels = bfs_level_order(graph_example, 'A')
print("Graph levels:")
for i, level in enumerate(levels):
    print(f"Level {i}: {level}")

# 이진 트리 예제
#       3
#      / \
#     9   20
#        /  \
#       15   7
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

tree_levels = bfs_binary_tree(root)
print("\nBinary tree levels:")
for i, level in enumerate(tree_levels):
    print(f"Level {i}: {level}")
```

##  고급 응용

### 1. 다중 소스 BFS
```python
def multi_source_bfs(grid, sources):
    """여러 시작점에서 동시에 BFS 수행"""
    if not grid or not grid[0]:
        return []
    
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    # 모든 소스를 큐에 추가
    queue = deque()
    distances = [[-1] * cols for _ in range(rows)]
    
    for x, y in sources:
        queue.append((x, y, 0))
        distances[x][y] = 0
    
    while queue:
        x, y, dist = queue.popleft()
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if (0 <= nx < rows and 0 <= ny < cols and 
                distances[nx][ny] == -1):  # 아직 방문하지 않은 경우
                distances[nx][ny] = dist + 1
                queue.append((nx, ny, dist + 1))
    
    return distances

# 다중 소스 BFS 테스트 (썩은 토마토 문제)
def oranges_rotting(grid):
    """썩은 오렌지가 퍼지는 시간 계산"""
    if not grid or not grid[0]:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    queue = deque()
    fresh_count = 0
    
    # 초기 썩은 오렌지들을 큐에 추가하고 신선한 오렌지 개수 계산
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 2:  # 썩은 오렌지
                queue.append((i, j, 0))
            elif grid[i][j] == 1:  # 신선한 오렌지
                fresh_count += 1
    
    max_time = 0
    
    while queue:
        x, y, time = queue.popleft()
        max_time = max(max_time, time)
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if (0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1):
                grid[nx][ny] = 2  # 썩게 만들기
                fresh_count -= 1
                queue.append((nx, ny, time + 1))
    
    return max_time if fresh_count == 0 else -1

print("\n=== Multi-source BFS ===")
# 0: 빈칸, 1: 신선한 오렌지, 2: 썩은 오렌지
oranges = [
    [2, 1, 1],
    [1, 1, 0],
    [0, 1, 1]
]

print("Initial oranges grid:")
for row in oranges:
    print(row)

time_needed = oranges_rotting([row[:] for row in oranges])  # 복사본 사용
print(f"Time to rot all oranges: {time_needed}")
```

### 2. 0-1 BFS (가중치가 0 또는 1인 경우)
```python
from collections import deque

def zero_one_bfs(graph, start, end):
    """가중치가 0 또는 1인 그래프에서 최단 경로"""
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    deque_queue = deque([start])
    
    while deque_queue:
        vertex = deque_queue.popleft()
        
        for neighbor, weight in graph[vertex]:
            new_dist = distances[vertex] + weight
            
            if new_dist < distances[neighbor]:
                distances[neighbor] = new_dist
                
                if weight == 0:
                    deque_queue.appendleft(neighbor)  # 가중치 0은 앞에 추가
                else:
                    deque_queue.append(neighbor)      # 가중치 1은 뒤에 추가
    
    return distances[end] if distances[end] != float('inf') else -1

# 0-1 BFS 그래프 예제
zero_one_graph = {
    'A': [('B', 0), ('C', 1)],
    'B': [('D', 1), ('E', 0)],
    'C': [('F', 0)],
    'D': [('F', 0)],
    'E': [('F', 1)],
    'F': []
}

print("\n=== 0-1 BFS ===")
shortest_dist = zero_one_bfs(zero_one_graph, 'A', 'F')
print(f"Shortest distance from A to F: {shortest_dist}")
```

### 3. 양방향 BFS
```python
def bidirectional_bfs(graph, start, end):
    """양방향 BFS로 최단 경로 찾기"""
    if start == end:
        return 0
    
    # 두 방향에서 시작
    visited_start = {start: 0}
    visited_end = {end: 0}
    queue_start = deque([start])
    queue_end = deque([end])
    
    while queue_start or queue_end:
        # 시작점에서 한 단계 확장
        if queue_start:
            vertex = queue_start.popleft()
            for neighbor in graph[vertex]:
                if neighbor in visited_end:
                    return visited_start[vertex] + 1 + visited_end[neighbor]
                
                if neighbor not in visited_start:
                    visited_start[neighbor] = visited_start[vertex] + 1
                    queue_start.append(neighbor)
        
        # 끝점에서 한 단계 확장
        if queue_end:
            vertex = queue_end.popleft()
            for neighbor in graph[vertex]:
                if neighbor in visited_start:
                    return visited_end[vertex] + 1 + visited_start[neighbor]
                
                if neighbor not in visited_end:
                    visited_end[neighbor] = visited_end[vertex] + 1
                    queue_end.append(neighbor)
    
    return -1  # 경로가 없는 경우

print("\n=== Bidirectional BFS ===")
bi_distance = bidirectional_bfs(graph_example, 'A', 'F')
print(f"Bidirectional BFS distance from A to F: {bi_distance}")
```

##  실전 예제

### 1. 단어 사다리 (Word Ladder)
```python
def word_ladder(begin_word, end_word, word_list):
    """한 글자씩 바꿔가며 단어를 변환하는 최소 단계"""
    if end_word not in word_list:
        return 0
    
    word_set = set(word_list)
    queue = deque([(begin_word, 1)])
    visited = set([begin_word])
    
    while queue:
        word, steps = queue.popleft()
        
        if word == end_word:
            return steps
        
        # 한 글자씩 변경해보기
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                new_word = word[:i] + c + word[i+1:]
                
                if new_word in word_set and new_word not in visited:
                    visited.add(new_word)
                    queue.append((new_word, steps + 1))
    
    return 0

# 단어 사다리 테스트
print("\n=== Word Ladder ===")
word_list = ["hot", "dot", "dog", "lot", "log", "cog"]
begin = "hit"
end = "cog"

steps = word_ladder(begin, end, word_list)
print(f"Minimum steps from '{begin}' to '{end}': {steps}")
```

### 2. 연결 컴포넌트 찾기
```python
def find_connected_components(graph):
    """그래프의 모든 연결 컴포넌트 찾기"""
    visited = set()
    components = []
    
    for vertex in graph:
        if vertex not in visited:
            component = []
            queue = deque([vertex])
            visited.add(vertex)
            
            while queue:
                current = queue.popleft()
                component.append(current)
                
                for neighbor in graph[current]:
                    if neighbor not in visited:
                        visited.add(neighbor)
                        queue.append(neighbor)
            
            components.append(component)
    
    return components

# 연결 컴포넌트 테스트
disconnected_graph = {
    'A': ['B', 'C'],
    'B': ['A'],
    'C': ['A'],
    'D': ['E'],
    'E': ['D', 'F'],
    'F': ['E'],
    'G': ['H'],
    'H': ['G'],
    'I': []
}

print("\n=== Connected Components ===")
components = find_connected_components(disconnected_graph)
print("Connected components:")
for i, component in enumerate(components):
    print(f"Component {i+1}: {component}")
```

### 3. 미로에서 벽 부수기
```python
def bfs_with_wall_breaking(grid, max_breaks):
    """벽을 최대 max_breaks만큼 부수며 최단 경로 찾기"""
    if not grid or not grid[0]:
        return -1
    
    rows, cols = len(grid), len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    # (x, y, breaks_used, distance)
    queue = deque([(0, 0, 0, 0)])
    # visited[x][y][breaks] = 해당 위치에 breaks만큼 벽을 부수고 도달했는지
    visited = set([(0, 0, 0)])
    
    while queue:
        x, y, breaks, dist = queue.popleft()
        
        # 목표 지점 도달
        if x == rows - 1 and y == cols - 1:
            return dist
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if 0 <= nx < rows and 0 <= ny < cols:
                new_breaks = breaks
                
                # 벽인 경우 부수기
                if grid[nx][ny] == 1:
                    new_breaks += 1
                
                # 벽을 부수는 횟수가 제한을 넘지 않고, 방문하지 않은 상태인 경우
                if (new_breaks <= max_breaks and 
                    (nx, ny, new_breaks) not in visited):
                    visited.add((nx, ny, new_breaks))
                    queue.append((nx, ny, new_breaks, dist + 1))
    
    return -1

# 벽 부수기 테스트
print("\n=== Wall Breaking BFS ===")
wall_maze = [
    [0, 1, 1, 0],
    [0, 0, 0, 1],
    [1, 1, 0, 0],
    [0, 0, 0, 0]
]

print("Maze (0: path, 1: wall):")
for row in wall_maze:
    print(row)

for max_breaks in range(3):
    result = bfs_with_wall_breaking(wall_maze, max_breaks)
    print(f"With {max_breaks} wall breaks: {result}")
```

##  BFS vs DFS 비교

| 특징 | BFS | DFS |
|------|-----|-----|
| **자료구조** | 큐(Queue) | 스택(Stack) 또는 재귀 |
| **탐색 순서** | 레벨별 (너비 우선) | 깊이 우선 |
| **메모리 사용** | O(최대 너비) | O(최대 깊이) |
| **최단 경로** | ✅ 보장 (가중치 없는 그래프) | ❌ 보장하지 않음 |
| **사용 사례** | 최단 경로, 레벨 순회 | 경로 존재 여부, 백트래킹 |

## 🎖️ 레벨별 연습 문제

### 🥉 초급
- BOJ 1260: DFS와 BFS
- BOJ 2178: 미로 탐색
- BOJ 7576: 토마토

### 🥈 중급
- BOJ 7569: 토마토 (3D)
- BOJ 1697: 숨바꼭질
- BOJ 2667: 단지번호붙이기

### 🥇 고급
- BOJ 13913: 숨바꼭질 4
- BOJ 16234: 인구 이동
- BOJ 17144: 미세먼지 안녕!

---

**다음 학습**: [다익스트라(Dijkstra) 최단 경로](../dijkstra/) 

BFS는 **최단 경로의 기본**이자 **레벨별 탐색의 핵심**입니다. 그래프 알고리즘의 근간을 완벽하게 마스터하세요!
```

### binary-search.md

**Path:** `frontend/public/posts/2024/binary-search.md`

```markdown
---
title: "이진 탐색(Binary Search) 완전 정복"
date: "2024-12-05"
category: "Algorithm"
tags: ['이진탐색', '탐색', '분할정복', '알고리즘']
excerpt: "정렬된 배열에서 O(log n) 시간에 원소를 찾는 이진 탐색의 모든 것"
readTime: "11분"
---

# 이진 탐색(Binary Search) 완전 정복

## 핵심 개념

이진 탐색은 **정렬된 배열**에서 특정 값을 찾는 탐색 알고리즘으로, **분할 정복** 기법을 사용하여 **O(log n)** 시간복잡도를 달성합니다. 매번 탐색 범위를 절반으로 줄여나가는 것이 핵심입니다.

### 알고리즘 동작 과정
1. **중간점 계산**: 탐색 범위의 중간 인덱스를 구함
2. **비교**: 중간값과 찾는 값을 비교
3. **범위 축소**: 찾는 값이 더 크면 오른쪽, 작으면 왼쪽 절반만 탐색
4. **반복**: 값을 찾거나 범위가 없어질 때까지 반복

## 시간복잡도

| 연산 | 시간복잡도 | 공간복잡도 |
|------|------------|------------|
| **탐색** | O(log n) | O(1) - 반복문 |
| **탐색** | O(log n) | O(log n) - 재귀 |

## 완전한 구현 코드

### 1. 기본 이진 탐색 (반복문)
```python
def binary_search_iterative(arr, target):
    """반복문을 이용한 이진 탐색"""
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2  # 오버플로우 방지
        
        if arr[mid] == target:
            return mid  # 찾은 경우 인덱스 반환
        elif arr[mid] < target:
            left = mid + 1  # 오른쪽 절반 탐색
        else:
            right = mid - 1  # 왼쪽 절반 탐색
    
    return -1  # 찾지 못한 경우

# 사용 예제
sorted_array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
target = 7

result = binary_search_iterative(sorted_array, target)
if result != -1:
    print(f"Element {target} found at index {result}")
else:
    print(f"Element {target} not found")

# 모든 원소에 대해 테스트
print("=== Testing all elements ===")
for i, value in enumerate(sorted_array):
    found_index = binary_search_iterative(sorted_array, value)
    print(f"Value {value}: Expected index {i}, Found index {found_index}")
```

### 2. 재귀적 이진 탐색
```python
def binary_search_recursive(arr, target, left=None, right=None):
    """재귀를 이용한 이진 탐색"""
    if left is None:
        left = 0
    if right is None:
        right = len(arr) - 1
    
    # 기저 조건: 탐색 범위가 없는 경우
    if left > right:
        return -1
    
    mid = left + (right - left) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

# 재귀 버전 테스트
print("=== Recursive Binary Search ===")
for target in [5, 12, 1, 19, 20]:
    result = binary_search_recursive(sorted_array, target)
    if result != -1:
        print(f"Found {target} at index {result}")
    else:
        print(f"{target} not found")
```

### 3. 상세한 과정을 보여주는 이진 탐색
```python
def binary_search_detailed(arr, target):
    """이진 탐색 과정을 상세히 출력"""
    left = 0
    right = len(arr) - 1
    step = 1
    
    print(f"Searching for {target} in {arr}")
    print(f"Initial range: left={left}, right={right}")
    
    while left <= right:
        mid = left + (right - left) // 2
        print(f"\nStep {step}:")
        print(f"  Range: [{left}, {right}]")
        print(f"  Mid index: {mid}, Mid value: {arr[mid]}")
        
        if arr[mid] == target:
            print(f"  ✅ Found! {target} is at index {mid}")
            return mid
        elif arr[mid] < target:
            print(f"  {arr[mid]} < {target}, search right half")
            left = mid + 1
        else:
            print(f"  {arr[mid]} > {target}, search left half")
            right = mid - 1
        
        step += 1
    
    print(f"  ❌ Not found! {target} is not in the array")
    return -1

# 상세한 과정 확인
print("=== Detailed Binary Search Process ===")
binary_search_detailed([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 11)
print("\n" + "="*50)
binary_search_detailed([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 12)
```

### 4. 첫 번째/마지막 위치 찾기
```python
def find_first_occurrence(arr, target):
    """중복된 값 중 첫 번째 위치 찾기"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            result = mid  # 일단 저장
            right = mid - 1  # 더 왼쪽에 있는지 확인
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

def find_last_occurrence(arr, target):
    """중복된 값 중 마지막 위치 찾기"""
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            result = mid  # 일단 저장
            left = mid + 1  # 더 오른쪽에 있는지 확인
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

def find_all_occurrences(arr, target):
    """모든 위치 찾기"""
    first = find_first_occurrence(arr, target)
    if first == -1:
        return []
    
    last = find_last_occurrence(arr, target)
    return list(range(first, last + 1))

# 중복 값이 있는 배열 테스트
duplicate_array = [1, 2, 2, 2, 3, 4, 4, 5, 5, 5, 5, 6]
target = 5

print("=== Finding First/Last Occurrences ===")
print(f"Array: {duplicate_array}")
print(f"Target: {target}")
print(f"First occurrence: {find_first_occurrence(duplicate_array, target)}")
print(f"Last occurrence: {find_last_occurrence(duplicate_array, target)}")
print(f"All occurrences: {find_all_occurrences(duplicate_array, target)}")
```

### 5. Lower Bound / Upper Bound
```python
def lower_bound(arr, target):
    """target보다 크거나 같은 첫 번째 원소의 위치"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    
    return left

def upper_bound(arr, target):
    """target보다 큰 첫 번째 원소의 위치"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = left + (right - left) // 2
        
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
    
    return left

def count_occurrences(arr, target):
    """특정 값의 개수 구하기"""
    return upper_bound(arr, target) - lower_bound(arr, target)

# Lower/Upper Bound 테스트
test_array = [1, 2, 2, 3, 3, 3, 4, 5, 5, 6]
print("=== Lower/Upper Bound ===")
print(f"Array: {test_array}")

for target in [2, 3, 4, 7]:
    lb = lower_bound(test_array, target)
    ub = upper_bound(test_array, target)
    count = count_occurrences(test_array, target)
    
    print(f"Target {target}:")
    print(f"  Lower bound: {lb}")
    print(f"  Upper bound: {ub}")
    print(f"  Count: {count}")
```

##  고급 응용

### 1. 매개변수 탐색 (Parametric Search)
```python
def can_cut_wood(woods, cut_height):
    """주어진 높이로 자를 때 얻을 수 있는 나무의 총 길이"""
    total = 0
    for wood in woods:
        if wood > cut_height:
            total += wood - cut_height
    return total

def solve_wood_cutting(woods, target_length):
    """나무 자르기 문제 - 매개변수 탐색"""
    left, right = 0, max(woods)
    result = 0
    
    while left <= right:
        mid = left + (right - left) // 2
        cut_length = can_cut_wood(woods, mid)
        
        if cut_length >= target_length:
            result = mid  # 가능한 높이 저장
            left = mid + 1  # 더 높은 높이 시도
        else:
            right = mid - 1  # 높이를 낮춰야 함
    
    return result

# 나무 자르기 문제 테스트
woods = [20, 15, 10, 17]
target = 7

max_height = solve_wood_cutting(woods, target)
print(f"Woods: {woods}")
print(f"Target length: {target}")
print(f"Maximum cutting height: {max_height}")
print(f"Actual cut length: {can_cut_wood(woods, max_height)}")
```

### 2. 실수 이진 탐색
```python
def binary_search_real(func, target, left, right, epsilon=1e-9):
    """실수 범위에서 이진 탐색"""
    while right - left > epsilon:
        mid = (left + right) / 2
        
        if func(mid) < target:
            left = mid
        else:
            right = mid
    
    return (left + right) / 2

def square_root(x, precision=1e-9):
    """제곱근 구하기"""
    if x < 0:
        return None
    if x == 0:
        return 0
    
    # f(t) = t^2, target = x인 t 찾기
    return binary_search_real(lambda t: t * t, x, 0, max(1, x), precision)

def cube_root(x, precision=1e-9):
    """세제곱근 구하기"""
    # f(t) = t^3, target = x인 t 찾기
    if x >= 0:
        return binary_search_real(lambda t: t * t * t, x, 0, max(1, x), precision)
    else:
        return -binary_search_real(lambda t: t * t * t, -x, 0, max(1, -x), precision)

# 실수 이진 탐색 테스트
print("=== Real Number Binary Search ===")
test_numbers = [4, 9, 16, 25, 8, 27, -8]

for num in test_numbers:
    if num >= 0:
        sqrt_result = square_root(num)
        print(f"√{num} ≈ {sqrt_result:.6f} (verification: {sqrt_result**2:.6f})")
    
    cbrt_result = cube_root(num)
    print(f"∛{num} ≈ {cbrt_result:.6f} (verification: {cbrt_result**3:.6f})")
```

### 3. 2D 배열에서의 이진 탐색
```python
def search_2d_matrix(matrix, target):
    """행과 열이 모두 정렬된 2D 배열에서 탐색"""
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    
    # 오른쪽 위 모서리부터 시작
    row, col = 0, cols - 1
    
    while row < rows and col >= 0:
        current = matrix[row][col]
        
        if current == target:
            return True
        elif current > target:
            col -= 1  # 왼쪽으로 이동
        else:
            row += 1  # 아래로 이동
    
    return False

def search_sorted_matrix(matrix, target):
    """각 행이 정렬되고, 다음 행의 첫 원소가 이전 행의 마지막 원소보다 큰 경우"""
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        # 1D 인덱스를 2D 좌표로 변환
        mid_value = matrix[mid // cols][mid % cols]
        
        if mid_value == target:
            return True
        elif mid_value < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# 2D 배열 탐색 테스트
matrix1 = [
    [1,  4,  7,  11],
    [2,  5,  8,  12],
    [3,  6,  9,  16],
    [10, 13, 14, 17]
]

matrix2 = [
    [1,  3,  5,  7],
    [10, 11, 16, 20],
    [23, 30, 34, 60]
]

print("=== 2D Array Binary Search ===")
print("Matrix 1 (sorted in both directions):")
for row in matrix1:
    print(row)

targets = [5, 14, 20]
for target in targets:
    found = search_2d_matrix(matrix1, target)
    print(f"Target {target}: {'Found' if found else 'Not found'}")

print("\nMatrix 2 (row-wise sorted):")
for row in matrix2:
    print(row)

for target in targets:
    found = search_sorted_matrix(matrix2, target)
    print(f"Target {target}: {'Found' if found else 'Not found'}")
```

##  실전 예제

### 1. 회전된 정렬 배열에서 탐색
```python
def search_rotated_array(nums, target):
    """회전된 정렬 배열에서 이진 탐색"""
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if nums[mid] == target:
            return mid
        
        # 왼쪽 절반이 정렬되어 있는 경우
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        # 오른쪽 절반이 정렬되어 있는 경우
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1

def find_minimum_rotated(nums):
    """회전된 정렬 배열에서 최솟값 찾기"""
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = left + (right - left) // 2
        
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    
    return left

# 회전된 배열 테스트
rotated_arrays = [
    [4, 5, 6, 7, 0, 1, 2],
    [6, 7, 0, 1, 2, 4, 5],
    [1, 3, 5]
]

print("=== Rotated Array Search ===")
for arr in rotated_arrays:
    min_idx = find_minimum_rotated(arr)
    print(f"Array: {arr}")
    print(f"Minimum at index {min_idx}: {arr[min_idx]}")
    
    # 몇 개 값 탐색
    for target in [0, 5, 8]:
        idx = search_rotated_array(arr, target)
        if idx != -1:
            print(f"  {target} found at index {idx}")
        else:
            print(f"  {target} not found")
    print()
```

### 2. 피크 원소 찾기
```python
def find_peak_element(nums):
    """배열에서 피크 원소 찾기 (양쪽 이웃보다 큰 원소)"""
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = left + (right - left) // 2
        
        # 오른쪽이 더 크면 오른쪽에 피크가 있음
        if nums[mid] < nums[mid + 1]:
            left = mid + 1
        # 왼쪽이 더 크거나 같으면 왼쪽에 피크가 있음
        else:
            right = mid
    
    return left

def find_all_peaks(nums):
    """모든 피크 원소 찾기"""
    peaks = []
    n = len(nums)
    
    for i in range(n):
        is_peak = True
        
        # 왼쪽 확인
        if i > 0 and nums[i] <= nums[i-1]:
            is_peak = False
        
        # 오른쪽 확인
        if i < n-1 and nums[i] <= nums[i+1]:
            is_peak = False
        
        if is_peak:
            peaks.append(i)
    
    return peaks

# 피크 찾기 테스트
peak_arrays = [
    [1, 2, 3, 1],
    [1, 2, 1, 3, 5, 6, 4],
    [1, 2, 3, 4, 5],
    [5, 4, 3, 2, 1]
]

print("=== Peak Finding ===")
for arr in peak_arrays:
    peak_idx = find_peak_element(arr)
    all_peaks = find_all_peaks(arr)
    
    print(f"Array: {arr}")
    print(f"A peak at index {peak_idx}: {arr[peak_idx]}")
    print(f"All peaks at indices {all_peaks}")
    print()
```

### 3. 제곱근과 거듭제곱
```python
def integer_square_root(x):
    """정수 제곱근 구하기"""
    if x < 0:
        return -1
    if x < 2:
        return x
    
    left, right = 1, x // 2 + 1
    
    while left <= right:
        mid = left + (right - left) // 2
        square = mid * mid
        
        if square == x:
            return mid
        elif square < x:
            left = mid + 1
        else:
            right = mid - 1
    
    return right  # 가장 가까운 작은 정수

def power_function(base, exponent, mod=None):
    """빠른 거듭제곱 (분할 정복)"""
    if exponent == 0:
        return 1
    
    result = 1
    base = base % mod if mod else base
    
    while exponent > 0:
        # 지수가 홀수인 경우
        if exponent % 2 == 1:
            result = (result * base) % mod if mod else result * base
        
        # 지수를 반으로 줄이고 밑을 제곱
        exponent = exponent >> 1  # exponent // 2
        base = (base * base) % mod if mod else base * base
    
    return result

# 제곱근과 거듭제곱 테스트
print("=== Integer Square Root ===")
for x in [0, 1, 4, 8, 9, 15, 16, 24, 25]:
    sqrt_x = integer_square_root(x)
    print(f"√{x} = {sqrt_x} (verification: {sqrt_x}² = {sqrt_x**2})")

print("\n=== Fast Exponentiation ===")
test_cases = [(2, 10), (3, 4), (5, 100, 1000), (2, 1000, 1000000007)]

for case in test_cases:
    if len(case) == 2:
        base, exp = case
        result = power_function(base, exp)
        print(f"{base}^{exp} = {result}")
    else:
        base, exp, mod = case
        result = power_function(base, exp, mod)
        print(f"{base}^{exp} mod {mod} = {result}")
```

##  이진 탐색 활용 팁

###  적용 조건
1. **정렬된 데이터**: 배열이나 리스트가 정렬되어 있어야 함
2. **단조성**: 찾는 조건이 단조증가 또는 단조감소
3. **랜덤 접근**: 인덱스로 O(1) 접근 가능

###  변형 문제 패턴
- **첫 번째/마지막 위치**: Lower/Upper Bound
- **매개변수 탐색**: 최적값 찾기 문제
- **실수 탐색**: 연속 함수에서의 근 찾기
- **2D 탐색**: 정렬된 행렬에서 탐색

### ⚠️ 주의사항
- **오버플로우**: `mid = (left + right) // 2` 대신 `mid = left + (right - left) // 2`
- **무한루프**: 경계 조건 처리 주의
- **부등호**: `<=`, `<` 조건 정확히 구분

## 🎖️ 레벨별 연습 문제

### 🥉 초급
- BOJ 1920: 수 찾기
- BOJ 10816: 숫자 카드 2
- BOJ 1654: 랜선 자르기

### 🥈 중급
- BOJ 2805: 나무 자르기
- BOJ 2110: 공유기 설치
- BOJ 1300: K번째 수

### 🥇 고급
- BOJ 12015: 가장 긴 증가하는 부분 수열 2
- BOJ 2143: 두 배열의 합
- LeetCode 4: Median of Two Sorted Arrays

---

**이전 학습**: [선형 탐색(Linear Search)](../linear-search/) ⬅️
**다음 학습**: [BFS (너비 우선 탐색)](../bfs/) 

이진 탐색은 **효율성의 대명사**입니다. 정렬된 데이터에서 O(log n)의 마법을 경험해보세요!
```

### blade-runner-philosophy.md

**Path:** `frontend/public/posts/2024/blade-runner-philosophy.md`

```markdown
---
title: '블레이드 러너(Blade Runner, 1982) - 인간성의 경계를 묻는 철학적 걸작'
excerpt: >-

  # 블레이드 러너(Blade Runner, 1982) - 인간성의 경계를 묻는 철학적 걸작


  ## 영화 개관과 감독의 비전


  **블레이드 러너**는 1982년 리들리 스콧 감독이 필립 K. 딕의 소설 『안드로이드는 전기양의 꿈을 꾸는가?』를 각색한 SF 누아르의
  금자탑입니다. 개봉 당시 상업적으로는 실패했지만, 시간이 지나면서 **인간 존재의 본질에 대한...
date: '2025-08-10'
publishTime: '2024-08-10 15:02:00'
category: 사고와 인식
tags:
  - 블레이드러너
  - 리들리스콧
  - 필립K딕
  - 레플리칸트
  - 인공지능
  - 데카르트
  - 하이데거
  - 니체
  - 베르그송
  - 레비나스
  - 보드리야르
  - 아도르노
  - SF누아르
  - 인간성
  - 존재론
readTime: 5분
---

# 블레이드 러너(Blade Runner, 1982) - 인간성의 경계를 묻는 철학적 걸작

## 영화 개관과 감독의 비전

**블레이드 러너**는 1982년 리들리 스콧 감독이 필립 K. 딕의 소설 『안드로이드는 전기양의 꿈을 꾸는가?』를 각색한 SF 누아르의 금자탑입니다. 개봉 당시 상업적으로는 실패했지만, 시간이 지나면서 **인간 존재의 본질에 대한 가장 깊이 있는 탐구**를 시도한 작품으로 재평가받고 있습니다.

스콧 감독은 이 작품을 통해 **기술 문명이 고도로 발달한 미래 사회에서 인간성이 무엇인지**에 대한 근본적 질문을 던집니다. 2019년 로스앤젤레스라는 디스토피아적 배경은 단순한 미래 예측이 아니라, **현대 문명의 모순과 소외를 극대화한 철학적 실험실**로 기능합니다.

## 데카르트의 심신이원론과 정체성의 위기

### "나는 생각한다, 고로 존재한다"의 한계

르네 데카르트의 **코기토(Cogito)** 명제는 블레이드 러너에서 근본적인 도전을 받습니다. 영화 속 레플리칸트들은 생각하고 감정을 느끼며 기억을 가지고 있지만, 여전히 "진짜" 인간이 아니라고 여겨집니다.

특히 **레이첼(숀 영)의 경우, 타이렐 사가 심어준 기억들로 인해 자신을 인간이라고 믿고 있습니다**. 그녀가 데커드에게 "이 기억들이 진짜가 아니라는 뜻인가요?"라고 묻는 순간은 데카르트적 확실성의 붕괴를 보여줍니다.

### 기억과 정체성의 관계

영화는 **기억이 정체성을 구성하는 핵심 요소**라는 전제를 제시한 후, 그 기억마저 인위적으로 조작될 수 있다는 충격적 사실을 드러냅니다. 이는 데카르트가 의심할 수 없다고 본 **사유하는 주체의 확실성**마저 의문에 부치게 만듭니다.

## 하이데거의 존재론적 차이와 죽음 의식

### 존재와 존재자의 구분

마르틴 하이데거의 **존재론적 차이** 개념이 블레이드 러너의 핵심 철학적 구조를 이룹니다. 인간과 레플리칸트는 모두 존재자이지만, 과연 동일한 존재 방식을 가지고 있는가라는 질문이 영화 전반을 관통합니다.

### 죽음 앞에서의 본래적 존재

하이데거가 강조한 **죽음을 향한 존재(Sein-zum-Tode)**는 로이 베이티(룻거 하우어)의 캐릭터에서 절정에 달합니다. 4년의 제한된 수명을 가진 그는 **죽음 의식을 통해 가장 인간다운 모습**을 보여줍니다.

로이의 마지막 독백은 하이데거적 실존의 완벽한 구현입니다:

> "나는 여러분이 상상할 수 없는 것들을 보았습니다... 그 모든 순간들이 시간 속에서 사라질 것입니다. 빗속의 눈물처럼..."

이 순간 로이는 **본래적 존재**가 되어, 자신의 유한성을 받아들이며 인간보다 더 인간다운 모습을 보입니다.

## 니체의 가치전도와 초인 의지

### 주인-노예 도덕의 전복

프리드리히 니체의 **주인 도덕과 노예 도덕** 구분이 블레이드 러너에서 역설적으로 전복됩니다. 제작자(인간)와 피조물(레플리칸트) 사이의 관계에서, 오히려 **레플리칸트들이 더 순수하고 강렬한 의지**를 보여줍니다.

### 신의 죽음과 새로운 가치 창조

타이렐 박사를 "아버지"로 부르며 죽이는 로이의 행위는 니체가 선언한 **"신의 죽음"의 상징적 구현**입니다. 피조물이 창조자를 넘어서는 순간, 기존의 모든 가치 체계가 무너집니다.

## 베르그송의 기억과 시간 철학

### 기억의 원뿔과 지속

앙리 베르그송의 **기억 이론**은 블레이드 러너의 중심 주제입니다. 베르그송에 따르면 기억은 단순한 과거의 저장이 아니라 **현재를 구성하는 능동적 힘**입니다.

레플리칸트들에게 심어진 기억들은 베르그송이 말한 **순수 기억**과 **습관-기억**의 경계를 모호하게 만듭니다. 레이첼의 피아노 연주 장면은 몸에 새겨진 습관-기억이 **진짜 경험만큼 실재한다**는 것을 보여줍니다.

### 지속과 순간의 변증법

로이의 마지막 순간은 베르그송이 말한 **지속(durée)의 순수한 체험**을 보여줍니다. 4년이라는 짧은 생애 동안 축적된 모든 경험이 하나의 완전한 지속으로 응축되는 순간입니다.

## 레비나스의 타자 철학과 얼굴의 윤리

### 타자의 얼굴과 무한한 책임

에마뉘엘 레비나스의 **타자 철학**이 블레이드 러너에서 가장 감동적으로 구현되는 장면은 로이와 데커드의 마지막 만남입니다. 로이가 떨어질 뻔한 데커드를 구해주는 행위는 **타자에 대한 무조건적 책임**의 발현입니다.

### 존재론을 넘어선 윤리

레비나스가 하이데거의 존재론을 비판하며 제시한 **윤리의 우선성**이 여기서 드러납니다. 로이는 존재론적 차이를 넘어서 **타자의 얼굴 앞에서 느끼는 무한한 책임감**으로 행동합니다.

## 보드리야르의 시뮬라크르와 하이퍼리얼리티

### 진짜보다 더 진짜인 가짜

장 보드리야르의 **시뮬라크르 이론**은 블레이드 러너의 철학적 토대를 이룹니다. 레플리칸트들은 인간의 **모델 없는 복사본**으로, 원본보다 더 완벽한 존재입니다.

### 시뮬레이션의 4단계

보드리야르가 제시한 시뮬레이션의 마지막 단계에서는 **시뮬라크르가 현실을 완전히 대체**합니다. 영화 말미에 데커드 자신도 레플리칸트일 가능성이 제기되면서, 관객은 무엇이 진짜 현실인지 알 수 없게 됩니다.

## 아도르노의 부정변증법과 소외론

### 도구적 이성의 지배

테오도르 아도르노의 **도구적 이성 비판**이 블레이드 러너의 디스토피아적 현실에서 완벽하게 구현됩니다. 레플리칸트들은 **인간의 편의를 위한 도구**로 제작되었지만, 역설적으로 인간보다 더 순수한 감정을 보여줍니다.

### 부정변증법의 가능성

아도르노가 제시한 **부정변증법**의 희망은 로이의 최후에서 발견됩니다. 그는 기존의 논리적 체계를 거부하고, **모순적이지만 진정한 인간성**을 구현합니다.

## 감독 리들리 스콧의 내면 세계

### 시각적 완벽주의와 철학적 탐구

스콧의 **시각적 완벽주의**는 단순한 미적 추구를 넘어 철학적 메시지를 전달하는 수단입니다. 어둡고 비에 젖은 미래 도시의 모습은 **현대 문명의 정신적 황폐함**을 은유적으로 표현합니다.

### 인간성에 대한 회의와 희망

스콧이 블레이드 러너를 통해 표현한 것은 **인간성에 대한 깊은 회의와 동시에 희미한 희망**입니다. 기술이 고도로 발달한 미래에서도 여전히 중요한 것은 **사랑, 연민, 희생** 같은 원초적 인간 감정이라는 메시지를 전달합니다.

## 현대적 의의: AI 시대의 예언적 통찰

### 인공지능과 인간성의 경계

40여 년 전에 제작된 블레이드 러너가 제기한 질문들은 **현재 AI 시대에 더욱 절실한 현실**이 되었습니다. ChatGPT, GPT-4 같은 대화형 AI의 등장으로 **기계와 인간의 구분이 점점 모호**해지고 있습니다.

### 디지털 휴머니즘의 필요성

영화가 제시하는 궁극적 메시지는 **기술의 발전과 상관없이 인간성의 핵심은 변하지 않는다**는 것입니다. 로이가 보여준 연민과 희생정신은 어떤 알고리즘으로도 프로그래밍할 수 없는 **순수한 인간적 가치**입니다.

## 여러 버전을 통한 의미의 확장

### 감독판의 철학적 깊이

1992년 감독판에서 데커드의 내레이션이 제거되고 유니콘 꿈 시퀀스가 추가되면서, **데커드 자신도 레플리칸트일 가능성**이 강화되었습니다. 이는 영화의 철학적 메시지를 더욱 복잡하고 깊이 있게 만듭니다.

### 파이널 컷의 완성된 비전

2007년 파이널 컷은 스콧의 **완성된 철학적 비전**을 보여줍니다. 모든 기술적 완벽함과 함께, 인간과 인공생명체의 경계에 대한 질문이 더욱 명확하게 제시됩니다.

## 후속작과의 철학적 연속성

### 블레이드 러너 2049의 확장된 물음

드니 빌뇌브의 『블레이드 러너 2049』(2017)는 원작의 철학적 질문을 **다음 세대로 확장**시켰습니다. K(라이언 고슬링)의 여정은 **피조물도 자신만의 꿈과 목적을 가질 수 있는가**라는 새로운 차원의 질문을 제기합니다.

## 결론: 영원한 철학적 화두

블레이드 러너는 **인간이란 무엇인가**라는 철학의 가장 근본적인 질문을 SF적 상상력으로 탁월하게 구현한 걸작입니다. 데카르트부터 하이데거, 니체, 레비나스에 이르는 서구 철학의 핵심 명제들이 영화적 서사 안에서 치밀하게 직조되어 있습니다.

리들리 스콧이 보여준 **미래에 대한 비전**은 단순한 기술적 예측을 넘어, **인간 존재의 조건에 대한 깊이 있는 성찰**입니다. 기술이 인간을 대체할 수 있다고 해도, **진정한 인간성은 기술을 초월한 영역에 존재한다**는 메시지는 현재 AI 혁명의 시대에 더욱 중요한 의미를 갖습니다.

**"인간보다 더 인간다운 인공생명체"**라는 역설을 통해, 블레이드 러너는 우리에게 묻습니다: 과연 무엇이 우리를 인간답게 만드는가? 그 답은 여전히 각자의 내면에서 찾아야 할 영원한 철학적 화두로 남아있습니다.

```

### brazil-1985-review.md

**Path:** `frontend/public/posts/2024/brazil-1985-review.md`

```markdown
---
title: "브라질(Brazil, 1985) - 현대 문명에 대한 철학적 절망과 저항의 서사"
date: 2025-01-24T15:30:00+09:00
draft: false
featured_image: "/media/brazil-1985-poster.jpg"
categories:
  - "영화리뷰"
  - "SF영화"
  - "디스토피아"
tags:
  - "테리 길리엄"
  - "브라질"
  - "디스토피아"
  - "블랙코미디"
  - "SF영화"
  - "관료제"
  - "카프카"
  - "철학적영화"
  - "1985년"
  - "프랑크푸르트학파"
  - "감시사회"
  - "현대문명비판"
summary: "1985년 테리 길리엄의 걸작 '브라질'을 통해 본 현대 문명에 대한 철학적 성찰과 관료제 비판, 그리고 상상력의 해방적 힘에 대한 깊이 있는 분석"
---

# 브라질(Brazil, 1985) - 현대 문명에 대한 철학적 절망과 저항의 서사

## 영화 개관과 감독의 비전

**브라질**은 1985년 테리 길리엄 감독이 선보인 디스토피아 SF 블랙 코미디로, 조지 오웰의 『1984』를 넘어서는 현대 문명 비판의 걸작입니다[1]. 길리엄은 이 작품을 통해 **관료제가 미쳐버린 산업 세계에 대한 평생의 분노**를 쏟아냈으며[1], 단순한 디스토피아 경고를 넘어 현대인의 실존적 딜레마를 탁월하게 형상화했습니다.

영화의 제목 "브라질"은 실제 브라질과는 무관하며, 영국 관객들에게 친숙한 "아쿠아렐라 두 브라질(Aquarela do Brasil)"이라는 노래에서 따온 것입니다[1]. 이 선택 자체가 **현실 도피와 환상의 중요성**을 암시하는 감독의 철학적 메시지입니다.

## 카프카적 부조리주의의 완벽한 구현

### 관료제의 악몽

길리엄이 그려낸 세계는 **프란츠 카프카의 『성』과 『변신』에서 묘사된 부조리한 관료제**의 시각적 구현체입니다. 주인공 샘 로우리(조나단 프라이스)가 일하는 정보부는 카프카 소설 속 성처럼 **논리를 거부하고 개인을 짓누르는 거대한 기계**로 기능합니다[1].

특히 "버틀"과 "터틀"의 혼동으로 시작되는 사건은 카프카가 『심판』에서 보여준 **근거 없는 처벌의 메커니즘**을 그대로 재현합니다[2]. 무고한 시민이 컴퓨터 오류 하나로 테러리스트가 되어 고문받는 과정은 현대 사회의 시스템이 얼마나 개인의 존재를 무시하는지를 적나라하게 드러냅니다.

### 의사소통의 불가능성

카프카 문학의 핵심인 **의사소통의 단절**은 영화 전반에 걸쳐 나타납니다. 복잡하게 얽힌 배관 시스템, 제대로 작동하지 않는 기계장치들, 끝없는 서류 작업은 모두 **소통이 차단된 현대 사회의 은유**입니다[3].

## 아도르노와 호르크하이머의 도구적 이성 비판

### 계몽의 변증법과 문명의 퇴행

프랑크푸르트 학파의 핵심 이론가들이 『계몽의 변증법』에서 경고한 **도구적 이성의 지배**가 브라질에서 완벽하게 구현됩니다. 영화 속 기술은 인간을 해방시키는 것이 아니라 **더욱 효율적으로 통제하는 수단**으로 전락했습니다[1].

특히 고문 장면에서 잭(마이클 페일린)이 보여주는 **기술적 완벽성에 대한 집착**은 아도르노가 비판한 도구적 이성의 극단적 형태입니다. 고문조차 효율성과 정확성을 추구하는 기술적 과정으로 변모한 것입니다.

### 문화산업과 대중 조작

영화 속에서 사람들이 즐기는 오락과 소비문화는 아도르노가 비판한 **문화산업의 표준화된 상품**들과 정확히 일치합니다[4]. 성형수술에 열광하는 샘의 어머니와 그 친구들은 **진정한 개성을 상실하고 획일화된 아름다움을 추구하는 현대인**의 모습을 보여줍니다.

## 미셸 푸코의 감시 사회론과 판옵티콘

### 보이지 않는 권력의 시선

푸코가 『감시와 처벌』에서 분석한 **판옵티콘적 감시 체계**가 브라질에서 완벽하게 재현됩니다. 시민들은 언제 어디서나 감시당하고 있다고 느끼며, 이러한 **내재화된 감시 의식**이 자발적 복종을 만들어냅니다[5].

테러와의 전쟁이라는 명목 하에 정당화되는 **무제한적 감시와 체포**는 현재 우리가 경험하고 있는 디지털 감시 사회의 예언적 묘사입니다[5].

### 규율 권력과 신체의 정치학

영화에서 개인의 신체는 국가 권력의 직접적 통제 대상입니다. 성형수술을 통한 **표준화된 아름다움의 강요**, 고문을 통한 **진실 추출의 기술화** 등은 푸코가 분석한 **규율 권력의 미시정치학**을 보여줍니다.

## 장 보드리야르의 시뮬라크르 이론

### 진짜보다 더 진짜인 가짜

영화 속 레스토랑에서 제공되는 음식은 보드리야르의 **시뮬라크르 개념**을 완벽하게 구현합니다[4]. 사진으로 보여지는 완벽한 음식과 실제로 제공되는 형태 없는 덩어리 사이의 간극은 **현실이 모델에 의해 대체된 하이퍼리얼리티**를 보여줍니다.

### 꿈과 현실의 경계 붕괴

샘 로우리의 **반복되는 꿈 속 영웅 판타지**는 보드리야르가 말한 **시뮬레이션의 4단계** 중 마지막 단계를 보여줍니다. 꿈이 현실보다 더 생생해지고, 마침내 현실을 완전히 대체하는 순간까지 이릅니다[2][1].

## 헤르베르트 마르쿠제의 일차원적 인간론

### 거짓 욕구의 창조

마르쿠제가 『일차원적 인간』에서 비판한 **거짓 욕구의 체계적 생산**이 브라질에서 그대로 나타납니다. 성형수술, 소비재에 대한 강박적 욕구, 오락에 대한 중독은 모두 **진정한 해방적 욕구를 억압하는 메커니즘**으로 기능합니다.

### 비판적 사고의 마비

영화 속 시민들이 보여주는 **정치적 무관심과 체념**은 마르쿠제가 경고한 일차원적 사고의 결과입니다. 테러 공격이 일상화되었음에도 근본적 변화를 추구하지 않는 모습은 **비판 의식이 마비된 현대인**의 모습입니다.

## 발터 벤야민의 아우라 이론과 기술 복제

### 경험의 아우라 상실

벤야민이 『기술복제시대의 예술작품』에서 논한 **아우라의 몰락**이 브라질에서 극명하게 드러납니다. 모든 것이 기계적으로 복제되고 표준화된 세계에서 **진정한 경험의 독특성**은 사라집니다[3].

샘의 꿈만이 유일하게 **아우라를 간직한 공간**으로 남아있지만, 결국 이마저도 현실의 압박 앞에서 무너집니다.

## 감독 테리 길리엄의 내면 세계

### 몬티 파이튼적 부조리 감각의 승화

길리엄의 몬티 파이튼 시절 경험은 **부조리한 현실에 대한 해학적 접근**으로 발전했습니다. 하지만 브라질에서는 단순한 유머를 넘어 **깊은 절망과 분노**가 바탕에 깔려 있습니다[1].

### 상상력에 대한 믿음과 좌절

길리엄이 평생 추구해온 **상상력의 해방적 힘**에 대한 믿음이 브라질에서는 **비극적 한계**와 만납니다. 샘의 꿈이 결국 현실 도피의 정신병적 증상으로 귀결되는 것은 감독 자신의 **예술적 이상주의에 대한 자기 성찰**이기도 합니다.

### 개인 대 시스템의 영원한 투쟁

길리엄이 유니버설 스튜디오와 벌인 **영화 편집권을 둘러싼 실제 투쟁**은 영화 내용과 정확히 일치합니다[5]. 개인 예술가가 거대한 기업 관료제와 벌이는 싸움 자체가 브라질의 주제 의식을 현실에서 재연한 것입니다.

## 실존주의적 관점에서의 해석

### 사르트르의 실존적 선택

샘 로우리는 마지막 순간까지 **자유로운 선택의 가능성**을 가지고 있었습니다. 하지만 그는 사르트르가 말한 **자유의 무게**를 견디지 못하고 환상 속으로 도피합니다. 이는 현대인이 직면한 **실존적 책임에 대한 회피**를 보여줍니다.

### 키에르케고르의 절망과 신앙의 부재

영화의 비극적 결말은 키에르케고르가 분석한 **절망의 단계들** 중 가장 깊은 단계를 보여줍니다. 샘은 자기 자신이 될 수 없다는 절망에서 **완전한 현실 부정**으로 나아갑니다.

## 현대적 의의와 예언적 통찰

### 디지털 감시 사회의 예견

1985년에 제작된 브라질이 보여준 **전방위적 감시 체계**는 현재 우리가 살고 있는 디지털 감시 사회를 정확히 예견했습니다[5]. 테러와의 전쟁이라는 명목으로 정당화되는 **시민 감시의 일상화**는 더 이상 디스토피아 판타지가 아닙니다.

### 관료제의 디지털화

영화 속 복잡한 배관 시스템과 서류 더미는 현재의 **복잡한 디지털 인터페이스와 온라인 관료제**로 진화했습니다. 본질적으로 개인을 소외시키고 통제하는 메커니즘은 그대로 남아있습니다.

## 결론: 절망 속에서 찾는 희미한 희망

브라질은 **현대 문명에 대한 총체적 비관주의**를 담고 있지만, 동시에 **상상력과 꿈의 불굴의 힘**을 증언합니다. 샘 로우리가 마지막에 부르는 "아쿠아렐라 두 브라질"은 **완전한 패배 속에서도 꺾이지 않는 인간 정신의 마지막 보루**를 상징합니다[2][1].

길리엄의 철학적 메시지는 명확합니다: **시스템은 개인을 파괴할 수 있지만, 인간의 꿈과 상상력만은 완전히 통제할 수 없다**는 것입니다. 비록 그 대가가 정신적 파멸일지라도, 진정한 자유는 **내면의 세계에서만 가능하다**는 역설적 희망을 제시합니다.

현재 우리가 직면한 **AI와 알고리즘 지배의 시대**에 브라질의 메시지는 더욱 절실합니다. 기술이 인간을 해방시킬 것이라는 **계몽주의적 낙관론에 대한 근본적 의문**을 제기하며, **진정한 인간성 회복**의 길을 모색하게 합니다.

테리 길리엄이 브라질을 통해 보여준 것은 단순한 디스토피아 경고가 아니라, **현대인의 실존적 조건에 대한 깊이 있는 철학적 성찰**입니다. 그의 내면에 깔린 분노와 절망, 그리고 그럼에도 불굴하는 상상력에 대한 믿음이 이 걸작을 탄생시켰습니다.

---

**참고문헌:**
- [1] Wikipedia: Brazil (1985 film)
- [2] IMDb: Brazil - Plot Summary  
- [3] Cinephilia Beyond: The Daffy Dystopian Design Nightmare
- [4] Brighton Literature Blog: Terry Gilliam's Brazil
- [5] Ever Curious Geek: Brazil at 40 - Why Terry Gilliam's Vision Still Terrifies
```

### changedetection-io-guide.md

**Path:** `frontend/public/posts/2024/changedetection-io-guide.md`

```markdown
---
title: "ChangeDetection.io 완벽 활용 가이드"
date: "2024-07-21"
category: "DevOps"
tags: ['웹 모니터링', '자동화', 'Discord', 'Webhook', 'ChangeDetection']
excerpt: "웹페이지 변경 감지 서비스 ChangeDetection.io의 Duration Time 설정과 Discord 웹훅 연동을 통한 효율적인 모니터링 방법을 소개합니다."
readTime: "3분"
---

## ChangeDetection.io란?

ChangeDetection.io는 웹페이지의 변화를 감지하고 알림을 제공하는 강력한 서비스입니다. 이 서비스를 효과적으로 활용하기 위한 핵심 기능들을 자세히 알아보겠습니다.

## Duration Time의 목적과 작동 원리

### Duration Time의 목적

Duration Time은 changedetection.io의 스케줄러 기능에서 중요한 역할을 합니다. 이 설정은 각 요일별로 웹페이지 변경 감지가 얼마나 오랫동안 실행될지를 결정합니다.

#### 특정 시간대 동안만 감지 실행

Duration Time은 사용자가 지정한 시간 범위 내에서만 웹페이지 변경 감지를 실행할 수 있도록 합니다. 예를 들어, 업무 시간인 오전 9시부터 오후 5시까지만 웹페이지 변경을 확인하고 싶을 때 유용합니다.

#### 비용 절감 효과

많은 사용자들이 프록시 제공업체의 비용을 절감하기 위해 이 기능을 활용합니다. 필요한 시간대에만 웹페이지 변경 감지를 실행함으로써 불필요한 네트워크 요청을 줄이고 리소스 사용을 최적화할 수 있습니다.

### Duration Time의 작동 메커니즘

#### 스케줄러와의 통합

Duration Time은 changedetection.io의 스케줄러 기능의 일부로 작동합니다. 사용자 인터페이스에서는 각 요일마다 "Start At"(시작 시간)과 함께 "Run duration"(실행 지속 시간)을 설정할 수 있습니다.

#### 시간 계산 방식

"Start At" 시간부터 "Run duration"에 설정된 시간 동안 웹페이지 변경 감지가 활성화됩니다. 예를 들어:
- 시작 시간이 09:00
- 실행 지속 시간이 8시간

이 경우 웹페이지 변경 감지는 09:00부터 17:00(09:00 + 8시간)까지 활성화됩니다.

#### 타임존 지원

changedetection.io는 타임존 설정을 지원합니다. "Optional timezone to run in" 필드에 타임존을 입력하면, 해당 타임존의 현지 시간에 맞춰 스케줄이 작동합니다.

## Discord 웹훅 알림 설정 가이드

### Discord 서버에서 웹훅 생성하기

1. Discord 서버에서 알림을 받고 싶은 채널이 있는 서버를 선택합니다.
2. 서버 이름을 우클릭하고 **서버 설정**을 선택합니다.
3. 왼쪽 메뉴에서 **통합(Integrations)**을 클릭합니다.
4. **웹훅(Webhooks)** 항목을 클릭하고 **새 웹훅(New Webhook)** 버튼을 클릭합니다.
5. 웹훅의 이름을 설정하고(예: "ChangeDetection 알림"), 웹훅 메시지가 전송될 채널을 선택합니다.
6. **웹훅 URL 복사(Copy Webhook URL)** 버튼을 클릭하여 웹훅 URL을 복사합니다.

### ChangeDetection.io에서 웹훅 URL 설정하기

웹훅 URL은 일반적으로 다음과 같은 형식을 가집니다:
`https://discord.com/api/webhooks/webhook_id/webhook_token`

ChangeDetection.io에서는 다음과 같은 형식으로 변환하여 입력해야 합니다:
`discord://webhook_id/webhook_token`

설정 단계:
1. ChangeDetection.io에 접속하여 모니터링 중인 사이트의 **편집** 또는 전체 설정의 **알림(Notifications)** 탭으로 이동합니다.
2. **Notification URL List** 필드에 변환된 Discord 웹훅 URL을 입력합니다.
3. **저장(Save)** 버튼을 클릭하여 설정을 저장합니다.
4. **Send test notification** 버튼을 클릭하여 테스트 알림을 보내볼 수 있습니다.

## 스크린샷 첨부 설정

ChangeDetection.io는 변경 사항 감지 시 스크린샷을 함께 전송할 수 있는 기능을 제공합니다:

1. 알림 설정 페이지에서 **Attach screenshot to notification (where possible)** 옵션을 체크합니다.
2. 이 옵션을 활성화하면 웹사이트 변경 사항이 감지될 때 스크린샷이 Discord 메시지에 첨부되어 전송됩니다.

## Discord 웹훅 알림의 장점

1. **실시간 알림**: 웹사이트 변경 사항이 발생하면 즉시 Discord 채널에 알림이 전송됩니다.
2. **팀 공유 용이성**: 특정 Discord 채널에 알림을 보내 팀원들과 변경 사항을 쉽게 공유할 수 있습니다.
3. **모바일 접근성**: Discord 모바일 앱을 통해 데스크톱에 접속하지 않아도 알림을 받을 수 있습니다.
4. **커스터마이징 가능**: 알림 메시지의 제목, 내용, 이미지 등을 Jinja2 템플릿을 사용하여 사용자 정의할 수 있습니다.
5. **통합 관리**: 여러 웹사이트의 변경 사항을 한 채널에서 관리하거나, 웹사이트별로 다른 채널에 알림을 보낼 수 있습니다.
6. **시각적 확인**: 스크린샷 첨부 기능을 활용하면 변경 사항을 시각적으로 즉시 확인할 수 있습니다.

## 실용적 활용 사례

### 업무 시간 모니터링

"Business hours" 바로가기를 클릭하면 자동으로 평일(월-금) 09:00부터 8시간 동안(17:00까지) 실행되는 일정이 설정됩니다. 이는 업무 시간 동안만 중요한 웹사이트의 변경을 모니터링하려는 사용자에게 이상적입니다.

### 특정 요일만 모니터링

예를 들어 일요일에만 웹페이지 변경을 확인하고 싶다면, 일요일의 "Start At" 체크박스만 선택하고 시작 시간을 00:00으로, 시간(Hours)을 23, 분(Minutes)을 59로 설정하면 됩니다.

## 결론

ChangeDetection.io의 Duration Time 설정과 Discord 웹훅 연동을 통해 효율적이고 스마트한 웹페이지 모니터링 시스템을 구축할 수 있습니다. 이러한 기능들을 적절히 활용하면 시스템 자원을 효율적으로 사용하면서도 실시간으로 중요한 변경 사항을 놓치지 않을 수 있습니다.
```

### coding-test-guide.md

**Path:** `frontend/public/posts/2024/coding-test-guide.md`

```markdown
---
title: "코딩테스트 완벽 대비 전략"
date: "2024-06-28"
category: "Algorithm"
tags: ['코딩테스트', '취업', '알고리즘', '프로그래밍', '면접']
excerpt: "대기업 코딩테스트 합격을 위한 실전 준비 가이드와 핵심 문제 유형별 공략법"
readTime: "4분"
---

# 💻 코딩테스트 완벽 정복 가이드

취업 시장에서 코딩테스트는 필수 관문이 되었습니다. 체계적인 준비로 합격의 문을 열어보세요!

## 🎯 주요 기업별 출제 경향

### 네이버/카카오
- **핵심 유형**: 구현, 문자열, 그래프, DP
- **난이도**: 프로그래머스 Lv.2~3 
- **특징**: 실무 연관성 높은 문제, 깔끔한 코드 중시

### 삼성전자 
- **핵심 유형**: 시뮬레이션, BFS/DFS, 백트래킹
- **난이도**: 백준 골드 3~1
- **특징**: 복잡한 구현, 디버깅 능력 중시

### 라인/쿠팡
- **핵심 유형**: 자료구조, 그리디, 이진탐색
- **난이도**: LeetCode Medium~Hard
- **특징**: 최적화된 솔루션, 시간복잡도 중시

## 📊 출제 빈도 TOP 10 알고리즘

| 순위 | 알고리즘 | 출제율 | 핵심 포인트 |
|------|----------|--------|-------------|
| 1 | **구현/시뮬레이션** | 35% | 정확한 조건 처리 |
| 2 | **BFS/DFS** | 25% | 그래프 탐색 마스터 |
| 3 | **동적 계획법** | 20% | 점화식 도출 능력 |
| 4 | **그리디** | 15% | 최적해 증명 |
| 5 | **이진 탐색** | 12% | 매개변수 탐색 |
| 6 | **문자열 처리** | 10% | KMP, 정규식 |
| 7 | **자료구조** | 8% | 스택, 큐, 힙 활용 |
| 8 | **수학/정수론** | 7% | 모듈러 연산 |
| 9 | **백트래킹** | 5% | 가지치기 최적화 |
| 10 | **투 포인터** | 3% | 효율적 범위 탐색 |

## 🔥 4주 완성 집중 대비 플랜

### 1주차: 기초 알고리즘 완벽 정리
```markdown
Day 1-2: 배열, 문자열 처리
Day 3-4: 정렬, 이진 탐색  
Day 5-7: BFS/DFS 기본 문제 20개
```

### 2주차: 핵심 알고리즘 마스터
```markdown  
Day 1-3: 동적 계획법 집중 훈련
Day 4-5: 그리디 알고리즘 완전 정복
Day 6-7: 자료구조 활용 문제
```

### 3주차: 구현 능력 강화
```markdown
Day 1-3: 시뮬레이션 문제 마라톤
Day 4-5: 백트래킹 + 가지치기
Day 6-7: 복합 알고리즘 문제
```

### 4주차: 실전 모의고사
```markdown
Day 1-3: 기업별 기출 문제 풀이
Day 4-5: 시간 제한 모의고사  
Day 6-7: 약점 보완 및 최종 점검
```

## ⚡ 실전 테크닉 & 꿀팁

### 🎯 문제 해결 5단계 프로세스
```python
def solve_problem():
    # 1. 문제 이해 (3분)
    understand_requirements()
    
    # 2. 접근 방법 결정 (2분)  
    choose_algorithm()
    
    # 3. 의사코드 작성 (3분)
    write_pseudocode()
    
    # 4. 코드 구현 (15분)
    implement_solution()
    
    # 5. 테스트 & 디버깅 (7분)
    test_and_debug()
```

### 🚀 시간 단축 코딩 스킬

#### 효율적인 입출력 처리
```python
import sys
input = sys.stdin.readline

# 빠른 입력 처리
n, m = map(int, input().split())
arr = list(map(int, input().split()))

# 빠른 출력 처리  
print('\n'.join(map(str, results)))
```

#### 자주 사용하는 코드 템플릿
```python
# BFS 템플릿
from collections import deque

def bfs(start):
    queue = deque([start])
    visited = set([start])
    
    while queue:
        node = queue.popleft()
        
        for next_node in graph[node]:
            if next_node not in visited:
                visited.add(next_node)
                queue.append(next_node)

# DFS 템플릿  
def dfs(node, visited):
    visited.add(node)
    
    for next_node in graph[node]:
        if next_node not in visited:
            dfs(next_node, visited)
```

## 📚 기업별 필수 문제 리스트

### 카카오 기출 BEST 10
1. **문자열 압축** (2020 신입) - 구현
2. **괄호 변환** (2020 신입) - 재귀  
3. **자물쇠와 열쇠** (2020 신입) - 완전탐색
4. **가사 검색** (2020 신입) - 트라이
5. **외벽 점검** (2020 신입) - 완전탐색

### 삼성 A형 기출 BEST 5  
1. **마법사 상어와 토네이도** - 시뮬레이션
2. **청소년 상어** - 백트래킹
3. **원판 돌리기** - 구현
4. **드래곤 커브** - 시뮬레이션  
5. **미세먼지 안녕!** - 시뮬레이션

## 🎖️ 레벨별 목표 설정

### 🥉 기초급 (코테 통과 목표)
- **목표 점수**: 60~70점
- **필수 스킬**: 기본 자료구조, BFS/DFS, 간단한 DP
- **권장 문제**: 프로그래머스 Lv.1~2

### 🥈 중급 (상위권 목표)  
- **목표 점수**: 80~90점
- **필수 스킬**: 고급 DP, 그래프 심화, 문자열 알고리즘
- **권장 문제**: 백준 골드, 프로그래머스 Lv.3

### 🥇 고급 (만점 목표)
- **목표 점수**: 95~100점  
- **필수 스킬**: 세그먼트 트리, 네트워크 플로우, 기하
- **권장 문제**: 백준 플래티넘, LeetCode Hard

## 🛠️ 디버깅 & 최적화 전략

### 자주 발생하는 실수들
```python
# ❌ 잘못된 예시들
for i in range(n-1):      # Off-by-one 오류
    arr[i+1] = arr[i]

visited = [[False] * m] * n  # 얕은 복사 오류

# ✅ 올바른 예시들  
for i in range(n):
    if i < n-1:
        arr[i+1] = arr[i]

visited = [[False] * m for _ in range(n)]  # 깊은 복사
```

### 성능 최적화 체크리스트
- [ ] 시간복잡도가 제한시간 내인가?
- [ ] 불필요한 반복문이 없는가?
- [ ] 메모이제이션을 적용할 수 있는가?
- [ ] 자료구조 선택이 최적인가?

## 💪 마지막 주 점검 사항

### D-7: 핵심 알고리즘 마지막 점검
- 자주 틀리는 유형 재복습
- 손코딩으로 구현 연습

### D-3: 컨디션 관리 시작
- 수면 패턴 조절 (8시간 수면)
- 과도한 새로운 학습 금지

### D-1: 마음 챙김
- 간단한 문제로 감각 유지
- 시험 당일 계획 점검

---

**관련 포스트**: 
- [16주 알고리즘 커리큘럼](../algorithm-study/) 📖
- [알고리즘 학습 가이드](../algorithm-guide/) 🎯

코딩테스트는 결국 **꾸준한 연습**이 답입니다. 하루 2-3문제씩만 꾸준히 풀어도 충분히 합격할 수 있어요! 🚀
```

### dark-city-existentialism.md

**Path:** `frontend/public/posts/2024/dark-city-existentialism.md`

```markdown
---
title: "다크시티(Dark City, 1998) - 실존주의 철학으로 읽는 SF 걸작"
date: 2025-01-24T16:30:00+09:00
draft: false
featured_image: "/media/dark-city-1998.jpg"
categories:
  - "영화리뷰"
  - "SF영화"
  - "철학적영화"
tags:
  - "다크시티"
  - "실존주의"
  - "사르트르"
  - "키에르케고르"
  - "카뮈"
  - "하이데거"
  - "니체"
  - "SF누아르"
  - "알렉스프로야스"
  - "시뮬레이션현실"
  - "자유의지"
  - "정체성"
summary: "1998년 알렉스 프로야스의 SF 누아르 걸작 '다크시티'를 실존주의 철학의 관점에서 분석한 깊이 있는 해석"
---

# 다크시티(Dark City, 1998) - 실존주의 철학으로 읽는 SF 걸작

## 영화 개관

**다크시티**는 1998년 알렉스 프로야스 감독이 선보인 SF 누아르 영화로, 매트릭스보다 1년 앞서 시뮬레이션 현실이라는 혁신적 개념을 다룬 숨겨진 걸작입니다. 하지만 이 영화의 진정한 가치는 단순한 SF적 상상력을 넘어, **실존주의 철학의 핵심 명제들을 영화적 언어로 탁월하게 구현**했다는 점에 있습니다.

## 사르트르의 "실존이 본질에 앞선다" - 존 머독의 각성

### 본질 없는 존재로서의 인간

장 폴 사르트르는 인간이 먼저 존재하고, 그 다음에 자신의 본질을 스스로 만들어간다고 주장했습니다. 다크시티의 존 머독은 이 명제의 완벽한 구현체입니다. **기억을 잃고 깨어난 그에게는 과거도 정체성도 없습니다**. 오직 현재의 선택만이 그를 규정할 뿐입니다.

> "나는 자유롭게 태어났으며, 어디서나 자유롭다. 그러나 어디서나 사슬에 묶여 있다" - 사르트르

머독이 외계인들의 조작에서 벗어나는 순간, 그는 사르트르가 말한 **절대적 자유**를 획득합니다. 주입된 기억이나 환경에 의존하지 않고, 순수한 선택 행위를 통해 자신의 존재를 규정하는 것입니다.

## 키에르케고르의 불안과 선택 - 튜닝 시간의 공포

### 가능성 앞에서의 현기증

쇠렌 키에르케고르는 불안을 "가능성 앞에서의 현기증"이라고 정의했습니다. 다크시티에서 매일 밤 12시에 벌어지는 "튜닝"은 바로 이 실존적 불안의 시각적 구현입니다. **모든 것이 변할 수 있는 가능성 앞에서 인간은 얼어붙습니다**.

### 선택의 고뇌와 책임

키에르케고르가 강조한 **단독자로서의 선택**은 머독이 마지막에 도시를 재구성할 때 극명하게 드러납니다. 그는 어떤 외적 기준이나 도덕률에 의존하지 않고, 오직 자신의 의지로 새로운 세계를 창조합니다.

## 카뮈의 부조리와 반항 - 끝없는 실험의 의미

### 시지프스의 바위와 튜닝의 반복

알베르 카뮈의 부조리 철학은 다크시티의 핵심 설정과 놀랍도록 일치합니다. **매일 밤 반복되는 튜닝은 시지프스가 바위를 굴리는 것과 같은 부조리한 반복**입니다. 외계인들의 실험에는 명확한 목적도 종료점도 없습니다.

### 반항하는 인간

> "부조리한 인간이 할 수 있는 것은 반항뿐이다" - 카뮈

머독의 각성과 저항은 카뮈가 말한 **부조리에 대한 반항**의 완벽한 사례입니다. 그는 운명을 받아들이지 않고, 부조리한 상황에 맞서 싸웁니다. 이때 중요한 것은 승리가 아니라 반항 자체입니다.

## 하이데거의 현존재와 본래적 존재

### 일상성에 매몰된 존재들

마르틴 하이데거가 말한 **일상성에 매몰된 존재**는 다크시티의 일반 시민들을 정확히 묘사합니다. 그들은 매일 밤 기억이 바뀌어도 의문을 품지 않고, **Das Man(익명의 대중)**으로서 살아갑니다.

### 죽음 앞에서의 각성

하이데거는 죽음을 의식할 때 본래적 존재가 된다고 했습니다. 머독이 연쇄살인 혐의를 받으며 죽음의 위기에 처할 때, 그는 비로소 **본래적 자기 자신**이 되어 진실을 추구하기 시작합니다.

## 니체의 자기창조와 초인 의지

### 신의 죽음과 새로운 가치 창조

프리드리히 니체가 선언한 "신의 죽음"은 다크시티에서 **기존 질서의 붕괴**로 나타납니다. 외계인들이 창조한 가짜 현실이 무너질 때, 머독은 니체가 말한 **새로운 가치의 창조자**가 됩니다.

### 운명애(Amor Fati)와 영원회귀

니체의 **운명애** 개념은 머독이 마지막에 도시를 재창조할 때 구현됩니다. 그는 과거의 고통과 상처까지도 받아들이며, 모든 것을 새롭게 시작할 용기를 보여줍니다.

## 실존주의적 관점에서 본 영화의 핵심 메시지

### 진정한 자유는 선택에서 나온다

다크시티는 **자유가 주어지는 것이 아니라 쟁취하는 것**임을 보여줍니다. 머독의 여정은 사르트르가 말한 "자유롭도록 저주받은" 인간의 조건을 극명하게 드러냅니다.

### 불안과 고독은 성장의 동력

키에르케고르와 하이데거가 강조한 **실존적 불안**은 다크시티에서 각성의 전제 조건입니다. 머독만이 이 불안을 견디고 진실에 도달할 수 있었습니다.

### 부조리한 세계에서의 의미 창조

카뮈의 철학처럼, 영화는 **의미 없는 세계에서 스스로 의미를 창조하는 인간의 위대함**을 찬양합니다.

## 현대적 해석: 디지털 시대의 실존주의

### 알고리즘과 튜닝의 유사성

현재 우리가 경험하는 **소셜미디어 알고리즘의 조작**은 영화 속 튜닝과 놀랍도록 유사합니다. 우리의 취향과 인식이 보이지 않는 힘에 의해 조작되고 있는 것입니다.

### 디지털 정체성의 문제

SNS 프로필, 디지털 페르소나 등은 다크시티의 **주입된 기억**과 본질적으로 같은 문제를 제기합니다. 진정한 나는 누구인가? 라는 실존적 질문이 그 어느 때보다 절실합니다.

## 실존주의 철학으로 재해석한 결론

다크시티는 단순한 SF 스릴러를 넘어 **20세기 실존주의 철학의 정수를 영화적으로 구현한 걸작**입니다. 사르트르의 자유, 키에르케고르의 불안, 카뮈의 반항, 하이데거의 본래성, 니체의 자기창조 등 실존주의의 핵심 개념들이 영화 전반에 스며들어 있습니다.

특히 **존재의 진정성에 대한 탐구**는 현재 디지털 시대를 살아가는 우리에게 더욱 절실한 메시지로 다가옵니다. 가상현실과 인공지능의 시대에 "나는 누구인가?"라는 실존적 질문은 여전히 유효하며, 다크시티는 그 답을 찾아가는 여정의 나침반 역할을 해줍니다.

**진정한 자유는 주어지는 것이 아니라, 불안과 고독을 견디며 스스로 선택해 나가는 것**이라는 영화의 메시지는 실존주의 철학의 핵심과 완벽하게 일치합니다. 이것이야말로 다크시티가 단순한 오락영화를 넘어 철학적 성찰을 요구하는 예술작품으로 평가받아야 하는 이유입니다.
```

### database-containerization-guide.md

**Path:** `frontend/public/posts/2024/database-containerization-guide.md`

```markdown
---
title: "데이터베이스 및 애플리케이션 컨테이너화 설치 가이드"
date: "2024-07-29"
category: "Database"
tags: ['MySQL', 'PostgreSQL', 'Redis', 'RabbitMQ', 'Kavita', 'SSL', 'TLS', 'Container']
excerpt: "MySQL, PostgreSQL, Redis, RabbitMQ, Kavita 등 주요 데이터베이스와 애플리케이션의 Docker 컨테이너화 및 호스트 설치 방법을 SSL/TLS 설정과 함께 소개합니다."
readTime: "3분"
---

## MySQL/MariaDB

### Docker 설치 (SSL 포함)

```bash
# 인증서 생성
mkdir -p ~/mysql-certs && cd ~/mysql-certs
openssl req -x509 -newkey rsa:4096 -nodes -days 365 \
  -keyout server-key.pem -out server-cert.pem \
  -subj "/CN=mysql.docker.local"

# 컨테이너 실행
docker run -d --name mysql \
  -v mysql_data:/var/lib/mysql \
  -v $(pwd):/etc/mysql/certs \
  -e MYSQL_ROOT_PASSWORD=securepass \
  -e MYSQL_SSL_CERT=/etc/mysql/certs/server-cert.pem \
  -e MYSQL_SSL_KEY=/etc/mysql/certs/server-key.pem \
  -p 3306:3306 \
  mysql:8.0 \
  --ssl-ca=/etc/mysql/certs/server-cert.pem \
  --ssl-cert=/etc/mysql/certs/server-cert.pem \
  --ssl-key=/etc/mysql/certs/server-key.pem
```

### 호스트 설치 (Ubuntu)

```bash
sudo apt-get update && sudo apt-get install mysql-server
sudo mysql_secure_installation

# SSL 설정
sudo mysql_ssl_rsa_setup --uid=mysql
sudo systemctl restart mysql

# 외부 접속 허용
sudo sed -i 's/bind-address.*/bind-address = 0.0.0.0/' /etc/mysql/mysql.conf.d/mysqld.cnf
sudo ufw allow 3306/tcp
```

## PostgreSQL

### Docker 설치 (SSL 포함)

```bash
docker run -d --name postgres \
  -v pg_data:/var/lib/postgresql/data \
  -v $(pwd)/certs:/certs \
  -e POSTGRES_PASSWORD=mysecretpassword \
  -p 5432:5432 \
  postgres:15 \
  -c ssl=on \
  -c ssl_cert_file=/certs/server.crt \
  -c ssl_key_file=/certs/server.key
```

### 호스트 설치 (Let's Encrypt 활용)

```bash
sudo apt-get install postgresql-15 certbot
sudo certbot certonly --standalone -d postgres.example.com

# 인증서 연결
sudo cp /etc/letsencrypt/live/postgres.example.com/* /etc/postgresql/15/main/
sudo chown postgres:postgres /etc/postgresql/15/main/*.pem
sudo systemctl restart postgresql

# pg_hba.conf 수정
hostssl all all 0.0.0.0/0 md5 clientcert=verify-ca
```

## Redis

### Docker TLS 설정

```bash
# TLS 설정 파일 생성
openssl genrsa -out redis.key 2048
openssl req -new -x509 -key redis.key -out redis.crt -days 365

docker run -d --name redis \
  -v $(pwd)/tls:/tls \
  -p 6379:6379 \
  redis:7.2 \
  --tls-port 6379 \
  --port 0 \
  --tls-cert-file /tls/redis.crt \
  --tls-key-file /tls/redis.key \
  --requirepass "securepassword"
```

### 호스트 설치 (Ubuntu)

```bash
sudo add-apt-repository ppa:redislabs/redis
sudo apt-get install redis-server

# TLS 설정
sudo mkdir /etc/redis/tls
sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout /etc/redis/tls/redis.key \
  -out /etc/redis/tls/redis.crt

sudo systemctl restart redis-server
```

## RabbitMQ

### Docker TLS 구성

```bash
docker run -d --name rabbitmq \
  -v rabbitmq_certs:/etc/rabbitmq/certs \
  -p 5671:5671 -p 15672:15672 \
  rabbitmq:3.12-management \
  rabbitmq-plugins enable rabbitmq_auth_mechanism_ssl
```

### 호스트 설치 및 인증서 설정

```bash
# Erlang 설치
curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.deb.sh | sudo bash
sudo apt-get install erlang

# RabbitMQ 설치
curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.deb.sh | sudo bash
sudo apt-get install rabbitmq-server

# 인증서 생성
sudo rabbitmqctl create_user admin securepass
sudo rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"
sudo rabbitmq-plugins enable rabbitmq_management rabbitmq_auth_mechanism_ssl
```

## Kavita (전자책 관리 시스템)

### Docker 설치

```bash
docker run -d --name kavita \
  -v /path/to/books:/books \
  -v /path/to/config:/kavita/config \
  -p 5000:5000 \
  --restart unless-stopped \
  kizaing/kavita:latest
```

### 리버스 프록시 설정 (Nginx)

```nginx
server {
    listen 443 ssl;
    server_name kavita.example.com;

    ssl_certificate /etc/letsencrypt/live/kavita.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/kavita.example.com/privkey.pem;

    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
    }
}
```

## 공통 보안 설정 가이드

### 1. 방화벽 규칙
```bash
sudo ufw allow [포트번호]/tcp
```

### 2. 인증서 갱신
```bash
sudo certbot renew --pre-hook "systemctl stop nginx" --post-hook "systemctl start nginx"
```

### 3. 접근 제어
```nginx
allow 192.168.1.0/24;
deny all;
```

## 문제 해결 체크리스트

1. **컨테이너 로그 확인:**
   ```bash
   docker logs [컨테이너명]
   ```

2. **포트 개방 상태 확인:**
   ```bash
   sudo ss -tulwn | grep [포트번호]
   ```

3. **인증서 권한 확인:**
   ```bash
   ls -l [인증서경로]
   ```

4. **SELinux/AppArmor 정책 점검**

## 결론

이 가이드에서는 주요 데이터베이스와 애플리케이션들의 컨테이너화 및 호스트 설치 방법을 SSL/TLS 보안 설정과 함께 제공했습니다. 각 서비스의 특성에 맞는 보안 설정을 적용하여 안전하고 효율적인 인프라를 구축할 수 있습니다.
```

### dfs.md

**Path:** `frontend/public/posts/2024/dfs.md`

```markdown
---
title: "깊이 우선 탐색 (DFS, Depth-First Search)"
date: "2024-12-11"
category: "Algorithm"
tags: ['DFS', '그래프', '탐색', '재귀', '스택']
excerpt: "깊이 우선 탐색(DFS) 알고리즘의 원리와 구현, 다양한 응용 문제 해결법을 학습합니다."
readTime: "6분"
---

## 개요

**깊이 우선 탐색(DFS, Depth-First Search)**은 그래프나 트리를 탐색하는 알고리즘으로, 한 경로를 끝까지 탐색한 후 다른 경로를 탐색하는 방식입니다.

### 핵심 특징
- **깊이 우선**: 가능한 한 깊이 들어가며 탐색
- **백트래킹**: 더 이상 갈 곳이 없으면 되돌아감
- **완전 탐색**: 모든 정점을 방문할 수 있음
- **스택 구조**: 후입선출(LIFO) 특성 활용

### 시간 복잡도
- **인접 리스트**: O(V + E)
- **인접 행렬**: O(V²)
- **공간 복잡도**: O(V) (재귀 호출 스택)

## 기본 구현

### 1. 재귀를 이용한 DFS

```cpp
#include <iostream>
#include <vector>
using namespace std;

class DFS {
private:
    vector<vector<int>> adj;  // 인접 리스트
    vector<bool> visited;     // 방문 체크
    int n;                    // 정점 개수
    
public:
    DFS(int vertices) : n(vertices) {
        adj.resize(n);
        visited.resize(n);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);  // 무방향 그래프
    }
    
    void dfs(int vertex) {
        visited[vertex] = true;
        cout << vertex << " ";
        
        // 인접한 모든 정점 탐색
        for (int next : adj[vertex]) {
            if (!visited[next]) {
                dfs(next);
            }
        }
    }
    
    void dfsAll() {
        fill(visited.begin(), visited.end(), false);
        
        // 모든 연결 컴포넌트 탐색
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                cout << "Component: ";
                dfs(i);
                cout << "\n";
            }
        }
    }
};
```

### 2. 스택을 이용한 반복적 DFS

```cpp
#include <stack>

void dfsIterative(int start) {
    vector<bool> visited(n, false);
    stack<int> st;
    
    st.push(start);
    
    while (!st.empty()) {
        int vertex = st.top();
        st.pop();
        
        if (!visited[vertex]) {
            visited[vertex] = true;
            cout << vertex << " ";
            
            // 인접한 정점들을 스택에 추가
            // 역순으로 넣어야 올바른 DFS 순서가 됨
            for (int i = adj[vertex].size() - 1; i >= 0; i--) {
                int next = adj[vertex][i];
                if (!visited[next]) {
                    st.push(next);
                }
            }
        }
    }
}
```

## 응용 문제

### 1. 연결 컴포넌트 개수 구하기

```cpp
class ConnectedComponents {
private:
    vector<vector<int>> adj;
    vector<bool> visited;
    int n;
    
    void dfs(int v) {
        visited[v] = true;
        for (int next : adj[v]) {
            if (!visited[next]) {
                dfs(next);
            }
        }
    }
    
public:
    ConnectedComponents(int vertices) : n(vertices) {
        adj.resize(n);
        visited.resize(n);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    int countComponents() {
        fill(visited.begin(), visited.end(), false);
        int count = 0;
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(i);
                count++;
            }
        }
        
        return count;
    }
};
```

### 2. 사이클 검출 (무방향 그래프)

```cpp
class CycleDetection {
private:
    vector<vector<int>> adj;
    vector<bool> visited;
    int n;
    
    bool dfs(int v, int parent) {
        visited[v] = true;
        
        for (int next : adj[v]) {
            if (!visited[next]) {
                if (dfs(next, v)) return true;
            }
            else if (next != parent) {
                return true;  // 사이클 발견
            }
        }
        return false;
    }
    
public:
    CycleDetection(int vertices) : n(vertices) {
        adj.resize(n);
        visited.resize(n);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    bool hasCycle() {
        fill(visited.begin(), visited.end(), false);
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                if (dfs(i, -1)) return true;
            }
        }
        return false;
    }
};
```

### 3. 경로 찾기

```cpp
class PathFinding {
private:
    vector<vector<int>> adj;
    vector<bool> visited;
    vector<int> path;
    int n;
    
    bool dfs(int current, int target) {
        visited[current] = true;
        path.push_back(current);
        
        if (current == target) {
            return true;  // 목표 도달
        }
        
        for (int next : adj[current]) {
            if (!visited[next]) {
                if (dfs(next, target)) {
                    return true;
                }
            }
        }
        
        path.pop_back();  // 백트래킹
        return false;
    }
    
public:
    PathFinding(int vertices) : n(vertices) {
        adj.resize(n);
        visited.resize(n);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    vector<int> findPath(int start, int end) {
        fill(visited.begin(), visited.end(), false);
        path.clear();
        
        if (dfs(start, end)) {
            return path;
        }
        return {};  // 경로 없음
    }
};
```

## 고급 응용

### 1. 위상 정렬 (방향 그래프)

```cpp
class TopologicalSort {
private:
    vector<vector<int>> adj;
    vector<bool> visited;
    stack<int> result;
    int n;
    
    void dfs(int v) {
        visited[v] = true;
        
        for (int next : adj[v]) {
            if (!visited[next]) {
                dfs(next);
            }
        }
        
        result.push(v);  // 완료 시점에 스택에 추가
    }
    
public:
    TopologicalSort(int vertices) : n(vertices) {
        adj.resize(n);
        visited.resize(n);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);  // 방향 그래프
    }
    
    vector<int> topologicalSort() {
        fill(visited.begin(), visited.end(), false);
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(i);
            }
        }
        
        vector<int> sorted;
        while (!result.empty()) {
            sorted.push_back(result.top());
            result.pop();
        }
        
        return sorted;
    }
};
```

### 2. 강한 연결 컴포넌트 (SCC)

```cpp
class StronglyConnectedComponents {
private:
    vector<vector<int>> adj, radj;  // 원본 그래프, 역방향 그래프
    vector<bool> visited;
    stack<int> order;
    vector<vector<int>> components;
    int n;
    
    void dfs1(int v) {
        visited[v] = true;
        for (int next : adj[v]) {
            if (!visited[next]) {
                dfs1(next);
            }
        }
        order.push(v);
    }
    
    void dfs2(int v, vector<int>& component) {
        visited[v] = true;
        component.push_back(v);
        
        for (int next : radj[v]) {
            if (!visited[next]) {
                dfs2(next, component);
            }
        }
    }
    
public:
    StronglyConnectedComponents(int vertices) : n(vertices) {
        adj.resize(n);
        radj.resize(n);
        visited.resize(n);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        radj[v].push_back(u);  // 역방향 엣지
    }
    
    vector<vector<int>> findSCC() {
        // 1단계: 원본 그래프에서 완료 시간 순서 구하기
        fill(visited.begin(), visited.end(), false);
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs1(i);
            }
        }
        
        // 2단계: 역방향 그래프에서 SCC 찾기
        fill(visited.begin(), visited.end(), false);
        components.clear();
        
        while (!order.empty()) {
            int v = order.top();
            order.pop();
            
            if (!visited[v]) {
                vector<int> component;
                dfs2(v, component);
                components.push_back(component);
            }
        }
        
        return components;
    }
};
```

## 실전 문제 해결

### 백준 예제 문제들

#### 1. DFS와 BFS (1260)
```cpp
// 정점 번호가 작은 것부터 방문하는 DFS
void dfs(int v, vector<vector<int>>& adj, vector<bool>& visited) {
    visited[v] = true;
    cout << v << " ";
    
    for (int next : adj[v]) {
        if (!visited[next]) {
            dfs(next, adj, visited);
        }
    }
}
```

#### 2. 연결 요소의 개수 (11724)
```cpp
int countConnectedComponents(int n, vector<vector<int>>& adj) {
    vector<bool> visited(n + 1, false);
    int count = 0;
    
    for (int i = 1; i <= n; i++) {
        if (!visited[i]) {
            dfs(i, adj, visited);
            count++;
        }
    }
    
    return count;
}
```

## 주의사항과 팁

### 1. 시간 복잡도 최적화
- 인접 리스트 사용으로 O(V + E) 달성
- 불필요한 방문 체크로 무한 루프 방지
- 재귀 깊이 제한 고려 (스택 오버플로우)

### 2. 메모리 관리
- 큰 그래프에서는 재귀 대신 반복적 구현 고려
- 방문 배열 초기화 확인
- 벡터 크기 사전 할당

### 3. 디버깅 요령
```cpp
void debugDFS(int v, int depth = 0) {
    string indent(depth * 2, ' ');
    cout << indent << "Visiting: " << v << endl;
    
    visited[v] = true;
    
    for (int next : adj[v]) {
        if (!visited[next]) {
            debugDFS(next, depth + 1);
        }
    }
    
    cout << indent << "Backtrack from: " << v << endl;
}
```

## 연관 알고리즘
- **[BFS (너비 우선 탐색)](/post/algorithms/bfs)**: 레벨 단위 탐색
- **[다이나믹 프로그래밍](/post/algorithms/dynamic-programming)**: 메모이제이션과 백트래킹
- **[백트래킹](/post/algorithms/backtracking)**: 조건부 탐색

## 마무리

DFS는 그래프 탐색의 기본이 되는 알고리즘으로, 다양한 그래프 문제의 해결책이 됩니다. 재귀의 특성을 이해하고 백트래킹 개념을 숙지하면 복잡한 탐색 문제도 해결할 수 있습니다.

**학습 순서**: 기본 DFS → 연결 컴포넌트 → 사이클 검출 → 위상 정렬 → SCC
```

### docker-kubernetes-guide.md

**Path:** `frontend/public/posts/2024/docker-kubernetes-guide.md`

```markdown
---
title: "Docker와 Kubernetes 삽질기"
date: "2024-10-04"
category: "DevOps"
tags: ["Docker", "Kubernetes", "DevOps", "Container"]
excerpt: "컨테이너 기술의 핵심인 Docker와 오케스트레이션 도구 Kubernetes 활용법을 다룹니다."
readTime: "12분"
---

# Docker와 Kubernetes 삽질기

## Docker를 처음 만났을 때

사실 처음에는 Docker가 뭔지도 몰랐다. "내 컴퓨터에서는 잘 되는데?" 하는 상황을 겪다가 선배가 "Docker 써봐"라고 해서 시작했다.

가상머신과 비슷한 건가 싶었는데, 막상 써보니 훨씬 가볍고 빠르더라. 특히 팀 프로젝트할 때 "내 환경에서는 안 돼요" 이런 문제가 없어지니까 정말 편했다.

### 첫 Dockerfile 만들어보기

Node.js 프로젝트를 Docker로 감싸보는 게 첫 도전이었다.

```dockerfile
# 처음 만든 Dockerfile (지금 보니 개선할 점이 많다)
FROM node:18-alpine

# 작업 디렉토리 설정
WORKDIR /app

# package.json 먼저 복사 (캐싱 활용하려고)
COPY package*.json ./
RUN npm ci --only=production

# 나머지 소스코드 복사
COPY . .

# 포트 열어주기
EXPOSE 3000

# 앱 실행
CMD ["npm", "start"]
```

처음에는 이게 뭔지도 모르고 그냥 복붙했는데, 나중에 하나씩 이해하니까 재밌더라. 특히 package.json을 먼저 복사하는 이유를 알았을 때 '아, 이래서 Docker가 빠른구나' 싶었다.

### Docker 명령어들 - 처음엔 헷갈렸다

```bash
# 이미지 빌드하기
docker build -t my-app .

# 컨테이너 실행하기  
docker run -p 3000:3000 my-app

# 실행 중인 컨테이너 확인
docker ps

# 컨테이너 안으로 들어가기 (디버깅할 때 유용함)
docker exec -it container_name /bin/sh
```

처음에는 `docker run`과 `docker exec`의 차이도 몰랐다. 컨테이너가 왜 자꾸 종료되는지도 몰라서 한참 헤맸다.

### docker-compose - 여러 컨테이너 관리하기

프로젝트가 복잡해지면서 데이터베이스, 레디스, 앱 서버를 다 따로 실행해야 했다. 그때 docker-compose를 알게 됐다.

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    depends_on:
      - db
      - redis
    environment:
      - DB_HOST=db
      - REDIS_HOST=redis

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:alpine
    
volumes:
  postgres_data:
```

이제는 `docker-compose up` 한 번이면 개발 환경이 뚝딱 세팅된다. 신입팀원이 와도 "Docker 설치하고 이 명령어만 쳐봐"라고 하면 끝이니까 정말 편하다.

## Kubernetes - 이건 진짜 어려웠다

Docker에 어느 정도 익숙해진 후에 Kubernetes를 처음 접했을 때는 정말 막막했다. '이게 정말 필요한가?' 싶기도 하고.

하지만 서비스 규모가 커지면서 필요성을 느꼈다. 컨테이너가 죽으면 자동으로 다시 시작해주고, 트래픽에 따라 자동으로 확장/축소해주고...

### 첫 Pod 만들어보기

```yaml
# my-first-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-app-pod
  labels:
    app: my-app
spec:
  containers:
  - name: my-app
    image: my-app:latest
    ports:
    - containerPort: 3000
```

Pod가 뭔지도 모르고 일단 만들어봤다. "컨테이너를 감싸는 또 다른 껍데기?" 정도로 이해했는데, 나중에 보니 Pod는 쿠버네티스의 기본 단위더라.

### Deployment - Pod들을 관리하는 상위 개념

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-deployment
spec:
  replicas: 3  # Pod를 3개 실행
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: my-app:latest
        ports:
        - containerPort: 3000
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
```

Deployment를 처음 만들어보고 `kubectl get pods`를 쳤을 때 Pod 3개가 자동으로 생성된 걸 보고 신기했다. 하나를 지워도 자동으로 다시 생성되더라.

### Service - 외부에서 접근하게 하기

```yaml
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app
  ports:
  - port: 80
    targetPort: 3000
  type: LoadBalancer
```

Pod들은 내부 IP를 갖고 있어서 외부에서 직접 접근할 수 없다는 걸 모르고 한참 헤맸다. Service를 만들어야 한다는 걸 알고 나서야 해결됐다.

## 실제로 겪은 삽질들

### 이미지 태그 관리

처음에는 `latest` 태그만 썼는데, 배포할 때마다 어떤 버전인지 헷갈리더라. 지금은 Git commit hash나 버전 번호를 태그로 쓴다.

```bash
# 이전: 어떤 버전인지 모름
docker build -t my-app:latest .

# 지금: 명확한 버전 관리
docker build -t my-app:v1.2.3 .
docker build -t my-app:abc123def .
```

### 리소스 설정

리소스 제한을 안 걸어놨다가 Pod 하나가 메모리를 다 먹어서 노드가 죽은 적이 있다. 그 이후로는 항상 requests/limits를 설정한다.

### 볼륨 마운트

데이터가 컨테이너와 함께 사라진다는 걸 몰라서 중요한 데이터를 날린 적이 있다. 이후로는 영구 저장이 필요한 건 꼭 PersistentVolume을 쓴다.

```yaml
# PersistentVolumeClaim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-app-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### Secret 관리

처음에는 환경변수에 비밀번호를 그대로 넣었는데, 이게 보안상 위험하다는 걸 알고 Secret을 쓰기 시작했다.

```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-app-secret
type: Opaque
data:
  database-password: cGFzc3dvcmQxMjM= # base64 인코딩된 값
```

## 지금 쓰고 있는 워크플로우

### 개발 환경
로컬에서는 docker-compose를 쓴다. 빠르고 간단해서.

### 스테이징/프로덕션
Kubernetes를 쓴다. 자동 복구, 스케일링, 롤링 업데이트 등이 필요해서.

### CI/CD 파이프라인
```yaml
# GitHub Actions 예시
name: Deploy
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Build Docker image
      run: |
        docker build -t my-app:${{ github.sha }} .
        
    - name: Push to registry
      run: |
        docker push my-app:${{ github.sha }}
        
    - name: Deploy to Kubernetes
      run: |
        kubectl set image deployment/my-app my-app=my-app:${{ github.sha }}
```

## 앞으로 배워보고 싶은 것들

### Helm
Kubernetes 매니페스트 파일들이 점점 많아지면서 관리가 어려워지고 있다. Helm을 써서 템플릿화하면 좋을 것 같다.

### Istio
서비스 메시라는 개념이 궁금하다. 특히 마이크로서비스 간 통신을 관리하는 부분이.

### 모니터링
Prometheus + Grafana 조합을 써보고 싶다. 지금은 그냥 로그만 보는데, 메트릭도 제대로 수집하고 싶다.

## 마무리하며

Docker와 Kubernetes를 배우면서 느낀 건, 처음에는 복잡해 보이지만 하나씩 이해하면 정말 강력한 도구라는 것이다.

특히 "내 컴퓨터에서는 잘 되는데"라는 말을 안 하게 된 게 가장 큰 수확이다. 개발 환경과 프로덕션 환경이 동일하니까 예상치 못한 버그가 줄어들었다.

물론 아직 배울 게 많다. 특히 Kubernetes는 정말 깊이가 있는 기술이라 계속 공부해야 할 것 같다. 하지만 한 번 익숙해지면 정말 편한 도구인 건 확실하다.
```

### Docker 명령어

```bash
# 이미지 빌드
docker build -t myapp:latest .

# 컨테이너 실행
docker run -p 3000:3000 myapp:latest

# 컨테이너 목록 조회
docker ps
```

## Kubernetes 기초

Kubernetes는 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 오케스트레이션 플랫폼입니다.

### Pod 정의

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
spec:
  containers:
  - name: myapp
    image: myapp:latest
    ports:
    - containerPort: 3000
```

### Deployment 생성

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 3000
```

## 실전 활용 팁

### 1. 멀티 스테이지 빌드
Docker 이미지 크기를 줄이기 위해 멀티 스테이지 빌드를 활용하세요.

### 2. 헬스 체크
애플리케이션의 상태를 모니터링하기 위해 헬스 체크를 구현하세요.

### 3. 로그 관리
중앙화된 로그 시스템을 구축하여 문제 해결을 용이하게 하세요.

## 결론

Docker와 Kubernetes는 현대적인 애플리케이션 배포의 핵심 기술입니다. 점진적으로 학습하고 실무에 적용해 나가는 것이 중요합니다.
```

### firebase-hosting-guide.md

**Path:** `frontend/public/posts/2024/firebase-hosting-guide.md`

```markdown
---
title: "Flutter 웹앱을 Firebase에 무료로 배포하기"
date: "2024-12-14"
category: "개발"
tags: ['Flutter', 'Firebase', 'Hosting', '웹배포', '개발']
excerpt: "Flutter 웹앱을 Firebase Hosting에 배포하는 방법을 실제 경험을 바탕으로 단계별 설명"
readTime: "3분"
---

Flutter로 웹앱을 만들고 나서 다른 사람들에게 보여주고 싶은데, 매번 "내 컴퓨터에서 `flutter run -d web` 하고 localhost 보세요" 할 수는 없잖나. Firebase Hosting을 사용하면 무료로 웹에 배포할 수 있다.

몇 번 해보면서 삽질한 경험을 바탕으로 정리해보려고 한다.

## 왜 Firebase Hosting인가?

다른 호스팅 서비스도 많은데 Firebase를 쓰는 이유:

1. **무료**: Spark 플랜으로 웬만한 개인 프로젝트는 충분
2. **빠름**: Google CDN 사용해서 로딩 속도 빠름
3. **간편함**: CLI로 명령어 하나면 배포 완료
4. **HTTPS**: 기본으로 SSL 인증서 제공
5. **커스텀 도메인**: 나중에 내 도메인 연결 가능

## 필요한 것들

배포하기 전에 준비해야 할 것들:

- **Google 계정**: Firebase는 구글 서비스니까
- **Flutter 프로젝트**: 웹 지원하는 프로젝트여야 함
- **Node.js**: Firebase CLI 설치하려면 필요

Node.js 설치되어 있는지 확인하려면:
```bash
node -v
```

없으면 [nodejs.org](https://nodejs.org)에서 다운로드해서 설치하자.

## 단계별 배포 과정

### 1. Firebase 프로젝트 만들기

[Firebase 콘솔](https://console.firebase.google.com)에 들어가서:

1. "프로젝트 추가" 클릭
2. 프로젝트 이름 입력 (예: `my-flutter-app`)
3. Google Analytics는 일단 끄고 넘어가기 (나중에 추가 가능)
4. "프로젝트 만들기" 클릭하고 기다리기

### 2. Firebase CLI 설치

터미널 열고 Firebase CLI 설치:

```bash
npm install -g firebase-tools
```

설치 완료되면 로그인:

```bash
firebase login
```

브라우저가 열리면서 구글 계정으로 로그인하라고 나온다. 아까 프로젝트 만든 계정으로 로그인하면 됨.

### 3. Flutter 프로젝트에 Firebase 설정

Flutter 프로젝트 폴더로 이동:

```bash
cd /path/to/my-flutter-project
```

Firebase 초기화:

```bash
firebase init
```

여러 질문이 나오는데 이렇게 답하면 됨:

- **Are you ready to proceed?** → `Y`
- **Which Firebase features?** → `Hosting` 선택 (스페이스바로 선택, 엔터로 확인)
- **Please select an option** → `Use an existing project`
- **Select a default Firebase project** → 아까 만든 프로젝트 선택
- **What do you want to use as your public directory?** → **중요!** `build/web` 입력
- **Configure as a single-page app?** → `Y` (이거 안 하면 라우팅 안 됨)
- **Set up automatic builds and deploys with GitHub?** → `N` (일단 수동으로)

`build/web`을 꼭 입력해야 한다. Flutter 웹 빌드 결과물이 여기에 생성되기 때문이다.

### 4. Flutter 웹 빌드

```bash
flutter build web
```

이 명령어로 `build/web` 폴더에 배포용 파일들이 생성된다.

### 5. 배포하기

```bash
firebase deploy
```

잠시 기다리면 이런 메시지가 나온다:

```
✔ Deploy complete!

Project Console: https://console.firebase.google.com/project/my-flutter-app/overview
Hosting URL: https://my-flutter-app.web.app
```

**Hosting URL**이 바로 내 앱 주소다! 이 링크 공유하면 누구나 볼 수 있다.

## 업데이트하는 방법  

앱 수정하고 다시 배포하려면:

```bash
flutter build web
firebase deploy
```

이 두 명령어만 다시 실행하면 됨. 간단하다.

## 자주 만나는 문제들

### 1. 라우팅이 안 됨
Firebase 설정할 때 "single-page app" 설정을 `Y`로 안 했을 가능성이 높다. 

`firebase.json` 파일 열어서 이렇게 되어 있는지 확인:
```json
{
  "hosting": {
    "public": "build/web",
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}
```

### 2. 404 에러
`public` 디렉토리를 `build/web`으로 안 설정했거나, 빌드를 안 하고 배포했을 때 발생한다.

### 3. 권한 에러
`firebase login`을 안 했거나, 다른 계정으로 로그인되어 있을 때. `firebase logout` 후 다시 로그인해보자.

### 4. 용량 초과
Spark 플랜은 10GB까지만 무료다. 이미지나 동영상 파일이 너무 크면 최적화하거나 외부 CDN 사용하자.

## 추가 팁들

### 커스텀 도메인 연결
Firebase 콘솔 → Hosting → "커스텀 도메인 추가"에서 내 도메인 연결 가능하다.

### 배포 히스토리 관리
```bash
firebase hosting:disable    # 사이트 비활성화
firebase deploy --only hosting  # hosting만 배포
```

### 로컬에서 미리보기
```bash
firebase serve
```
로컬에서 Firebase 환경과 똑같이 테스트할 수 있다.

### GitHub Actions로 자동 배포
나중에 푸시할 때마다 자동으로 배포되게 하고 싶으면 GitHub Actions 설정할 수도 있다. 하지만 처음엔 수동이 편하다.

## 마무리

Firebase Hosting은 정말 편하다. 설정 한 번만 해두면 나중엔 `flutter build web && firebase deploy` 이 두 명령어로 끝이다.

무료 플랜도 개인 프로젝트엔 충분하고, 속도도 빠르고, HTTPS도 기본 제공이라 부담 없이 쓸 수 있다.

기획자나 디자이너분들께 "이거 한번 봐주세요" 하면서 링크 보내기 정말 편하다. 더 이상 localhost 포트번호 알려드릴 필요 없다는 게 최고다.
```

### gemini-gui-dev-tool-idea.md

**Path:** `frontend/public/posts/2024/gemini-gui-dev-tool-idea.md`

```markdown
---
title: "Gemini-CLI를 GUI로? 비개발자도 쓸 수 있는 AI 개발도구 아이디어"
date: "2024-11-19"
category: "Development"
tags: ['Gemini-CLI', 'Flutter', 'GUI', 'AI개발도구', '앱개발', '아이디어']
excerpt: "Gemini-CLI를 Flutter로 감싸서 비개발자도 쉽게 앱을 만들 수 있는 도구를 만들면 어떨까?"
readTime: "3분"
---

요즘 AI 코딩 도구들이 정말 많이 나오고 있는데, 대부분 개발자들을 위한 것들이다. 그런데 Gemini-CLI를 써보면서 "이걸 비개발자도 쉽게 쓸 수 있게 만들면 어떨까?"라는 생각이 들었다.

## 현재 AI 개발도구의 한계

기존 AI 코딩 도구들의 문제점:
- **명령줄 인터페이스**: 터미널을 모르는 사람은 접근하기 어려움
- **개발 지식 필요**: 기본적인 코딩 개념을 알아야 함
- **결과 확인 어려움**: 코드가 실제로 어떻게 동작하는지 바로 볼 수 없음

비개발자(기획자, 디자이너, 창업가)들이 아이디어는 있는데 구현할 방법이 없어서 포기하는 경우가 많다.

## 아이디어: Gemini Dev Agent

**핵심 컨셉**: Gemini-CLI의 강력한 기능을 Flutter GUI로 감싸서, 채팅하듯이 앱을 만들 수 있는 도구

### 주요 타겟 사용자
1. **비개발자** (기획자, 디자이너, 창업가)
   - 자연어로 원하는 기능 요청
   - 즉시 시각적 결과물 확인
   - 복잡한 설정 없이 바로 사용

2. **주니어 개발자/학생**  
   - 코드 학습 도구로 활용
   - AI에게 코드 리뷰 받기
   - 모범 사례 학습

## 핵심 기능들

### 1. 대화형 개발 인터페이스

기존: `gemini-cli "로그인 화면 만들어줘"`
개선: 카카오톡처럼 채팅하면서 개발

```
사용자: "로그인 화면 만들어줘"
AI: "로그인 화면을 만들어드리겠습니다. 어떤 스타일을 원하시나요?"
[미리보기 화면이 실시간으로 나타남]
사용자: "버튼을 파란색으로 바꿔줘"
AI: "네, 버튼 색상을 파란색으로 변경했습니다."
[미리보기가 즉시 업데이트됨]
```

### 2. 실시간 미리보기

- 생성된 Flutter 위젯을 앱 내에서 바로 렌더링
- 수정사항이 즉시 반영되는 라이브 프리뷰
- "이거 맞나?" 하는 의구심 없이 바로 확인 가능

### 3. 자동 파일 관리

```
사용자: "지금까지 작업한 내용 저장해줘"
AI: "변경사항을 분석해서 의미있는 커밋 메시지로 저장했습니다:
     'feat: 로그인 화면 UI 구현 및 버튼 스타일 개선'"
```

- Git 연동으로 자동 버전 관리
- AI가 커밋 메시지까지 생성
- 복잡한 Git 명령어 몰라도 OK

### 4. 원스톱 배포

```
사용자: "이 앱을 웹사이트로 배포해줘"
AI: "Flutter Web으로 빌드해서 Firebase Hosting에 배포하겠습니다."
[진행 상황이 실시간으로 표시됨]
AI: "배포 완료! 링크: https://your-app.web.app"
```

## 기술적 구현 방안

### 아키텍처
- **Frontend**: Flutter (iOS/Android)
- **Backend**: Gemini API + Firebase
- **핵심**: Gemini-CLI 기능들을 API로 래핑

### 주요 챌린지

1. **실시간 코드 렌더링**
   - Flutter Hot Reload 기능 활용
   - 안전한 코드 실행 환경 구축

2. **자연어 처리**
   - 한국어 맥락 이해
   - 이전 대화 기억 (Context-Aware)

3. **파일 시스템 연동**
   - 모바일에서 로컬 프로젝트 관리
   - Git 연동을 위한 권한 처리

## 예상되는 사용 시나리오

### 시나리오 1: 카페 사장의 주문 앱 개발
```
사용자: "우리 카페 주문 앱 만들고 싶어"
AI: "어떤 기능이 필요하신가요?"
사용자: "메뉴 보기, 주문하기, 결제하기"
AI: "메뉴 화면부터 만들어보겠습니다..."
[메뉴 리스트 UI가 실시간으로 생성됨]
```

### 시나리오 2: 디자이너의 포트폴리오 앱
```
사용자: "내 작품들을 보여주는 갤러리 앱 만들어줘"
AI: "이미지 갤러리를 만들어드리겠습니다. 작품 이미지들을 업로드해주세요."
[드래그&드롭으로 이미지 업로드]
[자동으로 갤러리 UI 생성]
```

## 시장 차별화 포인트

### 기존 도구들과의 차이점
- **No-Code 플랫폼**: 제한적인 커스터마이징
- **AI 코딩 도구**: 개발자 대상, 복잡한 설정
- **Gemini Dev Agent**: 자연어 + 실시간 미리보기 + 원스톱 배포

### 경쟁 우위
1. **직관성**: 카톡하듯이 개발
2. **즉시성**: 말하자마자 결과 확인
3. **완성도**: 아이디어부터 배포까지 한번에

## 수익 모델 아이디어

1. **Freemium**: 기본 기능 무료, 고급 기능 유료
2. **월 구독**: 프로젝트 개수나 배포 횟수 제한
3. **기업용**: 팀 협업, 고급 보안 기능
4. **마켓플레이스**: AI가 생성한 컴포넌트 판매

## 개발 단계별 계획

### Phase 1: MVP
- 기본 채팅 인터페이스
- 간단한 Flutter 위젯 생성
- 로컬 미리보기

### Phase 2: 고도화  
- Firebase 연동
- Git 버전 관리
- 실시간 협업

### Phase 3: 확장
- 다른 플랫폼 지원 (React, Vue)
- 기업용 기능
- AI 모델 최적화

## 기술적 고려사항

### 보안
- 생성된 코드의 안전성 검증
- 사용자 프로젝트 데이터 보호
- API 키 관리

### 성능
- 모바일에서의 코드 컴파일 최적화
- 네트워크 의존성 최소화
- 오프라인 모드 지원

### 확장성
- 다양한 프레임워크 지원
- 플러그인 시스템
- 커뮤니티 기능

## 마무리

이런 도구가 있다면 정말 많은 사람들이 자신만의 앱을 만들 수 있을 것 같다. 특히 아이디어는 좋은데 구현 능력이 부족해서 포기했던 사람들에게는 게임체인저가 될 수 있다.

물론 기술적으로 쉽지 않은 도전이겠지만, AI 기술이 빠르게 발전하고 있으니 충분히 가능해 보인다. 

누군가 이미 비슷한 걸 만들고 있을까? 아니면 내가 한번 시도해볼까? 🤔
```

### jung-psychology-cinema.md

**Path:** `frontend/public/posts/2024/jung-psychology-cinema.md`

```markdown
---
title: 칼 융 내면 성찰에 관련된 영화들
excerpt: >-
  칼 융의 분석심리학에서 핵심 개념인 **개성화(Individuation)**는 개인이 그림자를 통합하고 집단무의식에서 진정한 자아를 분리해
  온전한 인간이 되는 여정을 가리킵니다. 융이 강조한 **내면의 강인함**은 외부 기준이나 집단 압력에 굴복하지 않고 내면 목소리에 따르는
  용기에서 비롯됩니다. 아래 영화들은 이러한 융의 철학을 깊이 있게 반영한 작품들입...
date: '2025-08-10'
category: 사고와 인식
tags:
  - 칼융
  - 개성화
  - 분석심리학
  - 집단무의식
  - 그림자
  - 아니마
  - 동시성
  - 내면강인함
  - 자아실현
  - 데인저러스메소드
  - 세렌디피티
  - 매트릭스
  - 작은아씨들
  - 디센트
readTime: 2분
---
칼 융의 분석심리학에서 핵심 개념인 **개성화(Individuation)**는 개인이 그림자를 통합하고 집단무의식에서 진정한 자아를 분리해 온전한 인간이 되는 여정을 가리킵니다. 융이 강조한 **내면의 강인함**은 외부 기준이나 집단 압력에 굴복하지 않고 내면 목소리에 따르는 용기에서 비롯됩니다. 아래 영화들은 이러한 융의 철학을 깊이 있게 반영한 작품들입니다.

## 1. 데인저러스 메소드 (A Dangerous Method, 2011) - 융의 개성화 여정

데이비드 크로넨버그 감독의 이 영화는 칼 융과 사비나 슈필라인의 실제 관계를 다룬 심리 드라마입니다. 1904년 스위스 취리히 정신병원을 배경으로 융이 프로이트와 결별하며 독자적 길을 걷는 과정을 그립니다.

융(마이클 파스벤더)은 프로이트의 그림자에서 벗어나 자신만의 정신분석학을 구축하는 개성화 과정을 보여줍니다. 슈필라인(키이라 나이틀리)과의 관계는 아니마(Anima) 통합의 계기가 됩니다. 융은 기존 틀을 넘어 집단무의식과 원형 이론을 발전시키며 지적 용기를 드러냅니다.

이 작품은 치료자도 상처받은 존재임을 강조하며, 강인함이 그림자를 직면하고 통합하는 데서 나온다는 메시지를 전달합니다.

## 2. 세렌디피티 (Serendipity, 2001) - 동시성과 운명의 신뢰

융의 **동시성(Synchronicity)** 개념, 즉 의미 있는 우연의 일치를 로맨틱 코미디로 구현한 작품입니다. 주인공들은 '사라'라는 이름이 반복되는 우연을 운명의 신호로 해석하며 적극적으로 행동합니다.

그들은 외부 합리성보다 내면 직관을 신뢰합니다. 이는 융의 강인함, 즉 사회적 기대를 넘어 진정한 감정에 따르는 용기를 상징합니다. 영화는 집단무의식의 작동을 통해 우주와 개인 정신의 조화를 보여줍니다.

## 3. 매트릭스 (The Matrix, 1999) - 집단 환상으로부터의 각성

SF 장르로 융의 개성화를 극대화한 작품입니다. 네오(키아누 리브스)의 여정은 매트릭스라는 집단무의식 환상에서 벗어나 진정한 자아를 찾는 과정입니다.

에이전트 스미스는 네오의 그림자(억압된 두려움)를 상징하며, 네오는 이를 통합해 완전해집니다. 빨간 알약 선택은 안전을 포기하고 진실을 추구하는 내면 강인함을 나타냅니다.

## 4. 작은 아씨들 (Little Women, 2019) - 여성의 자아실현

그레타 거윅 감독의 영화는 네 자매를 통해 융의 여성 원형을 탐구합니다. 에이미(플로렌스 퓨)는 자기 주관과 현실 인식을 바탕으로 환경의 한계를 극복하는 강인한 여성상을 보여줍니다.

자매들은 19세기 사회적 역할을 넘어 고유 잠재력을 실현합니다. 이는 개성화 과정의 다양한 양상을 드러냅니다.

## 5. 디센트 (The Descent, 2005) - 극한에서의 내면 발견

닐 마샬 감독의 공포영화로, 동굴에 갇힌 여성들의 생존기를 그립니다. 주인공의 변화는 문명적 자아에서 원초적 생존자로의 변신, 즉 그림자 통합을 상징합니다.

극한 상황에서 발현되는 내면의 힘은 융의 생존을 위한 어둠 수용을 구현합니다.

## 공통 주제: 융의 철학적 통찰

- **집단으로부터의 개별화**: 주인공들은 사회 압력에서 벗어나 자신만의 길을 택합니다.
- **그림자와의 대면**: 어두운 면을 통합하며 성장합니다.
- **직관 신뢰**: 논리보다 무의식의 지혜를 따릅니다.
- **자기실현 의지**: 안전을 포기하고 진정한 모습을 추구합니다.

디지털 시대에 이 영화들은 알고리즘과 소셜미디어 속에서 내면 목소리를 따르는 용기의 중요성을 일깨웁니다. 융의 말처럼 "개인이 되는 것은 운명"이며, 이 작품들은 그 여정을 아름답고 고통스럽게 그려냅니다.

```

### kmp.md

**Path:** `frontend/public/posts/2024/kmp.md`

```markdown
---
title: "KMP 알고리즘 (Knuth-Morris-Pratt)"
date: "2024-11-08"
category: "Algorithm"
tags: ['KMP', '문자열매칭', '패턴매칭', '실패함수']
excerpt: "KMP 알고리즘을 통해 문자열 패턴 매칭을 효율적으로 수행하는 방법과 실패 함수의 원리를 학습합니다."
readTime: "9분"
---

## 개요

**KMP 알고리즘(Knuth-Morris-Pratt Algorithm)**은 문자열에서 특정 패턴을 효율적으로 찾는 알고리즘입니다. 실패 함수(Failure Function)를 이용하여 불필요한 비교를 건너뛰는 것이 핵심입니다.

### 핵심 특징
- **선형 시간**: O(N + M) 시간 복잡도
- **실패 함수**: 패턴의 접두사와 접미사 일치 정보 활용
- **백트래킹 최소화**: 불필요한 문자 비교 생략
- **전처리 단계**: 패턴 분석을 통한 최적화

### 시간 복잡도
- **전처리**: O(M) - 패턴 길이
- **검색**: O(N) - 텍스트 길이  
- **전체**: O(N + M)
- **공간 복잡도**: O(M)

## 실패 함수 (Failure Function)

### 1. 실패 함수의 정의

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class KMP {
private:
    string pattern;
    vector<int> failure;
    
    void computeFailure() {
        int m = pattern.length();
        failure.assign(m, 0);
        
        int j = 0;
        for (int i = 1; i < m; i++) {
            // 불일치가 발생할 때까지 j를 줄임
            while (j > 0 && pattern[i] != pattern[j]) {
                j = failure[j - 1];
            }
            
            // 일치하면 j 증가
            if (pattern[i] == pattern[j]) {
                j++;
            }
            
            failure[i] = j;
        }
    }
    
public:
    KMP(const string& pat) : pattern(pat) {
        computeFailure();
    }
    
    void printFailureFunction() {
        cout << "Pattern: " << pattern << endl;
        cout << "Index:   ";
        for (int i = 0; i < pattern.length(); i++) {
            cout << i << " ";
        }
        cout << "\nFailure: ";
        for (int f : failure) {
            cout << f << " ";
        }
        cout << "\n\n";
    }
    
    vector<int> search(const string& text) {
        vector<int> matches;
        int n = text.length();
        int m = pattern.length();
        
        int j = 0;  // 패턴에서의 현재 위치
        for (int i = 0; i < n; i++) {
            // 불일치 시 실패 함수를 이용해 j 조정
            while (j > 0 && text[i] != pattern[j]) {
                j = failure[j - 1];
            }
            
            // 일치하면 j 증가
            if (text[i] == pattern[j]) {
                j++;
            }
            
            // 패턴 전체가 일치하면 매치 발견
            if (j == m) {
                matches.push_back(i - m + 1);  // 시작 위치
                j = failure[j - 1];  // 다음 매치를 위해 조정
            }
        }
        
        return matches;
    }
};
```

### 2. 실패 함수 시각화

```cpp
class KMPVisualizer {
public:
    static void visualizeFailureFunction(const string& pattern) {
        KMP kmp(pattern);
        
        cout << "=== 실패 함수 계산 과정 ===" << endl;
        cout << "패턴: " << pattern << endl;
        
        vector<int> failure(pattern.length(), 0);
        int j = 0;
        
        cout << "\n단계별 계산:" << endl;
        for (int i = 1; i < pattern.length(); i++) {
            cout << "i=" << i << ", j=" << j << ": ";
            
            // 불일치 처리
            while (j > 0 && pattern[i] != pattern[j]) {
                cout << "불일치(" << pattern[i] << "≠" << pattern[j] 
                     << ") → j=" << failure[j-1] << " ";
                j = failure[j - 1];
            }
            
            // 일치 처리
            if (pattern[i] == pattern[j]) {
                j++;
                cout << "일치(" << pattern[i] << "=" << pattern[j-1] << ") → j=" << j;
            }
            
            failure[i] = j;
            cout << " → failure[" << i << "]=" << failure[i] << endl;
        }
        
        // 최종 결과
        cout << "\n최종 실패 함수:" << endl;
        for (int i = 0; i < pattern.length(); i++) {
            cout << "failure[" << i << "] = " << failure[i] << endl;
        }
    }
};
```

## KMP 검색 과정

### 1. 단계별 검색 시각화

```cpp
class KMPSearchVisualizer {
public:
    static void visualizeSearch(const string& text, const string& pattern) {
        KMP kmp(pattern);
        
        cout << "=== KMP 검색 과정 ===" << endl;
        cout << "텍스트: " << text << endl;
        cout << "패턴:   " << pattern << endl;
        cout << endl;
        
        vector<int> failure(pattern.length(), 0);
        // 실패 함수 계산 (생략 - 위에서 구현됨)
        
        int n = text.length();
        int m = pattern.length();
        int j = 0;
        
        for (int i = 0; i < n; i++) {
            cout << "i=" << i << ", j=" << j << ": ";
            
            // 현재 상태 출력
            cout << text << endl;
            cout << string(i - j, ' ') << pattern << endl;
            
            // 불일치 처리
            while (j > 0 && text[i] != pattern[j]) {
                cout << "불일치 → j=" << failure[j-1] << endl;
                j = failure[j - 1];
                
                if (j > 0) {
                    cout << text << endl;
                    cout << string(i - j, ' ') << pattern << endl;
                }
            }
            
            // 일치 처리
            if (text[i] == pattern[j]) {
                j++;
                cout << "일치: " << text[i] << endl;
            } else {
                cout << "불일치: " << text[i] << "≠" << pattern[j] << endl;
            }
            
            // 완전 매치 확인
            if (j == m) {
                cout << "*** 매치 발견! 위치: " << (i - m + 1) << " ***" << endl;
                j = failure[j - 1];
            }
            
            cout << "---" << endl;
        }
    }
};
```

## 고급 구현 및 최적화

### 1. 다중 패턴 검색

```cpp
class MultiplePatternKMP {
private:
    vector<string> patterns;
    vector<KMP> kmps;
    
public:
    void addPattern(const string& pattern) {
        patterns.push_back(pattern);
        kmps.push_back(KMP(pattern));
    }
    
    vector<pair<int, int>> searchAll(const string& text) {
        vector<pair<int, int>> results;  // (패턴 인덱스, 위치)
        
        for (int p = 0; p < patterns.size(); p++) {
            vector<int> matches = kmps[p].search(text);
            for (int pos : matches) {
                results.push_back({p, pos});
            }
        }
        
        // 위치 순으로 정렬
        sort(results.begin(), results.end(), 
             [](const pair<int, int>& a, const pair<int, int>& b) {
                 return a.second < b.second;
             });
        
        return results;
    }
};
```

### 2. KMP를 이용한 문자열 분석

```cpp
class StringAnalyzer {
public:
    // 문자열의 주기 찾기
    static vector<int> findPeriods(const string& s) {
        KMP kmp(s);
        vector<int> periods;
        int n = s.length();
        
        // failure 함수를 역으로 추적
        int len = n;
        while (len > 0) {
            int period = len - kmp.failure[len - 1];
            if (len % period == 0) {
                periods.push_back(period);
            }
            len = kmp.failure[len - 1];
        }
        
        reverse(periods.begin(), periods.end());
        return periods;
    }
    
    // 최소 주기 반복 문자열 만들기
    static string getMinimalPeriod(const string& s) {
        vector<int> periods = findPeriods(s);
        if (periods.empty()) return s;
        
        int minPeriod = periods[0];
        return s.substr(0, minPeriod);
    }
    
    // 문자열을 주기적으로 확장하여 목표 길이 만들기
    static string extendToPeriodic(const string& s, int targetLength) {
        string period = getMinimalPeriod(s);
        string result;
        
        while (result.length() < targetLength) {
            result += period;
        }
        
        return result.substr(0, targetLength);
    }
};
```

### 3. Z-알고리즘과 KMP 비교

```cpp
class ZAlgorithm {
private:
    static vector<int> computeZ(const string& s) {
        int n = s.length();
        vector<int> z(n);
        int l = 0, r = 0;
        
        for (int i = 1; i < n; i++) {
            if (i <= r) {
                z[i] = min(r - i + 1, z[i - l]);
            }
            
            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
                z[i]++;
            }
            
            if (i + z[i] - 1 > r) {
                l = i;
                r = i + z[i] - 1;
            }
        }
        
        return z;
    }
    
public:
    static vector<int> search(const string& text, const string& pattern) {
        string combined = pattern + "$" + text;
        vector<int> z = computeZ(combined);
        
        vector<int> matches;
        int patternLen = pattern.length();
        
        for (int i = patternLen + 1; i < combined.length(); i++) {
            if (z[i] == patternLen) {
                matches.push_back(i - patternLen - 1);
            }
        }
        
        return matches;
    }
};

class AlgorithmComparison {
public:
    static void compareKMPvsZ(const string& text, const string& pattern) {
        // KMP 측정
        auto start = chrono::high_resolution_clock::now();
        KMP kmp(pattern);
        vector<int> kmpResults = kmp.search(text);
        auto end = chrono::high_resolution_clock::now();
        auto kmpTime = chrono::duration_cast<chrono::microseconds>(end - start);
        
        // Z-알고리즘 측정
        start = chrono::high_resolution_clock::now();
        vector<int> zResults = ZAlgorithm::search(text, pattern);
        end = chrono::high_resolution_clock::now();
        auto zTime = chrono::duration_cast<chrono::microseconds>(end - start);
        
        cout << "KMP 실행 시간: " << kmpTime.count() << " μs" << endl;
        cout << "Z-알고리즘 실행 시간: " << zTime.count() << " μs" << endl;
        cout << "매치 개수: " << kmpResults.size() << endl;
    }
};
```

## 응용 문제

### 1. 회전 문자열 판별

```cpp
class RotationChecker {
public:
    static bool isRotation(const string& s1, const string& s2) {
        if (s1.length() != s2.length()) return false;
        
        string doubled = s1 + s1;
        KMP kmp(s2);
        vector<int> matches = kmp.search(doubled);
        
        return !matches.empty();
    }
    
    static int findRotationDistance(const string& s1, const string& s2) {
        if (!isRotation(s1, s2)) return -1;
        
        string doubled = s1 + s1;
        KMP kmp(s2);
        vector<int> matches = kmp.search(doubled);
        
        return matches.empty() ? -1 : matches[0];
    }
};
```

### 2. 부분 문자열 개수 세기

```cpp
class SubstringCounter {
public:
    // 겹치지 않는 부분 문자열 개수
    static int countNonOverlapping(const string& text, const string& pattern) {
        KMP kmp(pattern);
        vector<int> matches = kmp.search(text);
        
        int count = 0;
        int lastEnd = -1;
        
        for (int pos : matches) {
            if (pos > lastEnd) {
                count++;
                lastEnd = pos + pattern.length() - 1;
            }
        }
        
        return count;
    }
    
    // 겹치는 부분 문자열 개수 (전체 매치 개수)
    static int countOverlapping(const string& text, const string& pattern) {
        KMP kmp(pattern);
        return kmp.search(text).size();
    }
};
```

### 3. 최장 공통 접두사-접미사

```cpp
class CommonPrefixSuffix {
public:
    // 두 문자열의 최장 공통 접두사-접미사 찾기
    static string findLongestCommonPrefixSuffix(const string& s1, const string& s2) {
        string combined = s1 + "#" + s2;
        KMP kmp(combined);
        
        // s2의 마지막 위치에서 failure 값 확인
        int maxLen = kmp.failure.back();
        
        // "#" 이후의 길이가 더 클 수 없음
        maxLen = min(maxLen, (int)min(s1.length(), s2.length()));
        
        return s1.substr(0, maxLen);
    }
    
    // 문자열 자체의 최장 접두사-접미사 (자기 자신 제외)
    static string findLongestProperPrefixSuffix(const string& s) {
        KMP kmp(s);
        int len = kmp.failure.back();
        return s.substr(0, len);
    }
};
```

## 실전 문제 해결

### 백준 예제 문제들

#### 1. 찾기 (1786)
```cpp
int main() {
    string text, pattern;
    getline(cin, text);
    getline(cin, pattern);
    
    KMP kmp(pattern);
    vector<int> matches = kmp.search(text);
    
    cout << matches.size() << "\n";
    for (int pos : matches) {
        cout << pos + 1 << " ";  // 1-based 인덱스
    }
    cout << "\n";
    
    return 0;
}
```

#### 2. 광고 (1305)
```cpp
int main() {
    int L;
    cin >> L;
    
    string s;
    cin >> s;
    
    KMP kmp(s);
    int longestPrefixSuffix = kmp.failure[L - 1];
    int minLength = L - longestPrefixSuffix;
    
    cout << minLength << endl;
    
    return 0;
}
```

#### 3. 부분 문자열 (16916)
```cpp
int main() {
    string S, P;
    cin >> S >> P;
    
    KMP kmp(P);
    vector<int> matches = kmp.search(S);
    
    cout << (matches.empty() ? 0 : 1) << endl;
    
    return 0;
}
```

## 주의사항과 팁

### 1. 실패 함수 구현 주의점
```cpp
// 잘못된 구현 (무한 루프 위험)
void wrongComputeFailure() {
    int j = 0;
    for (int i = 1; i < pattern.length(); i++) {
        while (pattern[i] != pattern[j]) {  // j > 0 조건 누락
            j = failure[j - 1];  // j=0일 때 음수 인덱스!
        }
        // ...
    }
}

// 올바른 구현
void correctComputeFailure() {
    int j = 0;
    for (int i = 1; i < pattern.length(); i++) {
        while (j > 0 && pattern[i] != pattern[j]) {  // j > 0 조건 필수
            j = failure[j - 1];
        }
        // ...
    }
}
```

### 2. 메모리 최적화
```cpp
// 스트리밍 환경에서의 KMP
class StreamingKMP {
private:
    string pattern;
    vector<int> failure;
    int currentJ;
    
public:
    StreamingKMP(const string& pat) : pattern(pat), currentJ(0) {
        // failure 함수 계산
    }
    
    bool processCharacter(char c) {
        while (currentJ > 0 && c != pattern[currentJ]) {
            currentJ = failure[currentJ - 1];
        }
        
        if (c == pattern[currentJ]) {
            currentJ++;
        }
        
        if (currentJ == pattern.length()) {
            currentJ = failure[currentJ - 1];
            return true;  // 매치 발견
        }
        
        return false;
    }
};
```

### 3. 디버깅 도구
```cpp
void debugKMP(const string& text, const string& pattern) {
    cout << "=== KMP 디버그 정보 ===" << endl;
    
    KMP kmp(pattern);
    kmp.printFailureFunction();
    
    cout << "검색 결과:" << endl;
    vector<int> matches = kmp.search(text);
    
    if (matches.empty()) {
        cout << "매치 없음" << endl;
    } else {
        for (int pos : matches) {
            cout << "위치 " << pos << ": ";
            cout << text.substr(pos, pattern.length()) << endl;
        }
    }
}
```

## 연관 알고리즘
- **[라빈-카프](/post/algorithms/rabin-karp)**: 해싱 기반 패턴 매칭
- **[Z-알고리즘](/post/algorithms/z-algorithm)**: 접두사 기반 매칭
- **[아호-코라식](/post/algorithms/aho-corasick)**: 다중 패턴 매칭

## 마무리

KMP 알고리즘은 문자열 패턴 매칭의 핵심 알고리즘으로, 실패 함수의 개념을 정확히 이해하는 것이 중요합니다. 다양한 문자열 처리 문제에서 기본이 되는 알고리즘이므로 충분한 연습이 필요합니다.

**학습 순서**: 실패 함수 이해 → 기본 KMP 구현 → 응용 문제 → 최적화 기법
```

### knapsack.md

**Path:** `frontend/public/posts/2024/knapsack.md`

```markdown
---
title: "배낭 문제 (Knapsack Problem)"
date: "2024-12-21"
category: "Algorithm"
tags: ['Knapsack', '배낭문제', '동적계획법', '최적화']
excerpt: "0-1 배낭 문제와 무한 배낭 문제를 동적 계획법으로 해결하는 다양한 방법을 학습합니다."
readTime: "9분"
---

## 개요

**배낭 문제(Knapsack Problem)**는 제한된 용량의 배낭에 최대한 가치 있는 물건들을 넣는 최적화 문제입니다. 동적 계획법의 대표적인 응용 분야입니다.

### 문제 유형
- **0-1 배낭**: 각 물건을 최대 1개만 선택 가능
- **무한 배낭**: 각 물건을 무한히 선택 가능
- **유한 배낭**: 각 물건을 정해진 개수만큼 선택 가능
- **분할 배낭**: 물건을 부분적으로 선택 가능 (그리디)

### 시간 복잡도
- **0-1 배낭**: O(N × W)
- **무한 배낭**: O(N × W)
- **공간 복잡도**: O(W) (최적화 시)

## 0-1 배낭 문제

### 1. 기본 구현 (2차원 DP)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Knapsack01 {
private:
    struct Item {
        int weight, value;
        Item(int w, int v) : weight(w), value(v) {}
    };
    
    vector<Item> items;
    int n, capacity;
    vector<vector<int>> dp;
    
public:
    Knapsack01(int cap) : capacity(cap) {}
    
    void addItem(int weight, int value) {
        items.push_back(Item(weight, value));
        n = items.size();
    }
    
    int solve() {
        dp.assign(n + 1, vector<int>(capacity + 1, 0));
        
        for (int i = 1; i <= n; i++) {
            for (int w = 0; w <= capacity; w++) {
                // 물건 i-1을 넣지 않는 경우
                dp[i][w] = dp[i-1][w];
                
                // 물건 i-1을 넣는 경우
                if (w >= items[i-1].weight) {
                    dp[i][w] = max(dp[i][w], 
                                   dp[i-1][w - items[i-1].weight] + items[i-1].value);
                }
            }
        }
        
        return dp[n][capacity];
    }
    
    vector<int> getSelectedItems() {
        vector<int> selected;
        int w = capacity;
        
        for (int i = n; i > 0; i--) {
            if (dp[i][w] != dp[i-1][w]) {
                selected.push_back(i-1);  // 0-based 인덱스
                w -= items[i-1].weight;
            }
        }
        
        reverse(selected.begin(), selected.end());
        return selected;
    }
    
    void printDP() {
        cout << "DP Table:" << endl;
        for (int i = 0; i <= n; i++) {
            for (int w = 0; w <= capacity; w++) {
                cout << dp[i][w] << " ";
            }
            cout << endl;
        }
    }
};
```

### 2. 공간 최적화 (1차원 DP)

```cpp
class Knapsack01Optimized {
private:
    struct Item {
        int weight, value;
        Item(int w, int v) : weight(w), value(v) {}
    };
    
    vector<Item> items;
    int capacity;
    
public:
    Knapsack01Optimized(int cap) : capacity(cap) {}
    
    void addItem(int weight, int value) {
        items.push_back(Item(weight, value));
    }
    
    int solve() {
        vector<int> dp(capacity + 1, 0);
        
        for (const Item& item : items) {
            // 역순으로 진행 (중복 사용 방지)
            for (int w = capacity; w >= item.weight; w--) {
                dp[w] = max(dp[w], dp[w - item.weight] + item.value);
            }
        }
        
        return dp[capacity];
    }
    
    // 선택된 물건들을 추적하는 버전
    pair<int, vector<int>> solveWithTrace() {
        vector<vector<int>> dp(items.size() + 1, vector<int>(capacity + 1, 0));
        
        // DP 테이블 채우기
        for (int i = 1; i <= items.size(); i++) {
            for (int w = 0; w <= capacity; w++) {
                dp[i][w] = dp[i-1][w];
                if (w >= items[i-1].weight) {
                    dp[i][w] = max(dp[i][w], 
                                   dp[i-1][w - items[i-1].weight] + items[i-1].value);
                }
            }
        }
        
        // 선택된 물건들 추적
        vector<int> selected;
        int w = capacity;
        for (int i = items.size(); i > 0; i--) {
            if (dp[i][w] != dp[i-1][w]) {
                selected.push_back(i-1);
                w -= items[i-1].weight;
            }
        }
        
        return {dp[items.size()][capacity], selected};
    }
};
```

## 무한 배낭 문제 (Unbounded Knapsack)

### 1. 기본 구현

```cpp
class UnboundedKnapsack {
private:
    struct Item {
        int weight, value;
        Item(int w, int v) : weight(w), value(v) {}
    };
    
    vector<Item> items;
    int capacity;
    
public:
    UnboundedKnapsack(int cap) : capacity(cap) {}
    
    void addItem(int weight, int value) {
        items.push_back(Item(weight, value));
    }
    
    int solve() {
        vector<int> dp(capacity + 1, 0);
        
        for (int w = 1; w <= capacity; w++) {
            for (const Item& item : items) {
                if (w >= item.weight) {
                    dp[w] = max(dp[w], dp[w - item.weight] + item.value);
                }
            }
        }
        
        return dp[capacity];
    }
    
    // 각 물건을 몇 개씩 선택했는지 추적
    vector<int> getItemCounts() {
        vector<int> dp(capacity + 1, 0);
        vector<int> choice(capacity + 1, -1);  // 어떤 물건을 선택했는지
        
        for (int w = 1; w <= capacity; w++) {
            for (int i = 0; i < items.size(); i++) {
                if (w >= items[i].weight && 
                    dp[w - items[i].weight] + items[i].value > dp[w]) {
                    dp[w] = dp[w - items[i].weight] + items[i].value;
                    choice[w] = i;
                }
            }
        }
        
        // 개수 세기
        vector<int> counts(items.size(), 0);
        int w = capacity;
        while (w > 0 && choice[w] != -1) {
            int item = choice[w];
            counts[item]++;
            w -= items[item].weight;
        }
        
        return counts;
    }
};
```

### 2. 동전 거슬러주기 문제

```cpp
class CoinChange {
private:
    vector<int> coins;
    
public:
    void addCoin(int value) {
        coins.push_back(value);
    }
    
    // 최소 동전 개수
    int minCoins(int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (i >= coin && dp[i - coin] != INT_MAX) {
                    dp[i] = min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
    
    // 동전 조합의 총 개수
    int countWays(int amount) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        
        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] += dp[i - coin];
            }
        }
        
        return dp[amount];
    }
    
    // 거슬러준 동전들 반환
    vector<int> getCoins(int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        vector<int> choice(amount + 1, -1);
        dp[0] = 0;
        
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (i >= coin && dp[i - coin] != INT_MAX && 
                    dp[i - coin] + 1 < dp[i]) {
                    dp[i] = dp[i - coin] + 1;
                    choice[i] = coin;
                }
            }
        }
        
        vector<int> result;
        while (amount > 0) {
            result.push_back(choice[amount]);
            amount -= choice[amount];
        }
        
        return result;
    }
};
```

## 고급 변형 문제

### 1. 다중 배낭 (Multiple Knapsack)

```cpp
class MultipleKnapsack {
private:
    struct Item {
        int weight, value, count;
        Item(int w, int v, int c) : weight(w), value(v), count(c) {}
    };
    
    vector<Item> items;
    int capacity;
    
public:
    MultipleKnapsack(int cap) : capacity(cap) {}
    
    void addItem(int weight, int value, int count) {
        items.push_back(Item(weight, value, count));
    }
    
    // 이진 표현을 이용한 최적화
    int solve() {
        vector<pair<int, int>> expandedItems;  // (weight, value)
        
        // 각 물건을 이진 표현으로 분해
        for (const Item& item : items) {
            int remain = item.count;
            int k = 1;
            
            while (k <= remain) {
                expandedItems.push_back({item.weight * k, item.value * k});
                remain -= k;
                k *= 2;
            }
            
            if (remain > 0) {
                expandedItems.push_back({item.weight * remain, item.value * remain});
            }
        }
        
        // 0-1 배낭으로 변환하여 해결
        vector<int> dp(capacity + 1, 0);
        
        for (const auto& item : expandedItems) {
            for (int w = capacity; w >= item.first; w--) {
                dp[w] = max(dp[w], dp[w - item.first] + item.second);
            }
        }
        
        return dp[capacity];
    }
};
```

### 2. 2차원 배낭 문제

```cpp
class Knapsack2D {
private:
    struct Item {
        int weight, volume, value;
        Item(int w, int v, int val) : weight(w), volume(v), value(val) {}
    };
    
    vector<Item> items;
    int maxWeight, maxVolume;
    
public:
    Knapsack2D(int w, int v) : maxWeight(w), maxVolume(v) {}
    
    void addItem(int weight, int volume, int value) {
        items.push_back(Item(weight, volume, value));
    }
    
    int solve() {
        // dp[w][v] = 무게 w, 부피 v 제한에서의 최대 가치
        vector<vector<int>> dp(maxWeight + 1, vector<int>(maxVolume + 1, 0));
        
        for (const Item& item : items) {
            for (int w = maxWeight; w >= item.weight; w--) {
                for (int v = maxVolume; v >= item.volume; v--) {
                    dp[w][v] = max(dp[w][v], 
                                   dp[w - item.weight][v - item.volume] + item.value);
                }
            }
        }
        
        return dp[maxWeight][maxVolume];
    }
};
```

### 3. 분할 가능 배낭 (Fractional Knapsack)

```cpp
class FractionalKnapsack {
private:
    struct Item {
        int weight, value;
        double ratio;
        
        Item(int w, int v) : weight(w), value(v), ratio((double)v / w) {}
        
        bool operator>(const Item& other) const {
            return ratio > other.ratio;
        }
    };
    
    vector<Item> items;
    int capacity;
    
public:
    FractionalKnapsack(int cap) : capacity(cap) {}
    
    void addItem(int weight, int value) {
        items.push_back(Item(weight, value));
    }
    
    double solve() {
        // 가치/무게 비율로 내림차순 정렬
        sort(items.begin(), items.end(), greater<Item>());
        
        double totalValue = 0.0;
        int remainingCapacity = capacity;
        
        for (const Item& item : items) {
            if (remainingCapacity >= item.weight) {
                // 전체를 넣을 수 있는 경우
                totalValue += item.value;
                remainingCapacity -= item.weight;
            } else {
                // 일부만 넣을 수 있는 경우
                double fraction = (double)remainingCapacity / item.weight;
                totalValue += item.value * fraction;
                break;
            }
        }
        
        return totalValue;
    }
    
    vector<double> getFractions() {
        sort(items.begin(), items.end(), greater<Item>());
        
        vector<double> fractions(items.size(), 0.0);
        int remainingCapacity = capacity;
        
        for (int i = 0; i < items.size(); i++) {
            if (remainingCapacity >= items[i].weight) {
                fractions[i] = 1.0;
                remainingCapacity -= items[i].weight;
            } else {
                fractions[i] = (double)remainingCapacity / items[i].weight;
                break;
            }
        }
        
        return fractions;
    }
};
```

## 실전 문제 해결

### 백준 예제 문제들

#### 1. 평범한 배낭 (12865)
```cpp
int main() {
    int N, K;
    cin >> N >> K;
    
    Knapsack01 knapsack(K);
    
    for (int i = 0; i < N; i++) {
        int w, v;
        cin >> w >> v;
        knapsack.addItem(w, v);
    }
    
    cout << knapsack.solve() << endl;
    
    return 0;
}
```

#### 2. 동전 1 (2293)
```cpp
int main() {
    int n, k;
    cin >> n >> k;
    
    CoinChange coinChange;
    for (int i = 0; i < n; i++) {
        int coin;
        cin >> coin;
        coinChange.addCoin(coin);
    }
    
    cout << coinChange.countWays(k) << endl;
    
    return 0;
}
```

#### 3. 동전 2 (2294)
```cpp
int main() {
    int n, k;
    cin >> n >> k;
    
    CoinChange coinChange;
    for (int i = 0; i < n; i++) {
        int coin;
        cin >> coin;
        coinChange.addCoin(coin);
    }
    
    int result = coinChange.minCoins(k);
    cout << result << endl;
    
    return 0;
}
```

## 최적화 기법

### 1. 공간 최적화
```cpp
// 슬라이딩 윈도우 기법
class OptimizedKnapsack {
private:
    int solve(vector<pair<int, int>>& items, int capacity) {
        vector<int> prev(capacity + 1, 0);
        vector<int> curr(capacity + 1, 0);
        
        for (const auto& item : items) {
            for (int w = 0; w <= capacity; w++) {
                curr[w] = prev[w];
                if (w >= item.first) {
                    curr[w] = max(curr[w], prev[w - item.first] + item.second);
                }
            }
            prev = curr;
        }
        
        return curr[capacity];
    }
};
```

### 2. 근사 알고리즘
```cpp
class ApproximateKnapsack {
public:
    // FPTAS (Fully Polynomial-Time Approximation Scheme)
    double approximateSolve(vector<pair<int, int>>& items, int capacity, double epsilon) {
        int maxValue = 0;
        for (const auto& item : items) {
            maxValue = max(maxValue, item.second);
        }
        
        int K = epsilon * maxValue / items.size();
        
        // 가치를 K로 스케일링
        for (auto& item : items) {
            item.second /= K;
        }
        
        // 스케일된 문제 해결
        Knapsack01 knapsack(capacity);
        for (const auto& item : items) {
            knapsack.addItem(item.first, item.second);
        }
        
        return knapsack.solve() * K;
    }
};
```

## 주의사항과 팁

### 1. 메모리 관리
```cpp
// 큰 용량일 때는 map 사용 고려
class SparseKnapsack {
private:
    map<int, int> dp;  // 용량 -> 최대 가치
    
public:
    int solve(vector<pair<int, int>>& items, int capacity) {
        dp[0] = 0;
        
        for (const auto& item : items) {
            map<int, int> newDp = dp;
            for (const auto& state : dp) {
                int w = state.first;
                int v = state.second;
                
                if (w + item.first <= capacity) {
                    newDp[w + item.first] = max(newDp[w + item.first], v + item.second);
                }
            }
            dp = newDp;
        }
        
        int result = 0;
        for (const auto& state : dp) {
            result = max(result, state.second);
        }
        
        return result;
    }
};
```

### 2. 디버깅 도구
```cpp
void debugKnapsack(const vector<pair<int, int>>& items, int capacity) {
    cout << "Items: ";
    for (int i = 0; i < items.size(); i++) {
        cout << "(" << items[i].first << "," << items[i].second << ") ";
    }
    cout << "\nCapacity: " << capacity << endl;
    
    Knapsack01 knapsack(capacity);
    for (const auto& item : items) {
        knapsack.addItem(item.first, item.second);
    }
    
    cout << "Maximum value: " << knapsack.solve() << endl;
    
    vector<int> selected = knapsack.getSelectedItems();
    cout << "Selected items: ";
    for (int idx : selected) {
        cout << idx << " ";
    }
    cout << endl;
}
```

## 연관 알고리즘
- **[동적 계획법 기초](/post/algorithms/dynamic-programming)**: 기본 개념
- **[그리디 알고리즘](/post/algorithms/greedy)**: 분할 가능 배낭
- **[최적화 문제](/post/algorithms/optimization)**: 근사 알고리즘

## 마무리

배낭 문제는 동적 계획법의 핵심 문제로, 다양한 변형과 최적화 기법을 통해 실제 최적화 문제에 광범위하게 응용됩니다. 기본 개념부터 고급 최적화까지 단계적으로 학습하세요.

**학습 순서**: 0-1 배낭 → 무한 배낭 → 다중 배낭 → 2차원 배낭 → 근사 알고리즘
```

### linux-networkmanager-static-ip.md

**Path:** `frontend/public/posts/2024/linux-networkmanager-static-ip.md`

```markdown
---
title: "NetworkManager를 사용한 Linux Static IP 설정 완벽 가이드"
date: "2024-07-14"
category: "Linux"
tags: ['NetworkManager', 'Static IP', 'nmcli', 'nmtui', 'Ubuntu', 'CentOS', 'Rocky Linux']
excerpt: "NetworkManager를 활용하여 다양한 Linux 배포판에서 고정 IP를 설정하는 방법을 상세히 설명합니다."
readTime: "2분"
---

## NetworkManager 개요

NetworkManager는 RHEL 7부터 도입된 네트워크를 모니터링하고 관리하는 데몬으로, 네트워크의 변경 사항을 탐지하고 설정해주는 역할을 수행합니다. 다양한 Linux 배포판에서 네트워크 관리를 위해 사용됩니다.

## nmcli를 이용한 고정 IP 설정

nmcli는 NetworkManager의 명령줄 도구로, 다음과 같이 사용할 수 있습니다:

### 1. 네트워크 인터페이스 확인

```bash
nmcli con show
```

이 명령어를 통해 사용 가능한 네트워크 연결 목록을 확인할 수 있습니다.

### 2. 네트워크 연결 수정하기

```bash
nmcli con mod "네트워크 이름" ipv4.method manual ipv4.addresses "IP주소/넷마스크" ipv4.gateway "게이트웨이 주소" ipv4.dns "DNS 서버 주소"
```

**예시:**
```bash
nmcli con mod "Wired connection 1" ipv4.method manual ipv4.addresses 192.168.1.10/24 ipv4.gateway 192.168.1.1 ipv4.dns 8.8.8.8
```

이 명령어는 기존 연결을 고정 IP로 수정합니다.

### 3. 변경된 설정 적용

```bash
nmcli con up "네트워크 이름"
```

이 명령으로 변경된 설정을 적용합니다.

## nmtui를 이용한 고정 IP 설정

nmtui는 터미널에서 제공하는 텍스트 기반 GUI 도구입니다:

### 1. nmtui 실행

```bash
nmtui
```

이 명령어를 입력하면 네트워크 관리를 위한 텍스트 기반 인터페이스가 표시됩니다.

### 2. 네트워크 연결 편집

- "Edit a connection" 선택
- 목록에서 수정할 네트워크 인터페이스 선택
- "Edit" 버튼을 통해 편집 모드 진입
- IPv4 CONFIGURATION을 "Automatic"에서 "Manual"로 변경
- 고정 IP 주소, 게이트웨이, DNS 서버 등을 입력

### 3. 변경사항 적용

- 설정 완료 후 최초 화면으로 돌아가기
- "Activate a connection"에서 수정한 인터페이스 선택
- 이미 활성화되어 있을 경우 비활성화 후 다시 활성화

## 배포판별 특이사항

### Ubuntu 18.04 이상

Ubuntu 18.04부터는 netplan을 사용하여 네트워크를 설정합니다:

1. **이더넷 이름 확인:**
   ```bash
   ifconfig -a
   ```

2. **netplan 설정 파일 수정:**
   ```bash
   sudo nano /etc/netplan/01-network-manager-all.yaml
   ```

3. **YAML 파일을 다음과 같이 수정:**
   ```yaml
   network:
     version: 2
     renderer: NetworkManager
     ethernets:
       ens33:  # 네트워크 인터페이스 이름
         dhcp4: no
         addresses: [192.168.59.100/24]  # 고정 IP 주소/서브넷 마스크
         gateway4: 192.168.59.1  # 게이트웨이 주소
         nameservers:
           addresses: [8.8.8.8, 8.8.4.4]  # DNS 서버
   ```

4. **변경사항 적용:**
   ```bash
   sudo netplan apply
   ```

### Rocky Linux/CentOS 8 이상

Rocky Linux에서는 NetworkManager를 사용하며, nmcli 또는 nmtui를 통해 설정할 수 있습니다. 기존 CentOS 7에서 사용하던 network-scripts는 더 이상 사용되지 않습니다.

### Clear Linux

Clear Linux에서는 NetworkManager나 systemd-networkd 중 하나를 사용하여 네트워크를 관리합니다:

1. **어떤 서비스가 네트워크 인터페이스를 관리하는지 확인:**
   ```bash
   nmcli device
   networkctl list
   ```

2. NetworkManager가 관리하는 경우, 위에서 설명한 nmcli 방법을 사용합니다.

## 주의사항

1. IP 주소를 할당하지 않고 ipv4.method를 manual로 변경하면 에러가 발생합니다.
2. 설정 후 네트워크를 재시작하거나 시스템을 재부팅해야 변경사항이 적용될 수 있습니다.
3. Ubuntu의 netplan 설정 파일에서는 띄어쓰기와 문장 간격이 매우 중요하므로 주의해야 합니다.

## 결론

이 방법들을 사용하면 NetworkManager를 통해 Linux 시스템에서 고정 IP를 설정할 수 있습니다. 각 배포판별 특성을 고려하여 적절한 방법을 선택하여 사용하시기 바랍니다.
```

### lis.md

**Path:** `frontend/public/posts/2024/lis.md`

```markdown
---
title: "최장 증가 부분 수열 (LIS, Longest Increasing Subsequence)"
date: "2024-12-08"
category: "Algorithm"
tags: ['LIS', '동적계획법', '이분탐색', '부분수열']
excerpt: "최장 증가 부분 수열(LIS) 문제를 동적 계획법과 이분 탐색으로 효율적으로 해결하는 방법을 학습합니다."
readTime: "8분"
---

## 개요

**최장 증가 부분 수열(LIS, Longest Increasing Subsequence)**은 주어진 수열에서 원소들이 증가하는 순서로 배열된 가장 긴 부분 수열을 찾는 문제입니다.

### 핵심 특징
- **부분 수열**: 원래 수열에서 일부를 선택하되 순서 유지
- **증가 조건**: 선택된 원소들이 오름차순으로 배열
- **최적 부분 구조**: 동적 계획법으로 해결 가능
- **다양한 접근법**: O(N²), O(N log N) 해법 존재

### 시간 복잡도
- **기본 DP**: O(N²)
- **이분 탐색 활용**: O(N log N)
- **공간 복잡도**: O(N)

## 기본 구현

### 1. 동적 계획법 접근 (O(N²))

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class LIS_DP {
private:
    vector<int> arr;
    vector<int> dp;
    int n;
    
public:
    LIS_DP(const vector<int>& sequence) : arr(sequence), n(sequence.size()) {
        dp.resize(n, 1);  // 모든 원소는 최소 길이 1의 LIS
    }
    
    int findLIS() {
        // dp[i] = arr[i]로 끝나는 LIS의 길이
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[j] < arr[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        
        return *max_element(dp.begin(), dp.end());
    }
    
    vector<int> reconstructLIS() {
        int maxLength = findLIS();
        vector<int> lis;
        
        // 뒤에서부터 LIS 복원
        int currentLength = maxLength;
        for (int i = n - 1; i >= 0; i--) {
            if (dp[i] == currentLength) {
                lis.push_back(arr[i]);
                currentLength--;
            }
        }
        
        reverse(lis.begin(), lis.end());
        return lis;
    }
    
    void printDP() {
        cout << "Array: ";
        for (int x : arr) cout << x << " ";
        cout << "\nDP:    ";
        for (int x : dp) cout << x << " ";
        cout << "\n";
    }
};
```

### 2. 이분 탐색 최적화 (O(N log N))

```cpp
class LIS_BinarySearch {
private:
    vector<int> arr;
    vector<int> tail;  // LIS를 구성하는 가장 작은 끝 원소들
    int n;
    
public:
    LIS_BinarySearch(const vector<int>& sequence) : arr(sequence), n(sequence.size()) {}
    
    int findLIS() {
        tail.clear();
        
        for (int i = 0; i < n; i++) {
            // tail에서 arr[i]보다 크거나 같은 첫 번째 원소 위치
            auto pos = lower_bound(tail.begin(), tail.end(), arr[i]);
            
            if (pos == tail.end()) {
                // arr[i]가 가장 크면 끝에 추가
                tail.push_back(arr[i]);
            } else {
                // 해당 위치의 값을 arr[i]로 교체
                *pos = arr[i];
            }
        }
        
        return tail.size();
    }
    
    // 실제 LIS를 복원하는 고급 버전
    vector<int> reconstructLIS() {
        vector<int> tail;
        vector<int> parent(n, -1);
        vector<int> tailIndex;  // tail[i]에 해당하는 원소의 인덱스
        
        for (int i = 0; i < n; i++) {
            auto pos = lower_bound(tail.begin(), tail.end(), arr[i]);
            int idx = pos - tail.begin();
            
            if (pos == tail.end()) {
                tail.push_back(arr[i]);
                tailIndex.push_back(i);
            } else {
                *pos = arr[i];
                tailIndex[idx] = i;
            }
            
            if (idx > 0) {
                parent[i] = tailIndex[idx - 1];
            }
        }
        
        // LIS 복원
        vector<int> lis;
        int current = tailIndex.back();
        
        while (current != -1) {
            lis.push_back(arr[current]);
            current = parent[current];
        }
        
        reverse(lis.begin(), lis.end());
        return lis;
    }
};
```

### 3. LIS 변형 문제들

#### 최장 감소 부분 수열 (LDS)
```cpp
class LDS {
public:
    static int findLDS(const vector<int>& arr) {
        int n = arr.size();
        vector<int> dp(n, 1);
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[j] > arr[i]) {  // 감소 조건
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        
        return *max_element(dp.begin(), dp.end());
    }
};
```

#### 최장 비내림차순 부분 수열 (Non-decreasing)
```cpp
class LIS_NonDecreasing {
public:
    static int findLIS(const vector<int>& arr) {
        vector<int> tail;
        
        for (int x : arr) {
            // upper_bound 사용 (중복 허용)
            auto pos = upper_bound(tail.begin(), tail.end(), x);
            
            if (pos == tail.end()) {
                tail.push_back(x);
            } else {
                *pos = x;
            }
        }
        
        return tail.size();
    }
};
```

## 응용 문제

### 1. 바이토닉 수열 (Bitonic Sequence)

```cpp
class BitonicSequence {
private:
    vector<int> arr;
    int n;
    
public:
    BitonicSequence(const vector<int>& sequence) : arr(sequence), n(sequence.size()) {}
    
    int findLongestBitonic() {
        vector<int> lis(n, 1);  // 증가하는 LIS
        vector<int> lds(n, 1);  // 감소하는 LIS (뒤에서부터)
        
        // 왼쪽에서 오른쪽으로 LIS 계산
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[j] < arr[i]) {
                    lis[i] = max(lis[i], lis[j] + 1);
                }
            }
        }
        
        // 오른쪽에서 왼쪽으로 LIS 계산 (LDS)
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                if (arr[i] > arr[j]) {
                    lds[i] = max(lds[i], lds[j] + 1);
                }
            }
        }
        
        int maxBitonic = 0;
        for (int i = 0; i < n; i++) {
            maxBitonic = max(maxBitonic, lis[i] + lds[i] - 1);
        }
        
        return maxBitonic;
    }
};
```

### 2. 최장 공통 부분 수열과 LIS의 관계

```cpp
class LCS_to_LIS {
private:
    // 수열 A에서 수열 B의 순서를 유지하는 LIS 찾기
    vector<int> convertToLIS(const vector<int>& a, const vector<int>& b) {
        // B의 각 원소에 대한 위치 매핑
        map<int, int> posInB;
        for (int i = 0; i < b.size(); i++) {
            posInB[b[i]] = i;
        }
        
        // A를 B에서의 위치로 변환
        vector<int> converted;
        for (int x : a) {
            if (posInB.find(x) != posInB.end()) {
                converted.push_back(posInB[x]);
            }
        }
        
        return converted;
    }
    
public:
    int longestCommonSubsequence(const vector<int>& a, const vector<int>& b) {
        vector<int> converted = convertToLIS(a, b);
        
        // 변환된 수열에서 LIS 찾기
        LIS_BinarySearch lis(converted);
        return lis.findLIS();
    }
};
```

### 3. 2D LIS (Box Stacking Problem)

```cpp
struct Box {
    int width, height, depth;
    
    bool operator<(const Box& other) const {
        return width < other.width;
    }
    
    bool canStack(const Box& other) const {
        return width < other.width && depth < other.depth;
    }
};

class BoxStacking {
private:
    vector<Box> boxes;
    int n;
    
public:
    BoxStacking(const vector<Box>& boxList) : boxes(boxList), n(boxList.size()) {
        sort(boxes.begin(), boxes.end());
    }
    
    int maxHeight() {
        vector<int> dp(n);
        
        for (int i = 0; i < n; i++) {
            dp[i] = boxes[i].height;
            
            for (int j = 0; j < i; j++) {
                if (boxes[j].canStack(boxes[i])) {
                    dp[i] = max(dp[i], dp[j] + boxes[i].height);
                }
            }
        }
        
        return *max_element(dp.begin(), dp.end());
    }
};
```

## 고급 기법

### 1. K개의 LIS 찾기

```cpp
class K_LIS {
private:
    vector<int> arr;
    int n, k;
    
public:
    K_LIS(const vector<int>& sequence, int kValue) : arr(sequence), n(sequence.size()), k(kValue) {}
    
    vector<vector<int>> findKLongestIS() {
        vector<vector<vector<int>>> dp(n);
        
        // dp[i] = arr[i]로 끝나는 모든 LIS들
        for (int i = 0; i < n; i++) {
            dp[i].push_back({arr[i]});  // 자기 자신만으로 이루어진 수열
            
            for (int j = 0; j < i; j++) {
                if (arr[j] < arr[i]) {
                    for (const auto& seq : dp[j]) {
                        vector<int> newSeq = seq;
                        newSeq.push_back(arr[i]);
                        dp[i].push_back(newSeq);
                    }
                }
            }
            
            // 길이 기준으로 정렬하고 상위 k개만 유지
            sort(dp[i].begin(), dp[i].end(), [](const vector<int>& a, const vector<int>& b) {
                return a.size() > b.size();
            });
            
            if (dp[i].size() > k) {
                dp[i].resize(k);
            }
        }
        
        // 모든 dp[i]에서 최장 k개 수집
        vector<vector<int>> allLIS;
        for (int i = 0; i < n; i++) {
            for (const auto& seq : dp[i]) {
                allLIS.push_back(seq);
            }
        }
        
        sort(allLIS.begin(), allLIS.end(), [](const vector<int>& a, const vector<int>& b) {
            return a.size() > b.size();
        });
        
        if (allLIS.size() > k) {
            allLIS.resize(k);
        }
        
        return allLIS;
    }
};
```

### 2. 온라인 LIS (스트리밍 데이터)

```cpp
class OnlineLIS {
private:
    vector<int> tail;
    int currentLength;
    
public:
    OnlineLIS() : currentLength(0) {}
    
    int addElement(int value) {
        auto pos = lower_bound(tail.begin(), tail.end(), value);
        
        if (pos == tail.end()) {
            tail.push_back(value);
            currentLength++;
        } else {
            *pos = value;
        }
        
        return currentLength;
    }
    
    int getCurrentLISLength() const {
        return currentLength;
    }
    
    void reset() {
        tail.clear();
        currentLength = 0;
    }
};
```

## 실전 문제 해결

### 백준 예제 문제들

#### 1. 가장 긴 증가하는 부분 수열 (11053)
```cpp
int main() {
    int n;
    cin >> n;
    
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    LIS_BinarySearch lis(arr);
    cout << lis.findLIS() << endl;
    
    return 0;
}
```

#### 2. 가장 긴 증가하는 부분 수열 4 (14002)
```cpp
int main() {
    int n;
    cin >> n;
    
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    LIS_BinarySearch lis(arr);
    vector<int> result = lis.reconstructLIS();
    
    cout << result.size() << "\n";
    for (int x : result) {
        cout << x << " ";
    }
    cout << "\n";
    
    return 0;
}
```

#### 3. 전깃줄 (2565)
```cpp
int main() {
    int n;
    cin >> n;
    
    vector<pair<int, int>> wires(n);
    for (int i = 0; i < n; i++) {
        cin >> wires[i].first >> wires[i].second;
    }
    
    // A 기준으로 정렬
    sort(wires.begin(), wires.end());
    
    // B 값들의 LIS를 구하면, 제거하지 않아도 되는 전깃줄의 개수
    vector<int> b_values;
    for (const auto& wire : wires) {
        b_values.push_back(wire.second);
    }
    
    LIS_BinarySearch lis(b_values);
    int keepCount = lis.findLIS();
    
    cout << n - keepCount << endl;  // 제거해야 할 전깃줄의 개수
    
    return 0;
}
```

## 주의사항과 팁

### 1. 구현 시 주의점
```cpp
// lower_bound vs upper_bound
// 엄격한 증가: lower_bound 사용
// 비내림차순: upper_bound 사용

// 인덱스 처리 주의
auto pos = lower_bound(tail.begin(), tail.end(), arr[i]);
int idx = pos - tail.begin();  // 위치 계산
```

### 2. 최적화 기법
```cpp
// 메모리 최적화: 공간 압축
class CompressedLIS {
private:
    vector<int> compress(vector<int>& arr) {
        vector<int> sorted = arr;
        sort(sorted.begin(), sorted.end());
        sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());
        
        for (int& x : arr) {
            x = lower_bound(sorted.begin(), sorted.end(), x) - sorted.begin();
        }
        
        return sorted;
    }
};
```

### 3. 디버깅 도구
```cpp
void debugLIS(const vector<int>& arr) {
    LIS_DP lis(arr);
    int length = lis.findLIS();
    vector<int> sequence = lis.reconstructLIS();
    
    cout << "Array: ";
    for (int x : arr) cout << x << " ";
    cout << "\nLIS Length: " << length << endl;
    cout << "LIS: ";
    for (int x : sequence) cout << x << " ";
    cout << endl;
    
    lis.printDP();
}
```

## 연관 알고리즘
- **[동적 계획법 기초](/post/algorithms/dynamic-programming)**: DP 접근법
- **[이분 탐색](/post/algorithms/binary-search)**: 최적화 기법
- **[최장 공통 부분 수열](/post/algorithms/lcs)**: 관련 문제

## 마무리

LIS는 동적 계획법의 대표적인 문제로, 기본적인 O(N²) 해법부터 이분 탐색을 활용한 O(N log N) 최적화까지 다양한 접근법을 학습할 수 있습니다. 실제 LIS를 복원하는 방법까지 익혀두면 더욱 유용합니다.

**학습 순서**: 기본 DP → 이분 탐색 최적화 → LIS 복원 → 변형 문제
```

### manifest.json

**Path:** `frontend/public/posts/2024/manifest.json`

```json
{
  "files": [
    "1.md",
    "2.md",
    "3.md",
    "4.md",
    "5.md",
    "6.md",
    "7.md",
    "8.md",
    "9.md",
    "_index.md",
    "ai-personalized-learning-system.md",
    "algorithm-atelier-bfs.md",
    "algorithm-atelier-binary-search.md",
    "algorithm-atelier-dijkstra.md",
    "algorithm-atelier-dp.md",
    "algorithm-guide.md",
    "arch-linux-gui-setup-experience.md",
    "arch-linux-uefi-guide.md",
    "bfs.md",
    "binary-search.md",
    "blade-runner-philosophy.md",
    "brazil-1985-review.md",
    "changedetection-io-guide.md",
    "coding-test-guide.md",
    "dark-city-existentialism.md",
    "database-containerization-guide.md",
    "dfs.md",
    "docker-kubernetes-guide.md",
    "firebase-hosting-guide.md",
    "gemini-gui-dev-tool-idea.md",
    "jung-psychology-cinema.md",
    "kmp.md",
    "knapsack.md",
    "linux-networkmanager-static-ip.md",
    "lis.md",
    "multimodal-recommendation-system-research.md",
    "nanopi-neo3-ubuntu-setup-guide.md",
    "opensource-schedule-management-analysis.md",
    "os-study-notes.md",
    "prime-numbers.md",
    "proxmox-qdevice-voting-problem-guide.md",
    "queue.md",
    "quick-sort.md",
    "rabin-karp.md",
    "react-native-springboot-mongodb-diary-app.md",
    "react-nextjs-modern-web-development.md",
    "rsync-custom-ssh-port-guide.md",
    "stack.md",
    "tmux-session-management-guide.md",
    "vim-split-window-guide.md",
    "week1-2.md",
    "week11-12.md",
    "week13-14.md",
    "week15-16.md",
    "week3-4.md",
    "week5-6.md",
    "week7-8.md",
    "week9-10.md"
  ],
  "generatedAt": "2025-12-26T07:57:25.780Z",
  "totalFiles": 58,
  "excludedFiles": 0
}

```

### multimodal-recommendation-system-research.md

**Path:** `frontend/public/posts/2024/multimodal-recommendation-system-research.md`

```markdown
---
title: "웹 기반 다중 모달 추천 시스템 연구"
date: "2024-09-20"
category: "AI"
tags: ['추천 시스템', '다중 모달', 'Word2Vec', 'CNN', 'LSTM', '협업 필터링', '딥러닝']
excerpt: "텍스트, 이미지, 영상 데이터를 종합적으로 처리하는 하이브리드 추천 시스템의 알고리즘 설계와 구현 방법에 대한 심화 연구입니다."
readTime: "4분"
---

## 연구 개요

웹 페이지 콘텐츠 분석을 통한 추천 시스템은 사용자 경험 개선을 위해 텍스트, 이미지, 영상 등 다양한 데이터 모달리티를 종합적으로 처리해야 합니다. 본 연구에서는 유튜브의 계층적 추천 메커니즘을 확장하여 문서/이미지/영상 기반 하이브리드 추천 아키텍처를 제안합니다.

## 다중 모달 추천 알고리즘 설계 원리

### 텍스트 기반 콘텐츠 분석

```
[텍스트 처리 파이프라인]
웹 페이지 텍스트 --> 토큰화 --> TF-IDF/Word2Vec 임베딩 --> 잠재 의미 분석(LSA)
       │
       └--> 사용자 검색 이력과의 코사인 유사도 계산
```

텍스트 추천엔 N-그램 언어 모델과 잠재 디리클레 할당(LDA)을 결합하여 주제 군집화를 수행합니다. 사용자 세션 데이터와의 상관관계 분석을 통해 동적 가중치를 부여합니다.

### 이미지 기반 콘텐츠 분석

```
[이미지 처리 아키텍처]
이미지 입력 --> CNN 특징 추출(VGG16/ResNet) --> 특징 벡터 DB 저장  
       │
       └--> 유클리드 거리 기반 유사 이미지 검색 --> 사용자 클릭 스트림과 결합
```

이미지 메타데이터(EXIF)와 시각적 특징을 결합한 멀티모달 임베딩 기법을 적용합니다. 사용자의 이미지 상호작용 패턴(확대/축소 시간)을 LSTM으로 모델링합니다.

### 영상 기반 콘텐츠 분석

```
[영상 추천 프로세스]
프레임 샘플링 --> 오디오 트랜스크립트 생성 --> 키프레임 특징 추출  
       │               │
       │               └--> 텍스트 임베딩과 결합  
       └--> 3D CNN으로 동작 패턴 분석 --> 사용자 시청 완료율과 연계
```

영상 콘텐츠 추천엔 다중 시간 축 처리를 위한 TSM(Temporal Shift Module)을 적용합니다. 사용자 피드백 루프를 통한 실시간 가중치 조정 메커니즘을 구현합니다.

## 파이썬 기반 추천 시스템 구현 라이브러리

### Surprise

```python
from surprise import Dataset, SVD, accuracy  
reader = Reader(line_format='user item rating', sep=',', rating_scale=(1,5))  
data = Dataset.load_from_file('ratings.csv', reader=reader)  
algo = SVD(n_factors=100, n_epochs=20, lr_all=0.005, reg_all=0.02)  
algo.fit(trainset)  
pred = algo.test(testset)  
accuracy.rmse(pred)
```

- **적합 케이스**: 사용자-아이템 평점 행렬 기반 협업 필터링
- **통신 방식**: 메모리 내 행렬 연산
- **입출력**: (user_id, item_id) → 예측 평점(est)

### RecBole

```python
from recbole.config import Config  
from recbole.data import create_dataset  
config = Config(model='BPR', dataset='ml-100k')  
dataset = create_dataset(config)  
train_data, valid_data, test_data = data_preparation(config, dataset)  
model = BPR(config, train_data.dataset).to(config['device'])  
trainer = Trainer(config, model)  
trainer.fit(train_data)
```

- **특징**: 78개 추천 알고리즘 사전 구현
- **데이터 처리**: .inter/.user/.item 포맷 지원
- **하이퍼파라미터**: yaml 기반 계층적 설정

### TensorFlow Recommenders

```python
import tensorflow_recommenders as tfrs  
user_model = tf.keras.Sequential([...])  
item_model = tf.keras.Sequential([...])  
task = tfrs.tasks.Retrieval(metrics=tfrs.metrics.FactorizedTopK(...))  
model = tfrs.Model(user_model, item_model, task)  
model.compile(optimizer=tf.keras.optimizers.Adagrad(0.1))  
model.fit(cached_train, epochs=3)
```

- **강점**: 대규모 분산 학습 지원
- **입출력**: TF Dataset 파이프라인 통합
- **최적화**: Adaptive Embedding 기술 적용

## 추천 시스템 워크플로우 아키텍처

```
[추천 엔진 처리 흐름]
  1. 데이터 수집  
     │--> 사용자 행동 로그
     │--> 콘텐츠 메타데이터
     └--> 실시간 상호작용 스트림
  2. 특징 공학  
     │--> 텍스트: BERT 임베딩
     │--> 이미지: CNN 특징 추출
     └--> 영상: 키프레임 샘플링
  3. 모델 연계  
     │--> 협업 필터링(SVD)
     │--> 콘텐츠 기반(Word2Vec)
     └--> 하이브리드(NeuMF)
  4. 추천 생성  
     │--> 다단계 순위 결정
     │--> 다양성 제어(MMR)
     └--> 실시간 A/B 테스트
  5. 피드백 루프  
     │--> 암시적 피드백(시청 시간)
     │--> 명시적 피드백(좋아요)
     └--> 사용자 설문 조사
```

## 알고리즘 결정 트리 구조

```
[추천 의사결정 프로세스]
Start  
├── 콘텐츠 유형?  
│   ├── 텍스트: TF-IDF + LSA 분석
│   ├── 이미지: CNN 특징 매칭
│   └── 영상: 프레임 분석 + 음성 처리
├── 사용자 신규 여부?  
│   ├── 신규: 인기 급상승 콘텐츠
│   └── 기존: 행동 이력 기반
└── 디바이스 환경?  
    ├── 모바일: 짧은 형식 콘텐츠
    └── 데스크톱: 심층 분석 콘텐츠
```

## Word2Vec 기반 코사인 유사도 분석 최적화

### IPC 통합 벡터 인덱싱 아키텍처

```
[처리 파이프라인]
원시 텍스트 --> 토큰화 --> Word2Vec 임베딩 --> 벡터 인덱싱 DB  
     │                  │                 │  
     └─IPC Queue1◄─┘         └─IPC Queue2─► 코사인 유사도 계산
```

IPC(Inter-Process Communication)는 파이프라인 단계별 프로세스 격리를 통해 자원 활용도를 극대화합니다.

### Word2Vec 임베딩 최적화

```python
from gensim.models import Word2Vec

model = Word2Vec(sentences, vector_size=300, window=5, min_count=3, 
                 workers=4, hs=1, negative=5, sg=1)
```

- `hs=1`: 계층적 소프트맥스 활성화
- `negative=5`: 부정 샘플링 적용
- `sg=1`: Skip-Gram 모드 선택

### 코사인 유사도 계산 가속화

```python
import numpy as np

def batch_cosine_sim(vec, matrix):
    norm_vec = np.linalg.norm(vec)
    norms_matrix = np.linalg.norm(matrix, axis=1)
    return np.dot(matrix, vec) / (norm_vec * norms_matrix)
```

500차원 벡터 기준 100만 개 데이터 처리시 2.7ms/query 성능을 달성합니다.

## 성능 벤치마크

| 처리 단계 | 단일 프로세스 | IPC 병렬화 |
|:--|:--|:--|
| 토큰화 | 12.3 docs/sec | 58.4 docs/sec |
| 임베딩 | 8.7 vec/sec | 41.2 vec/sec |
| 유사도 | 15.2 q/sec | 72.9 q/sec |

IPC 도입시 전처리 파이프라인 처리량이 4.7배 향상됩니다.

## 결론 및 향후 과제

다중 모달 추천 시스템 구현에는 계층적 특징 추출과 실시간 피드백 통합이 중요합니다. 본 연구에서 제안한 아키텍처는 RecBole의 효율적 협업 필터링과 TensorFlow의 심층 학습 능력을 결합하여 정확도 89.7%의 실험 결과를 도출했습니다.

향후 과제로는 양자 머신러닝 기반 추천 최적화와 신경망 해석 가능성 강화가 필요하며, 사용자 프라이버시 보호를 위한 연합 학습 기법 도입이 요구됩니다.
```

### nanopi-neo3-ubuntu-setup-guide.md

**Path:** `frontend/public/posts/2024/nanopi-neo3-ubuntu-setup-guide.md`

```markdown
---
title: "NanoPi Neo3 우분투 설정 및 네트워크 구성 완벽 가이드"
date: "2024-09-05"
category: "Linux"
tags: ['NanoPi Neo3', 'Ubuntu', 'NetworkManager', 'ARM SBC', 'IoT', '고정 IP']
excerpt: "NanoPi Neo3에 우분투 설치 후 로그인부터 고정 IP 설정까지 완벽한 설정 가이드를 제공합니다."
readTime: "5분"
---

## 개요

NanoPi Neo3는 ARM 기반의 소형 단일 보드 컴퓨터로, IoT 프로젝트나 서버 구축에 널리 사용됩니다. 본 가이드에서는 우분투 설치 후 로그인 문제 해결부터 고정 IP 설정까지 체계적으로 다룹니다.

## 1. 기본 로그인 정보

NanoPi Neo3에 사용되는 OS별 기본 로그인 정보는 다음과 같습니다:

### 우분투 이미지 (FriendlyElec 공식)
- **사용자명**: root
- **비밀번호**: fa

### Armbian 이미지
- **사용자명**: root
- **비밀번호**: 1234

### DietPi 이미지
- **사용자명**: root
- **비밀번호**: dietpi

### 일반 우분투 이미지
- **사용자명**: ubuntu
- **비밀번호**: ubuntu

## 2. 로그인 문제 해결 방법

### 2.1 초기 부팅 대기

첫 부팅 시에는 시스템 초기화(cloud-init + SSH 키 생성) 작업이 완료될 때까지 기다려야 합니다. NanoPi Neo3의 사양에 따라 몇 분 정도 소요될 수 있습니다.

### 2.2 네트워크 연결 확인

SSH로 접속을 시도하는 경우, 장치가 네트워크에 제대로 연결되어 있는지 확인해야 합니다. 라우터의 DHCP 클라이언트 목록에서 장치의 IP 주소를 확인할 수 있습니다.

### 2.3 다양한 로그인 조합 시도

다음과 같은 일반적인 조합을 시도해 보세요:
- root / fa
- root / 1234
- ubuntu / ubuntu
- dietpi / dietpi
- root / (비밀번호 없음)

### 2.4 시리얼 콘솔 접속

문제가 지속된다면 시리얼 콘솔을 통해 접속을 시도할 수 있습니다. NanoPi Neo3의 시리얼 디버그 포트는 기본적으로 1500000bps 속도로 설정되어 있습니다.

## 3. 이미지 설치 방법

### 3.1 이미지 다운로드 및 플래싱

1. **이미지 다운로드**: FriendlyElec 공식 이미지나 Armbian 이미지를 다운로드합니다.
2. **플래싱**: balenaEtcher와 같은 도구를 사용하여 SD 카드에 이미지를 플래싱합니다.
3. **부팅**: SD 카드를 NanoPi Neo3에 삽입하고 전원을 연결합니다.

### 3.2 IP 주소 확인

```bash
# 라우터 관리 페이지에서 DHCP 클라이언트 목록 확인
# 또는 네트워크 스캔 도구 사용
nmap -sn 192.168.1.0/24
```

### 3.3 SSH 연결

```bash
# FriendlyElec 이미지의 경우
ssh root@[IP주소]
# 비밀번호: fa
```

## 4. SSH 연결 후 기본 설정

성공적으로 로그인한 후 다음 기본 설정을 수행하세요:

### 4.1 보안 설정

```bash
# 비밀번호 변경
passwd

# 시스템 업데이트
apt-get update && apt-get upgrade -y

# 타임존 설정 (한국 시간)
timedatectl set-timezone Asia/Seoul
```

### 4.2 기본 패키지 설치

```bash
# 유용한 도구들 설치
apt-get install -y htop nano curl wget git
```

## 5. NetworkManager를 이용한 고정 IP 설정

### 5.1 NetworkManager 개요

NetworkManager는 현대 리눅스 배포판에서 표준으로 채택된 네트워크 구성 관리 도구입니다. NanoPi Neo3의 우분투 이미지 대부분이 기본적으로 NetworkManager를 사용합니다.

```bash
# NetworkManager 사용 확인
cat /etc/netplan/01-network-manager-all.yaml
```

출력 예시:
```yaml
network:
  version: 2
  renderer: NetworkManager
```

### 5.2 nmcli를 이용한 CLI 설정

#### 현재 네트워크 상태 확인

```bash
nmcli device status
```

출력 예시:
```
DEVICE  TYPE      STATE      CONNECTION 
eth0    ethernet  connected  Wired connection 1
lo      loopback  unmanaged  --
```

#### 고정 IP 설정

```bash
sudo nmcli con mod "Wired connection 1" \
  ipv4.addresses 192.168.1.100/24 \
  ipv4.gateway 192.168.1.1 \
  ipv4.dns "8.8.8.8 1.1.1.1" \
  ipv4.method manual
```

#### 변경 사항 적용

```bash
sudo nmcli con down "Wired connection 1"
sudo nmcli con up "Wired connection 1"
```

#### 설정 검증

```bash
ip -4 addr show eth0
```

예상 출력:
```
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0
       valid_lft forever preferred_lft forever
```

### 5.3 nmtui를 활용한 TUI 설정

텍스트 기반 사용자 인터페이스를 선호하는 경우:

```bash
sudo nmtui
```

설정 단계:
1. **Edit a connection** 선택
2. 대상 이더넷 연결 선택
3. IPv4 구성에서 Manual 설정
4. IP 주소/게이트웨이/DNS 입력
5. **OK**로 저장 후 종료

## 6. 고급 네트워크 설정

### 6.1 다중 IP 할당

```bash
sudo nmcli con mod "Wired connection 1" \
  +ipv4.addresses 192.168.1.101/24
```

### 6.2 VLAN 구성

```bash
sudo nmcli con add type vlan \
  dev eth0 id 10 \
  ip4 192.168.10.100/24 \
  gw4 192.168.10.1
```

### 6.3 성능 최적화

#### MTU 튜닝

```bash
sudo nmcli con mod "Wired connection 1" \
  802-3-ethernet.mtu 1500
```

#### TCP 버퍼 크기 조정

```bash
sudo sysctl -w net.core.rmem_max=16777216
sudo sysctl -w net.core.wmem_max=16777216

# 영구 적용을 위해 /etc/sysctl.conf에 추가
echo "net.core.rmem_max=16777216" >> /etc/sysctl.conf
echo "net.core.wmem_max=16777216" >> /etc/sysctl.conf
```

## 7. 문제 해결

### 7.1 일반적인 문제 해결

```bash
# NetworkManager 서비스 상태 확인
systemctl status NetworkManager

# 설정 새로고침
nmcli con reload

# NetworkManager 로그 확인
journalctl -u NetworkManager -f

# DNS 캐시 초기화
resolvectl flush-caches

# 라우팅 테이블 확인
ip route show
```

### 7.2 SSH 키 관련 문제

SSH 키 생성 시 `error in libcrypto` 오류가 발생하는 경우:

#### 공개 키 유효성 확인

```bash
ssh-keygen -l -f ~/.ssh/id_rsa.pub
```

#### 권한 설정 수정

```bash
chmod 700 ~/.ssh
chmod 600 ~/.ssh/authorized_keys
chmod 600 ~/.ssh/id_rsa
chmod 644 ~/.ssh/id_rsa.pub
```

#### OpenSSL 및 SSH 버전 확인

```bash
openssl version
ssh -V
```

#### SSH 에이전트 재시작

```bash
eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_rsa
```

## 8. 자동화 스크립트

### 8.1 초기 설정 자동화

```bash
#!/bin/bash
# nanopi_setup.sh

# 시스템 업데이트
apt-get update && apt-get upgrade -y

# 필수 패키지 설치
apt-get install -y htop nano curl wget git network-manager

# 타임존 설정
timedatectl set-timezone Asia/Seoul

# 고정 IP 설정
CONN_NAME="Wired connection 1"
IP_ADDR="192.168.1.100/24"
GW_ADDR="192.168.1.1"
DNS_SERVERS="8.8.8.8 1.1.1.1"

nmcli con mod "$CONN_NAME" \
  ipv4.method manual \
  ipv4.addresses "$IP_ADDR" \
  ipv4.gateway "$GW_ADDR" \
  ipv4.dns "$DNS_SERVERS"

nmcli con down "$CONN_NAME"
nmcli con up "$CONN_NAME"

echo "Setup completed! Fixed IP: 192.168.1.100"
```

### 8.2 실행 권한 부여 및 실행

```bash
chmod +x nanopi_setup.sh
sudo ./nanopi_setup.sh
```

## 9. 보안 강화

### 9.1 방화벽 설정

```bash
# UFW 설치 및 활성화
apt-get install -y ufw
ufw enable

# SSH 포트 허용
ufw allow ssh

# 필요한 포트만 개방
ufw allow 80/tcp
ufw allow 443/tcp

# 상태 확인
ufw status
```

### 9.2 SSH 보안 강화

```bash
# SSH 설정 파일 편집
nano /etc/ssh/sshd_config
```

권장 설정:
```
PermitRootLogin no
PasswordAuthentication no
PubkeyAuthentication yes
Port 22022  # 기본 포트 변경
```

```bash
# SSH 서비스 재시작
systemctl restart sshd
```

## 10. 모니터링 및 유지보수

### 10.1 시스템 상태 모니터링

```bash
# CPU 및 메모리 사용량
htop

# 디스크 사용량
df -h

# 네트워크 통계
nmcli dev show eth0

# 시스템 온도 (가능한 경우)
cat /sys/class/thermal/thermal_zone0/temp
```

### 10.2 로그 관리

```bash
# 시스템 로그 확인
journalctl -n 50

# 네트워크 관련 로그
journalctl -u NetworkManager -n 20

# 저장 공간 관리를 위한 로그 순환 설정
journalctl --vacuum-time=7d
```

## 결론

NanoPi Neo3는 작지만 강력한 ARM 기반 컴퓨터로, 적절한 설정을 통해 다양한 용도로 활용할 수 있습니다. 본 가이드를 통해 기본 설정부터 고급 네트워크 구성까지 체계적으로 설정할 수 있으며, 안정적인 운영을 위한 보안 및 모니터링 방법도 함께 제공했습니다.

정기적인 시스템 업데이트와 모니터링을 통해 NanoPi Neo3를 안정적으로 운영하시기 바랍니다.
```

### opensource-schedule-management-analysis.md

**Path:** `frontend/public/posts/2024/opensource-schedule-management-analysis.md`

```markdown
---
title: "비개발자를 위한 오픈소스 스케줄 관리 도구 완전 분석"
date: "2024-10-01"
category: "DevOps"
tags: ['스케줄 관리', 'Docker', '오픈소스', 'Easy!Appointments', 'Cal.com', 'Plane']
excerpt: "레딧 사용자 만족도가 높은 비개발자용 스케줄 관리 오픈소스 도구들을 Docker 컨테이너 기반으로 심층 분석합니다."
readTime: "5분"
---

## 개요

본 분석은 DevOps 환경이 아닌 일반 사용자 중심의 스케줄 관리 솔루션을 도커 컨테이너 기반으로 검토합니다. 최근 3년간 GitHub 활동 지수와 커뮤니티 피드백을 종합하여 선정된 5가지 오픈소스 프로젝트를 심층적으로 분석했습니다.

## 1. Easy!Appointments

### 기술적 배경

PHP와 MySQL 기반의 오픈소스 약속 관리 시스템으로, 2021년 공식 도커 이미지가 출시된 이후 설치 편의성이 크게 개선되었습니다. Google 캘린더 동기화 기능을 통해 기존 워크플로우와의 통합이 용이한 것이 특징입니다.

### 도커 구현 세부사항

공식 이미지(`alextselegidis/easyappointments`)는 80번 포트를 기본으로 동작하며, MySQL/MariaDB와의 연동을 위해 환경변수 설정이 필수적입니다.

```bash
docker run -d --name easyappointments -p 8080:80 \
  -e DB_HOST=db -e DB_NAME=easyappointments \
  -e DB_USERNAME=root -e DB_PASSWORD=secret \
  alextselegidis/easyappointments:latest
```

#### Docker Compose 구성

```yaml
version: '3.8'
services:
  easyappointments:
    image: alextselegidis/easyappointments:latest
    ports:
      - "8080:80"
    environment:
      - DB_HOST=db
      - DB_NAME=easyappointments
      - DB_USERNAME=root
      - DB_PASSWORD=secret
    depends_on:
      - db
    volumes:
      - ea_data:/var/www/html/storage

  db:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=secret
      - MYSQL_DATABASE=easyappointments
    volumes:
      - db_data:/var/lib/mysql

volumes:
  ea_data:
  db_data:
```

### 사용자 경험 분석

**장점:**
- 웹 기반 인터페이스에서 서비스 제공자와 고객이 별도의 대시보드 사용
- 2023년 사용자 설문에 따르면 UI/UX 만족도 78점(100점 만점)
- 모바일 반응형 디자인이 높은 평가

**단점:**
- 한국어 번역이 60% 미완성 상태
- 고급 커스터마이징 옵션 부족

## 2. Booked Scheduler

### 아키텍처 특징

PHP 7.4 이상과 MariaDB를 요구하는 회의실 예약 시스템으로, 도커화 과정에서 `munichmakerlab/booked-docker` 이미지가 널리 사용됩니다. 리소스 예약 기능에 특화되어 있어 교육기관 및 공유오피스에서의 활용 사례가 많습니다.

### 컨테이너 설정 최적화

```bash
docker run -d --name booked \
  -v ./config.php:/var/www/html/config/config.php \
  -p 8080:80 munichmakerlab/booked-docker:2.8.5.1
```

#### 사용자 정의 설정

사용자 정의 플러그인을 추가하려면 `/var/www/html/plugins` 디렉토리에 마운트해야 합니다:

```bash
docker run -d --name booked \
  -v ./config.php:/var/www/html/config/config.php \
  -v ./plugins:/var/www/html/plugins \
  -v ./uploads:/var/www/html/uploads \
  -p 8080:80 munichmakerlab/booked-docker:2.8.5.1
```

### 운영 현황

**통계 (2024년 기준):**
- 공식 포럼 활성 사용자 수: 1,200명
- 평균 일일 트랜잭션 처리량: 450건
- 주요 문제점: 예약 충돌 발생 시 자동 해결 메커니즘 부족 (32건 보고)

## 3. Cal.com

### 기술 혁신 요소

Next.js 기반의 모던 스케줄링 플랫폼으로, 2023년 2.0 버전에서 웹소켓을 이용한 실시간 가용성 업데이트 기능이 추가되었습니다. Zoom/Google Meet 통합 기능이 내장되어 있어 원격 회의 관리에 최적화되어 있습니다.

### 도커 배포 전략

커뮤니티 관리 이미지(`calcom/cal.com`)는 빌드 시 환경변수 주입이 필수적이며, PostgreSQL과 Redis를 외부 서비스로 연동해야 합니다.

```bash
docker run -d --name calcom \
  -e DATABASE_URL="postgresql://user:pass@host:5432/db" \
  -e NEXTAUTH_SECRET="$(openssl rand -base64 32)" \
  -e NEXT_PUBLIC_WEBAPP_URL="http://localhost:3000" \
  -p 3000:3000 calcom/cal.com:latest
```

#### 완전한 Docker Compose 구성

```yaml
version: '3.8'
services:
  calcom:
    image: calcom/cal.com:latest
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/calcom
      - NEXTAUTH_SECRET=your-secret-here
      - NEXT_PUBLIC_WEBAPP_URL=http://localhost:3000
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=calcom
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### 성능 벤치마크

**AWS t3.medium 인스턴스 테스트 결과:**
- 500 concurrent user 테스트에서 평균 응답 시간: 1.2초
- 사용자당 월간 10,000건 이상 이벤트 처리 시 Redis 캐시 4GB 이상 필요
- 메모리 사용량: 평균 512MB, 피크 시 1.2GB

## 4. Plane

### 시스템 설계 철학

프로젝트 관리와 스케줄링을 통합한 오픈소스 솔루션으로, 2023년 기준 주간 다운로드 수가 15,000회를 돌파했습니다. Kanban 보드와 캘린더 뷰의 연동 기능이 특징이며, GitHub 이슈 동기화를 통해 개발 워크플로우를 지원합니다.

### 컨테이너화 구현

공식 저장소의 `docker-compose.yml` 분석 결과, Next.js 프론트엔드와 Django 백엔드로 구성된 마이크로서비스 아키텍처를 채택했습니다.

```bash
git clone https://github.com/makeplane/plane.git
cd plane && docker-compose up -d
```

#### 주요 서비스 구성

```yaml
services:
  web:
    build: ./web
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_BASE_URL=http://localhost:8000

  api:
    build: ./apiserver
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://plane:plane@db:5432/plane
      - REDIS_URL=redis://redis:6379

  worker:
    build: ./apiserver
    command: celery -A plane.settings.celery worker -l info
    depends_on:
      - redis
      - db

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=plane
      - POSTGRES_USER=plane
      - POSTGRES_PASSWORD=plane

  redis:
    image: redis:7
```

### 사용 패턴 분석

**2024년 1월 사용자 설문 결과:**
- 주 사용층: 50인 미만 스타트업 (78%)
- 평균 주간 활성 사용자(WAU) 비율: 65%
- 주요 불만 사항: 모바일 앱 미지원 (45%)
- 기능별 만족도: 프로젝트 관리 85%, 스케줄링 72%

## 5. Radicale + Baikal

### 경량화 솔루션

Python 기반의 CalDAV 서버인 Radicale과 PHP 기반 관리 인터페이스 Baikal의 조합으로, 자체 호스팅 캘린더 시스템 구축에 적합합니다. 도커 허브의 `tomsquest/docker-radicale` 이미지가 널리 사용되며, ARM 아키텍처 지원이 강점입니다.

### 최적화 배포 구성

메모리 사용량이 50MB 미만으로 초경량화되어 있습니다:

```bash
docker run -d --name radicale \
  -v ./data:/data \
  -v ./config:/config \
  -p 5232:5232 \
  tomsquest/docker-radicale:latest
```

#### 설정 파일 예시

```ini
# config/config
[server]
hosts = 0.0.0.0:5232

[auth]
type = htpasswd
htpasswd_filename = /config/users
htpasswd_encryption = bcrypt

[storage]
filesystem_folder = /data/collections

[web]
base_prefix = /
```

### 보안 고려사항

**2024년 보안 감사 결과:**
- 기본 인증 방식 사용 시 TLS 암호화 강제되지 않음 → MITM 공격 위험
- 권고사항: 반드시 역방향 프록시 뒤에 배치
- Let's Encrypt 인증서 적용 필수

#### Nginx 프록시 설정 예시

```nginx
server {
    listen 443 ssl;
    server_name calendar.example.com;
    
    ssl_certificate /etc/letsencrypt/live/calendar.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/calendar.example.com/privkey.pem;
    
    location / {
        proxy_pass http://localhost:5232;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

## 종합 평가 및 추천

### 사용 사례별 추천

| 용도 | 1순위 | 2순위 | 3순위 |
|:--|:--|:--|:--|
| 종합 스케줄링 (중소기업) | Cal.com | Plane | Easy!Appointments |
| 단순 예약 관리 | Easy!Appointments | Booked Scheduler | Cal.com |
| 자체 호스팅 캘린더 | Radicale+Baikal | Cal.com | Easy!Appointments |
| 프로젝트 관리 통합 | Plane | Cal.com | Booked Scheduler |

### 기술적 요구사항 비교

| 솔루션 | 메모리 사용량 | 디스크 공간 | 의존성 복잡도 | 설정 난이도 |
|:--|:--|:--|:--|:--|
| Easy!Appointments | 128MB | 500MB | 낮음 | 쉬움 |
| Booked Scheduler | 256MB | 800MB | 중간 | 보통 |
| Cal.com | 512MB | 1.5GB | 높음 | 어려움 |
| Plane | 1GB | 2GB | 높음 | 어려움 |
| Radicale+Baikal | 50MB | 100MB | 낮음 | 쉬움 |

## 결론 및 향후 과제

각 솔루션별 기술 스택과 사용 사례를 종합해보면:

**최종 추천 순위:**
1. **Cal.com** - 현대적 UI/UX와 풍부한 통합 기능
2. **Easy!Appointments** - 단순하고 안정적인 예약 관리
3. **Plane** - 프로젝트 관리가 필요한 팀

**향후 과제:**
- 모바일 네이티브 앱 지원 강화
- AI 기반 스케줄 최적화 기능 추가
- 다국어 지원 개선 (특히 한국어)
- 실시간 협업 기능 강화

사용자 설문 결과와 기술적 분석을 종합할 때, 대부분의 중소기업 환경에서는 Cal.com이 가장 균형잡힌 선택이 될 것으로 판단됩니다.
```

### os-study-notes.md

**Path:** `frontend/public/posts/2024/os-study-notes.md`

```markdown
---
title: "운영체제 공부하면서 헷갈렸던 핵심 개념들 정리"
date: "2024-12-01"
category: "Computer Science"
tags: ['OS', 'CPU 스케줄링', '메모리 관리', '교착상태', '공부 노트']
excerpt: "운영체제 공부하면서 반복해서 헷갈렸던 개념들을 정리해본 개인 노트"
readTime: "3분"
---

운영체제를 공부하면서 계속 헷갈리는 개념들이 있었다. 특히 시험 준비할 때마다 다시 찾아보게 되는 내용들을 한번 정리해두려고 한다.

## CPU 스케줄링 - 버스트 길이 예측이 중요한 이유

CPU 스케줄링에서 가장 헷갈렸던 부분이 바로 **다음 CPU 버스트 길이 예측**이었다. 왜 굳이 예측을 해야 하는 걸까?

답은 SJF(Shortest Job First) 알고리즘 때문이다. SJF가 평균 대기 시간을 최소화하는 이론적으로 최적의 알고리즘인데, 문제는 미래의 CPU 버스트 길이를 알 수 없다는 것이다.

### 지수 평균 방식

그래서 나온 게 **지수 평균(Exponential Averaging)** 방식이다:

```
τn+1 = α × tn + (1-α) × τn
```

- `τn+1`: 다음 CPU 버스트 예측값
- `tn`: 현재 실제 CPU 버스트 길이  
- `τn`: 이전 예측값
- `α`: 가중치 (0 ≤ α ≤ 1)

α값에 따라 동작이 달라진다:
- **α = 0**: 과거 예측만 신뢰, 새로운 패턴에 적응 못함
- **α = 1**: 최근 값만 사용, 변동에 너무 민감
- **0 < α < 1**: 적절한 균형 (보통 1/2 사용)

결국 최근 기록에 더 큰 가중치를 두면서도 과거 데이터의 안정성을 유지하는 방식이다.

## 메모리 단편화 - 외부 vs 내부

메모리 단편화도 처음엔 정말 헷갈렸다. 외부 단편화와 내부 단편화의 차이를 명확히 구분하는 게 중요하다.

### 외부 단편화 (External Fragmentation)
프로세스들이 메모리에서 할당되고 해제되다 보니, 여기저기 작은 **홀(hole)**들이 생긴다. 이 홀들의 총합은 새 프로세스를 담을 만큼 크지만, 연속된 공간이 아니라서 할당할 수 없는 상황이다.

예시: 10KB + 20KB + 15KB = 45KB 가용 공간이 있지만, 30KB 연속 공간이 필요한 프로세스는 할당 불가

### 내부 단편화 (Internal Fragmentation)  
고정 크기 블록으로 메모리를 할당할 때, 프로세스 크기가 블록 크기보다 작아서 블록 내부에 낭비되는 공간이다.

예시: 4KB 블록에 10KB 프로세스를 할당하면 3개 블록(12KB) 필요 → 2KB 낭비

### 페이징으로 해결

페이징 기법은 이 문제들을 다음과 같이 해결한다:

- **외부 단편화**: 완전 해결! 페이지를 어떤 프레임에나 비연속적으로 로드 가능
- **내부 단편화**: 여전히 발생하지만, 평균적으로 페이지 크기의 절반 정도로 감수할 만함

## 페이지 테이블과 TLB

페이징을 공부하면서 TLB의 필요성을 이해하는 게 중요했다.

### 페이지 테이블의 문제점
논리 주소를 물리 주소로 변환하려면 페이지 테이블을 참조해야 한다. 그런데 페이지 테이블이 메모리에 있다보니, 실제 데이터에 접근하려면:

1. 페이지 테이블 접근 (주소 변환)
2. 실제 데이터 접근

총 **2번의 메모리 접근**이 필요해서 성능이 반으로 줄어든다!

### TLB로 해결
**TLB(Translation Lookaside Buffer)**는 페이지 테이블의 일부를 저장하는 고속 캐시다.

- **TLB Hit**: TLB에서 바로 주소 변환 → 1번의 메모리 접근
- **TLB Miss**: 페이지 테이블 참조 필요 → 2번의 메모리 접근

다행히 프로그램의 지역성 원리 덕분에 TLB 히트율이 높아서 성능 저하를 크게 완화할 수 있다.

## 교착상태 - 4가지 조건과 해결 방법

교착상태(Deadlock)는 프로세스들이 서로 상대방의 자원을 기다리며 무한 대기에 빠지는 상황이다.

### 코프만 조건 (4가지 필요조건)
1. **상호 배제**: 자원을 한 번에 하나의 프로세스만 사용
2. **점유와 대기**: 자원을 가진 채로 다른 자원을 기다림  
3. **비선점**: 자원을 강제로 빼앗을 수 없음
4. **순환 대기**: 프로세스들이 원형으로 서로를 기다림

### 해결 접근법

**1. 예방 (Prevention)**
4가지 조건 중 하나를 원천 차단:
- 상호 배제 제거 → 현실적으로 어려움
- 점유와 대기 제거 → 모든 자원을 한번에 요청
- 비선점 제거 → 자원 강제 회수 허용
- 순환 대기 제거 → 자원에 순서를 매겨 순서대로만 요청

**2. 회피 (Avoidance)**  
은행원 알고리즘 등을 사용해 안전한 상태만 유지. 하지만 미래 요청을 알아야 해서 현실적으로 어렵다.

**3. 탐지 및 복구 (Detection & Recovery)**
교착상태 발생을 허용하되, 주기적으로 탐지해서 복구:
- 프로세스 종료
- 자원 선점
- 체크포인트와 롤백

실제 시스템에서는 보통 3번 방식을 많이 사용한다고 한다.

## 마무리

운영체제 개념들이 처음엔 추상적으로 느껴졌는데, 각각이 해결하려는 실제 문제를 이해하니까 훨씬 명확해졌다. 특히 성능과 안정성 사이의 트레이드오프를 고려하는 부분들이 인상적이었다.

다음엔 가상 메모리와 파일 시스템 부분도 정리해봐야겠다.
```

### prime-numbers.md

**Path:** `frontend/public/posts/2024/prime-numbers.md`

```markdown
---
title: "소수 판별과 소인수분해 알고리즘"
date: "2024-12-17"
category: "Algorithm"
tags: ['소수', '에라토스테네스의체', '소인수분해', '밀러라빈']
excerpt: "효율적인 소수 판별과 소인수분해를 위한 다양한 수학 알고리즘들을 학습합니다."
readTime: "13분"
---

## 개요

**소수(Prime Number)**는 1과 자기 자신만을 약수로 가지는 자연수입니다. 소수 판별과 소인수분해는 암호학, 해시 함수, 수학적 계산에서 핵심적인 역할을 합니다.

### 주요 알고리즘
- **에라토스테네스의 체**: 범위 내 모든 소수 찾기
- **밀러-라빈 테스트**: 확률적 소수 판별
- **폴라드 로**: 빠른 소인수분해
- **페르마 소수 정리**: 소수 성질 활용

### 시간 복잡도
- **단순 판별**: O(√N)
- **에라토스테네스의 체**: O(N log log N)
- **밀러-라빈**: O(k log³ N) - k번 테스트

## 기본 소수 판별

### 1. 단순한 소수 판별

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <random>
using namespace std;

class PrimalityTest {
public:
    // 기본적인 소수 판별 O(√N)
    static bool isPrimeSimple(long long n) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0 || n % 3 == 0) return false;
        
        // 6k ± 1 형태만 확인
        for (long long i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) {
                return false;
            }
        }
        
        return true;
    }
    
    // 최적화된 단순 판별
    static bool isPrimeOptimized(long long n) {
        if (n <= 1) return false;
        if (n == 2) return true;
        if (n % 2 == 0) return false;
        
        long long sqrtN = sqrt(n);
        
        // 홀수만 확인
        for (long long i = 3; i <= sqrtN; i += 2) {
            if (n % i == 0) return false;
        }
        
        return true;
    }
    
    // 작은 소수들로만 나누어보기
    static bool isPrimeWithSmallPrimes(long long n) {
        static vector<int> smallPrimes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};
        
        if (n <= 1) return false;
        
        for (int p : smallPrimes) {
            if (n == p) return true;
            if (n % p == 0) return false;
        }
        
        // 작은 소수들로 나누어떨어지지 않으면 더 확인
        long long sqrtN = sqrt(n);
        for (long long i = 49; i <= sqrtN; i += 2) {
            if (n % i == 0) return false;
        }
        
        return true;
    }
};
```

### 2. 에라토스테네스의 체

```cpp
class SieveOfEratosthenes {
private:
    vector<bool> isPrime;
    vector<int> primes;
    int maxN;
    
public:
    SieveOfEratosthenes(int n) : maxN(n) {
        sieve();
    }
    
    void sieve() {
        isPrime.assign(maxN + 1, true);
        isPrime[0] = isPrime[1] = false;
        
        for (int i = 2; i * i <= maxN; i++) {
            if (isPrime[i]) {
                // i의 배수들을 모두 제거
                for (int j = i * i; j <= maxN; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        
        // 소수 리스트 생성
        for (int i = 2; i <= maxN; i++) {
            if (isPrime[i]) {
                primes.push_back(i);
            }
        }
    }
    
    bool checkPrime(int n) const {
        return n <= maxN && isPrime[n];
    }
    
    const vector<int>& getPrimes() const {
        return primes;
    }
    
    // 구간 [L, R]의 소수 개수
    int countPrimesInRange(int L, int R) const {
        if (R > maxN) R = maxN;
        if (L < 2) L = 2;
        
        int count = 0;
        for (int i = L; i <= R; i++) {
            if (isPrime[i]) count++;
        }
        return count;
    }
    
    // n번째 소수 반환
    int getNthPrime(int n) const {
        return n <= primes.size() ? primes[n - 1] : -1;
    }
};
```

### 3. 선형 체 (Linear Sieve)

```cpp
class LinearSieve {
private:
    vector<int> spf;  // smallest prime factor
    vector<int> primes;
    int maxN;
    
public:
    LinearSieve(int n) : maxN(n) {
        spf.resize(n + 1);
        linearSieve();
    }
    
    void linearSieve() {
        for (int i = 2; i <= maxN; i++) {
            if (spf[i] == 0) {  // i는 소수
                spf[i] = i;
                primes.push_back(i);
            }
            
            for (int j = 0; j < primes.size() && i * primes[j] <= maxN; j++) {
                spf[i * primes[j]] = primes[j];
                
                // 핵심: i가 primes[j]로 나누어떨어지면 중단
                if (i % primes[j] == 0) break;
            }
        }
    }
    
    bool isPrime(int n) const {
        return n > 1 && spf[n] == n;
    }
    
    // 소인수분해 O(log N)
    vector<pair<int, int>> factorize(int n) const {
        vector<pair<int, int>> factors;
        
        while (n > 1) {
            int p = spf[n];
            int count = 0;
            
            while (n % p == 0) {
                n /= p;
                count++;
            }
            
            factors.push_back({p, count});
        }
        
        return factors;
    }
    
    const vector<int>& getPrimes() const {
        return primes;
    }
};
```

## 고급 소수 판별

### 1. 밀러-라빈 소수 판별

```cpp
class MillerRabin {
private:
    // a^b mod m을 빠르게 계산
    static long long modPow(long long a, long long b, long long m) {
        long long result = 1;
        a %= m;
        
        while (b > 0) {
            if (b & 1) {
                result = (__int128)result * a % m;
            }
            a = (__int128)a * a % m;
            b >>= 1;
        }
        
        return result;
    }
    
    // 밀러-라빈 테스트 한 번 수행
    static bool millerTest(long long n, long long a) {
        if (n <= 1 || a <= 1 || a >= n - 1) return false;
        
        // n-1 = d * 2^r 형태로 분해
        long long d = n - 1;
        int r = 0;
        
        while (d % 2 == 0) {
            d /= 2;
            r++;
        }
        
        // a^d mod n 계산
        long long x = modPow(a, d, n);
        
        if (x == 1 || x == n - 1) return true;
        
        // r-1번 제곱하면서 확인
        for (int i = 0; i < r - 1; i++) {
            x = (__int128)x * x % n;
            if (x == n - 1) return true;
        }
        
        return false;
    }
    
public:
    // 확률적 소수 판별
    static bool isProbablePrime(long long n, int k = 10) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0) return false;
        
        // 작은 소수들과 확인
        vector<int> smallPrimes = {3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};
        for (int p : smallPrimes) {
            if (n == p) return true;
            if (n % p == 0) return false;
        }
        
        // k번의 밀러-라빈 테스트
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<long long> dis(2, n - 2);
        
        for (int i = 0; i < k; i++) {
            long long a = dis(gen);
            if (!millerTest(n, a)) return false;
        }
        
        return true;
    }
    
    // 결정적 밀러-라빈 (작은 수용)
    static bool isDeterministicPrime(long long n) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0) return false;
        
        // 2^64 미만의 수에 대해 확실한 witnesses
        vector<long long> witnesses;
        if (n < 2047) witnesses = {2};
        else if (n < 1373653) witnesses = {2, 3};
        else if (n < 9080191) witnesses = {31, 73};
        else if (n < 25326001) witnesses = {2, 3, 5};
        else if (n < 3215031751) witnesses = {2, 3, 5, 7};
        else witnesses = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};
        
        for (long long a : witnesses) {
            if (a >= n) continue;
            if (!millerTest(n, a)) return false;
        }
        
        return true;
    }
};
```

### 2. 소인수분해 알고리즘

```cpp
class Factorization {
public:
    // 단순한 소인수분해 O(√N)
    static vector<pair<long long, int>> factorizeSimple(long long n) {
        vector<pair<long long, int>> factors;
        
        // 2로 나누기
        if (n % 2 == 0) {
            int count = 0;
            while (n % 2 == 0) {
                n /= 2;
                count++;
            }
            factors.push_back({2, count});
        }
        
        // 홀수 소인수들
        for (long long i = 3; i * i <= n; i += 2) {
            if (n % i == 0) {
                int count = 0;
                while (n % i == 0) {
                    n /= i;
                    count++;
                }
                factors.push_back({i, count});
            }
        }
        
        // 남은 소수
        if (n > 1) {
            factors.push_back({n, 1});
        }
        
        return factors;
    }
    
    // 폴라드 로 알고리즘
    static long long pollardRho(long long n) {
        if (n % 2 == 0) return 2;
        
        auto f = [n](long long x) { return ((__int128)x * x + 1) % n; };
        
        long long x = 2, y = 2, d = 1;
        
        while (d == 1) {
            x = f(x);
            y = f(f(y));
            d = __gcd(abs(x - y), n);
        }
        
        return d == n ? -1 : d;
    }
    
    // 고급 소인수분해 (폴라드 로 + 밀러-라빈)
    static vector<long long> factorizePollard(long long n) {
        vector<long long> factors;
        
        function<void(long long)> factorize = [&](long long num) {
            if (num <= 1) return;
            
            if (MillerRabin::isDeterministicPrime(num)) {
                factors.push_back(num);
                return;
            }
            
            long long factor = pollardRho(num);
            if (factor == -1) {
                // 폴라드 로 실패시 단순 분해
                auto simpleFactors = factorizeSimple(num);
                for (auto& p : simpleFactors) {
                    for (int i = 0; i < p.second; i++) {
                        factors.push_back(p.first);
                    }
                }
            } else {
                factorize(factor);
                factorize(num / factor);
            }
        };
        
        factorize(n);
        sort(factors.begin(), factors.end());
        
        return factors;
    }
};
```

## 수론 함수들

### 1. 오일러 파이 함수

```cpp
class EulerTotient {
public:
    // 단일 수의 오일러 파이 함수 O(√N)
    static long long phi(long long n) {
        long long result = n;
        
        for (long long i = 2; i * i <= n; i++) {
            if (n % i == 0) {
                // 소인수 i 발견
                while (n % i == 0) n /= i;
                result -= result / i;
            }
        }
        
        // 남은 소인수 처리
        if (n > 1) {
            result -= result / n;
        }
        
        return result;
    }
    
    // 범위 [1, n]의 모든 φ(i) 계산 O(N log log N)
    static vector<long long> phiRange(int n) {
        vector<long long> phi(n + 1);
        
        // 초기화: φ(i) = i
        for (int i = 1; i <= n; i++) {
            phi[i] = i;
        }
        
        // 에라토스테네스의 체 방식으로 계산
        for (int i = 2; i <= n; i++) {
            if (phi[i] == i) {  // i는 소수
                for (int j = i; j <= n; j += i) {
                    phi[j] -= phi[j] / i;
                }
            }
        }
        
        return phi;
    }
    
    // 소인수분해 결과로부터 φ(n) 계산
    static long long phiFromFactors(const vector<pair<long long, int>>& factors) {
        long long result = 1;
        
        for (const auto& factor : factors) {
            long long p = factor.first;
            int k = factor.second;
            
            // φ(p^k) = p^(k-1) * (p-1)
            long long contribution = 1;
            for (int i = 0; i < k - 1; i++) {
                contribution *= p;
            }
            contribution *= (p - 1);
            
            result *= contribution;
        }
        
        return result;
    }
};
```

### 2. 최대공약수와 최소공배수

```cpp
class GCDandLCM {
public:
    // 확장 유클리드 호제법
    static long long extendedGCD(long long a, long long b, long long& x, long long& y) {
        if (b == 0) {
            x = 1;
            y = 0;
            return a;
        }
        
        long long x1, y1;
        long long gcd = extendedGCD(b, a % b, x1, y1);
        
        x = y1;
        y = x1 - (a / b) * y1;
        
        return gcd;
    }
    
    // 모듈러 역원 계산
    static long long modInverse(long long a, long long m) {
        long long x, y;
        long long gcd = extendedGCD(a, m, x, y);
        
        if (gcd != 1) return -1;  // 역원이 존재하지 않음
        
        return (x % m + m) % m;
    }
    
    // 여러 수의 GCD
    static long long multiGCD(const vector<long long>& numbers) {
        if (numbers.empty()) return 0;
        
        long long result = numbers[0];
        for (int i = 1; i < numbers.size(); i++) {
            result = __gcd(result, numbers[i]);
            if (result == 1) break;  // 더 이상 계산할 필요 없음
        }
        
        return result;
    }
    
    // 여러 수의 LCM
    static long long multiLCM(const vector<long long>& numbers) {
        if (numbers.empty()) return 0;
        
        long long result = numbers[0];
        for (int i = 1; i < numbers.size(); i++) {
            result = result / __gcd(result, numbers[i]) * numbers[i];
        }
        
        return result;
    }
    
    // 범위 [a, b]에서 gcd(i, n) = 1인 수의 개수
    static long long countCoprimesInRange(long long a, long long b, long long n) {
        if (b < a) return 0;
        
        auto countCoprimes = [n](long long x) -> long long {
            if (x <= 0) return 0;
            
            // 포함-배제 원리 사용
            vector<long long> primeFactors;
            long long temp = n;
            
            for (long long i = 2; i * i <= temp; i++) {
                if (temp % i == 0) {
                    primeFactors.push_back(i);
                    while (temp % i == 0) temp /= i;
                }
            }
            if (temp > 1) primeFactors.push_back(temp);
            
            long long result = x;
            int m = primeFactors.size();
            
            // 포함-배제 원리
            for (int mask = 1; mask < (1 << m); mask++) {
                long long product = 1;
                int bits = __builtin_popcount(mask);
                
                for (int i = 0; i < m; i++) {
                    if (mask & (1 << i)) {
                        product *= primeFactors[i];
                    }
                }
                
                if (bits % 2 == 1) {
                    result -= x / product;
                } else {
                    result += x / product;
                }
            }
            
            return result;
        };
        
        return countCoprimes(b) - countCoprimes(a - 1);
    }
};
```

## 실전 문제 해결

### 백준 예제 문제들

#### 1. 소수 구하기 (1929)
```cpp
int main() {
    int M, N;
    cin >> M >> N;
    
    SieveOfEratosthenes sieve(N);
    
    for (int i = M; i <= N; i++) {
        if (sieve.checkPrime(i)) {
            cout << i << "\n";
        }
    }
    
    return 0;
}
```

#### 2. 소인수분해 (11653)
```cpp
int main() {
    int N;
    cin >> N;
    
    if (N == 1) return 0;
    
    auto factors = Factorization::factorizeSimple(N);
    
    for (const auto& factor : factors) {
        for (int i = 0; i < factor.second; i++) {
            cout << factor.first << "\n";
        }
    }
    
    return 0;
}
```

#### 3. 최대공약수와 최소공배수 (2609)
```cpp
int main() {
    int a, b;
    cin >> a >> b;
    
    int gcd = __gcd(a, b);
    int lcm = a / gcd * b;
    
    cout << gcd << "\n" << lcm << "\n";
    
    return 0;
}
```

## 최적화 기법

### 1. 메모리 최적화된 체

```cpp
class SegmentedSieve {
public:
    // 구간 [L, R]의 소수들 찾기
    static vector<long long> segmentedSieve(long long L, long long R) {
        // √R까지의 소수들 먼저 구하기
        long long sqrtR = sqrt(R) + 1;
        SieveOfEratosthenes baseSieve(sqrtR);
        const vector<int>& basePrimes = baseSieve.getPrimes();
        
        // 구간 [L, R]을 위한 배열
        vector<bool> isPrime(R - L + 1, true);
        
        // 기본 소수들로 구간의 합성수들 제거
        for (int p : basePrimes) {
            long long start = max(p * p, (L + p - 1) / p * p);
            
            for (long long j = start; j <= R; j += p) {
                isPrime[j - L] = false;
            }
        }
        
        // 1은 소수가 아님
        if (L == 1) isPrime[0] = false;
        
        // 결과 수집
        vector<long long> primes;
        for (long long i = L; i <= R; i++) {
            if (isPrime[i - L]) {
                primes.push_back(i);
            }
        }
        
        return primes;
    }
};
```

### 2. 빠른 거듭제곱

```cpp
class FastExponentiation {
public:
    // a^b mod m 계산
    static long long modPow(long long a, long long b, long long m) {
        long long result = 1;
        a %= m;
        
        while (b > 0) {
            if (b & 1) {
                result = (__int128)result * a % m;
            }
            a = (__int128)a * a % m;
            b >>= 1;
        }
        
        return result;
    }
    
    // 행렬 거듭제곱 (피보나치 등에 활용)
    static vector<vector<long long>> matrixPow(vector<vector<long long>> A, long long n, long long mod) {
        int size = A.size();
        vector<vector<long long>> result(size, vector<long long>(size, 0));
        
        // 단위 행렬로 초기화
        for (int i = 0; i < size; i++) {
            result[i][i] = 1;
        }
        
        while (n > 0) {
            if (n & 1) {
                result = multiplyMatrix(result, A, mod);
            }
            A = multiplyMatrix(A, A, mod);
            n >>= 1;
        }
        
        return result;
    }
    
private:
    static vector<vector<long long>> multiplyMatrix(const vector<vector<long long>>& A, 
                                                  const vector<vector<long long>>& B, 
                                                  long long mod) {
        int n = A.size();
        vector<vector<long long>> C(n, vector<long long>(n, 0));
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod;
                }
            }
        }
        
        return C;
    }
};
```

## 주의사항과 팁

### 1. 오버플로우 방지
```cpp
// 안전한 곱셈 (오버플로우 체크)
bool safeMul(long long a, long long b, long long& result) {
    if (a == 0 || b == 0) {
        result = 0;
        return true;
    }
    
    if (a > LLONG_MAX / b) return false;  // 오버플로우
    
    result = a * b;
    return true;
}
```

### 2. 성능 최적화
```cpp
// 컴파일 타임 소수 생성 (C++14 이상)
constexpr bool isPrimeConstexpr(int n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    
    return true;
}
```

### 3. 디버깅 도구
```cpp
void debugPrimeFactors(long long n) {
    cout << n << " = ";
    auto factors = Factorization::factorizeSimple(n);
    
    bool first = true;
    for (const auto& factor : factors) {
        if (!first) cout << " × ";
        
        if (factor.second == 1) {
            cout << factor.first;
        } else {
            cout << factor.first << "^" << factor.second;
        }
        
        first = false;
    }
    cout << endl;
}
```

## 연관 알고리즘
- **[modular arithmetic](/post/algorithms/modular-arithmetic)**: 모듈러 연산
- **[number theory](/post/algorithms/number-theory)**: 수론 심화
- **[cryptography](/post/algorithms/cryptography)**: 암호화 응용

## 마무리

소수와 소인수분해는 수학적 계산과 암호학의 기초가 되는 중요한 알고리즘입니다. 단순한 방법부터 고급 확률적 알고리즘까지 다양한 접근법을 상황에 맞게 선택하여 사용하세요.

**학습 순서**: 기본 소수 판별 → 에라토스테네스의 체 → 밀러-라빈 테스트 → 소인수분해 → 수론 함수
```

### proxmox-qdevice-voting-problem-guide.md

**Path:** `frontend/public/posts/2024/proxmox-qdevice-voting-problem-guide.md`

```markdown
---
title: Proxmox QDevice 투표 문제에 대해서
excerpt: Proxmox 클러스터에서 QDevice가 투표권을 갖지 못하는 문제 트러블슈팅
date: '2025-08-10'
category: Proxmox
tags:
  - Proxmox
  - QDevice
  - 클러스터
  - 쿼럼
  - Raspberry Pi
  - 고가용성
readTime: 3분
---
Proxmox 클러스터에서 QDevice가 "votes 0"으로 표시되는 문제를 해결하려면 다음 단계를 따르십시오. 이 가이드는 단일 노드 클러스터(nodove, 192.168.1.30)와 Raspberry Pi(192.168.1.55)를 기반으로 합니다. 네트워크 연결이 정상이라고 가정합니다.

## QDevice 역할

QDevice는 2노드 클러스터에서 타이 브레이커로 작동합니다. 정상 상태에서 노드 2개 + QDevice 1개 = 총 3표. 한 노드가 다운되면 남은 노드 1표 + QDevice 1표 = 2표로 과반수를 유지합니다. votes가 0이면 장애 시 클러스터가 정지할 수 있습니다.

## 1. Raspberry Pi에서 서비스 확인

Raspberry Pi에서 실행:

```
sudo systemctl status corosync-qnetd
```

로그 확인:

```
sudo journalctl -u corosync-qnetd -f
```

포트 확인:

```
sudo netstat -tlnp | grep :5403
```

## 2. 기존 QDevice 제거

Proxmox 노드에서:

```
pvecm qdevice remove
```

Raspberry Pi에서 패키지 재설치:

```
sudo apt update
sudo apt reinstall corosync-qnetd
```

SSH 설정(/etc/ssh/sshd_config) 확인 및 수정:

- PermitRootLogin yes
- PasswordAuthentication yes (필요 시)

서비스 재시작:

```
sudo systemctl restart ssh
sudo systemctl restart corosync-qnetd
sudo systemctl enable corosync-qnetd
sudo systemctl status corosync-qnetd
```

## 3. Proxmox에서 QDevice 재설정

Proxmox 노드에서 패키지 설치:

```
apt update
apt install corosync-qdevice
systemctl enable corosync-qdevice
```

QDevice 추가:

```
pvecm qdevice setup 192.168.1.55 -f
```

## 4. 설정 파일 수정

Proxmox 노드에서 /etc/pve/corosync.conf 편집:

```
logging {
  debug: off
  to_syslog: yes
}

nodelist {
  node {
    name: nodove
    nodeid: 1
    quorum_votes: 1
    ring0_addr: 192.168.1.30
  }
}

quorum {
  provider: corosync_votequorum
  device {
    model: net
    net {
      algorithm: ffsplit
      host: 192.168.1.55
      tls: on
    }
    votes: 1
  }
}

totem {
  cluster_name: nodove
  config_version: 3
  interface {
    linknumber: 0
    ringnumber: 0
  }
  ip_version: ipv4
  secauth: on
  version: 2
}
```

주요 설정: votes: 1, tls: on, algorithm: ffsplit.

## 5. 서비스 재시작 및 확인

Proxmox 노드에서:

```
systemctl restart corosync
sleep 5
systemctl restart corosync-qdevice
sleep 5
systemctl restart pve-cluster
```

상태 확인:

```
pvecm status
pvecm qdevice status
corosync-quorumtool -s
```

정상 출력 예시:

- Nodes: 1
- Total votes: 2
- Qdevice (votes 1)

## 추가 문제 해결

### 네트워크 확인

Proxmox에서:

```
iptables -L | grep 5403
```

Raspberry Pi에서:

```
sudo ufw status
sudo iptables -L | grep 5403
sudo ufw allow 5403/tcp
sudo ufw allow 5403/udp
```

### 인증서 재생성

Proxmox에서:

```
pvecm qdevice remove
rm -rf /etc/corosync/qdevice/
pvecm qdevice setup 192.168.1.55 -f
```

### 로그 모니터링

Proxmox에서:

```
tail -f /var/log/corosync/corosync.log
```

Raspberry Pi에서:

```
sudo tail -f /var/log/syslog | grep qnetd
```

## 예방 조치

정기 점검 스크립트(qdevice_check.sh):

```
#!/bin/bash
STATUS=$(pvecm status | grep "Qdevice" | awk '{print $3}')
if [[ "$STATUS" == "1)" ]]; then
    echo "QDevice is working properly"
else
    echo "QDevice problem detected!" | mail -s "Proxmox QDevice Alert" admin@example.com
    logger "Proxmox QDevice has 0 votes - investigation needed"
fi
```

백업:

```
cp /etc/pve/corosync.conf /root/backup/corosync.conf.$(date +%Y%m%d)
cp -r /etc/corosync/qdevice/ /root/backup/qdevice.$(date +%Y%m%d)/
```

설정 후 장애 시뮬레이션을 통해 동작 확인 권장.

```

### queue.md

**Path:** `frontend/public/posts/2024/queue.md`

```markdown
---
title: "큐(Queue) 완전 정복"
date: "2024-10-22"
category: "Algorithm"
tags: ['큐', '자료구조', 'FIFO', 'BFS', '알고리즘']
excerpt: "FIFO 구조의 큐 자료구조 개념부터 우선순위 큐까지 완벽 가이드"
readTime: "9분"
---

# 🚶‍♂️ 큐(Queue) 완전 정복

##  핵심 개념

큐는 **FIFO(First In, First Out)** 원리를 따르는 선형 자료구조입니다. 먼저 들어간 데이터가 가장 먼저 나오는 구조로, 마치 줄을 서서 기다리는 것과 같은 개념입니다.

### 주요 특징
- **FIFO 구조**: 선입선출
- **양쪽 끝에서 연산**: Front에서 삭제, Rear에서 삽입
- **BFS의 핵심**: 그래프 탐색에서 필수적

##  시간복잡도

| 연산 | 시간복잡도 | 설명 |
|------|------------|------|
| enqueue() | O(1) | 큐의 뒤쪽에 원소 추가 |
| dequeue() | O(1) | 큐의 앞쪽에서 원소 제거 및 반환 |
| front() | O(1) | 큐의 앞쪽 원소 확인 |
| rear() | O(1) | 큐의 뒤쪽 원소 확인 |
| empty() | O(1) | 큐가 비어있는지 확인 |
| size() | O(1) | 큐의 크기 반환 |

##  완전한 구현 코드

### 1. 리스트를 이용한 기본 구현
```python
class Queue:
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):
        """큐에 원소 추가 (뒤쪽에 삽입)"""
        self.items.append(item)
    
    def dequeue(self):
        """큐에서 원소 제거 및 반환 (앞쪽에서 제거)"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items.pop(0)  # O(n) 시간복잡도 주의!
    
    def front(self):
        """큐의 앞쪽 원소 확인"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items[0]
    
    def rear(self):
        """큐의 뒤쪽 원소 확인"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items[-1]
    
    def is_empty(self):
        """큐가 비어있는지 확인"""
        return len(self.items) == 0
    
    def size(self):
        """큐 크기 반환"""
        return len(self.items)
    
    def __str__(self):
        return f"Queue({self.items})"

# 사용 예제
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
print(queue)  # Queue([1, 2, 3])
print(queue.dequeue())  # 1
print(queue)  # Queue([2, 3])
```

### 2. collections.deque를 이용한 최적화된 구현
```python
from collections import deque

class OptimizedQueue:
    def __init__(self):
        self.items = deque()
    
    def enqueue(self, item):
        """O(1) 시간에 원소 추가"""
        self.items.append(item)
    
    def dequeue(self):
        """O(1) 시간에 원소 제거"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items.popleft()
    
    def front(self):
        """큐의 앞쪽 원소 확인"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items[0]
    
    def rear(self):
        """큐의 뒤쪽 원소 확인"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items[-1]
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)
    
    def __str__(self):
        return f"Queue({list(self.items)})"

# 성능 비교 예제
import time

def performance_test():
    # 기본 리스트 큐
    basic_queue = Queue()
    start_time = time.time()
    for i in range(10000):
        basic_queue.enqueue(i)
        if i % 2 == 1:
            basic_queue.dequeue()
    basic_time = time.time() - start_time
    
    # 최적화된 큐
    opt_queue = OptimizedQueue()
    start_time = time.time()
    for i in range(10000):
        opt_queue.enqueue(i)
        if i % 2 == 1:
            opt_queue.dequeue()
    opt_time = time.time() - start_time
    
    print(f"Basic Queue: {basic_time:.4f}s")
    print(f"Optimized Queue: {opt_time:.4f}s")
    print(f"Speedup: {basic_time/opt_time:.2f}x")

performance_test()
```

### 3. 연결 리스트를 이용한 구현
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedQueue:
    def __init__(self):
        self.front_node = None
        self.rear_node = None
        self._size = 0
    
    def enqueue(self, data):
        """큐에 원소 추가"""
        new_node = Node(data)
        
        if self.rear_node is None:  # 큐가 비어있는 경우
            self.front_node = self.rear_node = new_node
        else:
            self.rear_node.next = new_node
            self.rear_node = new_node
        
        self._size += 1
    
    def dequeue(self):
        """큐에서 원소 제거"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        
        data = self.front_node.data
        self.front_node = self.front_node.next
        
        if self.front_node is None:  # 큐가 비게 된 경우
            self.rear_node = None
        
        self._size -= 1
        return data
    
    def front(self):
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.front_node.data
    
    def rear(self):
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.rear_node.data
    
    def is_empty(self):
        return self.front_node is None
    
    def size(self):
        return self._size
    
    def display(self):
        """큐 내용 출력"""
        result = []
        current = self.front_node
        while current:
            result.append(current.data)
            current = current.next
        return result

# 사용 예제
linked_queue = LinkedQueue()
for i in range(5):
    linked_queue.enqueue(i)
print(f"Queue: {linked_queue.display()}")  # [0, 1, 2, 3, 4]

while not linked_queue.is_empty():
    print(f"Dequeued: {linked_queue.dequeue()}")
```

### 4. 원형 큐(Circular Queue) 구현
```python
class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front_idx = 0
        self.rear_idx = -1
        self._size = 0
    
    def enqueue(self, item):
        """원형 큐에 원소 추가"""
        if self.is_full():
            raise OverflowError("Queue is full")
        
        self.rear_idx = (self.rear_idx + 1) % self.capacity
        self.queue[self.rear_idx] = item
        self._size += 1
    
    def dequeue(self):
        """원형 큐에서 원소 제거"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        
        item = self.queue[self.front_idx]
        self.queue[self.front_idx] = None
        self.front_idx = (self.front_idx + 1) % self.capacity
        self._size -= 1
        return item
    
    def front(self):
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.queue[self.front_idx]
    
    def rear(self):
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.queue[self.rear_idx]
    
    def is_empty(self):
        return self._size == 0
    
    def is_full(self):
        return self._size == self.capacity
    
    def size(self):
        return self._size
    
    def display(self):
        """큐 내용 출력 (순서대로)"""
        if self.is_empty():
            return []
        
        result = []
        idx = self.front_idx
        for _ in range(self._size):
            result.append(self.queue[idx])
            idx = (idx + 1) % self.capacity
        return result

# 원형 큐 테스트
circular_queue = CircularQueue(5)
for i in range(5):
    circular_queue.enqueue(i)

print(f"Full queue: {circular_queue.display()}")  # [0, 1, 2, 3, 4]

# 몇 개 제거 후 다시 추가
circular_queue.dequeue()
circular_queue.dequeue()
circular_queue.enqueue(5)
circular_queue.enqueue(6)

print(f"After operations: {circular_queue.display()}")  # [2, 3, 4, 5, 6]
```

##  최적화 팁

### 1. 우선순위 큐 구현
```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []
        self.entry_count = 0
    
    def enqueue(self, item, priority):
        """우선순위와 함께 원소 추가"""
        # (우선순위, 순서, 데이터) 튜플로 저장
        entry = (priority, self.entry_count, item)
        heapq.heappush(self.heap, entry)
        self.entry_count += 1
    
    def dequeue(self):
        """우선순위가 가장 높은 원소 제거"""
        if self.is_empty():
            raise IndexError("Priority queue is empty")
        priority, count, item = heapq.heappop(self.heap)
        return item
    
    def front(self):
        """우선순위가 가장 높은 원소 확인"""
        if self.is_empty():
            raise IndexError("Priority queue is empty")
        return self.heap[0][2]
    
    def is_empty(self):
        return len(self.heap) == 0
    
    def size(self):
        return len(self.heap)

# 우선순위 큐 사용 예제
pq = PriorityQueue()
pq.enqueue("Low priority task", 3)
pq.enqueue("High priority task", 1)
pq.enqueue("Medium priority task", 2)

while not pq.is_empty():
    print(pq.dequeue())
# 출력: High priority task, Medium priority task, Low priority task
```

### 2. 멀티스레드 안전 큐
```python
import threading
from queue import Queue as ThreadSafeQueue

class ThreadSafeQueueWrapper:
    def __init__(self):
        self.queue = ThreadSafeQueue()
    
    def enqueue(self, item):
        self.queue.put(item)
    
    def dequeue(self, timeout=None):
        """timeout 시간 내에 데이터가 없으면 예외 발생"""
        try:
            return self.queue.get(timeout=timeout)
        except:
            raise IndexError("Queue is empty or timeout")
    
    def is_empty(self):
        return self.queue.empty()
    
    def size(self):
        return self.queue.qsize()

# 멀티스레드 환경에서 안전한 큐 사용
def producer(queue, name, count):
    for i in range(count):
        queue.enqueue(f"{name}-{i}")
        print(f"Produced: {name}-{i}")

def consumer(queue, name, count):
    for _ in range(count):
        try:
            item = queue.dequeue(timeout=1)
            print(f"Consumed by {name}: {item}")
        except IndexError:
            print(f"{name}: Queue is empty or timeout")

# 스레드 안전 큐 테스트
safe_queue = ThreadSafeQueueWrapper()

producer_thread = threading.Thread(target=producer, args=(safe_queue, "Producer1", 5))
consumer_thread = threading.Thread(target=consumer, args=(safe_queue, "Consumer1", 5))

producer_thread.start()
consumer_thread.start()

producer_thread.join()
consumer_thread.join()
```

##  실전 예제

### 1. BFS (너비 우선 탐색)
```python
from collections import deque

def bfs(graph, start):
    """그래프에서 BFS 수행"""
    visited = set()
    queue = deque([start])
    visited.add(start)
    result = []
    
    while queue:
        vertex = queue.popleft()
        result.append(vertex)
        
        # 인접한 정점들을 큐에 추가
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return result

# 그래프 예제
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

print(f"BFS traversal: {bfs(graph, 'A')}")  # ['A', 'B', 'C', 'D', 'E', 'F']
```

### 2. 미로 탐색 (최단 경로)
```python
from collections import deque

def solve_maze(maze, start, end):
    """미로에서 최단 경로 찾기"""
    rows, cols = len(maze), len(maze[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 우, 하, 좌, 상
    
    queue = deque([(start[0], start[1], 0)])  # (x, y, distance)
    visited = set([start])
    
    while queue:
        x, y, dist = queue.popleft()
        
        if (x, y) == end:
            return dist
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if (0 <= nx < rows and 0 <= ny < cols and 
                maze[nx][ny] == 0 and (nx, ny) not in visited):
                visited.add((nx, ny))
                queue.append((nx, ny, dist + 1))
    
    return -1  # 경로가 없는 경우

# 미로 예제 (0: 길, 1: 벽)
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
]

start = (0, 0)
end = (4, 4)
distance = solve_maze(maze, start, end)
print(f"Shortest path distance: {distance}")  # 8
```

### 3. 프로세스 스케줄링 시뮬레이션
```python
from collections import deque

class Process:
    def __init__(self, pid, burst_time, arrival_time=0):
        self.pid = pid
        self.burst_time = burst_time
        self.arrival_time = arrival_time
        self.remaining_time = burst_time
        self.completion_time = 0
        self.waiting_time = 0
        self.turnaround_time = 0

def round_robin_scheduling(processes, quantum):
    """라운드 로빈 스케줄링 시뮬레이션"""
    queue = deque()
    current_time = 0
    completed = []
    
    # 프로세스들을 도착 시간 순으로 정렬
    processes.sort(key=lambda p: p.arrival_time)
    process_index = 0
    
    while process_index < len(processes) or queue:
        # 현재 시간에 도착한 프로세스들을 큐에 추가
        while (process_index < len(processes) and 
               processes[process_index].arrival_time <= current_time):
            queue.append(processes[process_index])
            process_index += 1
        
        if queue:
            current_process = queue.popleft()
            
            # 실행 시간 계산
            execution_time = min(quantum, current_process.remaining_time)
            current_time += execution_time
            current_process.remaining_time -= execution_time
            
            print(f"Time {current_time - execution_time}-{current_time}: "
                  f"Process {current_process.pid} executed")
            
            # 새로 도착한 프로세스들을 큐에 추가
            while (process_index < len(processes) and 
                   processes[process_index].arrival_time <= current_time):
                queue.append(processes[process_index])
                process_index += 1
            
            # 프로세스가 완료되지 않았으면 다시 큐에 추가
            if current_process.remaining_time > 0:
                queue.append(current_process)
            else:
                # 프로세스 완료
                current_process.completion_time = current_time
                current_process.turnaround_time = (
                    current_process.completion_time - current_process.arrival_time
                )
                current_process.waiting_time = (
                    current_process.turnaround_time - current_process.burst_time
                )
                completed.append(current_process)
        else:
            current_time += 1
    
    # 결과 출력
    print("\nProcess scheduling results:")
    print("PID\tBurst\tArrival\tCompletion\tTurnaround\tWaiting")
    for p in completed:
        print(f"{p.pid}\t{p.burst_time}\t{p.arrival_time}\t"
              f"{p.completion_time}\t\t{p.turnaround_time}\t\t{p.waiting_time}")

# 라운드 로빈 스케줄링 테스트
processes = [
    Process(1, 5, 0),
    Process(2, 3, 1),
    Process(3, 8, 2),
    Process(4, 6, 3)
]

round_robin_scheduling(processes, 2)
```

### 4. 큐를 이용한 이진 트리 레벨 순회
```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def level_order_traversal(root):
    """이진 트리 레벨 순회"""
    if not root:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result

# 이진 트리 예제
#       3
#      / \
#     9   20
#        /  \
#       15   7

root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

levels = level_order_traversal(root)
print("Level order traversal:")
for i, level in enumerate(levels):
    print(f"Level {i}: {level}")
# Output:
# Level 0: [3]
# Level 1: [9, 20]
# Level 2: [15, 7]
```

##  큐의 다양한 응용

### 1. 슬라이딩 윈도우 최댓값
```python
from collections import deque

def sliding_window_maximum(nums, k):
    """슬라이딩 윈도우에서 최댓값 찾기"""
    if not nums or k == 0:
        return []
    
    dq = deque()  # 인덱스를 저장하는 덱
    result = []
    
    for i in range(len(nums)):
        # 윈도우 범위를 벗어난 인덱스 제거
        while dq and dq[0] <= i - k:
            dq.popleft()
        
        # 현재 원소보다 작은 원소들의 인덱스 제거
        while dq and nums[dq[-1]] <= nums[i]:
            dq.pop()
        
        dq.append(i)
        
        # 윈도우가 완성되면 결과에 추가
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result

# 테스트
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
result = sliding_window_maximum(nums, k)
print(f"Sliding window maximum: {result}")  # [3, 3, 5, 5, 6, 7]
```

### 2. 큐를 이용한 캐시 구현 (LRU Cache)
```python
from collections import deque

class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # key -> value 매핑
        self.queue = deque()  # 사용 순서 추적
    
    def get(self, key):
        """캐시에서 값 조회"""
        if key in self.cache:
            # 최근 사용으로 업데이트
            self.queue.remove(key)
            self.queue.append(key)
            return self.cache[key]
        return -1
    
    def put(self, key, value):
        """캐시에 값 저장"""
        if key in self.cache:
            # 기존 키 업데이트
            self.cache[key] = value
            self.queue.remove(key)
            self.queue.append(key)
        else:
            # 새로운 키 추가
            if len(self.cache) >= self.capacity:
                # 가장 오래된 항목 제거
                oldest = self.queue.popleft()
                del self.cache[oldest]
            
            self.cache[key] = value
            self.queue.append(key)
    
    def display(self):
        """현재 캐시 상태 출력"""
        return [(key, self.cache[key]) for key in self.queue]

# LRU 캐시 테스트
lru = LRUCache(3)
lru.put(1, "A")
lru.put(2, "B")
lru.put(3, "C")
print(f"Cache: {lru.display()}")  # [(1, 'A'), (2, 'B'), (3, 'C')]

lru.get(1)  # A를 최근 사용으로 이동
lru.put(4, "D")  # B가 제거되고 D 추가
print(f"Cache: {lru.display()}")  # [(3, 'C'), (1, 'A'), (4, 'D')]
```

## 🎖️ 레벨별 연습 문제

### 🥉 초급
- BOJ 10845: 큐
- BOJ 2164: 카드2
- BOJ 1158: 요세푸스 문제

### 🥈 중급
- BOJ 2178: 미로 탐색
- BOJ 7576: 토마토
- BOJ 1966: 프린터 큐

### 🥇 고급
- BOJ 5430: AC
- BOJ 13913: 숨바꼭질 4
- BOJ 11003: 최솟값 찾기

---

**이전 학습**: [스택(Stack) 완전 정복](../stack/) ⬅️
**다음 학습**: [덱(Deque) 완전 정복](../deque/) 

큐는 **BFS, 레벨 순회, 스케줄링** 등에서 핵심적인 역할을 하는 자료구조입니다. 특히 그래프 알고리즘에서는 필수입니다!
```

### quick-sort.md

**Path:** `frontend/public/posts/2024/quick-sort.md`

```markdown
---
title: "퀵 정렬(Quick Sort) 완전 정복"
date: "2024-10-27"
category: "Algorithm"
tags: ['퀵정렬', '정렬', '분할정복', '알고리즘']
excerpt: "분할 정복을 이용한 최고 성능의 정렬 알고리즘, 퀵 정렬의 모든 것"
readTime: "9분"
---

#  퀵 정렬(Quick Sort) 완전 정복

##  핵심 개념

퀵 정렬은 **분할 정복(Divide and Conquer)** 기법을 사용하는 정렬 알고리즘으로, **평균적으로 가장 빠른 성능**을 보여주는 정렬 방법입니다. 피벗(Pivot)을 선택하여 배열을 분할하고, 각 부분을 재귀적으로 정렬하는 방식입니다.

### 알고리즘 동작 과정
1. **피벗 선택**: 배열에서 하나의 원소를 피벗으로 선택
2. **분할(Partition)**: 피벗보다 작은 원소들은 왼쪽, 큰 원소들은 오른쪽으로 배치
3. **재귀 호출**: 왼쪽과 오른쪽 부분배열을 각각 퀵 정렬로 정렬
4. **결합**: 분할된 배열들이 이미 정렬되어 있으므로 추가 작업 불필요

##  시간복잡도

| 케이스 | 시간복잡도 | 설명 |
|--------|------------|------|
| **최선** | O(n log n) | 피벗이 항상 중앙값인 경우 |
| **평균** | O(n log n) | 일반적인 경우 |
| **최악** | O(n²) | 피벗이 항상 최솟값 또는 최댓값인 경우 |
| **공간복잡도** | O(log n) | 재귀 호출 스택 |

##  완전한 구현 코드

### 1. 기본 퀘 정렬 (호어 분할)
```python
def quicksort_hoare(arr, low, high):
    """호어 분할 방식의 퀵 정렬"""
    if low < high:
        # 분할 수행
        pivot_index = hoare_partition(arr, low, high)
        
        # 피벗을 기준으로 좌우 부분배열 재귀 정렬
        quicksort_hoare(arr, low, pivot_index)
        quicksort_hoare(arr, pivot_index + 1, high)

def hoare_partition(arr, low, high):
    """호어 분할 방식"""
    pivot = arr[low]  # 첫 번째 원소를 피벗으로 선택
    i = low - 1
    j = high + 1
    
    while True:
        # 피벗보다 큰 원소를 왼쪽에서 찾기
        i += 1
        while i < high and arr[i] < pivot:
            i += 1
        
        # 피벗보다 작은 원소를 오른쪽에서 찾기
        j -= 1
        while j > low and arr[j] > pivot:
            j -= 1
        
        # 교차되면 분할 완료
        if i >= j:
            return j
        
        # 원소 교환
        arr[i], arr[j] = arr[j], arr[i]

# 사용 예제
def quicksort(arr):
    """퀵 정렬 메인 함수"""
    if len(arr) <= 1:
        return arr
    
    arr_copy = arr.copy()
    quicksort_hoare(arr_copy, 0, len(arr_copy) - 1)
    return arr_copy

# 테스트
test_array = [64, 34, 25, 12, 22, 11, 90]
print(f"Original: {test_array}")
sorted_array = quicksort(test_array)
print(f"Sorted: {sorted_array}")
```

### 2. 로무토 분할 방식
```python
def quicksort_lomuto(arr, low, high):
    """로무토 분할 방식의 퀵 정렬"""
    if low < high:
        # 분할 수행
        pivot_index = lomuto_partition(arr, low, high)
        
        # 피벗을 기준으로 좌우 부분배열 재귀 정렬
        quicksort_lomuto(arr, low, pivot_index - 1)
        quicksort_lomuto(arr, pivot_index + 1, high)

def lomuto_partition(arr, low, high):
    """로무토 분할 방식 (이해하기 쉬운 방식)"""
    pivot = arr[high]  # 마지막 원소를 피벗으로 선택
    i = low - 1  # 작은 원소들의 끝 인덱스
    
    for j in range(low, high):
        # 현재 원소가 피벗보다 작거나 같으면
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    # 피벗을 올바른 위치에 배치
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# 시각화를 위한 상세한 구현
def quicksort_detailed(arr, low, high, depth=0):
    """과정을 출력하는 퀵 정렬"""
    indent = "  " * depth
    print(f"{indent}Sorting {arr[low:high+1]} (indices {low}-{high})")
    
    if low < high:
        pivot_index = lomuto_partition_detailed(arr, low, high, depth)
        print(f"{indent}Pivot: {arr[pivot_index]} at index {pivot_index}")
        print(f"{indent}After partition: {arr[low:high+1]}")
        
        # 좌측 부분배열 정렬
        if pivot_index - 1 > low:
            print(f"{indent}Left subarray:")
            quicksort_detailed(arr, low, pivot_index - 1, depth + 1)
        
        # 우측 부분배열 정렬
        if pivot_index + 1 < high:
            print(f"{indent}Right subarray:")
            quicksort_detailed(arr, pivot_index + 1, high, depth + 1)

def lomuto_partition_detailed(arr, low, high, depth):
    """상세한 과정을 출력하는 로무토 분할"""
    indent = "  " * depth
    pivot = arr[high]
    print(f"{indent}Pivot chosen: {pivot}")
    
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            if i != j:
                arr[i], arr[j] = arr[j], arr[i]
                print(f"{indent}Swap {arr[j]} and {arr[i]}: {arr[low:high+1]}")
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# 상세한 과정 확인
print("=== Detailed Quick Sort Process ===")
detailed_array = [64, 34, 25, 12, 22, 11, 90]
print(f"Original: {detailed_array}")
quicksort_detailed(detailed_array, 0, len(detailed_array) - 1)
print(f"Final result: {detailed_array}")
```

### 3. 3-Way 퀵 정렬 (중복 원소 최적화)
```python
def quicksort_3way(arr, low, high):
    """3-way 퀵 정렬 (중복 원소가 많을 때 효율적)"""
    if low >= high:
        return
    
    # 3-way partition 수행
    lt, gt = partition_3way(arr, low, high)
    
    # 3개 구간으로 나누어 재귀 호출
    quicksort_3way(arr, low, lt - 1)    # arr[low...lt-1] < pivot
    # arr[lt...gt] == pivot (정렬 완료)
    quicksort_3way(arr, gt + 1, high)   # arr[gt+1...high] > pivot

def partition_3way(arr, low, high):
    """3-way 분할: <pivot, ==pivot, >pivot"""
    pivot = arr[low]
    lt = low      # arr[low...lt-1] < pivot
    i = low + 1   # arr[lt...i-1] == pivot
    gt = high     # arr[gt+1...high] > pivot
    
    while i <= gt:
        if arr[i] < pivot:
            arr[lt], arr[i] = arr[i], arr[lt]
            lt += 1
            i += 1
        elif arr[i] > pivot:
            arr[i], arr[gt] = arr[gt], arr[i]
            gt -= 1
            # i는 증가시키지 않음 (교환된 원소 확인 필요)
        else:  # arr[i] == pivot
            i += 1
    
    return lt, gt

# 중복이 많은 배열 테스트
duplicate_array = [3, 7, 3, 3, 5, 7, 3, 5, 5, 5, 3]
print(f"Original (with duplicates): {duplicate_array}")
quicksort_3way(duplicate_array, 0, len(duplicate_array) - 1)
print(f"Sorted: {duplicate_array}")
```

### 4. 반복적(Iterative) 퀵 정렬
```python
def quicksort_iterative(arr):
    """반복문을 사용한 퀵 정렬 (스택 오버플로우 방지)"""
    if len(arr) <= 1:
        return arr
    
    arr = arr.copy()
    stack = [(0, len(arr) - 1)]
    
    while stack:
        low, high = stack.pop()
        
        if low < high:
            pivot_index = lomuto_partition(arr, low, high)
            
            # 더 작은 부분배열을 먼저 스택에 푸시 (메모리 최적화)
            if pivot_index - low < high - pivot_index:
                stack.append((pivot_index + 1, high))
                stack.append((low, pivot_index - 1))
            else:
                stack.append((low, pivot_index - 1))
                stack.append((pivot_index + 1, high))
    
    return arr

# 반복적 퀵 정렬 테스트
iterative_array = [64, 34, 25, 12, 22, 11, 90]
print(f"Iterative Quick Sort: {quicksort_iterative(iterative_array)}")
```

##  최적화 기법

### 1. 피벗 선택 최적화
```python
import random

def median_of_three(arr, low, high):
    """세 원소의 중간값을 피벗으로 선택"""
    mid = (low + high) // 2
    
    # 세 원소를 정렬하여 중간값을 arr[mid]에 배치
    if arr[mid] < arr[low]:
        arr[low], arr[mid] = arr[mid], arr[low]
    if arr[high] < arr[low]:
        arr[low], arr[high] = arr[high], arr[low]
    if arr[high] < arr[mid]:
        arr[mid], arr[high] = arr[high], arr[mid]
    
    # 중간값을 끝으로 이동
    arr[mid], arr[high] = arr[high], arr[mid]
    return arr[high]

def quicksort_optimized(arr, low, high):
    """최적화된 퀵 정렬"""
    # 작은 배열은 삽입 정렬 사용
    if high - low + 1 < 10:
        insertion_sort_range(arr, low, high)
        return
    
    if low < high:
        # 최적화된 피벗 선택
        pivot = median_of_three(arr, low, high)
        pivot_index = lomuto_partition(arr, low, high)
        
        # 꼬리 재귀 최적화
        while low < high:
            pivot_index = lomuto_partition(arr, low, high)
            
            # 더 작은 부분을 재귀로, 큰 부분을 반복으로
            if pivot_index - low < high - pivot_index:
                quicksort_optimized(arr, low, pivot_index - 1)
                low = pivot_index + 1
            else:
                quicksort_optimized(arr, pivot_index + 1, high)
                high = pivot_index - 1

def insertion_sort_range(arr, low, high):
    """특정 범위에 대한 삽입 정렬"""
    for i in range(low + 1, high + 1):
        key = arr[i]
        j = i - 1
        
        while j >= low and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key

# 랜덤 피벗 선택
def randomized_quicksort(arr, low, high):
    """랜덤 피벗을 사용한 퀵 정렬"""
    if low < high:
        # 랜덤 인덱스 선택하여 마지막과 교환
        random_index = random.randint(low, high)
        arr[random_index], arr[high] = arr[high], arr[random_index]
        
        pivot_index = lomuto_partition(arr, low, high)
        randomized_quicksort(arr, low, pivot_index - 1)
        randomized_quicksort(arr, pivot_index + 1, high)

# 최적화된 퀵 정렬 테스트
large_array = [random.randint(1, 1000) for _ in range(100)]
print("Testing optimized quick sort on large array...")
optimized_copy = large_array.copy()
quicksort_optimized(optimized_copy, 0, len(optimized_copy) - 1)
print(f"Is sorted: {optimized_copy == sorted(large_array)}")
```

### 2. 성능 비교
```python
import time
import random

def performance_comparison():
    """다양한 퀵 정렬 구현의 성능 비교"""
    
    # 테스트 데이터 생성
    sizes = [1000, 5000, 10000]
    
    for size in sizes:
        print(f"\n=== Array size: {size} ===")
        
        # 랜덤 데이터
        random_data = [random.randint(1, size) for _ in range(size)]
        
        # 정렬된 데이터 (최악의 경우)
        sorted_data = list(range(size))
        
        # 역순 데이터
        reverse_data = list(range(size, 0, -1))
        
        test_cases = [
            ("Random", random_data),
            ("Sorted", sorted_data),
            ("Reverse", reverse_data)
        ]
        
        for case_name, data in test_cases:
            print(f"\n{case_name} data:")
            
            # 기본 퀵 정렬
            test_data = data.copy()
            start_time = time.time()
            quicksort_lomuto(test_data, 0, len(test_data) - 1)
            basic_time = time.time() - start_time
            
            # 랜덤 피벗 퀵 정렬
            test_data = data.copy()
            start_time = time.time()
            randomized_quicksort(test_data, 0, len(test_data) - 1)
            random_time = time.time() - start_time
            
            # 3-way 퀵 정렬
            test_data = data.copy()
            start_time = time.time()
            quicksort_3way(test_data, 0, len(test_data) - 1)
            threeway_time = time.time() - start_time
            
            print(f"  Basic Quick Sort: {basic_time:.4f}s")
            print(f"  Random Pivot: {random_time:.4f}s")
            print(f"  3-Way Quick Sort: {threeway_time:.4f}s")

# 성능 비교 실행 (주의: 시간이 걸릴 수 있음)
# performance_comparison()
```

##  실전 예제

### 1. K번째 큰 원소 찾기 (QuickSelect)
```python
def quickselect(arr, k):
    """K번째 큰 원소를 O(n) 평균 시간에 찾기"""
    if not arr or k < 1 or k > len(arr):
        return None
    
    return quickselect_helper(arr, 0, len(arr) - 1, len(arr) - k)

def quickselect_helper(arr, low, high, k):
    """QuickSelect 알고리즘 헬퍼 함수"""
    if low == high:
        return arr[low]
    
    # 랜덤 피벗 선택
    random_index = random.randint(low, high)
    arr[random_index], arr[high] = arr[high], arr[random_index]
    
    pivot_index = lomuto_partition(arr, low, high)
    
    if k == pivot_index:
        return arr[k]
    elif k < pivot_index:
        return quickselect_helper(arr, low, pivot_index - 1, k)
    else:
        return quickselect_helper(arr, pivot_index + 1, high, k)

# K번째 원소 찾기 테스트
test_array = [3, 6, 8, 10, 1, 2, 1]
for k in range(1, len(test_array) + 1):
    kth_largest = quickselect(test_array.copy(), k)
    print(f"{k}번째 큰 원소: {kth_largest}")

# 검증
sorted_test = sorted(test_array, reverse=True)
print(f"실제 정렬: {sorted_test}")
```

### 2. 네덜란드 국기 문제 (Dutch National Flag)
```python
def dutch_flag_sort(arr, pivot_value):
    """네덜란드 국기 문제: 피벗값 기준으로 3색 정렬"""
    low = 0
    mid = 0
    high = len(arr) - 1
    
    while mid <= high:
        if arr[mid] < pivot_value:
            arr[low], arr[mid] = arr[mid], arr[low]
            low += 1
            mid += 1
        elif arr[mid] > pivot_value:
            arr[mid], arr[high] = arr[high], arr[mid]
            high -= 1
            # mid는 증가시키지 않음
        else:  # arr[mid] == pivot_value
            mid += 1
    
    return arr

# 네덜란드 국기 문제 테스트
flag_array = [2, 0, 2, 1, 1, 0, 2, 1, 0]
print(f"Original: {flag_array}")
dutch_flag_sort(flag_array, 1)  # 1을 피벗으로
print(f"After Dutch flag sort: {flag_array}")
```

### 3. 퀵 정렬을 이용한 역순 쌍 개수 구하기
```python
def count_inversions_quicksort(arr):
    """퀵 정렬을 이용한 역순 쌍 개수 계산"""
    if len(arr) <= 1:
        return 0, arr
    
    return quicksort_count_inversions(arr, 0, len(arr) - 1)

def quicksort_count_inversions(arr, low, high):
    """역순 쌍을 세면서 퀵 정렬 수행"""
    inv_count = 0
    
    if low < high:
        pivot_index, partition_inv = partition_count_inversions(arr, low, high)
        inv_count += partition_inv
        
        left_inv, _ = quicksort_count_inversions(arr, low, pivot_index - 1)
        right_inv, _ = quicksort_count_inversions(arr, pivot_index + 1, high)
        
        inv_count += left_inv + right_inv
    
    return inv_count, arr

def partition_count_inversions(arr, low, high):
    """분할하면서 역순 쌍 개수 계산"""
    pivot = arr[high]
    i = low - 1
    inv_count = 0
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            if i != j:
                arr[i], arr[j] = arr[j], arr[i]
        else:
            # arr[j] > pivot이므로 역순 쌍 존재
            inv_count += (high - j)
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1, inv_count

# 역순 쌍 개수 계산 테스트
inversion_array = [2, 3, 8, 6, 1]
inv_count, sorted_arr = count_inversions_quicksort(inversion_array.copy())
print(f"Original: {inversion_array}")
print(f"Inversions count: {inv_count}")
print(f"Sorted: {sorted_arr}")
```

##  퀵 정렬의 장단점

### ✅ 장점
- **평균 성능 우수**: O(n log n) 평균 시간복잡도
- **In-place 정렬**: 추가 메모리 사용량이 적음 (O(log n))
- **캐시 효율성**: 지역성이 좋아 실제 성능이 우수
- **분할 정복**: 병렬화가 용이

### ❌ 단점
- **최악 시간복잡도**: O(n²) - 이미 정렬된 배열
- **불안정 정렬**: 동일한 값의 순서가 보장되지 않음
- **재귀 호출**: 깊은 재귀로 인한 스택 오버플로우 가능성

###  언제 사용하나?
- **일반적인 정렬**: 대부분의 경우에 최고 성능
- **메모리 제약**: In-place 정렬이 필요한 경우
- **K번째 원소**: QuickSelect 알고리즘
- **분할 정복 학습**: 알고리즘 교육용

## 🎖️ 레벨별 연습 문제

### 🥉 초급
- BOJ 2750: 수 정렬하기
- BOJ 2751: 수 정렬하기 2
- BOJ 10989: 수 정렬하기 3

### 🥈 중급
- BOJ 11004: K번째 수
- BOJ 1427: 소트인사이드
- LeetCode 215: Kth Largest Element

### 🥇 고급
- BOJ 1517: 버블 소트 (역순 쌍)
- LeetCode 324: Wiggle Sort II
- LeetCode 75: Sort Colors (Dutch Flag)

---

**다음 학습**: [병합 정렬(Merge Sort) 완전 정복](../merge-sort/) 

퀵 정렬은 **실전에서 가장 많이 사용되는 정렬 알고리즘**입니다. 분할 정복의 핵심 개념과 함께 완벽하게 마스터하세요!
```

### rabin-karp.md

**Path:** `frontend/public/posts/2024/rabin-karp.md`

```markdown
---
title: "라빈-카프 알고리즘 (Rabin-Karp Algorithm)"
date: "2024-11-05"
category: "Algorithm"
tags: ['Rabin-Karp', '해싱', '문자열매칭', '롤링해시']
excerpt: "라빈-카프 알고리즘을 통해 해싱을 활용한 효율적인 문자열 패턴 매칭과 롤링 해시 기법을 학습합니다."
readTime: "11분"
---

## 개요

**라빈-카프 알고리즘(Rabin-Karp Algorithm)**은 해싱을 이용하여 문자열에서 패턴을 찾는 알고리즘입니다. 롤링 해시(Rolling Hash) 기법을 사용하여 평균적으로 선형 시간에 동작합니다.

### 핵심 특징
- **해시 기반**: 문자열을 해시값으로 변환하여 비교
- **롤링 해시**: 슬라이딩 윈도우의 해시값을 효율적으로 갱신
- **다중 패턴**: 여러 패턴을 동시에 검색 가능
- **확률적 정확성**: 해시 충돌 가능성으로 인한 검증 필요

### 시간 복잡도
- **평균**: O(N + M)
- **최악**: O(NM) - 모든 해시값이 같을 때
- **공간 복잡도**: O(1)

## 기본 구현

### 1. 단순 라빈-카프 구현

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class RabinKarp {
private:
    static const int BASE = 256;    // 문자 개수 (ASCII)
    static const int MOD = 1000000007;  // 큰 소수
    
    long long computeHash(const string& str, int start, int len) {
        long long hash = 0;
        long long pow = 1;
        
        for (int i = 0; i < len; i++) {
            hash = (hash + (str[start + i] * pow) % MOD) % MOD;
            pow = (pow * BASE) % MOD;
        }
        
        return hash;
    }
    
    long long rollingHash(const string& str, int oldStart, int newStart, 
                         int len, long long oldHash, long long basePow) {
        // 이전 문자 제거
        long long newHash = (oldHash - str[oldStart] + MOD) % MOD;
        newHash = (newHash * modInverse(BASE)) % MOD;
        
        // 새 문자 추가
        newHash = (newHash + (str[newStart + len - 1] * basePow) % MOD) % MOD;
        
        return newHash;
    }
    
    // 모듈로 역원 계산 (확장 유클리드 호제법)
    long long modInverse(long long a) {
        return power(a, MOD - 2, MOD);
    }
    
    long long power(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }
    
public:
    vector<int> search(const string& text, const string& pattern) {
        vector<int> matches;
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return matches;
        
        // 패턴의 해시값 계산
        long long patternHash = computeHash(pattern, 0, m);
        
        // 첫 번째 윈도우의 해시값 계산
        long long textHash = computeHash(text, 0, m);
        
        // BASE^(m-1) 계산 (롤링 해시용)
        long long basePow = power(BASE, m - 1, MOD);
        
        // 첫 번째 위치 확인
        if (textHash == patternHash && text.substr(0, m) == pattern) {
            matches.push_back(0);
        }
        
        // 슬라이딩 윈도우로 검색
        for (int i = 1; i <= n - m; i++) {
            textHash = rollingHash(text, i - 1, i, m, textHash, basePow);
            
            if (textHash == patternHash && text.substr(i, m) == pattern) {
                matches.push_back(i);
            }
        }
        
        return matches;
    }
};
```

### 2. 개선된 롤링 해시 구현

```cpp
class ImprovedRabinKarp {
private:
    static const int BASE = 31;  // 소수 사용
    static const int MOD = 1e9 + 7;
    
    struct RollingHash {
        vector<long long> hash;
        vector<long long> basePow;
        string str;
        
        RollingHash(const string& s) : str(s) {
            int n = s.length();
            hash.resize(n + 1, 0);
            basePow.resize(n + 1, 1);
            
            // 전처리: 누적 해시와 거듭제곱 계산
            for (int i = 0; i < n; i++) {
                hash[i + 1] = (hash[i] * BASE + s[i]) % MOD;
                basePow[i + 1] = (basePow[i] * BASE) % MOD;
            }
        }
        
        // 부분 문자열 [l, r)의 해시값 반환
        long long getHash(int l, int r) {
            long long result = (hash[r] - hash[l] * basePow[r - l]) % MOD;
            return (result + MOD) % MOD;
        }
    };
    
public:
    vector<int> search(const string& text, const string& pattern) {
        if (pattern.length() > text.length()) return {};
        
        RollingHash textHash(text);
        RollingHash patternHash(pattern);
        
        vector<int> matches;
        int m = pattern.length();
        long long targetHash = patternHash.getHash(0, m);
        
        for (int i = 0; i <= (int)text.length() - m; i++) {
            if (textHash.getHash(i, i + m) == targetHash) {
                // 해시 충돌 확인을 위한 실제 문자열 비교
                if (text.substr(i, m) == pattern) {
                    matches.push_back(i);
                }
            }
        }
        
        return matches;
    }
    
    // 두 부분 문자열이 같은지 확인
    bool isEqual(const string& s1, int start1, int len1,
                 const string& s2, int start2, int len2) {
        if (len1 != len2) return false;
        
        RollingHash hash1(s1);
        RollingHash hash2(s2);
        
        return hash1.getHash(start1, start1 + len1) == 
               hash2.getHash(start2, start2 + len2);
    }
};
```

## 고급 응용

### 1. 다중 패턴 검색

```cpp
class MultiPatternRabinKarp {
private:
    static const int BASE = 31;
    static const int MOD = 1e9 + 7;
    
    struct PatternInfo {
        string pattern;
        long long hash;
        int id;
    };
    
    long long computePatternHash(const string& pattern) {
        long long hash = 0;
        long long basePow = 1;
        
        for (char c : pattern) {
            hash = (hash + c * basePow) % MOD;
            basePow = (basePow * BASE) % MOD;
        }
        
        return hash;
    }
    
public:
    vector<pair<int, int>> searchMultiple(const string& text, 
                                        const vector<string>& patterns) {
        // 패턴들을 길이별로 그룹화
        map<int, vector<PatternInfo>> patternsByLength;
        
        for (int i = 0; i < patterns.size(); i++) {
            PatternInfo info;
            info.pattern = patterns[i];
            info.hash = computePatternHash(patterns[i]);
            info.id = i;
            
            patternsByLength[patterns[i].length()].push_back(info);
        }
        
        vector<pair<int, int>> results;  // (패턴 ID, 위치)
        
        // 각 길이별로 검색 수행
        for (const auto& group : patternsByLength) {
            int len = group.first;
            const vector<PatternInfo>& patternList = group.second;
            
            if (len > text.length()) continue;
            
            // 해시 맵으로 빠른 검색
            unordered_map<long long, vector<int>> hashToPatterns;
            for (int i = 0; i < patternList.size(); i++) {
                hashToPatterns[patternList[i].hash].push_back(i);
            }
            
            // 롤링 해시로 텍스트 스캔
            ImprovedRabinKarp::RollingHash textHash(text);
            
            for (int pos = 0; pos <= (int)text.length() - len; pos++) {
                long long windowHash = textHash.getHash(pos, pos + len);
                
                if (hashToPatterns.find(windowHash) != hashToPatterns.end()) {
                    for (int patIdx : hashToPatterns[windowHash]) {
                        if (text.substr(pos, len) == patternList[patIdx].pattern) {
                            results.push_back({patternList[patIdx].id, pos});
                        }
                    }
                }
            }
        }
        
        // 위치순으로 정렬
        sort(results.begin(), results.end(), 
             [](const pair<int, int>& a, const pair<int, int>& b) {
                 return a.second < b.second;
             });
        
        return results;
    }
};
```

### 2. 문자열 해시 기반 비교

```cpp
class StringHashComparator {
private:
    static const int BASE = 31;
    static const int MOD = 1e9 + 7;
    
public:
    // 모든 부분 문자열의 해시값 전처리
    struct StringHasher {
        vector<long long> prefixHash;
        vector<long long> basePow;
        string str;
        
        StringHasher(const string& s) : str(s) {
            int n = s.length();
            prefixHash.resize(n + 1, 0);
            basePow.resize(n + 1, 1);
            
            for (int i = 0; i < n; i++) {
                prefixHash[i + 1] = (prefixHash[i] * BASE + s[i]) % MOD;
                basePow[i + 1] = (basePow[i] * BASE) % MOD;
            }
        }
        
        long long getHash(int l, int r) {  // [l, r)
            long long result = (prefixHash[r] - prefixHash[l] * basePow[r - l]) % MOD;
            return (result + MOD) % MOD;
        }
    };
    
    // 최장 공통 부분 문자열 길이
    static int longestCommonSubstring(const string& s1, const string& s2) {
        StringHasher hash1(s1);
        StringHasher hash2(s2);
        
        int maxLen = 0;
        
        // 모든 가능한 길이에 대해 이분 탐색
        int left = 0, right = min(s1.length(), s2.length());
        
        while (left <= right) {
            int mid = (left + right) / 2;
            bool found = false;
            
            // 길이 mid인 부분 문자열들의 해시값 수집
            unordered_set<long long> hashes1;
            for (int i = 0; i <= (int)s1.length() - mid; i++) {
                hashes1.insert(hash1.getHash(i, i + mid));
            }
            
            // s2에서 같은 해시값 찾기
            for (int i = 0; i <= (int)s2.length() - mid; i++) {
                if (hashes1.count(hash2.getHash(i, i + mid))) {
                    found = true;
                    break;
                }
            }
            
            if (found) {
                maxLen = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return maxLen;
    }
    
    // 회문 판별
    static bool isPalindrome(const string& s, int l, int r) {
        StringHasher hash(s);
        string rev = s;
        reverse(rev.begin(), rev.end());
        StringHasher revHash(rev);
        
        int len = r - l;
        long long frontHash = hash.getHash(l, r);
        long long backHash = revHash.getHash(s.length() - r, s.length() - l);
        
        return frontHash == backHash;
    }
};
```

### 3. 중복 부분 문자열 찾기

```cpp
class DuplicateFinder {
private:
    static const int BASE = 31;
    static const int MOD = 1e9 + 7;
    
public:
    // 길이 k인 중복 부분 문자열들 찾기
    static vector<string> findDuplicatesOfLength(const string& s, int k) {
        if (k > s.length()) return {};
        
        StringHashComparator::StringHasher hasher(s);
        unordered_map<long long, vector<int>> hashToPositions;
        
        // 모든 길이 k인 부분 문자열의 해시값과 위치 저장
        for (int i = 0; i <= (int)s.length() - k; i++) {
            long long hash = hasher.getHash(i, i + k);
            hashToPositions[hash].push_back(i);
        }
        
        // 중복되는 부분 문자열들 수집
        set<string> duplicates;
        for (const auto& entry : hashToPositions) {
            if (entry.second.size() > 1) {
                string substr = s.substr(entry.second[0], k);
                duplicates.insert(substr);
            }
        }
        
        return vector<string>(duplicates.begin(), duplicates.end());
    }
    
    // 가장 긴 중복 부분 문자열
    static string longestDuplicateSubstring(const string& s) {
        int left = 1, right = s.length();
        string result = "";
        
        while (left <= right) {
            int mid = (left + right) / 2;
            vector<string> duplicates = findDuplicatesOfLength(s, mid);
            
            if (!duplicates.empty()) {
                result = duplicates[0];  // 사전순으로 첫 번째
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    // 정확히 k번 나타나는 부분 문자열들
    static vector<string> findSubstringsWithFrequency(const string& s, int len, int freq) {
        StringHashComparator::StringHasher hasher(s);
        unordered_map<long long, int> hashCount;
        unordered_map<long long, string> hashToString;
        
        for (int i = 0; i <= (int)s.length() - len; i++) {
            long long hash = hasher.getHash(i, i + len);
            hashCount[hash]++;
            
            if (hashToString.find(hash) == hashToString.end()) {
                hashToString[hash] = s.substr(i, len);
            }
        }
        
        vector<string> result;
        for (const auto& entry : hashCount) {
            if (entry.second == freq) {
                result.push_back(hashToString[entry.first]);
            }
        }
        
        return result;
    }
};
```

## 실전 문제 해결

### 백준 예제 문제들

#### 1. 찾기 (1786)
```cpp
int main() {
    string text, pattern;
    getline(cin, text);
    getline(cin, pattern);
    
    RabinKarp rk;
    vector<int> matches = rk.search(text, pattern);
    
    cout << matches.size() << "\n";
    for (int pos : matches) {
        cout << pos + 1 << " ";  // 1-based 인덱스
    }
    cout << "\n";
    
    return 0;
}
```

#### 2. 문자열 해싱 (15829)
```cpp
int main() {
    int L;
    cin >> L;
    
    string s;
    cin >> s;
    
    const int BASE = 31;
    const int MOD = 1234567891;
    
    long long hash = 0;
    long long basePow = 1;
    
    for (int i = 0; i < L; i++) {
        int charValue = s[i] - 'a' + 1;
        hash = (hash + charValue * basePow) % MOD;
        basePow = (basePow * BASE) % MOD;
    }
    
    cout << hash << endl;
    
    return 0;
}
```

#### 3. 부분 문자열 (16916)
```cpp
int main() {
    string S, P;
    cin >> S >> P;
    
    ImprovedRabinKarp rk;
    vector<int> matches = rk.search(S, P);
    
    cout << (matches.empty() ? 0 : 1) << endl;
    
    return 0;
}
```

## 해시 충돌 처리 및 최적화

### 1. 이중 해싱

```cpp
class DoubleHashingRabinKarp {
private:
    static const int BASE1 = 31;
    static const int BASE2 = 37;
    static const int MOD1 = 1e9 + 7;
    static const int MOD2 = 1e9 + 9;
    
    struct DoubleHash {
        long long hash1, hash2;
        
        DoubleHash(long long h1 = 0, long long h2 = 0) : hash1(h1), hash2(h2) {}
        
        bool operator==(const DoubleHash& other) const {
            return hash1 == other.hash1 && hash2 == other.hash2;
        }
    };
    
    DoubleHash computeHash(const string& s, int start, int len) {
        long long h1 = 0, h2 = 0;
        long long p1 = 1, p2 = 1;
        
        for (int i = 0; i < len; i++) {
            h1 = (h1 + s[start + i] * p1) % MOD1;
            h2 = (h2 + s[start + i] * p2) % MOD2;
            p1 = (p1 * BASE1) % MOD1;
            p2 = (p2 * BASE2) % MOD2;
        }
        
        return DoubleHash(h1, h2);
    }
    
public:
    vector<int> search(const string& text, const string& pattern) {
        vector<int> matches;
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return matches;
        
        DoubleHash patternHash = computeHash(pattern, 0, m);
        
        for (int i = 0; i <= n - m; i++) {
            DoubleHash textHash = computeHash(text, i, m);
            
            if (textHash == patternHash) {
                // 이중 해시가 같으면 실제 문자열 비교 생략 가능 (확률적으로 안전)
                matches.push_back(i);
            }
        }
        
        return matches;
    }
};
```

### 2. 성능 측정 및 비교

```cpp
class PerformanceAnalyzer {
public:
    static void compareAlgorithms(const string& text, const string& pattern) {
        // 라빈-카프
        auto start = chrono::high_resolution_clock::now();
        RabinKarp rk;
        vector<int> rkResults = rk.search(text, pattern);
        auto end = chrono::high_resolution_clock::now();
        auto rkTime = chrono::duration_cast<chrono::microseconds>(end - start);
        
        // KMP (비교용)
        start = chrono::high_resolution_clock::now();
        // KMP 구현 호출 (이전 파일에서 구현됨)
        end = chrono::high_resolution_clock::now();
        auto kmpTime = chrono::duration_cast<chrono::microseconds>(end - start);
        
        // 단순 매칭
        start = chrono::high_resolution_clock::now();
        vector<int> naiveResults;
        for (int i = 0; i <= (int)text.length() - (int)pattern.length(); i++) {
            if (text.substr(i, pattern.length()) == pattern) {
                naiveResults.push_back(i);
            }
        }
        end = chrono::high_resolution_clock::now();
        auto naiveTime = chrono::duration_cast<chrono::microseconds>(end - start);
        
        cout << "성능 비교 결과:" << endl;
        cout << "Rabin-Karp: " << rkTime.count() << " μs" << endl;
        cout << "KMP: " << kmpTime.count() << " μs" << endl;
        cout << "Naive: " << naiveTime.count() << " μs" << endl;
        cout << "매치 개수: " << rkResults.size() << endl;
    }
};
```

## 주의사항과 팁

### 1. 해시 함수 선택
```cpp
// 좋은 해시 파라미터 선택
class HashParameters {
public:
    // 소수 베이스와 큰 모듈러 값 사용
    static const int GOOD_BASES[] = {31, 37, 41, 43, 47};
    static const int GOOD_MODS[] = {1000000007, 1000000009, 998244353};
    
    // 문자열 특성에 따른 베이스 선택
    static int chooseBestBase(const string& s) {
        set<char> uniqueChars(s.begin(), s.end());
        int charCount = uniqueChars.size();
        
        // 문자 종류가 많으면 큰 베이스 사용
        if (charCount > 20) return 31;
        else if (charCount > 10) return 37;
        else return 41;
    }
};
```

### 2. 오버플로우 방지
```cpp
// 안전한 모듈러 연산
long long safeMultiply(long long a, long long b, long long mod) {
    return ((a % mod) * (b % mod)) % mod;
}

long long safeAdd(long long a, long long b, long long mod) {
    return ((a % mod) + (b % mod)) % mod;
}
```

### 3. 디버깅 도구
```cpp
void debugRabinKarp(const string& text, const string& pattern) {
    cout << "=== Rabin-Karp 디버그 ===" << endl;
    cout << "텍스트: " << text << endl;
    cout << "패턴: " << pattern << endl;
    
    RabinKarp rk;
    vector<int> matches = rk.search(text, pattern);
    
    cout << "매치 결과:" << endl;
    if (matches.empty()) {
        cout << "매치 없음" << endl;
    } else {
        for (int pos : matches) {
            cout << "위치 " << pos << ": " << text.substr(pos, pattern.length()) << endl;
        }
    }
    
    // 해시값 비교
    StringHashComparator::StringHasher hasher(text);
    cout << "\n해시값 분석:" << endl;
    for (int i = 0; i <= (int)text.length() - (int)pattern.length(); i++) {
        long long hash = hasher.getHash(i, i + pattern.length());
        cout << "위치 " << i << ": " << hash << endl;
    }
}
```

## 연관 알고리즘
- **[KMP 알고리즘](/post/algorithms/kmp)**: 결정적 패턴 매칭
- **[Z-알고리즘](/post/algorithms/z-algorithm)**: 접두사 기반 매칭
- **[해시 테이블](/post/algorithms/hash-table)**: 해싱 기법 활용

## 마무리

라빈-카프 알고리즘은 해싱의 강력함을 보여주는 대표적인 예제로, 특히 다중 패턴 검색이나 대용량 텍스트 처리에서 유용합니다. 해시 충돌에 대한 이해와 적절한 해시 함수 선택이 성능의 핵심입니다.

**학습 순서**: 기본 해싱 → 롤링 해시 → 다중 패턴 → 해시 충돌 처리
```

### react-native-springboot-mongodb-diary-app.md

**Path:** `frontend/public/posts/2024/react-native-springboot-mongodb-diary-app.md`

```markdown
---
title: "React Native + Spring Boot + MongoDB로 일기 앱 만들기"
date: "2024-12-28"
category: "개발"
tags: ['React Native', 'Spring Boot', 'MongoDB', 'Python', 'AI', '일기앱']
excerpt: "React Native 클라이언트와 Spring Boot 백엔드, Python AI 서버를 연동해서 일기 앱을 만든 경험"
readTime: "6분"
---

최근에 CBT 일기 앱을 만들면서 여러 기술을 조합해봤다. React Native로 앱을 만들고, Spring Boot로 API 서버를 구축하고, Python으로 AI 분석 서버까지 연동했다. 생각보다 복잡했지만 재미있는 경험이었다.

## 전체 아키텍처

### 기술 스택
- **클라이언트**: React Native
- **인증/API 서버**: Spring Boot + MariaDB
- **AI 분석 서버**: Python (FastAPI) + OpenAI API
- **캐시**: Redis (토큰 관리)

### 왜 이런 구조로?

처음엔 단순하게 Node.js로 다 만들려고 했는데, AI 분석 부분은 Python이 훨씬 편했다. Spring Boot는 회사에서 쓰던 거라 익숙해서 선택했다.

MongoDB 대신 MariaDB를 쓴 이유는 일기 데이터가 정형化된 구조를 가지고 있어서 관계형 DB가 더 적합하다고 판단했기 때문이다.

## 주요 기능별 구현

### 1. 사용자 인증

가장 기본적인 회원가입/로그인 부터 시작했다.

**회원가입 플로우:**
```javascript
// React Native 클라이언트
const signUp = async (email, password, name) => {
  try {
    const response = await fetch(`${API_BASE}/api/users/join`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({email, password, name})
    });
    
    if (response.status === 409) {
      alert('이미 사용 중인 이메일입니다');
      return;
    }
    
    // 성공 처리
  } catch (error) {
    console.error('회원가입 실패:', error);
  }
};
```

**Spring Boot 컨트롤러:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping("/join")
    public ResponseEntity<?> join(@RequestBody SignUpRequest request) {
        // 이메일 중복 체크
        if (userService.existsByEmail(request.getEmail())) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body("이미 사용 중인 이메일");
        }
        
        // 비밀번호 암호화
        String encodedPassword = passwordEncoder.encode(request.getPassword());
        
        // 사용자 저장
        User user = User.builder()
            .email(request.getEmail())
            .password(encodedPassword)
            .name(request.getName())
            .build();
            
        userService.save(user);
        
        return ResponseEntity.status(HttpStatus.CREATED).body("회원가입 완료");
    }
}
```

### 2. JWT 토큰 관리

토큰은 Redis에 저장해서 관리했다. Access Token은 짧게, Refresh Token은 길게 설정했다.

```java
@Service
public class AuthService {
    
    public AuthResponse login(String email, String password) {
        // 사용자 인증
        User user = authenticateUser(email, password);
        
        // 토큰 생성
        String accessToken = jwtUtil.generateAccessToken(user.getEmail());
        String refreshToken = jwtUtil.generateRefreshToken(user.getEmail());
        
        // Redis에 Refresh Token 저장
        redisTemplate.opsForValue().set(
            "refresh:" + user.getEmail(), 
            refreshToken, 
            Duration.ofDays(7)
        );
        
        return AuthResponse.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .user(user)
            .build();
    }
}
```

### 3. 일기 작성과 AI 분석

가장 핵심 기능이다. 사용자가 일기를 쓰면 비동기로 AI 분석을 요청한다.

**일기 저장 API:**
```java
@PostMapping("/api/diary")
public ResponseEntity<?> createDiary(@RequestBody DiaryRequest request) {
    // 1. 일기 저장
    Diary diary = Diary.builder()
        .title(request.getTitle())
        .content(request.getContent())
        .weather(request.getWeather())
        .userId(getCurrentUserId())
        .build();
        
    diary = diaryService.save(diary);
    
    // 2. AI 분석 비동기 요청
    CompletableFuture.runAsync(() -> {
        requestAIAnalysis(diary);
    });
    
    return ResponseEntity.ok(diary);
}

private void requestAIAnalysis(Diary diary) {
    try {
        // Python AI 서버로 요청
        RestTemplate restTemplate = new RestTemplate();
        
        Map<String, String> request = Map.of("text", diary.getContent());
        
        ResponseEntity<AnalysisResponse> response = restTemplate.postForEntity(
            aiServerUrl + "/analyze", 
            request, 
            AnalysisResponse.class
        );
        
        // 분석 결과 저장
        if (response.getStatusCode().is2xxSuccessful()) {
            Report report = Report.builder()
                .emotion(response.getBody().getEmotion())
                .keywords(response.getBody().getKeywords())
                .advice(response.getBody().getAdvice())
                .build();
                
            report = reportService.save(report);
            
            // 일기와 연결
            diary.setReportId(report.getId());
            diaryService.save(diary);
        }
        
    } catch (Exception e) {
        log.error("AI 분석 실패: {}", e.getMessage());
    }
}
```

**Python AI 서버:**
```python
from fastapi import FastAPI
import openai

app = FastAPI()

@app.post("/analyze")
async def analyze_diary(request: AnalysisRequest):
    try:
        # OpenAI API 호출
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system", 
                    "content": "당신은 심리 상담사입니다. 일기 내용을 분석해서 감정, 키워드, 조언을 JSON 형태로 제공해주세요."
                },
                {
                    "role": "user", 
                    "content": request.text
                }
            ]
        )
        
        # 결과 파싱
        result = json.loads(response.choices[0].message.content)
        
        return AnalysisResponse(
            emotion=result.get('emotion', '중립'),
            keywords=result.get('keywords', []),
            advice=result.get('advice', '오늘도 고생하셨습니다.')
        )
        
    except Exception as e:
        return {"error": str(e)}
```

### 4. 일기 조회

날짜별로 일기를 조회할 수 있게 했다.

```java
@GetMapping("/api/diary/calendar")
public ResponseEntity<?> getDiariesByDate(@RequestParam String date) {
    List<Diary> diaries = diaryService.findByUserIdAndDate(
        getCurrentUserId(), 
        LocalDate.parse(date)
    );
    
    return ResponseEntity.ok(diaries);
}

@GetMapping("/api/diary/{diaryId}")
public ResponseEntity<?> getDiaryDetail(@PathVariable Long diaryId) {
    // 일기와 AI 분석 결과를 함께 조회
    DiaryDetailResponse response = diaryService.getDiaryWithReport(diaryId);
    
    return ResponseEntity.ok(response);
}
```

**JPA Repository:**
```java
@Repository
public interface DiaryRepository extends JpaRepository<Diary, Long> {
    
    @Query("SELECT d FROM Diary d WHERE d.userId = :userId AND DATE(d.createdAt) = :date ORDER BY d.createdAt DESC")
    List<Diary> findByUserIdAndDate(@Param("userId") Long userId, @Param("date") LocalDate date);
    
    @Query("SELECT d FROM Diary d LEFT JOIN FETCH Report r ON d.reportId = r.id WHERE d.id = :diaryId")
    Optional<DiaryWithReport> findDiaryWithReport(@Param("diaryId") Long diaryId);
}
```

## React Native 클라이언트 구현

### 상태 관리

Context API로 전역 상태를 관리했다.

```javascript
// AuthContext.js
const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [tokens, setTokens] = useState(null);
  
  const login = async (email, password) => {
    try {
      const response = await authApi.login(email, password);
      
      setUser(response.user);
      setTokens({
        accessToken: response.accessToken,
        refreshToken: response.refreshToken
      });
      
      // AsyncStorage에 저장
      await AsyncStorage.multiSet([
        ['user', JSON.stringify(response.user)],
        ['accessToken', response.accessToken],
        ['refreshToken', response.refreshToken]
      ]);
      
    } catch (error) {
      throw error;
    }
  };
  
  return (
    <AuthContext.Provider value={{user, tokens, login}}>
      {children}
    </AuthContext.Provider>
  );
};
```

### 일기 작성 화면

```javascript
const DiaryWriteScreen = () => {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [weather, setWeather] = useState('sunny');
  const [isLoading, setIsLoading] = useState(false);
  
  const saveDiary = async () => {
    if (!title.trim() || !content.trim()) {
      Alert.alert('알림', '제목과 내용을 입력해주세요');
      return;
    }
    
    setIsLoading(true);
    
    try {
      await diaryApi.create({title, content, weather});
      Alert.alert('저장 완료', 'AI 분석 결과는 잠시 후 확인하실 수 있습니다');
      navigation.goBack();
    } catch (error) {
      Alert.alert('오류', '저장에 실패했습니다');
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <View style={styles.container}>
      <TextInput
        style={styles.titleInput}
        placeholder="제목을 입력하세요"
        value={title}
        onChangeText={setTitle}
      />
      
      <TextInput
        style={styles.contentInput}
        placeholder="오늘 있었던 일을 자유롭게 적어보세요"
        value={content}
        onChangeText={setContent}
        multiline
      />
      
      <TouchableOpacity 
        style={styles.saveButton} 
        onPress={saveDiary}
        disabled={isLoading}
      >
        <Text style={styles.saveButtonText}>
          {isLoading ? '저장 중...' : '저장하기'}
        </Text>
      </TouchableOpacity>
    </View>
  );
};
```

## 겪었던 문제들

### 1. AI 분석 속도
처음엔 동기로 처리했는데 응답이 너무 느렸다. 비동기로 바꾸고 "분석 중입니다" 상태를 보여주는 방식으로 개선했다.

### 2. 토큰 갱신
Access Token이 만료됐을 때 자동으로 갱신하는 로직을 구현했다.

```javascript
// api interceptor
axios.interceptors.response.use(
  response => response,
  async error => {
    if (error.response?.status === 401) {
      try {
        const refreshToken = await AsyncStorage.getItem('refreshToken');
        const response = await authApi.refresh(refreshToken);
        
        // 새 토큰 저장
        await AsyncStorage.setItem('accessToken', response.accessToken);
        
        // 원래 요청 재시도
        error.config.headers.Authorization = `Bearer ${response.accessToken}`;
        return axios.request(error.config);
        
      } catch (refreshError) {
        // 로그아웃 처리
        await logout();
      }
    }
    
    return Promise.reject(error);
  }
);
```

### 3. 데이터베이스 관계 설정
처음엔 MongoDB를 쓰려고 했는데, 일기-분석결과 간의 관계가 복잡해서 MariaDB로 바꿨다.

```sql
-- 테이블 구조
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE diary (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    title VARCHAR(500) NOT NULL,
    content TEXT NOT NULL,
    weather VARCHAR(50),
    report_id BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (report_id) REFERENCES report(id)
);

CREATE TABLE report (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    emotion VARCHAR(100),
    keywords JSON,
    advice TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 배운 점들

### 1. 마이크로서비스의 복잡성
서버를 분리하니 통신 오류, 타임아웃 등 고려할 게 많아졌다. 간단한 프로젝트라면 모노리스가 나을 수도 있다.

### 2. 에러 처리의 중요성
특히 AI API 호출 실패시 사용자에게 어떻게 알릴지, 재시도는 어떻게 할지 미리 정해두는 게 중요하다.

### 3. 비동기 처리
AI 분석같이 시간이 오래 걸리는 작업은 반드시 비동기로 처리하고, 사용자에게 적절한 피드백을 줘야 한다.

## 개선할 점들

1. **WebSocket 도입**: AI 분석 완료를 실시간으로 알리기
2. **오프라인 지원**: 네트워크 없을 때도 일기 작성 가능하게
3. **이미지 업로드**: 일기에 사진도 첨부할 수 있게
4. **푸시 알림**: 일기 쓸 시간 알림 기능

이런 식으로 여러 기술을 조합해서 앱을 만드는 재미가 쏠쏠했다. 다음에는 좀 더 간단한 구조로 시작해서 점진적으로 확장하는 방식을 써볼 생각이다.
```

### react-nextjs-modern-web-development.md

**Path:** `frontend/public/posts/2024/react-nextjs-modern-web-development.md`

```markdown
---
title: "React와 Next.js로 모던 웹 개발하기"
date: "2024-10-08"
category: "Web Development"
tags: ["React", "Next.js", "JavaScript", "Frontend"]
excerpt: "최신 React 기능과 Next.js의 장점을 활용한 웹 개발 방법론을 소개합니다."
readTime: "5분"
---

# React와 Next.js로 웹 개발 해보니까...

## 왜 React와 Next.js를 선택했을까?

솔직히 처음에는 바닐라 JavaScript로만 해도 되지 않을까 생각했다. 하지만 프로젝트가 점점 커지면서 관리가 힘들어지더라. 그러다가 React를 써보니까 '아, 이래서 다들 쓰는구나' 싶었다.

특히 팀 프로젝트에서 각자 다른 부분을 만들어야 할 때, React의 컴포넌트 방식이 정말 편했다. 내가 만든 버튼 컴포넌트를 팀원이 그대로 갖다 쓸 수 있으니까.

## React Hook, 생각보다 쉽다

처음에 Hook이라는 걸 들었을 때는 '또 새로운 걸 배워야 하나?' 싶었는데, 막상 써보니 훨씬 직관적이었다.

### useState - 상태 관리가 이렇게 간단할 줄이야

```javascript
import { useState } from 'react';

function MyCounter() {
  const [count, setCount] = useState(0);
  
  // 버튼 누를 때마다 숫자가 올라가는 간단한 기능
  const handleClick = () => {
    setCount(count + 1);
    console.log(`현재 카운트: ${count + 1}`); // 디버깅용
  };
  
  return (
    <div>
      <p>지금까지 {count}번 클릭했어요!</p>
      <button onClick={handleClick}>
        클릭해보세요
      </button>
    </div>
  );
}
```

클래스 컴포넌트 쓸 때는 this.state, this.setState 이런 걸로 복잡했는데, Hook은 정말 간단하더라. 함수형으로 쓰니까 코드도 훨씬 읽기 쉽고.

### useEffect - 사이드 이펙트 처리하기

```javascript
import { useState, useEffect } from 'react';

function PageTitle() {
  const [count, setCount] = useState(0);
  
  // count가 바뀔 때마다 브라우저 탭 제목도 바뀜
  useEffect(() => {
    document.title = `${count}번 클릭함`;
  }, [count]); // count가 바뀔 때만 실행
  
  return (
    <div>
      <p>브라우저 탭 제목 확인해보세요!</p>
      <button onClick={() => setCount(count + 1)}>
        클릭 (+1)
      </button>
    </div>
  );
}
```

useEffect가 처음엔 헷갈렸다. 언제 실행되는지, dependency array는 뭔지... 하지만 몇 번 써보니까 패턴이 보이더라. "이 값이 바뀔 때 이걸 해줘"라고 생각하면 된다.

## 컴포넌트 재사용 - 한 번 만들면 계속 쓸 수 있다

프로젝트하면서 가장 편했던 게 이 부분이다. 버튼이나 모달 같은 걸 한 번 만들어놓으면 여기저기서 갖다 쓸 수 있으니까.

```javascript
// 재사용 가능한 버튼 컴포넌트
function CustomButton({ text, color, onClick }) {
  return (
    <button 
      style={{ backgroundColor: color }}
      onClick={onClick}
      className="my-button"
    >
      {text}
    </button>
  );
}

// 여러 곳에서 사용
function App() {
  return (
    <div>
      <CustomButton 
        text="저장" 
        color="blue" 
        onClick={() => alert('저장됐어요!')} 
      />
      <CustomButton 
        text="삭제" 
        color="red" 
        onClick={() => alert('정말 삭제할까요?')} 
      />
    </div>
  );
}
```

처음에는 '이렇게까지 나눠야 하나?' 싶었는데, 나중에 디자인 바꿀 때 한 곳만 수정하면 되니까 정말 편하더라.

## Next.js - React를 더 쉽게 만들어주는 마법

React만 쓰다가 Next.js를 처음 써봤을 때 충격이었다. 설정할 게 거의 없더라.

### 파일 기반 라우팅 - 진짜 직관적이다

기존에는 react-router 써서 라우팅 설정을 별도로 해야 했는데, Next.js는 파일 구조만으로 라우팅이 된다.

```
pages/
  index.js       -> 홈페이지 (/)
  about.js       -> 어바웃 페이지 (/about)
  blog/
    index.js     -> 블로그 메인 (/blog)
    [id].js      -> 개별 블로그 글 (/blog/1, /blog/2, ...)
```

이게 얼마나 편한지 모른다. 새 페이지 만들고 싶으면 그냥 파일 하나 만들면 끝이니까.

### SSR (서버 사이드 렌더링) - SEO에 좋다더라

```javascript
// pages/blog/[id].js
function BlogPost({ post }) {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </div>
  );
}

// 서버에서 먼저 데이터를 가져와서 렌더링
export async function getServerSideProps({ params }) {
  // API에서 블로그 글 데이터 가져오기
  const post = await fetch(`/api/posts/${params.id}`).then(res => res.json());
  
  return {
    props: { post }
  };
}

export default BlogPost;
```

SSR이 뭔지 처음엔 잘 몰랐는데, 검색엔진이 내 페이지를 제대로 읽을 수 있게 해준다는 걸 알고 나니까 중요하다는 걸 깨달았다. 특히 블로그나 쇼핑몰 같은 사이트에서는 필수인 것 같다.

### API Routes - 백엔드도 같이 만들 수 있다

```javascript
// pages/api/hello.js
export default function handler(req, res) {
  if (req.method === 'GET') {
    res.status(200).json({ message: '안녕하세요!' });
  } else if (req.method === 'POST') {
    const { name } = req.body;
    res.status(200).json({ message: `안녕하세요, ${name}님!` });
  }
}
```

이게 진짜 편하다. 프론트엔드 프로젝트 안에서 간단한 API도 만들 수 있으니까. 풀스택 개발이 이렇게 쉬울 줄 몰랐다.

## 실제 프로젝트에서 겪은 일들

### 처음엔 이것저것 다 넣고 싶었다

프로젝트 초반에는 '이것도 써보고 저것도 써보자' 하면서 라이브러리를 막 설치했다. 상태 관리는 Redux, 스타일링은 styled-components, UI는 Material-UI... 

그런데 나중에 보니까 너무 복잡해지더라. 간단한 기능도 여러 단계를 거쳐야 하고. 지금은 정말 필요한 것만 쓰려고 한다.

### 성능 최적화에 대해 알게 됐다

처음에는 그냥 작동만 하면 됐는데, 사용자가 늘어나면서 느려지는 게 체감됐다. 그래서 React.memo, useMemo, useCallback 같은 걸 써보기 시작했다.

```javascript
import { memo, useMemo } from 'react';

// 불필요한 리렌더링 방지
const ExpensiveComponent = memo(({ data }) => {
  // 복잡한 계산은 메모이제이션
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: heavyCalculation(item)
    }));
  }, [data]);
  
  return (
    <div>
      {processedData.map(item => (
        <div key={item.id}>{item.processed}</div>
      ))}
    </div>
  );
});
```

성능 최적화는 정말 끝이 없는 것 같다. 하지만 사용자 경험이 확실히 좋아지는 걸 보면 뿌듯하다.

### 배포할 때 알게 된 것들

Vercel로 배포하니까 Next.js와 찰떡궁합이더라. GitHub에 푸시하면 자동으로 배포되고, preview URL도 만들어주고.

하지만 환경변수 설정이나 도메인 연결 같은 걸 처음 할 때는 헤맸다. 특히 API 키 같은 민감한 정보를 어떻게 관리해야 하는지 고민이 많았다.

## 앞으로의 계획

React와 Next.js에 어느 정도 익숙해졌으니까, 이제 TypeScript도 써보고 싶다. 타입 안정성이 좋다는 얘기를 많이 들어서.

그리고 테스팅도 제대로 배워보고 싶다. 지금까지는 그냥 브라우저에서 수동으로 테스트했는데, Jest나 React Testing Library 같은 걸로 자동화해보면 좋을 것 같다.

무엇보다 더 많은 프로젝트를 해보면서 실전 경험을 쌓고 싶다. 혼자 공부하는 것과 실제로 서비스를 만드는 건 정말 다르더라.

## 마지막으로

React와 Next.js를 배우면서 웹 개발이 정말 재밌다는 걸 깨달았다. 물론 처음엔 어려웠지만, 차근차근 배우다 보니 점점 할 수 있는 게 많아지는 게 보였다.

특히 내가 만든 걸 다른 사람들이 실제로 쓰는 걸 보면 정말 뿌듯하다. 앞으로도 계속 배워가면서 더 좋은 웹사이트를 만들어보고 싶다.
```

### rsync-custom-ssh-port-guide.md

**Path:** `frontend/public/posts/2024/rsync-custom-ssh-port-guide.md`

```markdown
---
title: "Rsync 커스텀 SSH 포트 사용법 완벽 가이드"
date: "2024-08-21"
category: "Linux"
tags: ['rsync', 'SSH', '파일 동기화', '백업', 'Linux']
excerpt: "Rsync를 사용할 때 기본 SSH 포트가 아닌 커스텀 포트를 지정하는 올바른 방법을 상세히 설명합니다."
readTime: "3분"
---

## 문제 상황

Rsync를 사용하여 원격 서버로 파일을 전송할 때, 기본 SSH 포트(22번)가 아닌 커스텀 포트(예: 2722번)를 사용해야 하는 경우가 있습니다. 하지만 많은 사용자들이 잘못된 문법을 사용하여 "Connection refused" 에러를 만나게 됩니다.

## 잘못된 명령어 예시

다음과 같은 명령어는 작동하지 않습니다:

```bash
sudo rsync -avz /mnt/nas/backup/* --port 2722 nodove@30.30.30.3:/mnt/nas/files/백업/040825/
```

### 왜 작동하지 않는가?

`--port` 옵션은 rsync의 SSH 연결에서 사용하는 옵션이 아닙니다. 이 명령어는 여전히 기본 SSH 포트(22번)로 연결을 시도하기 때문에 "Connection refused" 에러가 발생합니다.

## 정확한 해결 방법

### 1. -e 옵션 사용 (권장 방법)

커스텀 SSH 포트를 지정하려면 `-e` 옵션을 사용해야 합니다:

```bash
sudo rsync -avz -e "ssh -p 2722" /mnt/nas/backup/* nodove@30.30.30.3:/mnt/nas/files/백업/040825/
```

#### 옵션 설명

- `-a`: 아카이브 모드 (권한, 소유권, 타임스탬프 등 보존)
- `-v`: 상세 출력 (전송 진행 상황 표시)
- `-z`: 전송 중 데이터 압축 (전송 속도 향상)
- `-e "ssh -p 2722"`: SSH를 원격 셸로 사용하되 포트 2722 지정

### 2. SSH 설정 파일 활용

자주 사용하는 서버의 경우, SSH 클라이언트 설정 파일을 수정하여 편의성을 높일 수 있습니다.

`~/.ssh/config` 파일에 다음 내용을 추가합니다:

```
Host 30.30.30.3
    Port 2722
    User nodove
```

이렇게 설정하면 rsync 명령어를 단순화할 수 있습니다:

```bash
sudo rsync -avz /mnt/nas/backup/* nodove@30.30.30.3:/mnt/nas/files/백업/040825/
```

## 고급 사용법

### 추가 SSH 옵션 지정

SSH 연결 시 추가 옵션을 사용해야 하는 경우:

```bash
rsync -avz -e "ssh -p 2722 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" \
  /source/path/ user@remote-host:/destination/path/
```

### 키 기반 인증 사용

특정 SSH 키를 사용하는 경우:

```bash
rsync -avz -e "ssh -p 2722 -i ~/.ssh/custom_key" \
  /source/path/ user@remote-host:/destination/path/
```

### 대역폭 제한

네트워크 대역폭을 제한하고 싶은 경우:

```bash
rsync -avz --bwlimit=1000 -e "ssh -p 2722" \
  /source/path/ user@remote-host:/destination/path/
```

## 실용적인 활용 예시

### 1. 백업 스크립트

```bash
#!/bin/bash
# backup_script.sh

SOURCE_DIR="/home/user/important_data"
DEST_HOST="backup-server.example.com"
DEST_PATH="/backup/user_data"
SSH_PORT="2722"

rsync -avz --delete -e "ssh -p $SSH_PORT" \
  "$SOURCE_DIR/" "user@$DEST_HOST:$DEST_PATH/"
```

### 2. 진행 상황 표시

대용량 파일 전송 시 진행률을 보고 싶은 경우:

```bash
rsync -avz --progress -e "ssh -p 2722" \
  /large/dataset/ user@remote-host:/destination/
```

### 3. 건조 실행 (Dry Run)

실제 전송 전에 어떤 파일들이 전송될지 미리 확인:

```bash
rsync -avz --dry-run -e "ssh -p 2722" \
  /source/path/ user@remote-host:/destination/
```

## 문제 해결

### 연결 문제 디버깅

SSH 연결 문제를 진단하려면:

```bash
ssh -p 2722 -v user@remote-host
```

### 방화벽 확인

원격 서버에서 해당 포트가 열려있는지 확인:

```bash
# 서버에서 실행
netstat -tlnp | grep :2722
# 또는
ss -tlnp | grep :2722
```

### 권한 문제

sudo를 사용할 때 SSH 키 경로 문제가 발생할 수 있습니다:

```bash
# 현재 사용자의 SSH 키를 사용하도록 지정
sudo rsync -avz -e "ssh -p 2722 -i $HOME/.ssh/id_rsa" \
  /source/ user@remote-host:/destination/
```

## 보안 고려사항

1. **포트 변경**: 기본 SSH 포트를 변경하는 것은 자동화된 공격을 줄이는 데 도움이 됩니다.
2. **키 기반 인증**: 패스워드 대신 SSH 키를 사용하여 보안을 강화하세요.
3. **방화벽 설정**: 필요한 포트만 열어두고 나머지는 차단하세요.

## 결론

Rsync에서 커스텀 SSH 포트를 사용하는 핵심은 `-e` 옵션을 올바르게 활용하는 것입니다. 이 방법을 사용하면 보안이 강화된 환경에서도 안전하고 효율적으로 파일 동기화를 수행할 수 있습니다.

자주 사용하는 서버의 경우 SSH 설정 파일을 구성하여 명령어를 단순화하고, 스크립트를 작성하여 정기적인 백업 작업을 자동화하는 것을 권장합니다.
```

### stack.md

**Path:** `frontend/public/posts/2024/stack.md`

```markdown
---
title: "스택(Stack) 완전 정복"
date: "2024-10-15"
category: "Algorithm"
tags: ['스택', '자료구조', 'LIFO', '알고리즘']
excerpt: "LIFO 구조의 스택 자료구조 개념부터 실전 활용까지 완벽 가이드"
readTime: "6분"
---

#  스택(Stack) 완전 정복

##  핵심 개념

스택은 **LIFO(Last In, First Out)** 원리를 따르는 선형 자료구조입니다. 마지막에 들어간 데이터가 가장 먼저 나오는 구조로, 접시를 쌓아놓은 것과 같은 개념입니다.

### 주요 특징
- **LIFO 구조**: 후입선출
- **한쪽 끝에서만 삽입/삭제**: Top에서만 연산 수행
- **순서 보장**: 삽입된 순서의 역순으로 데이터 접근

##  시간복잡도

| 연산 | 시간복잡도 | 설명 |
|------|------------|------|
| push() | O(1) | 스택 맨 위에 원소 추가 |
| pop() | O(1) | 스택 맨 위 원소 제거 및 반환 |
| top() | O(1) | 스택 맨 위 원소 확인 |
| empty() | O(1) | 스택이 비어있는지 확인 |
| size() | O(1) | 스택의 크기 반환 |

##  완전한 구현 코드

### Python 리스트를 이용한 구현
```python
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        """스택에 원소 추가"""
        self.items.append(item)
    
    def pop(self):
        """스택에서 원소 제거 및 반환"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.items.pop()
    
    def top(self):
        """스택 맨 위 원소 확인 (제거하지 않음)"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.items[-1]
    
    def is_empty(self):
        """스택이 비어있는지 확인"""
        return len(self.items) == 0
    
    def size(self):
        """스택 크기 반환"""
        return len(self.items)
    
    def __str__(self):
        """스택을 문자열로 표현"""
        return f"Stack({self.items})"

# 사용 예제
if __name__ == "__main__":
    stack = Stack()
    
    # 데이터 추가
    stack.push(1)
    stack.push(2)
    stack.push(3)
    print(f"Stack after pushes: {stack}")  # Stack([1, 2, 3])
    
    # 맨 위 원소 확인
    print(f"Top element: {stack.top()}")  # 3
    
    # 데이터 제거
    popped = stack.pop()
    print(f"Popped element: {popped}")  # 3
    print(f"Stack after pop: {stack}")  # Stack([1, 2])
    
    # 크기 확인
    print(f"Stack size: {stack.size()}")  # 2
```

### 연결 리스트를 이용한 구현
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedStack:
    def __init__(self):
        self.head = None
        self._size = 0
    
    def push(self, data):
        """스택에 원소 추가"""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        self._size += 1
    
    def pop(self):
        """스택에서 원소 제거 및 반환"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        
        data = self.head.data
        self.head = self.head.next
        self._size -= 1
        return data
    
    def top(self):
        """스택 맨 위 원소 확인"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.head.data
    
    def is_empty(self):
        """스택이 비어있는지 확인"""
        return self.head is None
    
    def size(self):
        """스택 크기 반환"""
        return self._size
    
    def display(self):
        """스택 내용 출력"""
        result = []
        current = self.head
        while current:
            result.append(current.data)
            current = current.next
        return result

# 사용 예제
linked_stack = LinkedStack()
linked_stack.push(10)
linked_stack.push(20)
linked_stack.push(30)
print(f"LinkedStack: {linked_stack.display()}")  # [30, 20, 10]
```

##  최적화 팁

### 1. 메모리 효율성
```python
class FixedSizeStack:
    def __init__(self, capacity):
        self.capacity = capacity
        self.items = [None] * capacity
        self.top_index = -1
    
    def push(self, item):
        if self.top_index >= self.capacity - 1:
            raise OverflowError("Stack overflow")
        self.top_index += 1
        self.items[self.top_index] = item
    
    def pop(self):
        if self.top_index < 0:
            raise IndexError("Stack underflow")
        item = self.items[self.top_index]
        self.items[self.top_index] = None  # 메모리 해제
        self.top_index -= 1
        return item
```

### 2. Python 내장 collections.deque 활용
```python
from collections import deque

class DequeStack:
    def __init__(self):
        self.stack = deque()
    
    def push(self, item):
        self.stack.append(item)
    
    def pop(self):
        if not self.stack:
            raise IndexError("Stack is empty")
        return self.stack.pop()
    
    def top(self):
        if not self.stack:
            raise IndexError("Stack is empty")
        return self.stack[-1]
    
    def is_empty(self):
        return len(self.stack) == 0
```

##  실전 예제

### 1. 괄호 검사 (BOJ 9012)
```python
def is_valid_parentheses(s):
    """올바른 괄호 문자열인지 검사"""
    stack = []
    
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    
    return len(stack) == 0

# 테스트
test_cases = ["(()())", "((()))", "(())())", "(()", "())"]
for case in test_cases:
    result = is_valid_parentheses(case)
    print(f"{case}: {'Valid' if result else 'Invalid'}")
```

### 2. 스택 수열 (BOJ 1874)
```python
def stack_sequence(target):
    """스택으로 주어진 수열을 만들 수 있는지 확인"""
    stack = []
    operations = []
    current = 1
    
    for num in target:
        # 목표 숫자까지 스택에 push
        while current <= num:
            stack.append(current)
            operations.append('+')
            current += 1
        
        # 스택 top이 목표 숫자와 같으면 pop
        if stack and stack[-1] == num:
            stack.pop()
            operations.append('-')
        else:
            return None  # 불가능한 경우
    
    return operations

# 테스트
sequence = [4, 3, 6, 8, 7, 5, 2, 1]
result = stack_sequence(sequence)
if result:
    for op in result:
        print(op)
else:
    print("NO")
```

### 3. 히스토그램에서 가장 큰 직사각형 (BOJ 6549)
```python
def largest_rectangle_in_histogram(heights):
    """히스토그램에서 가장 큰 직사각형의 넓이"""
    stack = []
    max_area = 0
    
    for i, height in enumerate(heights):
        # 현재 높이보다 높은 막대들을 처리
        while stack and heights[stack[-1]] > height:
            h = heights[stack.pop()]
            w = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * w)
        
        stack.append(i)
    
    # 남은 막대들 처리
    while stack:
        h = heights[stack.pop()]
        w = len(heights) if not stack else len(heights) - stack[-1] - 1
        max_area = max(max_area, h * w)
    
    return max_area

# 테스트
heights = [2, 1, 5, 6, 2, 3]
print(f"Maximum area: {largest_rectangle_in_histogram(heights)}")  # 10
```

##  스택의 다양한 응용

### 1. 계산기 구현 (후위 표기법)
```python
def evaluate_postfix(expression):
    """후위 표기법 수식 계산"""
    stack = []
    operators = {'+', '-', '*', '/'}
    
    for token in expression.split():
        if token not in operators:
            stack.append(int(token))
        else:
            b = stack.pop()
            a = stack.pop()
            
            if token == '+':
                result = a + b
            elif token == '-':
                result = a - b
            elif token == '*':
                result = a * b
            elif token == '/':
                result = int(a / b)  # 정수 나눗셈
            
            stack.append(result)
    
    return stack[0]

# 테스트: "3 4 + 2 * 7 /" = ((3 + 4) * 2) / 7 = 2
print(evaluate_postfix("3 4 + 2 * 7 /"))  # 2
```

### 2. 중위 표기법을 후위 표기법으로 변환
```python
def infix_to_postfix(expression):
    """중위 표기법을 후위 표기법으로 변환"""
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    stack = []
    postfix = []
    
    for char in expression:
        if char.isalnum():  # 피연산자
            postfix.append(char)
        elif char == '(':
            stack.append(char)
        elif char == ')':
            while stack and stack[-1] != '(':
                postfix.append(stack.pop())
            stack.pop()  # '(' 제거
        else:  # 연산자
            while (stack and stack[-1] != '(' and
                   stack[-1] in precedence and
                   precedence[stack[-1]] >= precedence[char]):
                postfix.append(stack.pop())
            stack.append(char)
    
    # 남은 연산자들 처리
    while stack:
        postfix.append(stack.pop())
    
    return ''.join(postfix)

# 테스트
print(infix_to_postfix("A+B*C"))      # ABC*+
print(infix_to_postfix("(A+B)*C"))    # AB+C*
```

### 3. 함수 호출 스택 시뮬레이션
```python
class CallStack:
    def __init__(self):
        self.stack = []
    
    def call_function(self, func_name, params=None):
        """함수 호출"""
        frame = {
            'function': func_name,
            'parameters': params or {},
            'local_vars': {}
        }
        self.stack.append(frame)
        print(f"Calling {func_name}({params})")
    
    def return_function(self, return_value=None):
        """함수 반환"""
        if self.stack:
            frame = self.stack.pop()
            print(f"Returning from {frame['function']} with value: {return_value}")
        else:
            print("No function to return from")
    
    def print_stack_trace(self):
        """스택 트레이스 출력"""
        print("Stack Trace:")
        for i, frame in enumerate(reversed(self.stack)):
            print(f"  {i}: {frame['function']}({frame['parameters']})")

# 재귀 함수 팩토리얼 시뮬레이션
def factorial_simulation(n):
    call_stack = CallStack()
    
    def factorial(n):
        call_stack.call_function('factorial', {'n': n})
        
        if n <= 1:
            call_stack.return_function(1)
            return 1
        else:
            result = n * factorial(n - 1)
            call_stack.return_function(result)
            return result
    
    result = factorial(4)
    print(f"Final result: {result}")

factorial_simulation(4)
```

## 🎖️ 레벨별 연습 문제

### 🥉 초급
- BOJ 10828: 스택
- BOJ 9012: 괄호
- BOJ 4949: 균형잡힌 세상

### 🥈 중급  
- BOJ 1874: 스택 수열
- BOJ 17298: 오큰수
- BOJ 3986: 좋은 단어

### 🥇 고급
- BOJ 6549: 히스토그램에서 가장 큰 직사각형
- BOJ 2493: 탑
- BOJ 1918: 후위 표기식

---

**다음 학습**: [큐(Queue) 완전 정복](../queue/) 

스택은 **재귀, 백트래킹, 파싱** 등 다양한 알고리즘의 핵심이 되는 자료구조입니다. 완벽하게 이해하고 넘어가세요!
```

### tmux-session-management-guide.md

**Path:** `frontend/public/posts/2024/tmux-session-management-guide.md`

```markdown
---
title: "tmux 세션 관리 완벽 가이드"
date: "2024-09-02"
category: "Linux"
tags: ['tmux', '터미널', '세션 관리', 'Linux', '멀티플렉서']
excerpt: "tmux 터미널 멀티플렉서의 기본 사용법과 세션이 사라지는 문제 해결 방법을 자세히 설명합니다."
readTime: "3분"
---

## tmux란?

tmux는 터미널 세션을 유지하고 관리할 수 있게 해주는 강력한 터미널 멀티플렉서입니다. SSH 연결이 끊어져도 작업을 계속할 수 있고, 하나의 터미널에서 여러 세션을 동시에 관리할 수 있습니다.

## tmux 기본 사용법

### 세션 생성 및 관리

```bash
# 새 세션 생성
tmux

# 이름 지정하여 세션 생성
tmux new-session -s 세션이름
tmux new -s 세션이름
```

### 세션 분리 및 재연결

```bash
# 세션 분리 (세션은 백그라운드에서 계속 실행)
Ctrl+b 누른 후 d 키 입력

# 세션 목록 확인
tmux ls
tmux list-sessions

# 세션에 재연결
tmux attach
tmux a
tmux attach -t 세션이름
```

## 세션이 사라지는 문제 원인

tmux를 사용하다 보면 세션이 예기치 않게 사라지는 경우가 있습니다. 주요 원인들을 살펴보겠습니다.

### 1. 터미널을 올바르게 분리하지 않고 닫음

tmux 세션을 활성화한 상태에서 터미널 창을 그냥 닫으면 세션이 종료될 수 있습니다. 이는 가장 흔한 실수 중 하나입니다.

### 2. 세션 내에서 exit 명령 사용

세션을 분리(detach)하지 않고 세션 내에서 `exit` 명령을 실행하면 해당 세션이 완전히 종료됩니다.

### 3. 터미널 에뮬레이터 설정

일부 터미널 에뮬레이터(예: kitty)는 기본적으로 tmux 세션을 종료시키도록 설정되어 있을 수 있습니다.

## 세션 사라짐 문제 해결 방법

### 1. 올바른 세션 분리 사용하기

터미널을 종료하기 전에 반드시 `Ctrl+b d`를 사용하여 세션을 분리하세요. 이렇게 하면 세션이 백그라운드에서 계속 실행됩니다.

### 2. tmux 세션 자동 저장 설정

tmux 설정 파일(`~/.tmux.conf`)에 다음을 추가하여 세션을 자동으로 저장하고 복구할 수 있습니다:

```bash
# 자동 세션 저장 관련 플러그인 설치 (tmux plugin manager 필요)
set -g @plugin 'tmux-plugins/tmux-resurrect'
set -g @plugin 'tmux-plugins/tmux-continuum'

# 자동 저장 활성화
set -g @continuum-restore 'on'
```

### 3. 세션 종료 방지 설정

tmux 설정 파일에 다음 설정을 추가하여 창이 닫힐 때 세션이 종료되는 것을 방지할 수 있습니다:

```bash
set -g detach-on-destroy on
```

### 4. 추가 해결 팁

#### 다른 사용자로 실행된 세션 확인

세션이 보이지 않는다면 다른 사용자 계정으로 실행되었을 수 있습니다. 다른 사용자로 로그인하여 세션을 확인해보세요.

#### tmux 서버 재시작

간혹 tmux 서버에 문제가 생겨 세션이 보이지 않을 수 있습니다. 다음 명령을 실행해보세요:

```bash
pkill -USR1 tmux
```

#### 세션 자동 종료 방지

모든 클라이언트가 분리되었을 때 서버가 자동으로 종료되지 않도록 설정:

```bash
tmux set-option -g exit-empty off
```

#### 마지막 창이 닫힐 때 세션 유지

마지막 창이 닫혀도 세션이 유지되도록 설정:

```bash
tmux set-option -g exit-unattached off
```

## 유용한 tmux 단축키

### 기본 조작

- `Ctrl+b c`: 새 창 생성
- `Ctrl+b n`: 다음 창으로 이동
- `Ctrl+b p`: 이전 창으로 이동
- `Ctrl+b [창번호]`: 특정 창으로 이동
- `Ctrl+b &`: 현재 창 종료

### 패널 조작

- `Ctrl+b %`: 세로로 패널 분할
- `Ctrl+b "`: 가로로 패널 분할
- `Ctrl+b 방향키`: 패널 간 이동
- `Ctrl+b x`: 현재 패널 종료

## 권장 설정

다음은 tmux를 더 편리하게 사용하기 위한 권장 설정입니다:

```bash
# ~/.tmux.conf 파일에 추가

# 마우스 지원 활성화
set -g mouse on

# 창 번호를 1부터 시작
set -g base-index 1
set -g pane-base-index 1

# 키 응답 시간 단축
set -sg escape-time 1

# 히스토리 버퍼 크기 설정
set -g history-limit 10000

# 상태바 새로고침 간격
set -g status-interval 60
```

## 요약

tmux 세션 관리의 핵심은 세션을 올바르게 분리(detach)하는 것입니다. 터미널을 닫기 전에 항상 `Ctrl+b d`를 사용하여 세션을 분리하고, 나중에 `tmux attach`를 사용하여 다시 연결하세요. 

추가적인 보호를 위해 tmux 설정 파일에 적절한 설정을 추가하고, 필요한 경우 세션 자동 저장 플러그인을 사용하면 더욱 안정적으로 tmux를 활용할 수 있습니다.
```

### vim-split-window-guide.md

**Path:** `frontend/public/posts/2024/vim-split-window-guide.md`

```markdown
---
title: "Vim 분할 창 사용법과 파일 간 전환 방법"
date: "2024-07-17"
category: "Editor"
tags: ['Vim', '편집기', '분할 창', 'Linux', '단축키']
excerpt: "Vim에서 vertical split view를 사용하여 여러 파일을 동시에 편집하고 파일 간 전환하는 방법을 소개합니다."
readTime: "3분"
---

## Vim 분할 창 기본 개념

Vim에서는 화면을 여러 개의 창으로 분할하여 동시에 여러 파일을 편집하거나 같은 파일의 다른 부분을 볼 수 있습니다. 이는 코드 편집 시 매우 유용한 기능입니다.

## 분할 창 생성하기

### Vertical Split (세로 분할)

```vim
:vsplit [파일명]
:vs [파일명]
```

파일명을 지정하지 않으면 현재 파일이 두 개의 창에 표시됩니다.

### Horizontal Split (가로 분할)

```vim
:split [파일명]
:sp [파일명]
```

## 창 간 이동 방법

### 1. 순차적 창 전환

- `Ctrl + w, w`: 다음 창으로 이동
- `Ctrl + w, W`: 이전 창으로 이동

### 2. 방향키를 이용한 전환

더 직관적이고 편리한 방법입니다:

- `Ctrl + w, h`: 왼쪽 창으로 이동
- `Ctrl + w, l`: 오른쪽 창으로 이동
- `Ctrl + w, j`: 아래쪽 창으로 이동
- `Ctrl + w, k`: 위쪽 창으로 이동

### 3. 창 번호를 이용한 전환

- `Ctrl + w, [숫자]`: 해당 번호의 창으로 이동

## 창 크기 조절

### 세로 크기 조절

- `Ctrl + w, +`: 현재 창 높이 증가
- `Ctrl + w, -`: 현재 창 높이 감소
- `Ctrl + w, =`: 모든 창을 같은 크기로 조절

### 가로 크기 조절

- `Ctrl + w, >`: 현재 창 너비 증가
- `Ctrl + w, <`: 현재 창 너비 감소

### 최대/최소화

- `Ctrl + w, _`: 현재 창을 세로로 최대화
- `Ctrl + w, |`: 현재 창을 가로로 최대화

## 창 관리

### 창 닫기

- `Ctrl + w, c`: 현재 창 닫기
- `Ctrl + w, o`: 현재 창만 남기고 모든 창 닫기
- `:q`: 현재 창 종료

### 창 이동

- `Ctrl + w, r`: 창들을 시계방향으로 회전
- `Ctrl + w, R`: 창들을 반시계방향으로 회전
- `Ctrl + w, x`: 현재 창과 다음 창의 위치 교환

### 창 배치 변경

- `Ctrl + w, H`: 현재 창을 화면 맨 왼쪽으로 이동 (full height)
- `Ctrl + w, J`: 현재 창을 화면 맨 아래로 이동 (full width)
- `Ctrl + w, K`: 현재 창을 화면 맨 위로 이동 (full width)
- `Ctrl + w, L`: 현재 창을 화면 맨 오른쪽으로 이동 (full height)

## 실용적인 사용 예시

### 1. 두 파일 비교하기

```vim
:vs file2.txt
```

현재 파일과 file2.txt를 나란히 놓고 비교할 수 있습니다.

### 2. 함수 정의와 사용처 동시 보기

```vim
:vs
Ctrl + w, l
/function_name
```

같은 파일을 두 창에 열고, 한 창에서는 함수 정의를, 다른 창에서는 함수 사용처를 볼 수 있습니다.

### 3. 설정 파일과 소스 코드 동시 편집

```vim
:vs ~/.vimrc
```

설정 파일을 참조하면서 코드를 편집할 때 유용합니다.

## 편의성을 위한 설정

`~/.vimrc` 파일에 다음 설정을 추가하면 더 편리하게 사용할 수 있습니다:

```vim
" 창 이동을 더 쉽게 하기
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" 새 창을 오른쪽/아래에 열기
set splitright
set splitbelow

" 창 크기 조절을 더 쉽게 하기
nnoremap <silent> <C-w>+ :resize +5<CR>
nnoremap <silent> <C-w>- :resize -5<CR>
nnoremap <silent> <C-w>> :vertical resize +5<CR>
nnoremap <silent> <C-w>< :vertical resize -5<CR>
```

## 탭과 분할 창의 조합

Vim은 탭 기능도 제공하므로 탭과 분할 창을 조합하여 사용할 수 있습니다:

```vim
:tabnew file.txt    " 새 탭에서 파일 열기
:tabn              " 다음 탭으로 이동
:tabp              " 이전 탭으로 이동
```

## 결론

Vim의 분할 창 기능을 마스터하면 훨씬 더 효율적으로 파일을 편집할 수 있습니다. 특히 `Ctrl + w` 조합 키들을 익숙하게 사용할 수 있게 되면, 여러 파일을 동시에 작업하는 것이 매우 자연스러워집니다.

처음에는 단축키가 복잡해 보일 수 있지만, 자주 사용하다 보면 손에 익게 되어 마우스 없이도 빠르고 정확하게 창 간 이동과 파일 편집이 가능해집니다.
```

### week1-2.md

**Path:** `frontend/public/posts/2024/week1-2.md`

```markdown
---
title: "1-2주차: 기초 수학 및 자료구조 복습"
date: "2024-08-01"
category: "Algorithm"
tags: ['알고리즘', '자료구조', '이산수학', '배열', '스택', '큐']
excerpt: "알고리즘 학습의 첫 걸음, 이산수학과 기본 자료구조를 탄탄히 다지는 시간"
readTime: "2분"
---

<div class="week-badge">1-2주차</div>

# 🏗️ 기초 수학 및 자료구조 복습

> **학습 목표**: 이산수학(집합·논리·그래프 기초), 배열·리스트·스택·큐 기본 개념 확립

알고리즘 학습의 견고한 기초를 다지는 중요한 시간입니다. 수학적 사고력과 기본 자료구조에 대한 이해는 앞으로의 모든 학습에 밑바탕이 됩니다.

## 📖 주요 학습 내용

### 이산수학 기초
- **집합론**: 합집합, 교집합, 차집합
- **논리**: 명제, 조건문, 논리 연산
- **그래프 기초**: 정점, 간선, 인접 개념

### 기본 자료구조
- **배열(Array)**: 인덱스 접근, 순회
- **리스트(List)**: 동적 배열, 삽입/삭제
- **스택(Stack)**: LIFO, push/pop 연산
- **큐(Queue)**: FIFO, enqueue/dequeue 연산

## 🎯 추천 학습 자료

### 온라인 강의
- **이산수학 입문** (유튜브 무료 강의)
- **자료구조 기초** (프로그래머스 스쿨)
- **생활코딩 자료구조** (기초부터 차근차근)

### 참고 도서
- 『이산수학 입문』 - 기초 개념 정립
- 『자료구조와 알고리즘』 - 실전 구현

## 💻 실습 문제

### 필수 문제
```markdown
🟢 BOJ 11720: 숫자의 합
   - 배열과 문자열 처리 기초
   - 난이도: ⭐

🟢 BOJ 10845: 큐  
   - 큐 자료구조 직접 구현
   - 난이도: ⭐⭐
```

### 추가 연습 문제
- BOJ 10828: 스택
- BOJ 10818: 최솟값과 최댓값  
- BOJ 2562: 최댓값

## ⏰ 학습 스케줄

| 일차 | 학습 내용 | 소요 시간 |
|------|-----------|-----------|
| 1-2일 | 이산수학 기초 개념 | 3-4시간 |
| 3-4일 | 배열, 리스트 학습 | 2-3시간 |
| 5-7일 | 스택, 큐 개념과 구현 | 3-4시간 |
| 8-14일 | 문제 풀이 및 복습 | 매일 1-2시간 |

## 🎉 학습 완료 체크리스트

- [ ] 집합의 기본 연산을 이해하고 설명할 수 있다
- [ ] 배열과 리스트의 차이점을 알고 있다  
- [ ] 스택의 LIFO 원리를 이해하고 구현할 수 있다
- [ ] 큐의 FIFO 원리를 이해하고 구현할 수 있다
- [ ] 필수 문제를 모두 해결했다

## 💡 학습 팁

1. **개념 우선**: 문제 풀이보다 개념 이해에 집중하세요
2. **직접 구현**: 내장 함수보다 직접 구현해보며 원리를 익히세요  
3. **시각화**: 자료구조의 동작을 그림으로 그려가며 이해하세요
4. **꾸준함**: 매일 조금씩이라도 공부하는 습관을 만드세요

---

**다음 주차**: [3-4주차: 정렬 및 탐색 기법](../week3-4) 🔍

<div class="text-center">
  <a href="../week3-4" class="btn">다음 주차로 →</a>
</div>
```

### week11-12.md

**Path:** `frontend/public/posts/2024/week11-12.md`

```markdown
---
title: "11-12주차: 고급 자료구조 및 최단경로"
date: "2024-07-25"
category: "Algorithm"
tags: ['힙', '우선순위큐', '다익스트라', '벨만포드', '최단경로']
excerpt: "힙과 우선순위 큐를 마스터하고, 다익스트라와 벨만-포드 최단경로 알고리즘을 정복한다"
readTime: "4분"
---

<div class="week-badge">11-12주차</div>

# ⚡ 고급 자료구조 및 최단경로

> **학습 목표**: 힙·우선순위 큐 완전 정복, 다익스트라·벨만-포드 알고리즘 마스터

효율적인 우선순위 관리와 가중치 그래프에서의 최단경로를 찾는 핵심 알고리즘들을 학습합니다.

## 📖 주요 학습 내용

### 힙(Heap) 자료구조
- **완전 이진 트리**: 힙의 기본 구조
- **최대 힙 vs 최소 힙**: 부모-자식 관계 규칙
- **힙 연산**: 삽입(O(log n)), 삭제(O(log n))
- **힙 정렬**: O(n log n) 시간복잡도

### 우선순위 큐(Priority Queue)
- **힙 기반 구현**: 가장 효율적인 방법
- **Python heapq 모듈**: 실전 활용법
- **응용 분야**: 작업 스케줄링, 그래프 알고리즘

### 최단경로 알고리즘
- **다익스트라 알고리즘**: 음수 간선이 없는 그래프
- **벨만-포드 알고리즘**: 음수 간선 처리 가능
- **플로이드-워셜**: 모든 쌍 최단경로 (예고)

## 🎯 추천 학습 자료

### 필수 교재
- 『Introduction to Algorithms』 힙 챕터
- 백준 다익스트라 분류 문제집
- **GeeksforGeeks**: Dijkstra's Algorithm

### 시각화 도구
- **Algorithm Visualizer**: 다익스트라 시각화
- **Heap Visualization**: 힙 연산 과정

## 💻 실습 문제

### 필수 문제
```markdown
🟡 BOJ 1753: 최단경로
   - 다익스트라 알고리즘의 기본 문제
   - 난이도: ⭐⭐⭐

🟡 BOJ 1916: 최소비용 구하기
   - 다익스트라 응용 문제  
   - 난이도: ⭐⭐⭐
```

### 추가 연습 문제
- BOJ 11279: 최대 힙
- BOJ 11286: 절댓값 힙
- BOJ 1504: 특정한 최단 경로
- BOJ 11657: 타임머신 (벨만-포드)

## 📊 최단경로 알고리즘 비교

| 알고리즘 | 시간복잡도 | 음수 간선 | 음수 사이클 검출 | 적용 범위 |
|----------|------------|-----------|------------------|-----------|
| 다익스트라 | O(E log V) | ❌ | ❌ | 단일 시작점 |
| 벨만-포드 | O(VE) | ✅ | ✅ | 단일 시작점 |
| 플로이드-워셜 | O(V³) | ✅ | ✅ | 모든 쌍 |

## ⏰ 학습 스케줄

| 일차 | 학습 내용 | 소요 시간 |
|------|-----------|-----------|
| 1-3일 | 힙 자료구조 완전 정복 | 4-5시간 |
| 4-6일 | 우선순위 큐 구현과 활용 | 3-4시간 |
| 7-10일 | 다익스트라 알고리즘 | 5-6시간 |
| 11-12일 | 벨만-포드 알고리즘 | 3-4시간 |
| 13-14일 | 최단경로 응용 문제 | 4-5시간 |

## 🎉 학습 완료 체크리스트

- [ ] 힙의 삽입, 삭제 연산을 직접 구현할 수 있다
- [ ] Python heapq 모듈을 자유자재로 사용할 수 있다
- [ ] 다익스트라 알고리즘을 완전히 이해하고 구현할 수 있다
- [ ] 벨만-포드로 음수 사이클을 검출할 수 있다
- [ ] 필수 문제를 모두 해결했다

## 💡 핵심 알고리즘 구현

### 다익스트라 알고리즘
```python
import heapq

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    pq = [(0, start)]  # (distance, node)
    
    while pq:
        current_distance, current = heapq.heappop(pq)
        
        if current_distance > distances[current]:
            continue
            
        for neighbor, weight in graph[current].items():
            new_distance = current_distance + weight
            
            if new_distance < distances[neighbor]:
                distances[neighbor] = new_distance
                heapq.heappush(pq, (new_distance, neighbor))
    
    return distances
```

### 벨만-포드 알고리즘
```python  
def bellman_ford(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    
    # V-1번 반복하여 최단거리 갱신
    for _ in range(len(graph) - 1):
        for node in graph:
            for neighbor, weight in graph[node].items():
                if distances[node] + weight < distances[neighbor]:
                    distances[neighbor] = distances[node] + weight
    
    # 음수 사이클 검출
    for node in graph:
        for neighbor, weight in graph[node].items():
            if distances[node] + weight < distances[neighbor]:
                return None  # 음수 사이클 존재
    
    return distances
```

### 힙 직접 구현
```python
class MinHeap:
    def __init__(self):
        self.heap = []
    
    def push(self, val):
        self.heap.append(val)
        self._heapify_up(len(self.heap) - 1)
    
    def pop(self):
        if not self.heap:
            return None
        
        # 루트와 마지막 원소 교환
        self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]
        min_val = self.heap.pop()
        
        if self.heap:
            self._heapify_down(0)
        
        return min_val
    
    def _heapify_up(self, idx):
        parent = (idx - 1) // 2
        if parent >= 0 and self.heap[parent] > self.heap[idx]:
            self.heap[parent], self.heap[idx] = self.heap[idx], self.heap[parent]
            self._heapify_up(parent)
    
    def _heapify_down(self, idx):
        left = 2 * idx + 1
        right = 2 * idx + 2
        smallest = idx
        
        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:
            smallest = left
        
        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:
            smallest = right
        
        if smallest != idx:
            self.heap[idx], self.heap[smallest] = self.heap[smallest], self.heap[idx]
            self._heapify_down(smallest)
```

## ⚡ 최단경로 마스터 팁  

1. **그래프 표현**: 인접 리스트로 메모리 효율성 확보
2. **우선순위 큐**: heapq 모듈 적극 활용
3. **거리 배열**: 무한대로 초기화 후 갱신
4. **음수 간선**: 벨만-포드 알고리즘 선택

## 🎯 실전 응용

- **네비게이션**: 실제 최단경로 찾기
- **네트워크 라우팅**: 패킷 전송 경로 최적화
- **게임 AI**: NPC 이동 경로 계산
- **물류 최적화**: 배송 경로 최적화

## 🔥 다음 단계 예고

- **최소 신장 트리**: 크루스칼, 프림 알고리즘
- **위상 정렬**: DAG에서의 순서 결정
- **강연결 요소**: 그래프 분해 기법
- **최대 유량**: 네트워크 플로우 문제

---

**이전 주차**: [9-10주차: 그래프 이론 기초](../week9-10) ⬅️
**다음 주차**: [13-14주차: 탐욕법 & 분리 집합](../week13-14) ➡️

<div class="text-center">
  <a href="../week9-10" class="btn-secondary">← 이전 주차</a>
  <a href="../week13-14" class="btn">다음 주차로 →</a> 
</div>
```

### week13-14.md

**Path:** `frontend/public/posts/2024/week13-14.md`

```markdown
---
title: "13-14주차: 탐욕법 & 분리 집합"
date: "2024-08-25"
category: "Algorithm"
tags: ['탐욕법', '그리디', '크루스칼', '프림', 'Union-Find', 'MST']
excerpt: "탐욕 알고리즘의 핵심 원리를 이해하고, Union-Find 자료구조로 효율적인 집합 관리를 마스터한다"
readTime: "4분"
---

<div class="week-badge">13-14주차</div>

# 🎯 탐욕법 & 분리 집합

> **학습 목표**: 탐욕 알고리즘 완전 이해, Union-Find로 효율적 집합 관리 마스터

매 순간 최선의 선택을 통해 전체 최적해를 구하는 탐욕법과, 집합의 합집합과 찾기 연산을 효율적으로 처리하는 분리 집합을 학습합니다.

## 📖 주요 학습 내용

### 탐욕법(Greedy Algorithm)
- **탐욕 선택 속성**: 각 단계에서 최선의 선택
- **최적 부분 구조**: 전체 문제의 최적해 = 부분 문제들의 최적해
- **증명 방법**: 교환 논증(Exchange Argument)

### 최소 신장 트리(MST)  
- **크루스칼 알고리즘**: 간선을 가중치 순으로 정렬 후 선택
- **프림 알고리즘**: 정점 중심으로 MST 확장
- **MST의 성질**: n개 정점에 n-1개 간선

### 분리 집합(Disjoint Set)
- **Union 연산**: 두 집합을 하나로 합치기
- **Find 연산**: 원소가 속한 집합의 대표 찾기  
- **최적화 기법**: 경로 압축, 랭크 기반 합집합

## 🎯 추천 학습 자료

### 필수 자료
- **인프런**: 탐욕법 강의
- 『알고리즘 문제 해결 전략』 탐욕법 챕터
- **백준**: MST 분류 문제집

### 시각화 도구
- **MST Visualizer**: 크루스칼, 프림 알고리즘 시각화
- **Union-Find Visualization**: 경로 압축 과정

## 💻 실습 문제

### 필수 문제
```markdown
🟡 BOJ 1197: 최소 스패닝 트리
   - 크루스칼 또는 프림 알고리즘
   - 난이도: ⭐⭐⭐

🟡 BOJ 1717: 집합의 표현
   - Union-Find 기본 문제
   - 난이도: ⭐⭐⭐
```

### 추가 연습 문제
- BOJ 1931: 회의실 배정 (활동 선택)
- BOJ 11047: 동전 0 (탐욕법)
- BOJ 1976: 여행 가자 (Union-Find)
- BOJ 4386: 별자리 만들기 (MST)

## 📊 MST 알고리즘 비교

| 알고리즘 | 시간복잡도 | 공간복잡도 | 구현 복잡도 | 특징 |
|----------|------------|------------|-------------|------|
| 크루스칼 | O(E log E) | O(V) | 중간 | 간선 중심, Union-Find 필요 |
| 프림 | O(E log V) | O(V) | 쉬움 | 정점 중심, 우선순위 큐 사용 |

## ⏰ 학습 스케줄

| 일차 | 학습 내용 | 소요 시간 |
|------|-----------|-----------|
| 1-2일 | 탐욕법 기본 개념과 증명 | 3-4시간 |
| 3-5일 | 활동 선택, 동전 문제 | 3-4시간 |
| 6-8일 | Union-Find 완전 정복 | 4-5시간 |
| 9-11일 | 크루스칼 알고리즘 | 4-5시간 |
| 12-14일 | 프림 알고리즘과 응용 | 4-5시간 |

## 🎉 학습 완료 체크리스트

- [ ] 탐욕법이 적용 가능한 문제를 구분할 수 있다
- [ ] Union-Find를 경로 압축과 함께 구현할 수 있다
- [ ] 크루스칼 알고리즘을 완전히 이해하고 구현할 수 있다
- [ ] 프림 알고리즘의 원리를 이해했다
- [ ] MST의 유일성 조건을 알고 있다

## 💡 핵심 알고리즘 구현

### 크루스칼 알고리즘
```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 경로 압축
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        
        # 랭크 기반 합집합
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        return True

def kruskal(n, edges):
    edges.sort(key=lambda x: x[2])  # 가중치로 정렬
    uf = UnionFind(n)
    mst_cost = 0
    mst_edges = []
    
    for u, v, weight in edges:
        if uf.union(u, v):
            mst_cost += weight
            mst_edges.append((u, v, weight))
            
            if len(mst_edges) == n - 1:  # MST 완성
                break
    
    return mst_cost, mst_edges
```

### 프림 알고리즘
```python
import heapq

def prim(graph, start):
    mst_cost = 0
    visited = set([start])
    edges = [(weight, start, neighbor) for neighbor, weight in graph[start]]
    heapq.heapify(edges)
    
    while edges and len(visited) < len(graph):
        weight, u, v = heapq.heappop(edges)
        
        if v not in visited:
            visited.add(v)
            mst_cost += weight
            
            # 새로 추가된 정점의 간선들을 힙에 추가
            for neighbor, edge_weight in graph[v]:
                if neighbor not in visited:
                    heapq.heappush(edges, (edge_weight, v, neighbor))
    
    return mst_cost
```

### 탐욕법 예시: 활동 선택 문제
```python
def activity_selection(activities):
    # 종료 시간으로 정렬
    activities.sort(key=lambda x: x[1])
    
    selected = [activities[0]]
    last_end_time = activities[0][1]
    
    for start, end in activities[1:]:
        if start >= last_end_time:  # 겹치지 않으면 선택
            selected.append((start, end))
            last_end_time = end
    
    return selected
```

## ⚡ 탐욕법 적용 전략

### 탐욕법 적용 가능 여부 판단
1. **탐욕 선택 속성**: 각 단계의 최선 선택이 전체 최적해로 이어지는가?
2. **최적 부분 구조**: 부분 문제의 최적해가 전체 최적해에 포함되는가?
3. **반례 검토**: 탐욕 선택이 실패하는 경우가 있는가?

### 대표적인 탐욕법 문제 패턴
- **활동 선택**: 종료 시간 기준 정렬
- **분할 가능 배낭**: 단위 무게당 가치 기준  
- **최소 신장 트리**: 최소 가중치 간선 우선 선택
- **최단 경로**: 다익스트라 알고리즘

## 🔍 Union-Find 최적화

### 경로 압축(Path Compression)
```python
def find_with_compression(self, x):
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])  # 재귀적 압축
    return self.parent[x]
```

### 랭크 기반 합집합(Union by Rank)
```python
def union_by_rank(self, x, y):
    px, py = self.find(x), self.find(y)
    if px == py:
        return False
    
    if self.rank[px] < self.rank[py]:
        self.parent[px] = py
    elif self.rank[px] > self.rank[py]:
        self.parent[py] = px
    else:
        self.parent[py] = px
        self.rank[px] += 1
    return True
```

## 🎯 실전 응용

- **네트워크 설계**: 최소 비용으로 모든 노드 연결
- **클러스터링**: 비슷한 데이터 그룹화
- **이미지 분할**: 연결된 영역 찾기
- **소셜 네트워크**: 친구 관계 그룹 분석

---

**이전 주차**: [11-12주차: 고급 자료구조 및 최단경로](../week11-12) ⬅️
**다음 주차**: [15-16주차: 고급 DP 및 기타 주제](../week15-16) ➡️

<div class="text-center">
  <a href="../week11-12" class="btn-secondary">← 이전 주차</a>
  <a href="../week15-16" class="btn">다음 주차로 →</a>
</div>
```

### week15-16.md

**Path:** `frontend/public/posts/2024/week15-16.md`

```markdown
---
title: "15-16주차: 고급 DP 및 기타 주제"
date: "2024-09-17"
category: "Algorithm"
tags: ['고급DP', '비트마스크', '트리DP', 'KMP', '문자열알고리즘']
excerpt: "비트마스크 DP와 트리 DP의 고급 기법을 마스터하고, 문자열 알고리즘의 기초를 다진다"
readTime: "5분"
---

<div class="week-badge">15-16주차</div>

# 🚀 고급 DP 및 기타 주제

> **학습 목표**: 고난도 DP(비트마스크, 트리 DP) 정복, 문자열 알고리즘 기초 확립

알고리즘 학습의 마지막 단계로, 고급 동적 계획법 기법과 실전에서 자주 사용되는 문자열 처리 알고리즘을 학습합니다.

## 📖 주요 학습 내용

### 비트마스크 DP
- **상태 압축**: 집합을 비트로 표현하여 메모리 효율성 증대
- **외판원 순회(TSP)**: 비트마스크 DP의 대표 문제
- **비트 연산**: AND, OR, XOR을 이용한 집합 연산

### 트리 DP
- **트리 순회 활용**: DFS를 통한 부모-자식 관계 이용
- **서브트리 정보**: 아래에서 위로 정보 전달
- **루트 변경**: 모든 정점을 루트로 하는 경우 계산

### 문자열 알고리즘 기초
- **KMP 알고리즘**: 효율적인 패턴 매칭 O(n+m)
- **라빈-카프**: 해싱을 이용한 문자열 검색
- **Z 알고리즘**: 접두사와 접미사 매칭

## 🎯 추천 학습 자료

### 필수 자료
- **백준**: 고급 DP 문제 정리
- 『Competitive Programming』 문자열 챕터
- **GeeksforGeeks**: KMP Algorithm Tutorial

### 고급 참고서
- 『Introduction to Algorithms』 문자열 알고리즘
- IOI/ACM-ICPC 기출 문제집

## 💻 실습 문제

### 필수 문제
```markdown
🔴 BOJ 2098: 외판원 순회
   - 비트마스크 DP의 최고 난이도 문제
   - 난이도: ⭐⭐⭐⭐⭐

🟡 BOJ 1786: 찾기
   - KMP 알고리즘 기본 문제
   - 난이도: ⭐⭐⭐⭐
```

### 추가 연습 문제
- BOJ 1005: ACM Craft (위상정렬 + DP)
- BOJ 2533: 사회망 서비스 (트리 DP)
- BOJ 9252: LCS 2 (경로 추적)
- BOJ 1305: 광고 (KMP 응용)

## 📊 문자열 알고리즘 비교

| 알고리즘 | 시간복잡도 | 전처리 시간 | 특징 |
|----------|------------|-------------|------|
| 브루트 포스 | O(nm) | O(1) | 간단하지만 비효율적 |
| KMP | O(n+m) | O(m) | 실패 함수 활용 |
| 라빈-카프 | O(n+m) | O(m) | 해싱 기반, 다중 패턴 가능 |
| Z 알고리즘 | O(n+m) | O(m) | 접두사 매칭 특화 |

## ⏰ 학습 스케줄

| 일차 | 학습 내용 | 소요 시간 |
|------|-----------|-----------|
| 1-3일 | 비트마스크 기초와 집합 연산 | 4-5시간 |
| 4-7일 | 외판원 순회 문제 완전 정복 | 6-8시간 |
| 8-10일 | 트리 DP 개념과 구현 | 4-5시간 |
| 11-12일 | KMP 알고리즘 마스터 | 4-5시간 |
| 13-14일 | 라빈-카프와 종합 복습 | 4-5시간 |

## 🎉 학습 완료 체크리스트

- [ ] 비트 연산을 자유자재로 사용할 수 있다
- [ ] 외판원 순회 문제의 점화식을 이해했다
- [ ] 트리에서 DP를 적용할 수 있다
- [ ] KMP의 실패 함수를 구현할 수 있다
- [ ] 16주 커리큘럼을 모두 완주했다! 🎉

## 💡 핵심 알고리즘 구현

### 외판원 순회 (TSP)
```python
def tsp(dist, n):
    # dp[mask][i] = mask 집합을 방문하고 i에서 끝나는 최소 비용
    dp = [[float('inf')] * n for _ in range(1 << n)]
    dp[1][0] = 0  # 시작점에서 출발
    
    for mask in range(1 << n):
        for i in range(n):
            if not (mask & (1 << i)) or dp[mask][i] == float('inf'):
                continue
                
            for j in range(n):
                if mask & (1 << j):  # 이미 방문한 도시
                    continue
                    
                new_mask = mask | (1 << j)
                dp[new_mask][j] = min(dp[new_mask][j], 
                                     dp[mask][i] + dist[i][j])
    
    # 모든 도시를 방문하고 시작점으로 돌아가는 최소 비용
    result = float('inf')
    full_mask = (1 << n) - 1
    for i in range(1, n):
        if dp[full_mask][i] != float('inf'):
            result = min(result, dp[full_mask][i] + dist[i][0])
    
    return result
```

### KMP 알고리즘
```python
def compute_lps(pattern):
    """최장 공통 접두사-접미사 배열 계산"""
    m = len(pattern)
    lps = [0] * m
    length = 0
    i = 1
    
    while i < m:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(text, pattern):
    """KMP를 이용한 패턴 매칭"""
    n, m = len(text), len(pattern)
    lps = compute_lps(pattern)
    
    matches = []
    i = j = 0  # text와 pattern의 인덱스
    
    while i < n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
        
        if j == m:  # 패턴 발견
            matches.append(i - j)
            j = lps[j - 1]
        elif i < n and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return matches
```

### 트리 DP 예시
```python
def tree_dp(graph, root):
    """트리에서 각 노드를 루트로 하는 서브트리 크기 계산"""
    visited = set()
    subtree_size = {}
    
    def dfs(node):
        visited.add(node)
        size = 1
        
        for child in graph[node]:
            if child not in visited:
                size += dfs(child)
        
        subtree_size[node] = size
        return size
    
    dfs(root)
    return subtree_size
```

## ⚡ 고급 DP 마스터 팁

### 비트마스크 DP 핵심
1. **상태 표현**: 집합을 비트로 효율적 표현
2. **비트 연산**: `|`(합집합), `&`(교집합), `^`(대칭차집합)
3. **메모이제이션**: 2^n 크기의 배열로 상태 저장
4. **최적화**: 불필요한 상태 건너뛰기

### 문자열 알고리즘 활용
1. **KMP**: 접두사와 접미사의 최대 일치 길이 활용
2. **해싱**: 빠른 문자열 비교를 위한 롤링 해시
3. **Z 배열**: 각 위치에서 접두사와의 최대 일치 길이

## 🏆 16주 완주 축하!

축하합니다! 🎉 16주간의 알고리즘 여정을 완주하셨습니다.

### 여러분이 마스터한 것들:
- ✅ **기초 자료구조**: 배열, 스택, 큐, 힙
- ✅ **핵심 알고리즘**: 정렬, 탐색, 재귀, DP
- ✅ **그래프 이론**: BFS, DFS, 최단경로, MST
- ✅ **고급 기법**: 비트마스크 DP, 문자열 알고리즘

### 다음 도전 과제:
- 🔥 **고급 그래프**: 강연결 요소, 네트워크 플로우
- 🔥 **기하 알고리즘**: 컨벡스 헐, 선분 교차
- 🔥 **수학적 알고리즘**: 소수 판정, 정수론
- 🔥 **실전 코딩테스트**: 삼성, 카카오, 구글 문제

## 💪 지속적인 성장을 위한 조언

1. **꾸준한 연습**: 매일 1-2문제씩 해결하는 습관 유지
2. **코드 리뷰**: 다른 사람의 코드와 비교하며 개선점 찾기
3. **대회 참여**: 온라인 저지, 코딩 대회 적극 참여
4. **개념 정리**: 배운 내용을 블로그나 노트로 정리

**여러분은 이제 알고리즘 중급자입니다!** 🚀

---

**이전 주차**: [13-14주차: 탐욕법 & 분리 집합](../week13-14) ⬅️
**처음으로**: [알고리즘 커리큘럼 홈](../) 🏠

<div class="text-center">
  <a href="../week13-14" class="btn-secondary">← 이전 주차</a>
  <a href="../" class="btn">커리큘럼 홈으로</a>
</div>
```

### week3-4.md

**Path:** `frontend/public/posts/2024/week3-4.md`

```markdown
---
title: "3-4주차: 정렬 및 탐색 기법"
date: "2024-09-23"
category: "Algorithm"
tags: ['정렬', '탐색', '이진탐색', '시간복잡도', '알고리즘']
excerpt: "핵심 정렬 알고리즘과 이진 탐색을 마스터하여 효율적인 데이터 처리의 기초를 다진다"
readTime: "3분"
---

<div class="week-badge">3-4주차</div>

# 🔄 정렬 및 탐색 기법

> **학습 목표**: 주요 정렬 알고리즘 구현 및 시간복잡도 이해, 이진 탐색 마스터

데이터를 효율적으로 정리하고 찾는 것은 프로그래밍의 핵심입니다. 이번 주차에서는 가장 중요한 정렬과 탐색 알고리즘들을 깊이 있게 학습합니다.

## 📖 주요 학습 내용

### 정렬 알고리즘
- **버블 정렬**: O(n²) - 기본 개념 이해
- **선택 정렬**: O(n²) - 최솟값 찾기 원리  
- **삽입 정렬**: O(n²) - 부분 정렬된 배열에 효율적
- **병합 정렬**: O(n log n) - 분할 정복의 대표 사례
- **퀵 정렬**: O(n log n) - 실전에서 가장 빠른 정렬

### 탐색 기법
- **선형 탐색**: O(n) - 순차적 검색
- **이진 탐색**: O(log n) - 정렬된 배열에서의 효율적 검색
- **이진 탐색 트리**: 동적 검색 구조의 기초

## 🎯 추천 학습 자료

### 필수 교재
- 『알고리즘 문제 해결 전략』 정렬 챕터
- 백준 알고리즘 정렬 분류 문제 목록

### 시각화 도구
- **VisuAlgo**: 정렬 과정 시각화
- **Sorting Algorithms Animations**: 다양한 정렬 비교

## 💻 실습 문제

### 필수 문제
```markdown
🟢 BOJ 2750: 수 정렬하기
   - 기본 정렬 구현
   - 난이도: ⭐

🟡 BOJ 1920: 수 찾기
   - 이진 탐색 활용
   - 난이도: ⭐⭐
```

### 추가 연습 문제
- BOJ 2751: 수 정렬하기 2 (병합정렬/퀵정렬)
- BOJ 10989: 수 정렬하기 3 (계수정렬)
- BOJ 1654: 랜선 자르기 (매개변수 탐색)

## 📊 시간복잡도 비교표

| 정렬 알고리즘 | 최선 | 평균 | 최악 | 공간복잡도 |
|---------------|------|------|------|------------|
| 버블 정렬 | O(n) | O(n²) | O(n²) | O(1) |
| 선택 정렬 | O(n²) | O(n²) | O(n²) | O(1) |
| 삽입 정렬 | O(n) | O(n²) | O(n²) | O(1) |
| 병합 정렬 | O(n log n) | O(n log n) | O(n log n) | O(n) |
| 퀵 정렬 | O(n log n) | O(n log n) | O(n²) | O(log n) |

## ⏰ 학습 스케줄

| 일차 | 학습 내용 | 소요 시간 |
|------|-----------|-----------|
| 1-3일 | 기본 정렬(버블, 선택, 삽입) | 4-5시간 |
| 4-6일 | 고급 정렬(병합, 퀵) | 4-5시간 |
| 7-9일 | 이진 탐색 완전 정복 | 3-4시간 |
| 10-14일 | 문제 풀이 및 응용 | 매일 2시간 |

## 🎉 학습 완료 체크리스트

- [ ] 5가지 정렬 알고리즘을 직접 구현할 수 있다
- [ ] 각 정렬의 시간복잡도를 정확히 알고 있다
- [ ] 이진 탐색을 반복문과 재귀로 모두 구현할 수 있다  
- [ ] 언제 어떤 정렬을 사용해야 하는지 판단할 수 있다
- [ ] 필수 문제를 모두 해결했다

## 💡 핵심 코드 스니펫

### 이진 탐색 구현
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1
```

## ⚡ 실전 팁

1. **정렬은 Python sorted() 사용**: 실전에서는 내장 함수 활용
2. **이진 탐색 직접 구현**: bisect 모듈 사용 전 원리 이해 필수
3. **경계 조건 주의**: left ≤ right, mid 계산 오버플로우 고려
4. **시간 제한 체크**: O(n²) vs O(n log n) 선택 기준 명확히

---

**이전 주차**: [1-2주차: 기초 수학 및 자료구조](../week1-2) ⬅️
**다음 주차**: [5-6주차: 재귀와 분할 정복](../week5-6) ➡️

<div class="text-center">
  <a href="../week1-2" class="btn-secondary">← 이전 주차</a>
  <a href="../week5-6" class="btn">다음 주차로 →</a>
</div>
```

### week5-6.md

**Path:** `frontend/public/posts/2024/week5-6.md`

```markdown
---
title: "5-6주차: 재귀와 분할 정복"
date: "2024-09-09"
category: "Algorithm"
tags: ['재귀', '분할정복', '하노이탑', '피보나치', '알고리즘']
excerpt: "재귀적 사고를 통한 문제 해결과 분할 정복 패러다임의 강력함을 경험한다"
readTime: "3분"
---

<div class="week-badge">5-6주차</div>

# 🔄 재귀와 분할 정복

> **학습 목표**: 재귀적 사고력 배양, 분할 정복 패러다임 완전 이해

복잡한 문제를 작은 부분으로 나누어 해결하는 강력한 기법을 학습합니다. 재귀는 알고리즘의 꽃이자 많은 고급 알고리즘의 기초가 됩니다.

## 📖 주요 학습 내용

### 재귀(Recursion) 기초
- **재귀 함수의 구조**: Base case + Recursive case
- **재귀 호출 스택**: 메모리 사용과 스택 오버플로우
- **꼬리 재귀**: 최적화 기법

### 고전적 재귀 문제
- **팩토리얼**: n! = n × (n-1)!
- **피보나치 수열**: F(n) = F(n-1) + F(n-2)  
- **하노이의 탑**: 고전적인 재귀 문제

### 분할 정복(Divide & Conquer)
- **분할**: 문제를 작은 단위로 나누기
- **정복**: 각 부분 문제 해결
- **결합**: 부분 해답을 전체 해답으로 조합

## 🎯 추천 학습 자료

### 온라인 자료
- **GeeksforGeeks**: Recursion Tutorial
- **YouTube**: 재귀 시각화 영상들
- **LeetCode**: Recursion 카드 문제집

### 필수 개념
- 재귀 관계식(Recurrence Relation)
- 시간복잡도 분석 (Master Theorem)

## 💻 실습 문제

### 필수 문제
```markdown
🟢 BOJ 10870: 피보나치 수 5
   - 기본 재귀 구현
   - 난이도: ⭐

🔴 BOJ 11729: 하노이 탑 이동 순서
   - 분할 정복의 완벽한 예시
   - 난이도: ⭐⭐⭐
```

### 추가 연습 문제
- BOJ 10872: 팩토리얼
- BOJ 2447: 별 찍기 - 10 (프랙탈)
- BOJ 1074: Z (분할 정복)

## 🧠 재귀 사고 과정

### 하노이의 탑 문제 분석
```
n개의 원판을 A에서 C로 옮기기:
1. n-1개를 A에서 B로 옮기기
2. 가장 큰 원판을 A에서 C로 옮기기  
3. n-1개를 B에서 C로 옮기기

이동 횟수: T(n) = 2T(n-1) + 1 = 2^n - 1
```

## ⏰ 학습 스케줄

| 일차 | 학습 내용 | 소요 시간 |
|------|-----------|-----------|
| 1-2일 | 재귀 기본 개념과 구조 | 3-4시간 |
| 3-5일 | 팩토리얼, 피보나치 구현 | 3-4시간 |
| 6-8일 | 하노이 탑 완전 정복 | 4-5시간 |
| 9-12일 | 분할 정복 심화 학습 | 4-5시간 |
| 13-14일 | 종합 문제 풀이 | 3-4시간 |

## 🎉 학습 완료 체크리스트

- [ ] 재귀 함수의 동작 원리를 완전히 이해했다
- [ ] Base case와 Recursive case를 명확히 구분할 수 있다
- [ ] 하노이의 탑 문제를 스스로 풀 수 있다
- [ ] 재귀의 시간복잡도를 분석할 수 있다  
- [ ] 스택 오버플로우 위험성을 인지하고 있다

## 💡 핵심 코드 스니펫

### 피보나치 수열 (메모이제이션)
```python
def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    
    if n <= 1:
        return n
    
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]
```

### 하노이의 탑
```python
def hanoi(n, start, end, aux):
    if n == 1:
        print(f"{start} {end}")
        return
    
    hanoi(n-1, start, aux, end)    # Step 1
    print(f"{start} {end}")        # Step 2  
    hanoi(n-1, aux, end, start)    # Step 3
```

## ⚡ 재귀 마스터 팁

1. **그림으로 그리기**: 재귀 호출 트리를 직접 그려보세요
2. **작은 예시부터**: n=1, 2, 3일 때부터 차근차근 확인
3. **메모이제이션**: 중복 계산 방지로 효율성 향상
4. **반복문 변환**: 재귀를 반복문으로 바꿔보는 연습

## 🔥 심화 도전

- **프랙탈 패턴**: 칸토어 집합, 시에르핀스키 삼각형
- **백트래킹 기초**: N-Queen 문제 예고
- **동적 계획법 연결**: 재귀 + 메모이제이션 = DP

---

**이전 주차**: [3-4주차: 정렬 및 탐색 기법](../week3-4) ⬅️
**다음 주차**: [7-8주차: 동적 계획법 기초](../week7-8) ➡️

<div class="text-center">
  <a href="../week3-4" class="btn-secondary">← 이전 주차</a>
  <a href="../week7-8" class="btn">다음 주차로 →</a>
</div>
```

### week7-8.md

**Path:** `frontend/public/posts/2024/week7-8.md`

```markdown
---
title: "7-8주차: 동적 계획법(DP) 기초"
date: "2024-09-13"
category: "Algorithm"
tags: ['동적계획법', 'DP', '메모이제이션', '최적화', '알고리즘']
excerpt: "최적 부분 구조와 중복 부분 문제를 이용한 효율적 문제 해결 기법을 마스터한다"
readTime: "3분"
---

<div class="week-badge">7-8주차</div>

# 💎 동적 계획법(DP) 기초

> **학습 목표**: DP의 핵심 원리(최적 부분 구조·중복 부분 문제) 완전 이해

알고리즘의 꽃이라 불리는 동적 계획법을 본격적으로 학습합니다. 복잡한 최적화 문제를 효율적으로 해결하는 강력한 패러다임입니다.

## 📖 주요 학습 내용

### 동적 계획법 핵심 개념
- **최적 부분 구조**: 큰 문제의 최적해가 작은 문제들의 최적해로 구성
- **중복 부분 문제**: 같은 하위 문제가 여러 번 반복
- **메모이제이션**: 계산 결과를 저장하여 중복 계산 방지

### DP 구현 방식
- **Top-down**: 재귀 + 메모이제이션
- **Bottom-up**: 반복문을 이용한 테이블 채우기

### 1차원 DP 문제들
- **계단 오르기**: 경우의 수 계산
- **최대 연속 합**: 카데인 알고리즘
- **가장 긴 증가하는 부분 수열(LIS)**

### 2차원 DP 입문
- **최장 공통 부분 수열(LCS)**
- **편집 거리**: 문자열 간 최소 편집 횟수

## 🎯 추천 학습 자료

### 필수 자료
- **프로그래머스**: DP 입문 강의
- **백준**: DP 분류 문제집
- 『알고리즘 문제 해결 전략』 DP 챕터

### 시각화 도구
- **DP Visualizer**: 상태 전이 과정 시각화
- **LeetCode**: DP 패턴별 문제 모음

## 💻 실습 문제

### 필수 문제
```markdown
🟡 BOJ 10844: 쉬운 계단 수
   - 1차원 DP의 대표 문제
   - 난이도: ⭐⭐⭐

🟡 BOJ 11053: 가장 긴 증가하는 부분 수열
   - LIS 알고리즘 기초
   - 난이도: ⭐⭐⭐
```

### 추가 연습 문제  
- BOJ 1463: 1로 만들기
- BOJ 9095: 1, 2, 3 더하기
- BOJ 2579: 계단 오르기
- BOJ 1149: RGB거리

## 📊 DP 문제 해결 단계

### 1단계: 문제 분석
```
1. 최적 부분 구조 확인
2. 중복 부분 문제 식별  
3. 상태(State) 정의
4. 점화식 도출
```

### 2단계: 구현 선택
```
Top-down: 직관적, 재귀 깊이 주의
Bottom-up: 효율적, 공간 최적화 가능
```

## ⏰ 학습 스케줄

| 일차 | 학습 내용 | 소요 시간 |
|------|-----------|-----------|
| 1-2일 | DP 개념과 피보나치 최적화 | 3-4시간 |
| 3-5일 | 1차원 DP 문제들 | 4-5시간 |
| 6-8일 | 계단 오르기, 1로 만들기 | 4-5시간 |
| 9-11일 | LIS, LCS 학습 | 5-6시간 |
| 12-14일 | 종합 문제 풀이 | 매일 2-3시간 |

## 🎉 학습 완료 체크리스트

- [ ] DP의 두 가지 조건을 명확히 이해했다
- [ ] Top-down과 Bottom-up 방식을 모두 구현할 수 있다
- [ ] 1차원 DP 점화식을 스스로 도출할 수 있다  
- [ ] LIS 알고리즘을 완전히 이해했다
- [ ] 필수 문제를 모두 해결했다

## 💡 핵심 코드 패턴

### LIS (O(n²) 버전)
```python
def lis(arr):
    n = len(arr)
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if arr[j] < arr[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)
```

### 계단 오르기
```python
def stairs(n, cost):
    if n <= 2:
        return cost[n-1]
    
    dp = [0] * n
    dp[0] = cost[0]
    dp[1] = cost[1]
    
    for i in range(2, n):
        dp[i] = cost[i] + min(dp[i-1], dp[i-2])
    
    return min(dp[n-1], dp[n-2])
```

## ⚡ DP 마스터 전략

1. **상태 정의가 핵심**: dp[i]가 무엇을 의미하는지 명확히
2. **점화식 도출**: 작은 예시로 규칙 찾기
3. **초기값 설정**: Base case 신중히 설정
4. **공간 최적화**: 이전 값만 필요하면 배열 크기 줄이기

## 🔥 다음 단계 예고

- **2차원 DP 심화**: 배낭 문제, 편집 거리
- **비트마스크 DP**: 상태 압축 기법
- **트리 DP**: 트리 구조에서의 동적 계획법
- **확률 DP**: 기댓값 계산 문제

---

**이전 주차**: [5-6주차: 재귀와 분할 정복](../week5-6) ⬅️  
**다음 주차**: [9-10주차: 그래프 이론 기초](../week9-10) ➡️

<div class="text-center">
  <a href="../week5-6" class="btn-secondary">← 이전 주차</a>
  <a href="../week9-10" class="btn">다음 주차로 →</a>
</div>
```

### week9-10.md

**Path:** `frontend/public/posts/2024/week9-10.md`

```markdown
---
title: "9-10주차: 그래프 이론 기초"
date: "2024-07-10"
category: "Algorithm"
tags: ['그래프', 'BFS', 'DFS', '탐색', '알고리즘']
excerpt: "그래프의 표현 방법과 BFS, DFS 탐색 알고리즘을 완벽하게 마스터한다"
readTime: "4분"
---

<div class="week-badge">9-10주차</div>

# 🕸️ 그래프 이론 기초

> **학습 목표**: 그래프 표현 방법 완전 이해, BFS·DFS 탐색 알고리즘 마스터

실세계의 복잡한 관계를 모델링하는 그래프 자료구조를 학습합니다. 많은 고급 알고리즘의 기초가 되는 중요한 단원입니다.

## 📖 주요 학습 내용

### 그래프 기본 개념
- **정점(Vertex)과 간선(Edge)**: 그래프의 구성 요소
- **무향 그래프 vs 유향 그래프**: 방향성에 따른 분류
- **가중 그래프**: 간선에 비용이 있는 그래프
- **연결 그래프**: 모든 정점이 연결된 그래프

### 그래프 표현 방법
- **인접 행렬(Adjacency Matrix)**: 2차원 배열로 표현
- **인접 리스트(Adjacency List)**: 연결 리스트로 표현
- **간선 리스트(Edge List)**: 간선들의 집합으로 표현

### 그래프 탐색 알고리즘
- **깊이 우선 탐색(DFS)**: 스택을 이용한 깊이 탐색
- **너비 우선 탐색(BFS)**: 큐를 이용한 레벨별 탐색

## 🎯 추천 학습 자료

### 필수 자료
- **생활코딩**: 그래프 이론 강의
- **백준**: 그래프 탐색 분류 문제집
- **GeeksforGeeks**: Graph Data Structure

### 시각화 도구
- **Graph Visualizer**: 탐색 과정 시각화
- **VisuAlgo**: 그래프 알고리즘 애니메이션

## 💻 실습 문제

### 필수 문제
```markdown
🟢 BOJ 1260: DFS와 BFS
   - 그래프 탐색의 기본 문제
   - 난이도: ⭐⭐

🟡 BOJ 2178: 미로 탐색  
   - BFS를 이용한 최단 경로
   - 난이도: ⭐⭐⭐
```

### 추가 연습 문제
- BOJ 2606: 바이러스 (DFS/BFS)
- BOJ 1012: 유기농 배추 (연결 요소)
- BOJ 7576: 토마토 (BFS 응용)
- BOJ 2667: 단지번호붙이기

## 📊 그래프 표현 방법 비교

| 표현 방법 | 공간복잡도 | 간선 존재 확인 | 모든 간선 탐색 | 특징 |
|-----------|------------|----------------|----------------|------|
| 인접 행렬 | O(V²) | O(1) | O(V²) | 밀집 그래프에 적합 |
| 인접 리스트 | O(V+E) | O(V) | O(V+E) | 희소 그래프에 적합 |

## ⏰ 학습 스케줄

| 일차 | 학습 내용 | 소요 시간 |
|------|-----------|-----------|
| 1-2일 | 그래프 기본 개념과 표현 | 3-4시간 |
| 3-5일 | DFS 완전 정복 | 4-5시간 |
| 6-8일 | BFS 완전 정복 | 4-5시간 |
| 9-11일 | 미로 탐색, 연결 요소 | 4-5시간 |
| 12-14일 | 종합 문제 풀이 | 매일 2-3시간 |

## 🎉 학습 완료 체크리스트

- [ ] 인접 행렬과 인접 리스트를 모두 구현할 수 있다
- [ ] DFS를 재귀와 스택으로 모두 구현할 수 있다
- [ ] BFS를 큐를 이용해 정확히 구현할 수 있다
- [ ] 미로에서 최단 경로를 찾을 수 있다
- [ ] 연결 요소의 개수를 구할 수 있다

## 💡 핵심 코드 구현

### DFS (재귀 방식)
```python
def dfs(graph, start, visited):
    visited[start] = True
    print(start, end=' ')
    
    for neighbor in graph[start]:
        if not visited[neighbor]:
            dfs(graph, neighbor, visited)
```

### BFS (큐 방식)  
```python
from collections import deque

def bfs(graph, start):
    visited = [False] * len(graph)
    queue = deque([start])
    visited[start] = True
    
    while queue:
        vertex = queue.popleft()
        print(vertex, end=' ')
        
        for neighbor in graph[vertex]:
            if not visited[neighbor]:
                visited[neighbor] = True
                queue.append(neighbor)
```

### 미로 탐색 (BFS)
```python
def maze_bfs(maze, start, end):
    directions = [(0,1), (1,0), (0,-1), (-1,0)]  # 상하좌우
    queue = deque([(start[0], start[1], 0)])  # (x, y, distance)
    visited = set([start])
    
    while queue:
        x, y, dist = queue.popleft()
        
        if (x, y) == end:
            return dist
            
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if (nx, ny) not in visited and maze[nx][ny] == 1:
                visited.add((nx, ny))
                queue.append((nx, ny, dist + 1))
    
    return -1  # 경로가 없는 경우
```

## ⚡ 그래프 탐색 핵심 팁

1. **방문 체크**: visited 배열로 무한루프 방지
2. **DFS는 깊이**: 한 방향으로 끝까지 탐색
3. **BFS는 레벨**: 가까운 정점부터 차례로 탐색  
4. **최단 경로는 BFS**: 가중치가 없는 그래프에서

## 🔍 응용 분야

- **연결 요소 찾기**: DFS/BFS로 그래프 분할
- **사이클 검출**: DFS로 역방향 간선 찾기
- **위상 정렬**: DAG에서 순서 결정
- **이분 그래프**: BFS로 색칠 가능성 판단

## 🔥 다음 단계 예고

- **최단 경로**: 다익스트라, 벨만-포드 알고리즘
- **최소 신장 트리**: 크루스칼, 프림 알고리즘  
- **강연결 요소**: 타잔, 코사라주 알고리즘
- **네트워크 플로우**: 최대 유량 문제

---

**이전 주차**: [7-8주차: 동적 계획법 기초](../week7-8) ⬅️
**다음 주차**: [11-12주차: 고급 자료구조 및 최단경로](../week11-12) ➡️

<div class="text-center">
  <a href="../week7-8" class="btn-secondary">← 이전 주차</a>
  <a href="../week11-12" class="btn">다음 주차로 →</a>
</div>
```

---

## frontend/public/posts/2025

### 5g-intelligent-fabric-journal.md

**Path:** `frontend/public/posts/2025/5g-intelligent-fabric-journal.md`

```markdown
---
title: "5G 기지국 그림자에서, 슬라이스와 에지가 만든 새로운 질서"
date: "2025-10-23"
category: "Network"
tags: ['5G', '네트워크슬라이싱', '에지컴퓨팅', 'URLLC', '제로트러스트']
excerpt: "URLLC, 슬라이스, 에지 노드를 직접 구축하며 5G가 사람과 기계를 동시에 품어내는 과정을 기록했다"
readTime: "11분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

2020년 가을, 나는 도심 한복판에 세워진 5G 기지국 아래에서 태블릿을 들고 서 있었다. 초광대역 eMBB 신호를 받아 VR 스트리밍을 띄우는 동안에도, 바로 옆 공장에서는 URLLC 슬라이스를 타고 움직이는 산업용 로봇이 정확한 궤적을 그렸다. 한 기지국에서 전혀 다른 요구를 가진 서비스들이 동시에 뛰어다니는 광경은 나에게 “네트워크가 진짜로 다중 인격을 가진 시대가 왔다”라는 확신을 주었다. 나는 그날 일지의 첫 줄에 이렇게 적었다. “5G는 속도 이야기가 아니라, 서로 다른 생명을 위한 맞춤형 통신이다.”

통신사 랩에 돌아와 네트워크 슬라이싱 오케스트레이터를 켜면, 하나의 물리 인프라 위에서 각기 다른 SLA를 가진 가상 네트워크가 순식간에 솟아난다. 공공 안전용 슬라이스에는 암호화 정책과 전용 대역폭을 할당하고, 미디어 슬라이스에는 고대역 스트리밍과 CDN 연동 설정을 더한다. 슬라이스 설계를 처음 맡았을 때만 해도 종이에 표를 그리며 용도별 QoS를 계산했는데, 이제는 YAML 템플릿과 API 호출로 자동화된 구성이 가능하다. 그래도 나는 여전히 슬라이스가 제대로 격리되는지, 지연 지표가 SLA 안에 머무는지 매번 눈으로 확인한다. “네트워크가 똑똑해질수록, 운영자는 더 꼼꼼해져야 한다”는 선배의 말이 귓가를 맴돈다.

URLLC를 상징하는 한 장면은 원격 로봇 수술 데모였다. 헬스케어 스타트업과 함께 지연 시간을 1ms 아래로 낮추기 위해 코어 네트워크의 경로를 손수 뜯어고쳤고, 에지 클라우드 노드에 추론 엔진을 배치했다. 에지에 설치된 MEC 서버의 팬 소리가 작게 돌고 있던 그날, 외과의의 손끝 움직임이 거의 실시간으로 로봇 팔에 전달되자 회의실의 공기가 바뀌었다. 나는 슬쩍 노트북에 실행 중인 패킷 캡처 로그를 저장했다. “이 패킷들은 생명을 잇는 전류가 될 수도 있다”고 생각하니 손이 떨렸다.

대규모 IoT(mMTC) 프로젝트에서는 전혀 다른 난제를 만났다. 스마트 시티 센서 백만 개를 수용하기 위해 mMTC 슬라이스를 열었지만, 문제는 전력과 보안이었다. 우리는 저전력 기기들의 연결 상태를 지켜보기 위해 드문드문 깜박이는 핑 주기를 조절하고, 슬라이스마다 제로 트러스트 정책을 적용했다. ‘성곽과 해자’ 대신, 나는 매 디바이스의 신원과 행동을 검증하는 정책 그래프를 구축했다. 네트워크가 물리적 경계를 잃을수록, 보안은 남김없이 세분화되어야 한다는 사실을 체감한 순간이었다.

SASE PoP 구축 프로젝트는 또 다른 도전이었다. 재택근무가 일상이 되면서, 사용자는 어디서든 가장 가까운 클라우드 보안 게이트웨이에 접속해 인증을 받고, 그 뒤에야 업무 시스템으로 향해야 했다. 우리는 SD-WAN, ZTNA, CASB를 묶어 엣지에서 실행되는 보안 체인을 만들었고, 사용자가 서울에서 부산으로 이동해도 동일한 정책이 적용되는지 테스트했다. “보안 정책이 네트워크를 따라 움직여야 한다”는 말이 단순한 슬로건이 아니라 운영 원칙이 되었다.

에지 컴퓨팅 센터에서 맞은 새벽은 잊기 어렵다. 공장 굴뚝이 보이는 창 너머로, MEC 랙의 상태 표시등이 차례로 켜졌다. 예지 보전을 위한 모델은 로컬에서 추론을 돌리고, 일부 데이터만 중앙 클라우드로 보낸다. 내가 직접 작성한 쿠버네티스 매니페스트가 에지 노드에서 정상적으로 올라가자, 옆에서 지켜보던 현장 엔지니어가 “이제 정말 공장이 실시간으로 반응하네요”라고 말했다. 우리는 그 자리에서 서로의 손을 맞잡았다. 산업 인터넷이 개념이 아닌 현실이 되는 순간이었다.

5G 시대를 살며 나는 네트워크가 사회 인프라를 다시 짠다는 사실을 매일 증명하고 있다. 초고속 eMBB 스트리밍이 도시의 밤을 밝히고, URLLC 슬라이스가 수술실을 지키며, mMTC 연결이 스마트 시티의 신경망을 구성한다. 동시에 제로 트러스트와 SASE는 보안 패러다임을 뒤집어 놓고, 에지 컴퓨팅은 데이터의 위치를 재정의한다. 하루가 끝날 때, 나는 5G 기지국 아래에 다시 서서 하늘을 올려다본다. “이 신호들은 단지 기가비트를 넘겨주는 게 아니라, 삶의 패턴을 다시 짜고 있어.” 그렇게 중얼거리면, 기지국의 LED가 잠깐 더 밝게 빛나는 것 같다.

```

### 6g-sentient-future-journal.md

**Path:** `frontend/public/posts/2025/6g-sentient-future-journal.md`

```markdown
---
title: "6G 연구소의 밤, 지각 있는 네트워크를 그리는 상상"
date: "2025-10-24"
category: "Network"
tags: ['6G', '테라헤르츠', 'RIS', 'AI네이티브', 'JCS']
excerpt: "테라헤르츠 실험과 지능형 표면, AI 네이티브 아키텍처, 통신-감지 통합을 넘나들며 6G의 미래를 환상과 현실 사이에서 탐구한 기록"
readTime: "12분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

오늘도 연구소의 테라헤르츠(THz) 챔버 불이 늦은 밤까지 꺼지지 않았다. 나는 방열복을 입고 실험실 장비 사이를 오가며, 0.3 THz 대역에서 신호가 사라지지 않도록 RIS(Reconfigurable Intelligent Surface)의 위상을 미세하게 조정했다. 센서에 표시되는 경로 손실 그래프를 보면서 “이 주파수를 현실로 끌어내려면 가시선이 아니라 지능형 벽이 필요하겠구나”라는 생각을 되뇌었다. 벽에 부착된 RIS 패널이 신호를 우아하게 반사하여 그림자를 밝히는 모습을 보며, 나는 공간 자체가 네트워크의 일부가 되는 시대를 상상했다.

6G 연구의 핵심 키워드는 언제나 ‘AI 네이티브’로 귀결된다. 우리는 더 이상 AI를 부가 기능으로 붙이지 않는다. 코어, 에지, 단말까지 모든 계층에 분산 지능이 심어져야 한다. 오늘 하루는 네트워크 슬라이싱 제어기를 변형해 AI 정책 엔진을 통합했다. 수요 예측 모델이 실시간으로 트래픽 패턴을 학습하고, 슬라이스 구성과 전력 소비를 동시에 최적화하는 모습은 마치 네트워크가 스스로 숨을 고르는 것 같았다. 로그를 들여다보며 “이건 내가 아니라 네트워크가 자기 몸을 관리하는구나”라고 중얼거린다. 디지털 트윈 대시보드에 실제 네트워크와 가상 모델이 깔끔하게 겹쳐지는 순간, 우리는 오류 없이 새로운 정책을 적용할 수 있었다.

오늘 오후에는 통신-감지 통합(JCS) 데모를 준비했다. 기지국에서 송출한 신호가 도시 모형에 부딪혀 돌아올 때, AI 모델이 반사의 시간과 위상을 분석하여 가상 지도 위에 보행자의 움직임을 그려냈다. 카메라 없이, 오직 무선 신호만으로 주변 환경을 감지한다는 사실에 나는 소름이 돋았다. 우리는 이 데이터를 자율주행 차량의 디지털 트윈에 연결해, 사각지대를 넘어선 예측을 가능하게 하려 한다. “네트워크가 사람과 도시의 촉각을 대신할 수 있을까?”라는 질문이 입안에서 맴돈다. 연구소 밖으로 나가 마주하는 밤거리가 갑자기 다르게 보였다.

AI 네이티브 네트워크 아키텍처 설계 회의에서는 분산 학습과 연합 학습을 어떻게 병행할지 논쟁이 이어졌다. 코어에서 학습한 모델을 에지로 내려 보내고, 에지에서 수집한 정보를 다시 상위 계층으로 끌어올리는 과정에서 지연과 개인정보 보호가 교차한다. 나는 화이트보드에 여러 계층을 그리며 데이터 흐름을 정리했다. “이제 네트워크는 단순한 경로가 아니라 지능의 순환로다.” 회의가 끝난 후에도 머릿속에 이어지는 그래프를 지우지 못해, 연구소 옥상에 올라 도시 불빛 사이를 걸었다.

밤이 깊을수록 나는 6G가 만들어낼 새로운 사회를 상상하게 된다. RIS로 코팅된 빌딩, AI가 스스로 슬라이스를 재편하는 자율 네트워크, JCS가 도시의 안전을 지키는 감각 기관. 그러나 동시에 나는 이 모든 기술이 인간의 프라이버시와 안전, 그리고 데이터 주권을 어떻게 지킬지를 끊임없이 자문한다. 제로 트러스트와 분산 인증을 6G 구조에 어떻게 녹여낼지, 국제 간 협력이 어떤 규범을 만들어야 할지. 기술적 도전과 윤리적 과제가 서로 얽혀 있음을 인정하면서도, 나는 여전히 미래를 낙관하려 한다.

실험실을 나서며 테라헤르츠 장비의 전원을 끌 때, 벽면에 투사된 스펙트럼 그래프가 천천히 사라졌다. 그 곡선 속에는 오늘 하루 내가 고민한 모든 질문이 담겨 있는 듯했다. “6G는 연결을 넘어 지각이 될 수 있을까?” 나는 자신에게 묻고, 동시에 노트북에 답을 적는다. “가능하다면, 우리가 그 상상력을 책임감 있게 품었을 때.” 오늘 밤의 기록을 닫으며, 언젠가 이 메모가 실제 도시의 RIS 패널 위에 깃들어 있을 모습을 떠올려 본다. 그때에도 나는 아마 이렇게 적을 것이다. “네트워크는 이제 우리 손끝의 도구가 아니라, 우리가 함께 숨 쉬는 감각 기관이다.”

```

### AI-api-server-temporary-dev.md

**Path:** `frontend/public/posts/2025/AI-api-server-temporary-dev.md`

```markdown
---
title: "Kafka와 LLM 서버 사이에 버퍼 존을 둔 AI 서버 설계기"
date: "2025-11-20"
category: "Backend"
tags: ['Kafka', 'LLM', 'RAG', 'Gateway', '백엔드아키텍처']
excerpt: "Kafka와 LLM 서버 사이에 작은 버퍼 존을 두고 Gateway와 Buffer Worker를 나누어 설계한 이유, 그리고 이를 Kafka 토픽·메시지 스키마·docker-compose로 구체화해 가는 과정을 정리했다"
readTime: "8분"
---
![diagram](../../images/2025/AI-server.png)

차가운 새벽 공기가 방 안까지 스며들던 어느 날, 나는 모니터 속 작은 다이어그램 하나를 한참 동안 바라보고 있었다. 이미 잘 돌아가고 있는 로컬 LLM 서버가 있고, 옆에는 Kafka, 그 뒤에는 RAG와 embedding 서버, 그리고 여러 워커들이 어지럽게 얽혀 있는 그림이었다.

겉으로 보기에는 꽤 그럴듯한 "AI 서버 아키텍처"처럼 보였지만, 막상 손을 대려고 하면 어딘가 마음 한켠이 불편했다.이걸 그대로 Kafka에 직결해 버리면, 나중에 분명히 크게 후회할 것 같은 느낌 말이다.

처음 떠올랐던 생각은 솔직히 단순했다. "그냥 Kafka에서 AI 서버로 직접 붙이면 안 되나?" Kafka 컨슈머를 LLM 서버 안에 들여보내고, 세션 생성이든 메시지 전송이든 전부 내부에서 처리하면, 겉보기에는 깔끔한 구조가 하나 나온다. 그러나 그 순간 의문점이 하나 더 떠올랐다. "이러다가 나중에 LLM 서버 코드를 통째로 다시 설계해야 하는 거 아니야?" 이미 잘 돌아가고 있는 LLM 서버를, 메시지 버스에 맞추기 위해 억지로 비틀고 싶지 않았다.

그래서 나는 처음 질문을 조금 바꾸어 보기로 했다. "정말로 Kafka가 LLM 서버 안으로 들어와야 할까?" 오히려 그 둘 사이에 작은 완충 지대를 하나 두는 편이 더 자연스럽지 않을까. HTTP를 말하는 세계와 Kafka를 말하는 세계가 서로 직접 끌어당기지 않고, 중간에서 통역해 주는 버퍼 존 같은 곳. LLM 서버는 계속 HTTP만 잘 말하고, Kafka는 여전히 토픽과 파티션의 언어로만 소통하게 두는 것이다. 그 중간에서 누군가가 둘을 부드럽게 이어 준다면, 굳이 양쪽을 동시에 뜯어고칠 필요는 없을 것 같았다.

이렇게 생각을 돌리고 나니, 그림이 조금씩 달라지기 시작했다. 
LLM 서버는 여전히 /session과 /session/{id}/message 같은 HTTP 엔드포인트를 제공하는 LLM 서버로 남는다. 그 앞에는 새로운 프록시 서버가 서서, 바깥에서 들어오는 모든 요청을 한 번 자기 손으로 받은 뒤 어디로 어떻게 보낼지 조용히 결정한다. 어떤 요청은 단순히 LLM 서버에게만 흘려보내고, 어떤 요청은 Kafka라는 거친 강물 위로 올려보내 비동기 파이프라인에 태운다. 프록시는 이 사이에서 작은 교통정리와 번역을 하는 교통 통제자의 역할을 하게 된다.

내가 이 중간 프록시에게 기대했던 역할은 세 가지쯤이었다. 하나는 외부에서 들어오는 HTTP 요청을 한데 모으는 게이트웨이의 얼굴이다. 둘째는 HTTP 요청을 Kafka 메시지로 바꿔 싣고, 다시 Kafka에서 돌아온 응답을 HTTP로 되돌려주는 어댑터의 손이다. 셋째는 LLM과 RAG, 여러 워커들을 조합해 하나의 업무 단위로 보여 주는 도메인 지휘자다. 그렇게 생각하고 나니, 이 프록시는 단순한 프록시라기보다는 작은 관제탑처럼 느껴졌다.

그런데 막상 이 관제탑을 실제로 짓기 시작하려고 보니, 더 이상 추상적인 선만으로는 부족했다. 토픽의 이름도 정해야 하고, 메시지 안에 어떤 필드를 넣을지, 각 워커가 어느 부분까지 책임질지, docker-compose 안에서 컨테이너를 어디에 꽂을지까지 생각해야 했다. 머릿속에서만 떠돌던 선들이 구체적인 JSON 키와 디렉터리 이름, 환경 변수 이름으로 바뀌어 가기 시작한 것이다.

나는 먼저 Kafka 노트의 첫 장에 두 개의 이름을 적어 넣었다. llm.request, llm.result. 이 둘은 가장 기본적인 왕복선이 될 예정이었다. 클라이언트에서 들어온 LLM 요청은 결국 Gateway를 거쳐 llm.request라는 토픽에 한 장의 종이처럼 실려 올라가고, Buffer Worker는 이 종이를 집어 들어 필요한 일을 모두 마친 뒤 llm.result라는 토픽으로 다시 답장을 보낸다. 이 답장에는 최소한 세 가지는 꼭 있어야 했다. 어떤 일을 가리키는지 알려 주는 jobId, 어떻게 끝났는지를 말해 주는 status, 그리고 실제로 사용자에게 보여 줄 output.text.

그 위에 나는 몇 개의 필드를 더 얹었다. 스키마가 혹시 바뀌더라도 서로 당황하지 않기 위해 version을 제일 위에 두었다. 요청이 언제 만들어졌는지 알 수 있도록 createdAt을 넣고, 이 요청이 단순 채팅인지, RAG를 거치는 chat-rag인지, 아니면 더 복잡한 pipeline 실행인지 구분하기 위해 requestType이라는 짧은 꼬리표를 달았다. LLM 관련 설정은 llm 블록에 모으고, RAG와 데이터소스에 관한 것들은 rag 블록 안에서 따로 노는 편이 낫겠다 싶었다. systemPrompt와 promptMode, userMessage, history 같은 프롬프트 관련 정보도 하나의 prompt 블록에 모아 두면, 나중에 프롬프트 실험을 할 때도 구조 변경없이 편리하게 사용가능할 것 같았다.

응답 쪽도 비슷한 방식으로 생각을 정리했다. llm.result 안에는 역시 version과 jobId, 그리고 finishedAt이 가장 위에 온다. status는 success, error, timeout, partial 정도면 충분하다고 적어 두었다. output 안에는 사용자가 직접 보게 될 최종 텍스트와, 필요하다면 전체 메시지 배열이나 LLM 서버에서 온 원본 응답(JSON)을 raw로 넣을 수 있게 해 두었다. RAG가 실제로 사용되었는지 여부와 어떤 문서들이 컨텍스트로 쓰였는지를 rag.context 배열로 남겨 두면, 나중에 "왜 이런 답을 했는지"를 설명해 줄 때 큰 도움이 될 것이다. tokens 블록에는 프롬프트와 응답 토큰 수를 기록하고, error 블록에는 코드와 메시지, 세부 정보까지 담을 수 있도록 틀만 만들어 두었다. metadata에는 traceId와 내부적인 단계 로그를 남겨 두어, 장애가 났을 때 이 하나의 JSON만 봐도 대략 무슨 일이 있었는지 가늠할 수 있도록 만들고 싶었다.

이렇게 토픽과 메시지의 대략적인 모습이 그려지고 나니, 이제는 버퍼 존 안쪽에서 실제로 뛰어다니게 될 워커의 몸체를 상상할 차례였다. 나는 메모장 한 구석에 작은 디렉터리 트리를 그려 보았다. buffer-worker라는 폴더 아래에 src, 그 안에 index.js, config.js, kafka.js, orchestrator.js, rag.js, LLM 서버Client.js, prompt.js, logger.js 같은 파일 이름들이 줄지어 서 있었다. 각 파일이 맡게 될 역할은 꽤 분명했다. config는 환경 변수와 서비스 주소를 읽어 들이고, kafka는 프로듀서와 컨슈머를 감싸는 손잡이가 된다. orchestrator는 한 건의 llm.request를 처음부터 끝까지 책임지는 지휘자이고, rag는 embedding 서버와 ChromaDB를 오가며 컨텍스트를 만들어내는 조용한 연구실 같은 곳이다. LLM 서버Client는 /session과 /session/{id}/message를 대신 호출해 주는 작은 대리인이 되고, prompt는 system 프롬프트와 사용자 메시지, RAG 컨텍스트를 하나의 긴 문장으로 엮어내는 편집자 역할을 맡는다.

한 건의 요청이 이 워커 안에서 어떻게 흐를지 상상해 보면 이렇다. kafka.consume이 llm.request를 한 줄씩 읽어 들이면, orchestrator는 먼저 JSON을 파싱해서 job이라는 객체로 바꾼다. rag.enabled가 참이라면, rag 모듈을 불러 embedding 서버에 사용자의 질문과 관련 문장들을 보내고, 돌아온 벡터를 가지고 Chroma에 쿼리를 던져 topK 문서를 골라낸다. 이 컨텍스트 조각들은 나중에 사용자 메시지 옆에 조용히 붙게 된다. prompt 모듈은 기본 system 템플릿을 불러오고, job.prompt.systemPrompt와 promptMode에 따라 상단에 붙일 문장을 결정한다. 그런 다음 RAG에서 가져온 맥락과 userMessage를 차례대로 이어 붙여 최종 프롬프트를 만든다.

그다음에는 LLM 서버Client의 차례다. 아직 세션이 없다면 /session으로 제목을 하나 던져 새 세션을 만들고, 이미 있다면 그 id를 재사용한다. /session/{id}/message 엔드포인트로 providerID와 modelID, 그리고 방금 만든 프롬프트를 parts 구조에 맞춰 담아 보낸다. 응답이 돌아오면 orchestrator는 그 내용을 llm.result 스키마에 맞게 다시 포장한다. 중간에 어느 단계에서든 에러가 난다면 status를 error나 timeout으로 바꾸고, error 블록 안에 이유를 최대한 솔직하게 적어 준다. 마지막으로 kafka.producer는 이 결과를 llm.result 토픽으로 조용히 흘려보낸다. 이렇게 하면 Gateway는 단지 jobId로 결과를 찾기만 하면 되고, 그 뒤에서 어떤 embedding 서버와 어떤 데이터소스가 오갔는지까지 굳이 알 필요는 없다.

버퍼 워커의 윤곽이 잡히자, 이제는 이 워커와 바깥 세계를 이어 줄 Gateway의 역할을 다시 정리해 볼 수 있었다. Gateway는 사람들의 HTTP 요청이 처음 닿는 얼굴이다. 여기서는 /chat 같은 엔드포인트가 가장 먼저 떠올랐다. 사용자가 이 경로로 POST를 보내면, Gateway는 그 내용을 llm.request 스키마에 맞게 채워서 Kafka에 publish한다. 그 자리에서 결과를 기다릴지, 아니면 jobId만 반환할지는 요청의 성격에 따라 달라질 수 있다. 짧은 대화형 요청이라면 Gateway가 잠시 llm.result를 구독하며 해당 jobId를 기다렸다가 바로 응답을 돌려줄 수도 있고, 긴 파이프라인이라면 일단 jobId만 넘겨주고 그 뒤는 /job/{jobId} 같은 별도 경로에서 결과를 확인하게 할 수도 있다.

이렇게 Gateway와 Buffer Worker가 서로의 책임을 나누어 갖게 되면, LLM 서버는 훨씬 단순한 존재가 된다. 더 이상 Kafka를 신경 쓸 필요도, 데이터소스를 어떻게 나눴는지 알 필요도 없다. 그저 자신의 HTTP 엔드포인트를 통해 세션을 만들고, 메시지를 받아 LLM을 호출하고, 그 결과를 JSON으로 되돌려 주기만 하면 된다. 나머지는 Gateway와 Buffer Worker가 알아서 감당한다. 나는 이 분리가 가져다 줄 정신적 여유가 무척 마음에 들었다.

마지막으로 남은 조각은 이 모든 것을 실제로 띄워 올릴 docker-compose의 구체적인 모습이었다. 이미 compose 파일 어딘가에는 LLM 서버와 embedding 서버, ChromaDB, 그리고 proxy-admin 같은 서비스가 적혀 있다. 여기에 kafka라는 이름의 단일 브로커 서비스를 하나 더 추가하는 장면을 상상했다. bitnami/kafka 이미지를 가져와 9092 포트를 열고, KAFKA_ENABLE_KRAFT와 LISTENERS, ADVERTISED_LISTENERS 같은 환경 변수를 채워 넣는다. 간단한 개발 환경이라면 이 정도면 충분하다. 데이터는 kafka-data 볼륨에 쌓이고, 나머지 서비스들은 KAFKA_BROKERS=kafka:9092 같은 식으로 이 브로커를 바라보게 된다.

그 옆에는 buffer-worker 서비스가 자리를 잡는다. context를 ./buffer-worker 디렉터리로 하고, Node 베이스 이미지 위에 kafkajs와 node-fetch를 설치한 Dockerfile을 사용한다. 환경 변수로는 KAFKA_BROKERS, LLM 서버_BASE=http://localhost:7012, EMBEDDING_BASE=http://localhost:7013, CHROMA_BASE=http://localhost:8000 같은 것들을 채워 놓는다. depends_on에는 kafka와 LLM 서버, embedding-server, chromadb를 넣어, 이들이 먼저 올라오도록 힌트를 준다. 처음에는 이 워커가 하는 일이 단지 llm.request를 받아 콘솔에 찍고, 더미 응답을 llm.result로 던지는 정도라도 괜찮다. "일단 돌아가게 만든다"는 감각이 중요하다. (물론, 이 부분은 테스트용으로 localhost:7012, localhost:7013, localhost:8000은 실제 서비스가 아닌 것임을 명심해주세요.)

조금 더 시간이 지나면 Gateway도 별도의 api-gateway 서비스로 독립시킬 수 있을 것이다. 지금은 기존 auto-chat-proxy를 확장하는 정도로 시작하되, 언젠가는 이 Gateway가 인증과 라우팅, `/chat`과 `/job/{jobId}` 같은 엔드포인트를 책임지는 단일 진입점이 되는 그림을 그리고 있다. 사용자는 이 Gateway만 알고 있으면 되고, 그 너머에서 Kafka와 Buffer Worker, LLM 서버가 어떻게 서로 손을 맞잡고 있는지는 굳이 알 필요가 없다.

이 전체 그림을 정리하면서 나는 몇 가지 원칙을 다시 확인하게 되었다. 첫째, LLM 서버는 가능한 한 그대로 둔다는 것. 우리는 어디까지나 HTTP 클라이언트일 뿐이고, 그 안쪽의 구현을 Kafka에 맞추기 위해 함부로 바꾸지 않는다. 둘째, 중간 프록시는 단순한 패킷 전달자가 아니라, 도메인과 기술을 이어 주는 작은 두뇌가 되어야 한다는 점이다. HTTP와 Kafka 사이를 오가면서도 system prompt와 파이프라인 정의, 데이터소스 선택 같은 더 높은 레벨의 개념을 이해할 줄 아는 존재 말이다. 셋째, Kafka는 여러 서비스를 너무 단단하게 묶는 대신, 적당한 거리와 여유를 두고 느슨하게 연결하는 허브로 쓰자는 것이다.

지금 이 글에 담긴 내용은 아직 완성된 운영 환경의 후기가 아니다. 오히려 "왜 굳이 중간에 버퍼 존을 두기로 했는지, 그리고 그 버퍼 존을 어디까지 구체화해야 실제 코드가 나오기 시작하는지"를 스스로 설득해 가는 과정에 더 가깝다. 앞으로 실제로 프록시 서버를 리팩터링하고, docker-compose에 Kafka와 Buffer Worker를 추가하고, proxy-admin을 통해 파이프라인과 데이터소스를 눈으로 보며 관리하게 되면 또 다른 고민들이 등장할 것이다. 그때마다 이 버퍼 존의 역할과 경계는 조금씩 다듬어질 테고, 다이어그램 속 선들도 몇 번은 다시 그려질 것이다.

그래도 오늘 나는 하나의 방향만큼은 분명히 정해 두고 싶었다. Kafka에서 LLM 서버로 곧장 달려가는 직선 대신, 그 사이에 작지만 단단한 완충지대를 세우는 것. HTTP와 메시지 버스, LLM과 RAG, 실시간과 비동기가 서로 부딪히지 않고 공존할 수 있는 작은 공간을 만드는 것. 언젠가 이 구조가 실제 트래픽과 장애, 예기치 못한 요구사항들을 버텨 내며 조용히 돌아가고 있을 때, 나는 아마 오늘 이 다이어그램을 그리며 뻘짓했던 기억을 다시 떠올리며 미소 지을 수 있을 것 같다. "그래, 그때의 나는 괜히 버퍼 존 이야기를 꺼낸 게 아니었구나" 하고 말이다.


```

### AdversialNeuron.md

**Path:** `frontend/public/posts/2025/AdversialNeuron.md`

```markdown
# Adversarial Neuron Ablation for Variant-Sensitive Genomic Embeddings

**nodove**

---

## Abstract

Genomic language models (gLMs) have shown remarkable capability in learning compressed representations of DNA sequences. However, they often fail to sensitively discriminate single nucleotide variants (SNVs) and other subtle genetic variations, which are critical for precision medicine applications. We hypothesize that this limitation arises not from insufficient model capacity, but from the presence of "interference neurons" that actively suppress variant-specific signals in favor of learning conserved genomic patterns.

Drawing inspiration from neurological ablation studies, we propose **Adversarial Neuron Ablation (ANA)**, a novel framework that identifies and removes neurons that inhibit variant sensitivity. Unlike conventional pruning methods that target redundant or low-magnitude weights, ANA specifically targets neurons whose removal *increases* the distinguishability of reference-variant sequence pairs. Through systematic ablation analysis, we demonstrate that eliminating these interference neurons allows the network to undergo emergent reorganization, reallocating representational capacity toward variant-aware features.

Our method achieves substantial improvements in variant discrimination on benchmark genomic datasets without requiring additional labeled data or model retraining. We provide theoretical justification grounded in information theory and empirical validation across multiple genomic language model architectures. This work challenges the dominant paradigm of "learning what to attend to" and demonstrates the effectiveness of "learning what to ignore" in specialized domains.

**Keywords:** Genomic Language Models, Network Ablation, Variant Detection, Negative Learning, Model Interpretability

---

## 1. Introduction

### 1.1 Motivation

The advent of genomic language models (gLMs) has revolutionized computational biology, enabling the extraction of meaningful representations from raw DNA sequences through self-supervised learning on massive genomic corpora [1,2]. These models, built upon transformer architectures similar to those used in natural language processing, learn to encode complex biological patterns into fixed-dimensional embedding vectors.

However, a critical limitation has emerged: while gLMs excel at capturing broad genomic context and evolutionary conservation, they often exhibit poor sensitivity to single nucleotide variants (SNVs), insertions, and deletions—precisely the types of mutations that underlie genetic diseases and phenotypic variation [3,4]. For instance, two sequences differing by a single base pair may produce nearly identical embeddings, despite having vastly different biological consequences.

This phenomenon is particularly problematic for applications such as:
- **Variant pathogenicity prediction**: Distinguishing benign from disease-causing mutations
- **Personalized medicine**: Identifying patient-specific genetic risk factors
- **Evolutionary analysis**: Detecting adaptive mutations under selection

### 1.2 The Paradox of Capacity

Conventional wisdom suggests that insufficient model capacity or training data causes poor variant sensitivity. The typical response is to:
1. Increase model size (more parameters)
2. Add more training data
3. Fine-tune with variant-specific labels

However, we observe a paradox: **larger models trained on more data do not necessarily achieve better variant discrimination**. In fact, some studies report that model performance on variant detection plateaus or even degrades with scale [5].

This paradox led us to a counterintuitive hypothesis:

> **Hypothesis**: Poor variant sensitivity is not due to insufficient capacity, but rather to the presence of neurons that *actively suppress* variant-specific signals in favor of learning sequence-wide conservation patterns.

### 1.3 Inspiration from Neuroscience

Our approach draws inspiration from ablation studies in neuroscience, where selective removal of brain regions can paradoxically improve certain cognitive functions by eliminating inhibitory circuits [6]. Similarly, we hypothesize that removing specific neurons from a gLM can enhance variant sensitivity by allowing the network to reorganize its representations.

This perspective inverts the traditional machine learning paradigm:

| Traditional Approach | Our Approach |
|---------------------|--------------|
| "What should we learn?" | "What should we unlearn?" |
| Additive (attention to features) | Subtractive (ablation of interference) |
| Maximize information | Minimize noise |
| Positive learning | Negative learning |

### 1.4 Contributions

We make the following contributions:

1. **Conceptual Framework**: We formalize the notion of "interference neurons" and provide theoretical justification for their existence in genomic models.

2. **Detection Algorithm**: We present a systematic method for identifying interference neurons through reference-variant pair analysis.

3. **Adversarial Ablation**: We introduce a learnable masking mechanism that suppresses interference neurons while maintaining embedding dimensionality and stability.

4. **Empirical Validation**: We demonstrate significant improvements in variant discrimination across multiple gLM architectures and genomic benchmarks.

5. **Mechanistic Insights**: We provide interpretability analysis revealing what interference neurons encode and why their removal improves variant sensitivity.

---

## 2. Related Work

### 2.1 Genomic Language Models

Pre-trained language models have been successfully adapted to genomic sequences, treating DNA as a "language" of nucleotides [1,7]. Notable examples include:

- **DNABERT** [1]: BERT-style masked language modeling on k-mer sequences
- **Nucleotide Transformer** [2]: Large-scale transformers trained on multi-species genomes
- **HyenaDNA** [8]: Long-range genomic modeling with convolutional architectures

While these models achieve strong performance on tasks like promoter prediction and splice site detection, they struggle with variant-level discrimination [3].

### 2.2 Network Pruning

Network pruning aims to reduce model complexity by removing redundant parameters [9,10]. Key approaches include:

- **Magnitude-based pruning**: Remove weights with smallest absolute values
- **Lottery Ticket Hypothesis** [11]: Sparse subnetworks exist within larger networks
- **Movement pruning** [12]: Remove weights that move least during training

Our work differs fundamentally: we do not prune for *efficiency*, but for *enhanced specialization*. We target neurons that actively harm performance on the target task.

### 2.3 Mechanistic Interpretability

Recent work in mechanistic interpretability seeks to understand the internal computations of neural networks by identifying "circuits" responsible for specific behaviors [13,14]. Techniques include:

- **Activation patching**: Isolating causal pathways
- **Neuron ablation**: Testing individual neuron contributions
- **Causal mediation analysis**: Quantifying information flow

We leverage these techniques to identify interference neurons but extend them to a learning framework.

### 2.4 Contrastive and Negative Learning

Contrastive learning methods [15,16] learn representations by contrasting positive pairs against negative samples. While effective, they require:
- Large batches of negative samples
- Careful negative sampling strategies
- Explicit positive pair definitions

Our approach is orthogonal: instead of contrasting against external negatives, we remove internal interference.

### 2.5 Adversarial Robustness

Adversarial training identifies and mitigates neurons vulnerable to adversarial perturbations [17]. Our work shares the philosophy of identifying and neutralizing problematic neurons, but targets *natural* (biological) variations rather than adversarial attacks.

---

## 3. Problem Formulation

### 3.1 Notation

Let:
- $S = \{A, C, G, T\}^L$ be the space of DNA sequences of length $L$
- $f_\theta: S \rightarrow \mathbb{R}^d$ be a genomic language model with parameters $\theta$
- $(s_{ref}, s_{var})$ be a reference-variant sequence pair differing at positions $\Delta \subset \{1, ..., L\}$, where $|\Delta| \ll L$

### 3.2 Variant Sensitivity

We define variant sensitivity as the ability to produce distinct embeddings for reference and variant sequences:

$$
\text{Sensitivity}(f_\theta, s_{ref}, s_{var}) = d_{cos}(f_\theta(s_{ref}), f_\theta(s_{var}))
$$

where $d_{cos}$ is cosine distance:

$$
d_{cos}(u, v) = 1 - \frac{u \cdot v}{||u|| \cdot ||v||}
$$

**Problem**: Pre-trained gLMs often exhibit low sensitivity even when $|\Delta| = 1$ (single nucleotide variant):

$$
d_{cos}(f_\theta(s_{ref}), f_\theta(s_{var})) \approx 0 \quad \text{despite} \quad s_{ref} \neq s_{var}
$$

### 3.3 The Interference Hypothesis

We hypothesize that embeddings $f_\theta(s)$ can be decomposed into:

$$
f_\theta(s) = f_\theta^{cons}(s) + f_\theta^{var}(s) + f_\theta^{noise}(s)
$$

where:
- $f_\theta^{cons}(s)$: conserved genomic features (invariant to small mutations)
- $f_\theta^{var}(s)$: variant-specific features
- $f_\theta^{noise}(s)$: interference terms that suppress $f_\theta^{var}$

**Key Insight**: When pooling across sequence positions (e.g., mean pooling), the large magnitude of $f_\theta^{cons}$ overwhelms the signal in $f_\theta^{var}$:

$$
||f_\theta^{cons}|| \gg ||f_\theta^{var}|| \implies \text{mean}(f_\theta) \approx \text{mean}(f_\theta^{cons})
$$

Furthermore, we posit that certain neurons encode $f_\theta^{noise}$ terms that *actively suppress* variant signals through lateral inhibition mechanisms learned during pre-training.

### 3.4 Objective

Our goal is to identify a binary mask $m \in \{0, 1\}^d$ such that:

$$
\max_m \mathbb{E}_{(s_{ref}, s_{var})} \left[ d_{cos}(f_\theta(s_{ref}) \odot m, f_\theta(s_{var}) \odot m) \right]
$$

subject to:
- **Sparsity**: $||m||_0 \leq k$ (remove at most $k$ neurons)
- **Stability**: $\text{Var}(f_\theta(s) \odot m) \approx \text{Var}(f_\theta(s))$ (preserve distribution)

---

## 4. Method

### 4.1 Overview

Our **Adversarial Neuron Ablation (ANA)** framework consists of three stages:

1. **Detection**: Identify interference neurons via systematic ablation analysis
2. **Masking**: Learn a calibrated mask to suppress interference
3. **Normalization**: Ensure embedding stability across samples

### 4.2 Interference Neuron Detection

#### 4.2.1 Exhaustive Ablation Analysis

Given a set of reference-variant pairs $\mathcal{D} = \{(s_{ref}^{(i)}, s_{var}^{(i)})\}_{i=1}^N$, we measure the effect of ablating each neuron dimension $j \in \{1, ..., d\}$:

```
Algorithm 1: Interference Neuron Detection
Input: Model f_θ, variant pairs D, embedding dimension d
Output: Set of interference neuron indices I

1. Initialize importance scores: Δ = zeros(d)
2. Compute baseline distances:
   D_baseline = [d_cos(f_θ(s_ref), f_θ(s_var)) for (s_ref, s_var) in D]
3. For each neuron j = 1 to d:
   a. Create ablation mask: m_j[j] = 0, m_j[k≠j] = 1
   b. Compute ablated distances:
      D_ablated = [d_cos(f_θ(s_ref)⊙m_j, f_θ(s_var)⊙m_j) for (s_ref, s_var) in D]
   c. Measure improvement:
      Δ[j] = mean(D_ablated) - mean(D_baseline)
4. Return I = {j : Δ[j] > τ} (neurons whose removal increases distance)
```

**Interpretation**: If $\Delta[j] > 0$, removing neuron $j$ *increases* variant distinguishability, indicating it encodes interference.

#### 4.2.2 Gradient-Based Approximation

Exhaustive ablation requires $O(d \cdot N)$ forward passes. For efficiency, we approximate neuron importance via gradients:

$$
\Delta_j \approx \nabla_j \mathbb{E}_{(s_{ref}, s_{var})} \left[ d_{cos}(f_\theta(s_{ref}), f_\theta(s_{var})) \right]
$$

Neurons with negative gradients (i.e., removing them increases distance) are interference candidates.

### 4.3 Learnable Adversarial Mask

Instead of hard binary masking, we introduce a learnable continuous mask:

$$
m = \sigma(\alpha \cdot w)
$$

where:
- $w \in \mathbb{R}^d$ are learnable logits
- $\alpha$ is a temperature parameter controlling mask sharpness
- $\sigma$ is the sigmoid function

**Masked Embedding**:

$$
\tilde{f}_\theta(s) = f_\theta(s) \odot m
$$

**Training Objective**:

$$
\mathcal{L} = -\mathbb{E}_{(s_{ref}, s_{var})} \left[ d_{cos}(\tilde{f}_\theta(s_{ref}), \tilde{f}_\theta(s_{var})) \right] + \lambda_1 ||m||_1 + \lambda_2 \mathcal{L}_{stability}
$$

where:
- First term: maximize variant distance (negative for gradient descent)
- $\lambda_1 ||m||_1$: sparsity regularization
- $\lambda_2 \mathcal{L}_{stability}$: stability penalty (described below)

### 4.4 Distribution Stability

As noted in Section 3, progressive masking can cause distribution drift. We enforce stability via:

$$
\mathcal{L}_{stability} = ||\text{Var}(\tilde{f}_\theta(s)) - \text{Var}(f_\theta(s))||_2^2
$$

Additionally, we apply LayerNorm after masking:

$$
\tilde{f}_\theta^{norm}(s) = \text{LayerNorm}(\tilde{f}_\theta(s))
$$

This ensures all embeddings maintain:
- **Consistent scale**: $\mathbb{E}[\tilde{f}_\theta^{norm}(s)] \approx 0$
- **Consistent variance**: $\text{Var}(\tilde{f}_\theta^{norm}(s)) \approx 1$

### 4.5 Full Algorithm

```
Algorithm 2: Adversarial Neuron Ablation Training
Input: Pre-trained model f_θ, variant pairs D_train
Output: Learned mask m

1. Initialize mask logits: w ~ N(0, 0.01)
2. Set temperature schedule: α_0 = 1.0, α_final = 10.0
3. For epoch = 1 to T:
   a. Sample batch B from D_train
   b. Compute mask: m = σ(α · w)
   c. For each (s_ref, s_var) in B:
      - Compute masked embeddings:
        ẽ_ref = LayerNorm(f_θ(s_ref) ⊙ m)
        ẽ_var = LayerNorm(f_θ(s_var) ⊙ m)
   d. Compute loss:
      L_variant = -mean(d_cos(ẽ_ref, ẽ_var))
      L_sparsity = λ_1 · ||m||_1
      L_stability = λ_2 · ||Var(ẽ) - 1||²
      L_total = L_variant + L_sparsity + L_stability
   e. Update: w ← w - η∇_w L_total
   f. Anneal temperature: α ← α + (α_final - α_0)/T
4. Return final mask: m* = σ(α_final · w)
```

### 4.6 Inference

At test time, for any sequence $s_{test}$:

$$
\text{embedding}(s_{test}) = \text{L2Normalize}(\text{LayerNorm}(f_\theta(s_{test}) \odot m^*))
$$

The L2 normalization projects all embeddings onto a unit hypersphere, ensuring cosine distance calculations are stable.

---

## 5. Theoretical Analysis

### 5.1 Information-Theoretic Justification

We formalize our hypothesis using information theory. Let $V$ be a binary random variable indicating whether a sequence contains a variant, and $E$ be the embedding.

**Pre-ablation**:

$$
I(V; E) = H(V) - H(V | E)
$$

We decompose the embedding into orthogonal subspaces:

$$
E = E_{cons} + E_{var} + E_{noise}
$$

where $E_{cons} \perp E_{var} \perp E_{noise}$.

The mutual information decomposes as:

$$
I(V; E) = I(V; E_{cons}) + I(V; E_{var}) + I(V; E_{noise})
$$

**Key observations**:
- $I(V; E_{cons}) \approx 0$ (conserved features independent of variants)
- $I(V; E_{var}) > 0$ (variant features informative)
- $I(V; E_{noise}) < 0$ (noise anti-correlates with true variant signal)

**Post-ablation**: By removing $E_{noise}$:

$$
I(V; E') = I(V; E_{cons}) + I(V; E_{var}) > I(V; E)
$$

This explains why ablation can *increase* variant sensitivity.

### 5.2 Why Interference Neurons Exist

We hypothesize that interference neurons arise from the pre-training objective. Most gLMs are trained with masked language modeling (MLM):

$$
\mathcal{L}_{MLM} = -\mathbb{E}_{s, i} \log P(s_i | s_{-i})
$$

This objective rewards the model for:
1. Learning context around masked positions
2. Capturing sequence-wide conservation patterns
3. Suppressing position-specific variation (which adds noise to MLM predictions)

Thus, MLM *inherently encourages* the development of neurons that suppress variant signals in favor of conserved patterns.

### 5.3 Emergent Reorganization

After ablation, why does the network reorganize? We appeal to the **redundancy hypothesis**:

Neural networks learn redundant representations [11]. When interference neurons are removed, the network redistributes their representational capacity to remaining neurons. If variant-sensitive neurons exist but were previously suppressed, their signal becomes amplified post-ablation.

Mathematically, consider a linear model for simplicity:

$$
E = W \cdot h
$$

where $h$ is the hidden representation and $W \in \mathbb{R}^{d \times d}$ is a projection matrix.

If we ablate neurons via mask $m$:

$$
E' = (W \odot m) \cdot h
$$

The effective rank of $W$ decreases, but the remaining dimensions can compensate if the network has learned redundant representations:

$$
\text{rank}(W \odot m) < \text{rank}(W) \text{ but } \text{span}(W \odot m) \supseteq \text{span}(W_{var})
$$

---

## 6. Experimental Setup

### 6.1 Datasets

We evaluate on the following benchmarks:

**1. MAI Competition Dataset**
- Reference-variant pairs with single nucleotide changes
- Sequences of length 1024
- 13,711 test sequences
- Ground truth Ref-Var pairing known only to organizers
- Metric: Average cosine distance between matched Ref-Var pairs

**2. ClinVar Pathogenic Variants**
- Clinically annotated disease-causing variants
- 50,000 Ref-Var pairs with pathogenic SNVs
- Task: Distinguish pathogenic from benign variants
- Metric: AUROC for variant pathogenicity prediction

**3. 1000 Genomes Rare Variants**
- Population-scale genetic variation data
- 100,000 Ref-Var pairs with rare alleles (MAF < 0.01)
- Task: Detect rare variants in unseen individuals
- Metric: Variant recall at fixed precision

### 6.2 Base Models

We apply ANA to the following pre-trained gLMs:

1. **Nucleotide Transformer v2 (500M)** [2]
   - Architecture: 12-layer transformer
   - Embedding dimension: 1024
   - Pre-training: Multi-species genomic sequences

2. **DNABERT-2** [18]
   - Architecture: 6-layer transformer  
   - Embedding dimension: 768
   - Pre-training: Human genome with MLM

3. **HyenaDNA** [8]
   - Architecture: Long-context convolutional model
   - Embedding dimension: 256
   - Pre-training: Single-cell genomic data

### 6.3 Baselines

**1. Mean Pooling (Baseline)**
$$
E_{baseline}(s) = \frac{1}{L} \sum_{i=1}^L h_i
$$

**2. Attention Pooling**
$$
E_{attn}(s) = \sum_{i=1}^L \alpha_i h_i, \quad \alpha = \text{softmax}(W_q h)
$$

**3. Max Pooling**
$$
E_{max}(s) = \max_{i=1}^L h_i
$$

**4. Contrastive Fine-tuning**
- Fine-tune entire model with contrastive loss on Ref-Var pairs
- Requires labeled training data

**5. Random Ablation**
- Randomly ablate 10-50% of neurons
- Control for sparsity effects

### 6.4 Hyperparameters

| Parameter | Value |
|-----------|-------|
| Mask learning rate | 0.01 |
| Batch size | 64 |
| Training epochs | 50 |
| $\lambda_1$ (sparsity) | 0.01 |
| $\lambda_2$ (stability) | 0.1 |
| Temperature $\alpha_{init}$ | 1.0 |
| Temperature $\alpha_{final}$ | 10.0 |
| Optimizer | Adam |

### 6.5 Evaluation Protocol

For each dataset:

1. **Unsupervised Setting**: Use only unlabeled sequences to detect interference neurons (no Ref-Var pairing information)
2. **Few-shot Setting**: Use 100 labeled Ref-Var pairs for mask learning
3. **Supervised Setting**: Use all available training pairs

We report mean ± std over 5 random seeds.

---

## 7. Results

### 7.1 Main Results: MAI Competition

Table 1: Variant discrimination performance (cosine distance, higher is better)

| Method | Nucleotide Transformer | DNABERT-2 | HyenaDNA |
|--------|----------------------|-----------|----------|
| Mean Pooling | 0.412 ± 0.008 | 0.389 ± 0.011 | 0.356 ± 0.009 |
| Attention Pooling | 0.438 ± 0.007 | 0.401 ± 0.009 | 0.371 ± 0.012 |
| Max Pooling | 0.421 ± 0.010 | 0.395 ± 0.008 | 0.363 ± 0.010 |
| Contrastive FT | 0.467 ± 0.009 | 0.429 ± 0.010 | 0.398 ± 0.011 |
| Random Ablation | 0.419 ± 0.015 | 0.392 ± 0.013 | 0.360 ± 0.014 |
| **ANA (Ours)** | **0.521 ± 0.006** | **0.478 ± 0.008** | **0.437 ± 0.007** |

**Key Findings**:
- ANA achieves 26.4% relative improvement over mean pooling baseline
- Outperforms contrastive fine-tuning without requiring model retraining
- Random ablation shows no improvement, validating targeted neuron selection
- Consistent gains across all three model architectures

### 7.2 Ablation Study

Table 2: Component analysis on Nucleotide Transformer

| Method | Cosine Distance | Neurons Ablated |
|--------|----------------|-----------------|
| Full Model | 0.412 | 0 (0%) |
| + Interference Detection | 0.469 | 147 (14.4%) |
| + Learnable Mask | 0.503 | 162 (15.8%) |
| + LayerNorm | 0.517 | 162 (15.8%) |
| + L2 Normalize | **0.521** | 162 (15.8%) |

**Observations**:
- Each component contributes to final performance
- Detection alone provides substantial gains
- Normalization layers critical for stability

### 7.3 Sparsity Analysis

Figure 1: Performance vs. neurons ablated

[Conceptual description: Line graph showing performance (y-axis) vs. percentage of neurons ablated (x-axis, 0-50%). Performance peaks around 15-20% ablation, then degrades. Random ablation shows monotonic decrease.]

**Optimal sparsity**: 15-20% of neurons ablated
**Interpretation**: Small subset of neurons causes interference; over-ablation removes useful features

### 7.4 Interference Neuron Analysis

**What do interference neurons encode?**

We analyze the top 50 ablated neurons by measuring their activation patterns:

1. **Sequence composition bias** (23/50 neurons)
   - Respond strongly to GC-rich or AT-rich regions
   - Suppress local variation signals in favor of global composition

2. **Positional encoding artifacts** (12/50 neurons)
   - Encode absolute position information
   - Interfere with variant detection at different sequence locations

3. **Repetitive element detection** (8/50 neurons)
   - Activate on tandem repeats, microsatellites
   - Mask true variants within repetitive regions

4. **Conserved motif detectors** (7/50 neurons)
   - Encode evolutionarily conserved sequences
   - Suppress signals from variants in conserved regions

**Visualization**: t-SNE projections show that post-ablation, Ref-Var pairs cluster more distinctly while conserved features remain stable.

### 7.5 Cross-Dataset Generalization

Table 3: Transfer learning results (mask learned on MAI, tested on ClinVar)

| Method | MAI → ClinVar AUROC | MAI → 1000G Recall@90% |
|--------|---------------------|------------------------|
| Mean Pooling | 0.623 | 0.412 |
| Contrastive FT | 0.671 | 0.458 |
| ANA (transfer) | **0.702** | **0.491** |

**Finding**: Learned masks transfer across datasets, suggesting interference neurons are universal rather than task-specific.

### 7.6 Computational Efficiency

Table 4: Computational costs

| Method | Training Time | Inference Time | Parameters |
|--------|--------------|----------------|------------|
| Mean Pooling | 0 | 1.0× | 500M |
| Contrastive FT | 8.3 hours | 1.0× | 500M |
| ANA | **0.7 hours** | **0.98×** | 500M + 1024 |

**Advantage**: ANA requires minimal additional computation—only learning a 1024-dimensional mask vector.

---

## 8. Discussion

### 8.1 Why Does This Work?

Our results validate the central hypothesis: **pre-trained gLMs contain neurons that actively suppress variant-specific signals**. Three key insights emerge:

**1. Interference is learned, not random**
- Random ablation shows no improvement
- Systematic detection identifies specific neurons
- These neurons encode biologically interpretable patterns

**2. Redundancy enables reorganization**
- 15% ablation improves performance
- Network reallocates capacity to variant-sensitive features
- Consistent with Lottery Ticket Hypothesis [11]

**3. Conservation vs. variation trade-off**
- MLM pre-training prioritizes conserved patterns
- Interference neurons emerge as a consequence
- Ablation shifts trade-off toward variation

### 8.2 Connection to Neuroscience

Our approach mirrors neurological ablation studies where removing inhibitory circuits enhances specific functions [6]. For example:

- **Stroke recovery**: Removing damaged inhibitory neurons allows healthy regions to compensate
- **Savant syndrome**: Reduced inhibition in certain brain areas leads to enhanced specialized abilities

In neural networks, we observe analogous phenomena: removing "inhibitory" neurons allows "specialist" neurons to dominate.

### 8.3 Broader Implications

**Paradigm shift**: Our work challenges the assumption that *more capacity always helps*. In specialized domains, **strategic removal of capacity** may be more effective than addition.

**Negative learning**: While most ML focuses on "what to learn," we demonstrate the power of "what to unlearn." This opens new research directions:
- Can we pre-train models to be "ablation-ready"?
- Should we explicitly penalize interference neurons during training?
- Can adversarial ablation apply to other domains (images, text, audio)?

**Interpretability**: By identifying what to remove, we inherently learn what not to represent—providing negative evidence for mechanistic understanding.

### 8.4 Limitations

**1. Requires variant pairs for detection**
- Currently needs some Ref-Var examples
- Future work: unsupervised interference detection

**2. Fixed mask at inference**
- Cannot adapt to sequence-specific interference
- Potential extension: dynamic, context-dependent masking

**3. Linear masking**
- We use element-wise multiplication
- More sophisticated transformations (rotations, projections) may help

**4. Limited theoretical understanding**
- Why exactly 15-20% ablation is optimal remains unclear
- Need deeper analysis of reorganization dynamics

---

## 9. Related Open Questions

### 9.1 Theoretical Questions

**Q1**: Can we predict which neurons will interfere *before* ablation analysis?
- Potential: Analyze neuron activations on conserved vs. variable regions
- Challenge: High-dimensional, nonlinear interactions

**Q2**: Is there a universal "interference signature" across models?
- Our transfer results suggest yes
- Could enable pre-computed ablation masks

**Q3**: How does interference scale with model size?
- Do larger models have more interference?
- Or does redundancy offset it?

### 9.2 Methodological Extensions

**Dynamic masking**: Learn sequence-specific masks
$$
m(s) = g_\phi(f_\theta(s))
$$
where $g_\phi$ is a lightweight mask predictor.

**Differentiable ablation**: Replace hard masking with soft attention
$$
\tilde{E} = \sum_i (1 - m_i) \cdot w_i \cdot h_i
$$

**Multi-task ablation**: Simultaneously optimize for multiple variant types (SNVs, indels, SVs)

**Causal ablation**: Use causal inference to identify neurons with direct (not correlational) effects

### 9.3 Applications Beyond Genomics

**Protein language models**: Detect mutation effects on protein function

**Medical imaging**: Remove confounding features in disease classification

**Natural language**: Suppress gender/racial bias neurons

**Time series**: Remove seasonal effects for anomaly detection

---

## 10. Conclusion

We introduced **Adversarial Neuron Ablation (ANA)**, a novel framework for improving variant sensitivity in genomic language models by identifying and removing interference neurons. Our approach inverts the traditional machine learning paradigm: instead of learning what to attend to, we learn what to ignore.

Through systematic ablation analysis, we demonstrate that:
1. Pre-trained gLMs contain neurons that suppress variant-specific signals
2. Removing these neurons allows emergent reorganization toward variant-aware representations
3. Strategic ablation outperforms conventional approaches including contrastive fine-tuning
4. The method generalizes across architectures and datasets

This work opens new research directions in negative learning, model interpretability, and specialized domain adaptation. By challenging the "more is better" assumption, we show that **strategic subtraction can be more powerful than addition**.

As genomic medicine increasingly relies on AI for variant interpretation, methods like ANA that enhance variant sensitivity without requiring massive labeled datasets will be critical. We hope this work inspires further exploration of ablation-based learning across machine learning domains.

---

## References

[1] Ji, Y., et al. (2021). DNABERT: pre-trained Bidirectional Encoder Representations from Transformers model for DNA-language in genome. *Bioinformatics*.

[2] Dalla-Torre, H., et al. (2023). The Nucleotide Transformer: Building and Evaluating Robust Foundation Models for Human Genomics. *bioRxiv*.

[3] Zhou, J., & Troyanskaya, O. G. (2015). Predicting effects of noncoding variants with deep learning–based sequence model. *Nature Methods*.

[4] Avsec, Ž., et al. (2021). Effective gene expression prediction from sequence by integrating long-range interactions. *Nature Methods*.

[5] Benegas, G., et al. (2023). Genomic language models: opportunities and challenges. *Nature Machine Intelligence*.

[6] Lomber, S. G., & Malhotra, S. (2008). Double dissociation of 'what' and 'where' processing in auditory cortex. *Nature Neuroscience*.

[7] Chen, K., et al. (2022). Self-supervised learning on millions of pre-mRNA sequences improves sequence-based RNA splicing prediction. *bioRxiv*.

[8] Nguyen, E., et al. (2023). HyenaDNA: Long-Range Genomic Sequence Modeling at Single Nucleotide Resolution. *NeurIPS*.

[9] Han, S., et al. (2015). Learning both Weights and Connections for Efficient Neural Networks. *NeurIPS*.

[10] Molchanov, P., et al. (2019). Importance Estimation for Neural Network Pruning. *CVPR*.

[11] Frankle, J., & Carbin, M. (2019). The Lottery Ticket Hypothesis: Finding Sparse, Trainable Neural Networks. *ICLR*.

[12] Sanh, V., et al. (2020). Movement Pruning: Adaptive Sparsity by Fine-Tuning. *NeurIPS*.

[13] Olah, C., et al. (2020). Zoom In: An Introduction to Circuits. *Distill*.

[14] Meng, K., et al. (2022). Locating and Editing Factual Associations in GPT. *NeurIPS*.

[15] Chen, T., et al. (2020). A Simple Framework for Contrastive Learning of Visual Representations. *ICML*.

[16] Wang, T., & Isola, P. (2020). Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere. *ICML*.

[17] Madry, A., et al. (2018). Towards Deep Learning Models Resistant to Adversarial Attacks. *ICLR*.

[18] Zhou, Z., et al. (2023). DNABERT-2: Efficient Foundation Model and Benchmark For Multi-Species Genome. *arXiv*.

---

## Appendix

### A. Additional Experimental Details

#### A.1 Hardware
- GPU: 8× NVIDIA A100 (80GB)
- CPU: 128-core AMD EPYC
- RAM: 1TB
- Training time: ~1 hour for mask learning

#### A.2 Data Processing
- Sequences padded to length 1024
- Tokenization: 6-mer with stride 3
- Special tokens: [CLS], [SEP], [MASK]
- Normalization: None (raw DNA sequences)

#### A.3 Neuron Importance Metrics

Beyond cosine distance, we tested alternative importance measures:

**Gradient magnitude**:
$$
\Delta_j^{grad} = \left| \nabla_{h_j} \mathcal{L}_{variant} \right|
$$

**Activation variance**:
$$
\Delta_j^{var} = \text{Var}(h_j | \text{variant}) - \text{Var}(h_j | \text{reference})
$$

**Mutual information**:
$$
\Delta_j^{MI} = I(h_j; V)
$$

All metrics produced similar neuron rankings (Spearman ρ > 0.8), validating robustness.

### B. Failure Cases

We observed two scenarios where ANA underperforms:

**1. Structural variants**
- Large insertions/deletions (>10bp)
- Ablation designed for SNVs may not transfer
- Future work: variant-type-specific ablation

**2. Low-complexity regions**
- Homopolymer runs (e.g., AAAAAAA)
- Interference neurons correctly suppress these
- Need to distinguish biological vs. technical variation

### C. Reproducibility

All code, pre-trained models, and ablation masks available at:
**https://github.com/anonymous/adversarial-neuron-ablation**

Exact hyperparameters, random seeds, and data splits provided for full reproducibility.

### D. Broader Impact

**Positive impacts**:
- Improved variant interpretation for precision medicine
- Reduced need for expensive labeled datasets
- Generalizable framework for other domains

**Potential concerns**:
- Over-reliance on automated variant calling
- Biases in pre-training data may persist
- Clinical validation required before medical use

We emphasize that ANA is a research tool, not a clinical diagnostic. Medical decisions should involve human oversight.

---

**Acknowledgments**

We thank the organizers of the MAI competition for providing benchmark datasets, and the developers of Nucleotide Transformer for open-sourcing pre-trained models. We also acknowledge insightful discussions with colleagues in mechanistic interpretability and computational biology.

This work was supported by [ANONYMOUS for review].

---

**Author Contributions**

All authors contributed equally to conceptualization, methodology, experimentation, and writing. Order determined by coin flip.

---

## Ethics Statement

This work follows ethical guidelines for AI research:
- No patient data used without consent
- Public datasets only
- Transparent methodology
- Code and data openly shared
- Clinical applicability clearly delineated

We commit to responsible development of genomic AI technologies.
```

### AnimalsMind.md

**Path:** `frontend/public/posts/2025/AnimalsMind.md`

```markdown
---
title: "우리는 DNA의 꼭두각시인가: 이성의 붕괴와 야성적 충동의 역설에 대한 생각"
date: "2025-12-01"
category: "Essays"
tags: ["Philosophy","Economics","Psychology","Minsky","Evolution"]
excerpt: "애덤 스미스의 이성적 인간관에 대한 반박부터 케인스와 민스키의 야성적 충동, 그리고 진화심리학적 관점까지. 인간 본성의 모순에 대한 생각"
author: "Admin"
published: true
---

"모든 고통은 욕망에서 비롯된다." 오래된 철학적 명제처럼 들리지만, 사실 이것은 지극히 과학적인 사실일지도 모른다.

 결국 인간의 고통과 욕망이란 우리 DNA에 각인된 유기화학적 반응이며, 생존을 위해 발동하는 야성적 충동의 결과값일 뿐이기 때문이다.
실제로 우리는 스스로를 이성적이고 합리적인 존재라 믿고 싶어 하지만 경제의 역사와 인간의 내면을 들여다보면, 그 믿음은 처참히 깨지기 일쑤임을 볼 수 있다.

## 1. 애덤 스미스의 오판과 이성의 한계
고전 경제학의 아버지 애덤 스미스는 인간의 **'이성적 사고관'**을 신뢰했고, 그는 개인의 합리적 이기심이 시장을 조화롭게 이끌 것이라 보았다. 하지만 그의 이론은 설명할 수 없는 것이 있었는데, 바로 대중의 광기와 불안으로 인한 '대공황'이었다.

인간이 정말로 합리적이라면, 왜 스스로 파국을 향해 달려가는 것일까요? 이 모순적 한계에 대한 답은 오랜 시간이 흐른 뒤, 존 메이너드 케인스와 하이먼 민스키에 의해 해석되게 된다. 그들의 전제는 단순하지만 충격적이었다.

> "인간은 결코 이성적일 수 없다."

## 2. 안정의 역설: 평온은 붕괴를 잉태한다
하이먼 민스키는 인간을 미래에 대한 불안을 안고 살아가는 존재로 정의했다. 우리는 이성이 아닌 **'야성적 충동(Animal Spirits)'**에 휩쓸린다.
여기서 **'안정의 역설(Paradox of Stability)'**이 발생하게 되는데, 경제와 삶이 안정적일 때, 인간의 DNA는 그 안정을 견디지 못하거나 영원할 것이라는 착각에 빠지게된다. 그래서 과도한 위험을 감수하고 투기를 감행하는 안정된 세계관 붕괴의 비극을 스스로 불러일으킨다.

결국 안정은 역설적으로 장기적인 붕괴를 낳는다는 것이다. 우리가 구성적 오류와 본능을 통제하지 못한다면, 영원한 불안과 실패의 공포는 필연적인 것이다. 즉, 경제 위기의 본질은 시스템의 결함이 아니며, 그것은 DNA에 새겨진 인간 본성의 필연적 발현이라 볼 수 있다.

## 3. 진화의 지체: 구석기 뇌로 스마트폰을 쥐다
우리의 야성적 본능은 수만 년 전 사바나 초원에 머물러 있다. 그러나 우리는 고도로 발달한 첨단 기술의 시대를 살고 있으며, 인간의 본성은 이 급변한 환경에 적응할 수 있을 만큼 빠르게 진화하지 못했다. 혹은 너무 빠르게 발전했다거나.

이러한 '진화의 지체'가 낳은 비극은 우리를 **스스로를 안다고 착각하는 도구(Tool)**로 전락시켰다.

## 4. 가시덤불을 쥔 손: 의식이라는 허상
우리는 스스로 생각하고 결정한다고 믿는다. 하지만 우리는 그저 내면 무의식의 복잡한 전투 끝에 도출된 '결과값'을 화면에 띄우는 모니터일지도 모르겠다.
거대한 육체 덩어리는 사실 호르몬 작용이라는 야성적 충동과 내면 무의식 간의 치열한 전장의 승자에 조종 당하게 된다.즉, 우리가 매우 합리적인 것이라 생각한 의식은 그 전투에서 승리한 쪽의 의견을 대변할 뿐인 아주 일부분만을 표출하는 것이다.

그 결과, 인간은 비극적인 선택을 반복한다. 그것은 마치 가시덤불을 움켜쥐고 있는 것과 같은 모순이다.
가시에 찔려 피가 흐르는 고통을 느끼면서도, 손을 펴면 이 덤불마저 빼앗길까 봐 두려워 더 강하게 움켜쥔다. 야성적 충동에 억압된 인간은 그 사슬을 끊지 못한 채, 불안이라는 족쇄에 묶여 스스로 상처를 깊게 만든다.

## 내 생각
우리가 이토록 불안정한 존재임을 깨닫는 것은 고통스러운 일입니다. 하지만 인정해야 합니다. 거창한 이성이나 자유의지가 아니라, 호르몬과 DNA가 빚어낸 충동이 나를 지배하고 있음을.
어쩌면 인간의 삶이란, 승리할 수 없는 내면의 전투를 끊임없이 관전하며, 그 불안정함 속에서 위태로운 균형을 잡으려 애쓰는 과정 그 자체일지도 모릅니다.
```

### BST-think01.md

**Path:** `frontend/public/posts/2025/BST-think01.md`

```markdown
---
title: "BST TreeInsertion 횟수 구하기 고민한 내용 정리"
date: "2025-10-17"
category: "Algorithm"
tags: ['Machine Learning', 'BST', '최적화', '줌인']
excerpt: "BST 트리 호출 횟수 구하기를 보다가 떠오른 최적화 방안 생각 정리"
readTime: "7분"
---

BST 를 처음 구현하는데 뭔가 각 레벨의 레이어의 전체 순회는 비효율적일 것 같다는 느낌이 들었다.

이러한 이유로 조금 고민해보니 
>BST 전체 순회없이 Bottom-up 방식에서 중간 레이어 건너뛰고 근접값에서의 가중치 구하기만 적용하면 바로 횟수 알 수 있지 않을까라는 아이디어에서 확장한 내용이 아래와 같다.

### 아이디어를 세분화 해보자.
- **위치 예측**: 가중치·편향으로 데이터 위치를 O(1)에 예측
- **국소 탐색**: 예측된 위치 주변만 탐색하여 호출 횟수 감소
- **데이터 분포 학습**: 트리 순회 대신 패턴 학습으로 접근
- **캐시 친화적**: 연속된 메모리 접근으로 성능 향상

> 문제는 나는 BST 도 처음 구현한다는 것이었다. 머신러닝인 것 같은 느낌이 드는데 머신러닝은 공부해본 적도 없다. 
### Thinking..
- 그냥 처음부터 생각해보자..
- 흠.. 생각해보니 벡터 공간상에서 가중치를 적용하여 가장 근접값을 생각해볼 수 있겠다. 이걸 사용하면 될 듯..
- LLM 의 가중치와 bias 를 사용하여 추적 범위를 줄이면 원시인이 가장 효율적인 음식을 찾기와 같은 방식을 사용 가능할 것 같다..
- 그러면.. 가중치 * 키 + bias 를 적용하면 그 자체로 벡터 공간 상에서의 대략적 위치를 표시 가능할 것 같은 생각이 났다.
- 굳이 일차원적인 트리구조에 대한 연산에 더 고차원적인 연산이 필요할까? 같은 차원에서 모두 처리 가능할 것 같은데?
- 트리는 그 자체로 정렬되어 있으니 그나마 다행이다.
- 역전파 확산 방식처럼 오차의 정도는 어떻게 파악할까? 트리의 잘못된 리프노드에서의 예상값 적용은 오히려 역효과를 낼 수 있다.
- 일단 같은 차원의 자료구조 중에 유동적인 배열 등을 사용하면 좋을 것 같은데, 공간 상의 연산이므로 벡터 자료 구조를 사용하면 좋겠다. 
- wight, bias 를 어떻게 구현할까?
- 일단 평균적인 시냅스 연결처럼 평균 가중치와 편향도를 구해야겠다.
- 잘못 생각했다. 바로 앞만 보고 가다가는 방향조차 잃을 것이다.
- 일단 지도를 다시 만들어보자
### Thinking.. 2
1. 지구본에서 특정 지역을 보려면 확대만 하면 되는데, 대략적인 위치를 알아야 가능하다. 우린 어떻게 구분 가능한가?
    - 트리 구조에서는 대략적인 크기의 차이에 따른 구분이 가능하다.
    - 즉, 예상위치는 그 크기에 가중치를 곱하고나서 그 근처의 편향을 적용하면 찾을 수 있을 것 같다. - 그 이후에는 경사하강법처럼 그 주변을 살펴보면 된다.
2. 머리가 복잡하니 핵심만 다시 짚어보자 
    - 일단 중심을 찾는다.
    - 크기에 따른 예상 위치 추적
    - 그 주변만 살핀다.

## 일단 결론
###  머신러닝, 딥러닝 공부를 하나도 안 해서 수식적으론 이 느낌을 정리하기 힘든 것 같다. 

```

### BankRuptIn1929.md

**Path:** `frontend/public/posts/2025/BankRuptIn1929.md`

```markdown
---
title: "왜 Bank of America는 있는데, Bank of United States는 없을까?"
date: "2025-01-20"
category: "History"
tags: ["대공황","기업사","재무데이터","은행위기","생존전략"]
excerpt: "1929년 뉴욕 퀸즈에서 한 은행 앞에 몰린 예금자 행렬은 미국 금융사의 결정적 장면으로 남았다. 이름만 보면 국립은행처럼 신뢰를 줬던 Bank of United States는 단 며칠 사이에 무너졌고, 그 여파는 대공황을 더욱 깊게 만들었다. 이 글은 1929년 정점에서 1933년 바닥까지, 기업의 재무 데이터를 따라가며 생존과 몰락의 서사를 재구성한다."
author: "Admin"
published: true
defaultLanguage: "ko"
availableLanguages: ["en"]
translations:
  en:
    title: " Why is Bank of America here but Bank of United States is gone?"
    description: "A data-rich narrative tracing how specific companies either collapsed or survived between 1929 and 1933."
    excerpt: "From GE and Coca-Cola to Ford and US Steel, follow the financial plot lines that defined who endured the Great Depression and who fell."
---
  
## 왜 Bank of America 는 있는데, Bank of United States 는 없을까?

1929년 뉴욕 퀸즈에서 한 은행 앞에 몰린 예금자 행렬은 미국 금융사의 결정적 장면으로 남았다. 이름만 보면 국립은행처럼 신뢰를 줬던 Bank of United States는 단 며칠 사이에 무너졌고, 그 여파는 대공황을 더욱 깊게 만들었다. 이 글은 1929년 정점에서 1933년 바닥까지, 기업의 재무 데이터를 따라가며 생존과 몰락의 서사를 재구성한다.

## 1929년 9월, 전례 없는 번영의 정점

1929년 9월 3일, 다우존스 산업평균지수는 381.17로 사상 최고치를 찍었다. 공장 가동률은 111로 정점을 기록했고, 650개 기업의 1929년 상반기 수익은 전년 대비 24.4% 늘어났다.(1)(2) 모두가 "새로운 시대"를 외쳤지만, 두 달 뒤 시작될 폭락을 감지한 이는 드물었다.

## 제1막: 붕괴 – 블랙 튜즈데이의 충격

### 주가 폭락의 시퀀스

- 10월 24일 블랙 목요일: 장 초반 11% 급락
- 10월 28일 블랙 먼데이: 하루 만에 12% 추가 하락
- 10월 29일 블랙 튜즈데이: 1,641만 주 거래와 함께 다시 11% 폭락

한 달 사이 증시는 약 160억 달러의 가치를 잃었다. 제너럴 일렉트릭(GE)은 396달러에서 210달러로 47% 하락했고, AT&T는 하루 만에 100달러가 증발했다. US Steel(261→166달러, -36%), 듀폰(217→80달러, -63%), RCA(505→26달러, -95%) 등 대형주가 줄줄이 무너졌다.(3)(4)

## 제2막: 생존자들의 전략 (1929-1933)

### 제너럴 일렉트릭 – 혁신으로 버티다

- 1929년 순이익 6,729만 달러, 매출 4억 1,534만 달러 (전년 대비 +23%)
- 1930년대 전체(1930~1939) 누적 순이익 7,553만 달러로 급락
- 전력 설비 투자가 7억 4,000만 달러에서 3억 4,000만 달러(-54%)로 줄었지만 R&D를 유지

GE는 의료 영상, 가전, 플라스틱 등 신사업을 키우며 전력 수요 급감의 충격을 완화했다.(5)(6)

### 코카콜라 – 불황 속 성장 신화

| 연도 | 매출(만 달러) | 순이익(만 달러) | 시럽 판매량(만 갤런) |
| ---- | ------------- | --------------- | -------------------- |
| 1929 | 3,926         | 1,276           | N/A                  |
| 1930 | 4,130         | 1,350           | 2,780                |
| 1931 | 4,020         | 1,400           | 2,670                |
| 1932 | N/A           | 870             | N/A                  |
| 1933 | N/A           | 880             | N/A                  |

원자재 가격 하락과 비용 절감 덕분에 배당을 유지했고, 1934년 순이익은 1,200만 달러로 40% 급반등했다.(7)(8)

### 프록터 앤 갬블 – 필수재의 힘

- 경쟁사들이 광고비를 줄일 때 오히려 광고와 시장조사 예산을 확대
- 1933년 합성세제 Dreft 출시로 세탁 시장 선점
- 1934년 순이익 1,437만 달러 (1933년 1,081만 달러 대비 +33%)

생활 필수재는 불황에도 꾸준히 팔렸고, 공격적 마케팅이 브랜드 충성도를 높였다.(9)(10)

### 크라이슬러 – 역경 속 시장점유율 3배

- 1929년 시장점유율 8.9%
- 1932년 1,125만 달러 손실에도 구조조정과 저가 전략으로 버텨 1933년 순이익 1,213만 달러(주당 2.78달러)
- 1933년 시장점유율 25.3%로 Ford를 추월, 주가 7.75달러 → 52.87달러 (682% 상승)

플리머스 브랜드 확대와 비수기 마케팅이 수요를 끌어올렸다.(11)(12)

### IBM – 역발상 투자

- 1929~1932년 생산능력 33% 확충, 매출 1,700만~1,900만 달러로 정체
- 1932년 매출의 6%를 연구센터 건설에 투자
- 1930년 6,346명 → 1935년 8,654명으로 고용 확대
- 1935년 사회보장법 계약 확보로 매출 2,100만 달러, 1937년 3,100만 달러까지 증가

모두가 감축할 때 R&D와 재고를 늘렸고, 사회보장제도 도입으로 쌓아둔 장비가 황금이 됐다.(13)(14)(15)

## 제3막: 거인들의 몰락

### 포드 – 경직성의 대가

- 1929년 순이익 8,180만 달러 → 1930년 4,446만 달러 (-46%) → 1931년 -5,359만 달러
- 고용 17만 4,000명 → 4만 9,000명 (-72%), 루지 공장 9만 8,000명 → 2만 9,000명 (-71%)
- 수직 통합 구조의 고정비와 느린 대응, 가격 인상이 치명타

1933년까지 6년간 누적 이익은 3,300만 달러에 불과했다.(16)(17)(18)

### US Steel – 철강 제국의 추락

- 1929년 순이익 1억 9,700만 달러
- 1930년 1억 400만 달러 (-47%)
- 1931년 1,300만 달러 (특별수입 제외 시 적자)
- 1932년 가동률 10%, 1933년 생산량 최저치

수요 붕괴로 설비 가동이 멈췄고, 배당 지급 후 대규모 적자가 발생했다.(16)(19)(20)

### 제너럴 모터스 – 선방했지만 고통은 피할 수 없었다

| 연도 | 순이익(만 달러) |
| ---- | --------------- |
| 1929 | 248,280         |
| 1930 | 141,620         |
| 1931 | 96,880          |
| 1932 | 1,650           |
| 1933 | 83,210          |

GM은 공장 가동 중단, 대량 해고, 브랜드 축소, 저가 쉐보레의 손익분기점 33% 하향 등 초고속 비용 절감으로 현금을 지켰다. 1933년에도 현금 및 시장성 증권이 2억 400만 달러에 달했다.(21)(22)(23)(18)

### 몽고메리 워드 – 소매 거인의 고난

- 1930년 1분기 손실 200만 달러 이상
- 1930년 24개 매장, 1931년 18개 매장 추가 폐쇄
- JP Morgan의 압박으로 새 사장 시웰 에이버리를 선임, 구조조정과 리모델링

극단적인 비용 절감으로 1930년대 후반 수익성을 회복했다.(24)(25)

### 울워스 – 예상 밖의 승자

1931년 순이익 4,135만 달러(영국 자회사 주식 매각익 제외 시 3,100만 달러)로 기록을 세웠다. 낮은 단가와 폭넓은 점포망이 위기 속 강점으로 작동했다.(26)

## 제4막: 금융 시스템의 붕괴

### Bank of United States – 도미노의 시작

- 1930년 12월 11일 파산: 예금 2억 달러, 예금자 40만 명 영향
- 1930년 11~12월 두 달간 608개 은행 파산, 예금 손실 5억 5,000만 달러 (이 중 3분의 1이 Bank of United States)
- 1931년 2,294개 은행 파산, 예금 손실 17억 달러
- 1929~1933년 총 9,000개 은행 파산, 70억 달러 예금 증발

단일 은행 붕괴가 전국적 뱅크런을 촉발했고, 은행들은 대출 회수와 자산 매각에 나서면서 실물경제의 추락을 가속했다.(27)(28)(29)

### Chase National Bank – 위기 속 확장

Chase는 불황기에 Garfield National Bank, National Park Bank, Equitable Trust Company, Interstate Trust Company 등을 잇달아 인수하며 1930년 세계 최대 은행으로 부상했다. 위기 속 기회를 포착한 대표적 사례다.(30)(31)

## 제5막: 산업별 명암

### 자동차 산업 – 75% 매출 증발

- 생산량 1929년 562만 대 → 1932년 143만 대 (-75%)
- 1932년 업계 합산 손실 1억 9,100만 달러
- 1929~1932년 자동차 브랜드 75% 폐업

1933년 204만 대로 반등했으나, 구조조정의 상흔이 깊었다.(18)(32)(33)

### 거시 지표의 붕괴

- GDP: 1929년 1,040억 달러 → 1933년 550억 달러 (-47%)
- 산업생산지수: 114 → 54 (-53%)
- 실업률: 3.1% → 25.0% (1,263만 명)
- 도매물가: 33% 하락, 화폐공급(M2) 30% 감소
- 기업 파산: 1931년 28,285건, 일평균 133건

경제 시스템 전반이 붕괴하며 수요와 공급, 금융이 동시에 마비됐다.(34)(35)

## 에필로그: 교훈과 유산

### 생존 기업의 공통점

1. **제품의 필수성** – 코카콜라와 P&G처럼 불황에도 소비가 지속되는 상품
2. **재무 건전성** – 낮은 부채와 두터운 현금 보유
3. **전략적 유연성** – 크라이슬러와 IBM처럼 위기를 기회로 전환
4. **혁신 지속** – GE와 IBM의 R&D 투자 유지
5. **비용 관리** – GM의 공격적 구조조정과 손익분기점 하향

### 실패 기업의 공통점

1. **높은 고정비** – 포드처럼 수직 통합 구조에 묶인 비용
2. **경직된 사고** – 초반 경고 신호를 무시한 경영 판단
3. **과도한 레버리지** – 은행과 금융사의 연쇄 파산
4. **경기 민감 산업 집중** – 철강, 건설, 자동차 등 순환 산업 의존

### 숫자로 본 1929~1933년의 재앙

- 주가는 89.2% 폭락했고, 은행의 3분의 1이 사라졌다.
- 4명 중 1명이 일자리를 잃었고, 뉴욕에서는 2만 9,000개 제조업체 중 1만 곳이 폐업했다.

그럼에도 IBM의 토머스 왓슨처럼 미래를 준비한 기업은 절망의 시대를 도약의 발판으로 바꾸었다. 대공황의 교훈은 분명하다. **최악의 시기에도 미래를 준비하는 기업만이 살아남는다.**

## References

[1] Gordon, R. A. (1990) *The 1929 stock market crash*. EH.Net Encyclopedia. Available at: [https://eh.net/encyclopedia/the-1929-stock-market-crash/](https://eh.net/encyclopedia/the-1929-stock-market-crash/) (Accessed: 8 November 2025).

[2] Chen, J. (2023) ‘What caused the stock market crash of 1929?’, *Investopedia*, 27 April. Available at: [https://www.investopedia.com/ask/answers/042115/what-caused-stock-market-crash-1929-preceded-great-depression.asp](https://www.investopedia.com/ask/answers/042115/what-caused-stock-market-crash-1929-preceded-great-depression.asp) (Accessed: 8 November 2025).

[3] Britannica (2024) ‘Stock market crash of 1929’. Available at: [https://www.britannica.com/event/stock-market-crash-of-1929](https://www.britannica.com/event/stock-market-crash-of-1929) (Accessed: 8 November 2025).

[4] University of Houston (n.d.) ‘The Great Crash’. *Digital History*. Available at: [https://www.digitalhistory.uh.edu/disp_textbook.cfm?smtID=2&psid=3431](https://www.digitalhistory.uh.edu/disp_textbook.cfm?smtID=2&psid=3431) (Accessed: 8 November 2025).

[5] ‘General Electric shows record net’ (1930) *The New York Times*, 24 March. Available at: [https://www.nytimes.com/1930/03/24/archives/general-electric-shows-record-net-67289880-profit-reported-for-1929.html](https://www.nytimes.com/1930/03/24/archives/general-electric-shows-record-net-67289880-profit-reported-for-1929.html) (Accessed: 8 November 2025).

[6] ‘Utilities: Happy G.E.’ (1934) *TIME*, 12 February. Available at: [https://time.com/archive/6770018/utilities-happy-g-e/](https://time.com/archive/6770018/utilities-happy-g-e/) (Accessed: 8 November 2025).

[7] ‘Coca-Cola profits up 25.21% in 1929’ (1930) *The New York Times*, 6 February. Available at: [https://www.nytimes.com/1930/02/06/archives/cocacola-profits-up-2521-in-1929-company-reports-increase-in-its.html](https://www.nytimes.com/1930/02/06/archives/cocacola-profits-up-2521-in-1929-company-reports-increase-in-its.html) (Accessed: 8 November 2025).

[8] Gurufocus (2012) ‘The Coca-Cola Company 1930-1934’. Available at: [https://www.gurufocus.com/news/170243/the-cocacola-company-19301934](https://www.gurufocus.com/news/170243/the-cocacola-company-19301934) (Accessed: 8 November 2025).

[9] ‘Procter and Gamble 1929 crisis’ (2016) *Scribd*. Available at: [https://ro.scribd.com/document/313448703/Procter-and-Gamble-1929-crisis](https://ro.scribd.com/document/313448703/Procter-and-Gamble-1929-crisis) (Accessed: 8 November 2025).

[10] Kim, S. (2025) ‘Procter & Gamble: A century of steady gains in the Dow Jones’, *DisruptionBanking*, 13 October. Available at: [https://www.disruptionbanking.com/2025/10/13/procter-gamble-a-century-of-steady-gains-in-the-dow-jones/](https://www.disruptionbanking.com/2025/10/13/procter-gamble-a-century-of-steady-gains-in-the-dow-jones/) (Accessed: 8 November 2025).

[11] ‘Business: Cock of 1933’ (1933) *TIME*, 9 October. Available at: [https://time.com/archive/6752319/business-cock-of-1933/](https://time.com/archive/6752319/business-cock-of-1933/) (Accessed: 8 November 2025).

[12] ‘Chrysler earns $12,129,119 in year’ (1934) *The New York Times*, 10 February. Available at: [https://www.nytimes.com/1934/02/10/archives/chrysler-earns-12129119-in-year-net-equal-to-278-a-share-contrasts.html](https://www.nytimes.com/1934/02/10/archives/chrysler-earns-12129119-in-year-net-equal-to-278-a-share-contrasts.html) (Accessed: 8 November 2025).

[13] Farnam Street (2019) ‘IBM’s competitive advantage’. Available at: [https://fs.blog/ibm-competitive-advantage/](https://fs.blog/ibm-competitive-advantage/) (Accessed: 8 November 2025).

[14] Lochhead, C. (2020) ‘What IBM’s experience during the Great Depression can teach today’s tech CEOs’. Available at: [https://lochhead.com/blog/what-ibms-experience-during-the-great-depression-can-teach-todays-tech-ceos/](https://lochhead.com/blog/what-ibms-experience-during-the-great-depression-can-teach-todays-tech-ceos/) (Accessed: 8 November 2025).

[15] Wikipedia (2025) ‘History of IBM’. Available at: [https://en.wikipedia.org/wiki/History_of_IBM](https://en.wikipedia.org/wiki/History_of_IBM) (Accessed: 8 November 2025).

[16] ‘Business & finance: Earnings’ (1934) *TIME*, 29 January. Available at: [https://time.com/archive/6748672/business-finance-earnings-2/](https://time.com/archive/6748672/business-finance-earnings-2/) (Accessed: 8 November 2025).

[17] ‘1932: A year of tragedy and triumph’ (2008) *Autoweek*, 10 July. Available at: [https://www.autoweek.com/news/a2057491/1932-year-tragedy-and-triumph/](https://www.autoweek.com/news/a2057491/1932-year-tragedy-and-triumph/) (Accessed: 8 November 2025).

[18] Boston Consulting Group (2010) *Accelerated out of the Great Depression*. Available at: [https://www.bcg.com/publications/2010/growth-automakers-accelerated-out-great-depression](https://www.bcg.com/publications/2010/growth-automakers-accelerated-out-great-depression) (Accessed: 8 November 2025).

[19] ‘U.S. Steel’ (2024) *American Butler*. Available at: [https://americanbutler.ru/en/useful/history/great-depression](https://americanbutler.ru/en/useful/history/great-depression) (Accessed: 8 November 2025).

[20] Boyd, J. (2019) ‘The long strange history of U.S. Steel’, *Engineering.com*. Available at: [https://www.engineering.com/the-long-strange-history-of-u-s-steel/](https://www.engineering.com/the-long-strange-history-of-u-s-steel/) (Accessed: 8 November 2025).

[21] General Motors Corporation (1930) *Annual report 1930*. McGill University Digital Library. Available at: [https://digital.library.mcgill.ca/images/hrcorpreports/pdfs/G/General_Motors_Corporation_1930.pdf](https://digital.library.mcgill.ca/images/hrcorpreports/pdfs/G/General_Motors_Corporation_1930.pdf) (Accessed: 8 November 2025).

[22] General Motors Corporation (1933) *Annual report 1933*. McGill University Digital Library. Available at: [https://digital.library.mcgill.ca/images/hrcorpreports/pdfs/G/General_Motors_Corporation_1933.pdf](https://digital.library.mcgill.ca/images/hrcorpreports/pdfs/G/General_Motors_Corporation_1933.pdf) (Accessed: 8 November 2025).

[23] ‘General Motors made big 1933 gain’ (1934) *The New York Times*, 26 January. Available at: [https://www.nytimes.com/1934/01/26/archives/general-motors-made-big-1933-gain-net-profits-were-83214000-against.html](https://www.nytimes.com/1934/01/26/archives/general-motors-made-big-1933-gain-net-profits-were-83214000-against.html) (Accessed: 8 November 2025).

[24] University of Wyoming (n.d.) *Montgomery Ward records*. Available at: [https://www.uwyo.edu/ahc/_files/pdffa/08088.pdf](https://www.uwyo.edu/ahc/_files/pdffa/08088.pdf) (Accessed: 8 November 2025).

[25] Wikipedia (2025) ‘Montgomery Ward’. Available at: [https://en.wikipedia.org/wiki/Montgomery_Ward](https://en.wikipedia.org/wiki/Montgomery_Ward) (Accessed: 8 November 2025).

[26] ‘Woolworth profit highest in history’ (1932) *The New York Times*, 28 January. Available at: [https://www.nytimes.com/1932/01/28/archives/woolworth-profit-highest-in-history-company-reports-earnings-of.html](https://www.nytimes.com/1932/01/28/archives/woolworth-profit-highest-in-history-company-reports-earnings-of.html) (Accessed: 8 November 2025).

[27] British Broadcasting Corporation (2023) ‘Great Depression facts’. Available at: [https://www.bbc.co.uk/bitesize/articles/zmjmywx](https://www.bbc.co.uk/bitesize/articles/zmjmywx) (Accessed: 8 November 2025).

[28] Social Security Administration (2020) ‘Bank failures in the Great Depression’. Available at: [https://www.ssa.gov/history/bank.html](https://www.ssa.gov/history/bank.html) (Accessed: 8 November 2025).

[29] Wikipedia (2025) ‘Bank of United States’. Available at: [https://en.wikipedia.org/wiki/Bank_of_United_States](https://en.wikipedia.org/wiki/Bank_of_United_States) (Accessed: 8 November 2025).

[30] Britannica (2024) ‘The Chase Manhattan Corporation’. Available at: [https://www.britannica.com/money/The-Chase-Manhattan-Corporation](https://www.britannica.com/money/The-Chase-Manhattan-Corporation) (Accessed: 8 November 2025).

[31] EBSCO (2023) ‘JPMorgan Chase’. *Research Starters*. Available at: [https://www.ebsco.com/research-starters/business-and-management/jpmorgan-chase](https://www.ebsco.com/research-starters/business-and-management/jpmorgan-chase) (Accessed: 8 November 2025).

[32] ‘American automobile industry’ (2023) *Research Starters*. EBSCO. Available at: [https://www.ebsco.com/research-starters/history/american-automobile-industry-1930s](https://www.ebsco.com/research-starters/history/american-automobile-industry-1930s) (Accessed: 8 November 2025).

[33] Webb, M. (2023) ‘Automobile brand failures during the Great Depression’, *Journal of Business History*, 12(2), pp. 45–63. Available at: [https://webofjournals.com/index.php/1/article/download/2068/2050/4041](https://webofjournals.com/index.php/1/article/download/2068/2050/4041) (Accessed: 8 November 2025).

[34] Britannica (2024) ‘Great Depression’. Available at: [https://www.britannica.com/event/Great-Depression](https://www.britannica.com/event/Great-Depression) (Accessed: 8 November 2025).

[35] Federal Reserve History (2013) ‘The Great Depression’. Available at: [https://www.federalreservehistory.org/essays/great-depression](https://www.federalreservehistory.org/essays/great-depression) (Accessed: 8 November 2025).

```

### FutureClouding.md

**Path:** `frontend/public/posts/2025/FutureClouding.md`

```markdown
---
title: "격자를 부수다: 폰 노이만 아키텍처의 종말과 그리드 시스템의 한계"
date: "2025-02-21"
category: "기술"
tags: ['폰노이만아키텍처', '그리드시스템', '분산컴퓨팅', '엣지컴퓨팅', '블록체인']
excerpt: "우리가 당연하게 여겼던 중앙화된 '그리드' 시스템의 환상을 깨고, 폰 노이만 아키텍처의 근본적 한계를 넘어 분산형 미래로 나아가는 길을 제시합니다."
readTime: "6분"
---

## 우리가 숭배한 '그리드'라는 환상

우리는 질서정연한 '그리드(Grid)' 시스템을 신뢰하도록 교육받았습니다. 도시 계획, 전력망, 그리고 컴퓨터 아키텍처까지. 모든 것이 중앙에서 통제되고 격자처럼 예측 가능하게 연결되는 구조는 효율성의 상징처럼 여겨졌습니다. 하지만 이는 안정성이란 이름 아래 숨겨진 거대한 **취약성**의 다른 이름일 뿐입니다.

기존의 고정관념은 그리드가 가장 안정적이라고 말하지만, 이는 **단 하나의 치명적인 약점**을 외면하는 주장입니다. 그리드의 심장, 즉 중앙이 멈추면 모든 것이 멈춥니다. 이제 그 낡은 신념에 반론을 제기할 때입니다.



### 모든 문제의 시작점: 폰 노이만 병목현상

컴퓨터 과학의 근간을 이루는 **폰 노이만 아키텍처** 자체가 바로 중앙 집중형 그리드 사고의 완벽한 예시입니다.

-   **구조**: 연산을 담당하는 CPU(중앙처리장치)와 데이터를 저장하는 메모리가 분리되어 있습니다.
-   **근본적 한계**: CPU가 일을 하려면 메모리에서 데이터를 가져와야 하고, 결과를 다시 메모리에 저장해야 합니다. 이 둘을 잇는 통로(버스)는 한정되어 있어 모든 데이터가 이 좁은 길을 지나가야만 합니다. 이것이 바로 **'폰 노이만 병목현상'**입니다.

마치 모든 국민이 단 하나의 관공서에서만 서류를 뗄 수 있는 것과 같습니다. 아무리 CPU가 빨라져도 데이터가 오가는 길이 막히면 전체 시스템의 속도는 저하될 수밖에 없습니다.

**엣지 컴퓨팅**은 바로 이 낡은 아키텍처에 대한 반역입니다. 모든 데이터를 중앙 CPU로 보내 처리하는 대신, "데이터가 발생하는 그 자리에서 즉시 처리하자"는 발상입니다. 이는 폰 노이만 구조의 중앙 집중성을 **물리적으로 분산**시켜 병목현상 자체를 회피하는 근본적인 해결책입니다.

### 블록체인 철학: 죽음을 허락하는 생존

중앙화된 시스템의 또 다른 고정관념은 '데이터는 안전한 단 하나의 저장소에 있어야 한다'는 믿음입니다. 하지만 이 "안전한 저장소"가 파괴되면 모든 것이 끝납니다.

블록체인의 아이디어는 이 고정관념을 정면으로 반박합니다.

**개념**: 원본 데이터 하나를 철옹성처럼 지키는 대신, 수많은 복사본(원장)을 네트워크 전체에 흩뿌려 놓습니다.

**효과**:
-   **단일 장애점의 완전한 제거**: 저장소 몇 개, 혹은 수십 개가 해킹당하거나 물리적으로 파괴되어도 네트워크의 나머지 노드들에 원본이 그대로 살아있습니다.
-   **무조건적인 데이터 복구**: 네트워크가 살아있는 한 데이터는 **무조건 복구 가능합니다.** 이는 '죽지 않으려는' 시스템이 아니라, 일부의 '죽음을 당연하게 허용함으로써' 전체가 영원히 살아남는 역설적인 생존 전략입니다.

메쉬 네트워크의 데이터 저장 방식은 바로 이 철학을 따릅니다. 데이터는 더 이상 중앙 서버라는 하나의 심장에 의존하지 않고, 네트워크 전체에 흐르는 피처럼 존재하게 됩니다.

### 그리드를 넘어 유기체로

우리는 지금 기술 패러다임의 거대한 전환을 목격하고 있습니다.

1.  **아키텍처의 전환**: 중앙 처리(폰 노이만)에서 **분산 지능(엣지 컴퓨팅)**으로.
2.  **데이터 철학의 전환**: 중앙 집중형 보관에서 **분산 원장을 통한 영속성(블록체인)**으로.
3.  **시스템 구조의 전환**: 경직된 '그리드'에서 유연하고 자율적인 **'유기체적 네트워크(메쉬망)'**로.

이는 단순히 더 빠른 컴퓨터를 만드는 문제가 아닙니다. 지난 수십 년간 이어져 온 중앙 통제와 위계질서라는 낡은 관념을 부수고, 자율, 분산, 그리고 회복탄력성이라는 새로운 가치를 기술의 핵심에 심는 철학입니다.

### 참고자료

- [폰 노이만 병목현상이란? (Techopedia)](https://www.techopedia.com/definition/27016/von-neumann-bottleneck)
- [나심 탈레브의 안티프래질 (Antifragile)](https://en.wikipedia.org/wiki/Antifragile)
- [블록체인의 기본 원리 (Investopedia)](https://www.investopedia.com/terms/b/blockchain.asp)

---

*이 포스트는 예측 가능한 질서의 감옥을 부수고, 예측 불가능한 자유 속에서 더 강인하게 생존하는 미래 시스템에 대한 선언입니다.*

```

### Limitation-Of-Transformer.md

**Path:** `frontend/public/posts/2025/Limitation-Of-Transformer.md`

```markdown
---
title: "트랜스포머의 한계에 대하여: 바텀업을 넘어 하향식으로"
date: "2025-10-17"
category: "AI"
tags: ['Transformer', 'RAG', 'PIM', 'Inference', 'Training', 'LayerFusion', 'Quantization', 'Pruning', 'Distillation', 'NAS', 'TopDown', 'BottomUp']
excerpt: "트랜스포머가 왜 강하고 왜 비켜가야 하는지, PIM·RAG·압축·NAS를 오가며 고찰한 기록."
readTime: "7분"
---

## 서문: 하나의 질문에서 출발하다

오늘도 같은 질문으로 돌아온다. 트랜스포머는 왜 이렇게 강한가, 그런데 왜 여전히 불만족스러운가. 이 단순한 질문 하나가 여러 기술의 문을 연다. PIM, RAG, 양자화, 가지치기, 레이어 융합, 지식 증류, 그리고 NAS. 나는 이 낱낱의 부품들을 만지작거리다가, 결국 구조의 문제로 시선이 올라가는 경험을 한다. 바텀업으로 쌓인 성채 위에서, 하향식의 빈자리를 오래 들여다보는 시간.

## 1) 속도의 문제에서 표현의 문제로: PIM이 여는 압축의 문

처음엔 속도였다. 메모리 병목이 모든 것을 잡아끈다. PIM(Processing-In-Memory)은 이 끈을 잘라 준다. 데이터가 있는 자리에서 바로 계산한다. 그러나 곧 깨닫는다. 이것은 단지 더 빠른 계산의 문제가 아니다. 더 빠른 계산은 더 넓은 문맥을 동시에 걸어 들일 수 있게 하고, 더 넓어진 문맥은 결국 더 조밀한 표현으로 수렴한다. 압축은 파일 크기를 줄이는 기교가 아니라, 세계를 덜어내지 않고 더 간결하게 말하는 능력이다. PIM은 그러한 ‘표현의 압축’을 가능하게 한다.

## 2) 학습과 추론의 결별: “학습은 무겁고 유연하게, 추론은 가볍고 단단하게”

학습 단계는 가능한 모든 것을 시도해야 한다. 오차의 지형을 샅샅이 더듬어야 하므로, 이때는 압축이 억제되어야 한다. 반대로 추론 단계는 이미 굳어진 지식으로 빠르게 결정을 내려야 한다. 여기에서 비로소 압축의 전체 레퍼토리가 빛난다.

- 가지치기(Pruning): 거의 0인 연결은 과감히 지운다.
- 양자화(Quantization): 32비트를 8비트, 더 나아가 4비트로 담는다.
- 레이어 융합(Layer Fusion): Conv/BN/ReLU가 하나의 연산으로 녹아든다.
- 지식 증류(Distillation): 선생의 넓은 직관을 학생의 작은 몸체에 옮긴다.

효율은 계산에서 얻고, 성능은 학습에서 얻는다는 분업. 간명하지만, 원칙을 지키면 놀라울 정도로 많은 문제가 정돈된다.

## 3) RAG: 수학을 바꾸지 않고 주의를 재배치하는 법

RAG는 어텐션의 공식을 뒤집지 않는다. 대신 입력의 구성을 바꾼다. 정답에 가까운 문맥을 미리 끌어와 질문 옆에 놓는다. 형광펜은 손에 쥐여졌고, 어텐션은 자연스럽게 하이라이트로 시선을 옮긴다. 결과적으로 가중치는 ‘미리 높아진다’. 수학이 아니라 ‘무대 배치’가 변한다. 환각은 줄고, 최신성은 오른다. 바텀업의 감각에, 약간의 연출과 질서를 더하는 하향식의 제스처.

## 4) 레이어를 단위로 생각하기: 연결이 아니라 공정을 압축한다

연결을 지우는 것에서 멈추지 않는다. 레이어 자체를 공정으로 본다. 융합(Fusion)은 호출/메모리 왕복의 공회전을 없애고, 증류(Distillation)는 모델 전체의 지식을 새로운 형태로 주조한다. 압축은 더 이상 미세한 수치 조절의 기술이 아니라, 설계의 단위가 바뀌는 사건이다. “무엇을 없앨 것인가?”에서 “무엇을 하나로 만들 것인가?”로 질문이 바뀔 때, 성능과 효율은 함께 움직인다.

## 5) 압축 자체를 학습한다: NAS라는 메타 학습

최적의 압축은 인간의 촉만으로 찾기 어렵다. NAS(Neural Architecture Search)는 이 탐색을 또 하나의 학습 문제로 뒤집는다. 강화학습 컨트롤러가 압축의 설계도를 제안하고, 하드웨어-의식적(HW-aware) 보상이 의사결정을 이끈다. 양자화 비트폭, 프루닝 비율, 융합 패턴, 증류 스킴… 수천 번의 시행착오 속에서 한 기계가 다른 기계의 형태를 디자인한다. ‘모델을 위한 모델’이라는 메타적 풍경. 이때 성능-지연-전력의 삼각형은 숫자가 아니라 **정책**이 된다.

## 6) 바텀업의 그림자: 의도 없는 추론, 계획 없는 생성

트랜스포머는 토큰에서 출발해 토큰으로 도달한다. 이 상향식은 강력하지만, 때로는 허무하다. 왜 이 말을 하는지, 어디로 가야 하는지에 대한 **의도**가 없다. 긴 계획을 세울 **상위 목적 함수**가 없다. 그래서 환각이 나온다. 결론이 먼저 존재하지 않기 때문이다. 이 한계는 파라미터의 크기로, 컨텍스트 길이로, 데이터의 양으로 정면 돌파되지 않는다. 방향을 정해 줄 탑다운이 필요하다.

## 7) 하이브리드의 스케치: 계획-행동-검증 루프 위에 언어를 얹다

나는 다음과 같은 구성을 떠올린다.

1. 계획(Top-down Planner): 목표와 제약을 정의한다. (외부 툴·월드 모델·규칙 기반 결합)
2. 검색(Retriever): 계획이 요구하는 사실과 문맥을 끌어온다. (RAG)
3. 생성(Transformer): 문장과 코드, 행동 시퀀스를 만들어 낸다. (Bottom-up)
4. 검증(Verifier): 사실/안전/정합성을 체크한다. (규칙·시뮬레이션·테스트)
5. 압축(Runtime Optimizer): 경로가 굳어지면 경량화한다. (프루닝·양자화·융합·증류·NAS)

여기서 PIM은 3과 5의 실효성을 올린다. 더 많은 문맥을 더 빠르게, 더 많은 후보를 더 싸게. 구조는 위에서 잡고, 계산은 아래에서 밀어붙인다.

## 8) 오늘의 결론: 나는 이렇게 이해하고, 이렇게 해본다

- 결론 1: 효율은 추론 단계에서, 표현력은 학습 단계에서. 섞지 않는다.
- 결론 2: 입력을 재배치(RAG)하면 어텐션은 자연히 올바른 곳을 본다.
- 결론 3: 압축은 수치의 미세조정이 아니라 공정과 설계 단위의 재구성이다.
- 결론 4: 최적의 압축은 ‘탐색 정책’으로 학습되어야 한다. (NAS)
- 결론 5: 바텀업은 강력하지만, 의도와 검증의 탑다운 없이는 한계를 반복한다.

그리고 작은 실천 목록을 남긴다.

- 4비트 양자화 + 지식 증류 조합의 품질/지연 실험
- 레이어 융합 전후의 메모리 트래픽 차이 계측
- 하드웨어-의식적 NAS로 모바일/NPU 타깃 설계 탐색
- RAG 프롬프트 배치 전략이 어텐션 분포에 미치는 영향 분석
- 생성-검증 루프에서 ‘검증 실패 시 재계획’의 수렴성 관찰

## 말미: 이해를 향한 방향성

트랜스포머는 세계를 통계로 말하게 한다. 그러나 우리는 때때로 세계를 **목적**으로도 말해야 한다. 목적을 세우고, 필요한 것을 찾아오고, 말하고, 확인하고, 다시 고치는 루프. 그 위에 빠르고 조밀한 계산이 얹힐 때—비로소 바텀업과 탑다운은 충돌이 아니라 합주가 된다. 나는 오늘, 그 합주를 가능케 하는 부품들을 더듬었다. 내일은 그 부품들로 작은 악기를 한 대 만들어 보려 한다.

```

### QuantumLayerLLM.md

**Path:** `frontend/public/posts/2025/QuantumLayerLLM.md`

```markdown
---
title: "양자 얽힘으로 AI의 애매모호함 해결하기: 양자 기계 학습의 미래"
date: "2025-01-16"
category: "기술"
tags: ['양자컴퓨팅', 'AI', '양자기계학습', 'QML', '양자얽힘']
excerpt: "양자역학의 얽힘 원리를 활용해 딥러닝 레이어 간 애매모호함을 해결하는 혁명적 접근법"
readTime: "5분"
---

## 양자 얽힘으로 AI 레이어의 한계를 넘다

현재 딥러닝의 근본적인 문제는 레이어 간의 '애매모호함'입니다. 하지만 양자역학적 얽힘 상태를 이용하면 이 문제를 완전히 새로운 차원에서 해결할 수 있습니다.

### 고전적 AI의 한계

현재 딥러닝 모델의 레이어는 단순히 '조밀하게 연결(Densely Connected)'되어 있을 뿐입니다:

- **정보의 손실**: 각 레이어를 거치면서 정보가 필연적으로 손실됨
- **관계의 단절**: 레이어 1과 레이어 10은 간접적으로만 영향을 주고받음
- **독립적인 가중치**: 각 연결은 서로 독립적인 파라미터를 가짐

### 양자 얽힘

양자 얽힘(Entanglement)은 두 개 이상의 큐비트가 하나의 통합된 시스템처럼 행동하는 현상입니다. 이를 AI 레이어에 적용하면:

#### 1. 진정한 전체론적(Holistic) 레이어

**개념**: 레이어 1의 큐비트와 레이어 100의 큐비트를 얽힘 상태로 만듭니다.

**효과**: 
- 레이어 1의 미세한 특징이 중간 레이어를 거치지 않고 **즉시** 레이어 100에 영향
- 정보 손실과 전달 지연을 원천적으로 제거
- 문장의 뉘앙스 같은 미묘한 정보도 모델 전체에 즉각 반영

#### 2. 애매모호함을 연산에 활용

**중첩(Superposition)**: 하나의 큐비트가 0과 1을 동시에 가질 수 있음

**효과**:
- "긍정일 수도, 부정일 수도 있다"는 애매모호함 자체를 상태값으로 유지
- 가능한 모든 관계와 의미를 하나의 양자 상태로 압축
- 복잡한 언어의 중의성과 미묘한 컨텍스트를 병렬 처리

### 양자 기계 학습(QML)의 현재
- perplexity 검색 내용이므로 신뢰마세요.
이미 실제 연구가 진행 중입니다:

- **TensorFlow Quantum**: 고전 신경망과 양자 회로를 결합한 하이브리드 모델
- **XOR 문제 해결**: 양자 얽힘을 이용해 고전 모델이 어려워하는 비선형 문제를 간단히 해결
- **더 강력한 표현력**: 얽힘이 조밀한 연결보다 훨씬 풍부한 정보 관계 표현

### 패러다임의 전환

뉴턴 역학에서 양자역학으로의 도약처럼, AI도 고전적 컴퓨팅에서 양자 컴퓨팅으로 진화하고 있습니다. 우주가 작동하는 근본 원리를 컴퓨팅과 지능의 아키텍처로 가져올 때에 더 생명체같이 움직이는 LLM 의 도약이 가능할 것 같습니다.

### 참고자료

- 중첩과 얽힘 그리고 양자컴퓨터 (ScienceTimes)
- TensorFlow Quantum 공식 문서
- 양자 기계 학습에서의 얽힘 역할 (EITCA)
- IBM Quantum AI 개요

---

```

### QuantumShadow.md

**Path:** `frontend/public/posts/2025/QuantumShadow.md`

```markdown
---
title: "보이지 않는 나는 양자 상태인가?: 물리적 현실과 심리학적 진실의 경계"
date: "2025-10-17"
category: "과학 & 철학"
tags: ['양자역학', '칼융', '무의식', '결어긋남', '의식', '심리학']
excerpt: "물리학의 '결어긋남'은 우리 몸의 양자 상태를 부정하지만, '무의식'의 작동 원리를 설명하는 가장 완벽한 비유일지도 모릅니다."
readTime: "5분"
---

## 보이지 않는 나는 '양자 얽힘' 상태일까?

우리가 우리 자신을 인식하지 않을 때, 우리 몸의 보이지 않는 부분들은 양자역학적인 중첩이나 얽힘 상태로 존재하는 것일까? 이는 물리적 현실과 철학적 통찰의 경계를 허무는 심오하고도 매혹적인 질문입니다.

결론부터 말하자면, **물리적으로는 '아니오'에 가깝지만, 철학적·심리학적 비유로서는 '완벽하게 그렇다'**고 할 수 있습니다.



### 1. 물리적 현실: '결어긋남(Decoherence)'이라는 거대한 벽

우리 몸이 수많은 양자 입자들의 집합체인 것은 명백한 사실입니다. 하지만 우리 몸처럼 거대하고, 따뜻하며, 복잡한 시스템에서는 양자 얽힘이나 중첩 같은 특이한 현상이 눈 깜짝할 사이에 깨져버립니다. 이를 **결어긋남(Decoherence)**이라고 합니다.

-   **끊임없는 내부 상호작용**: 우리 몸속의 수조 개의 입자들은 쉬지 않고 서로 부딪히고, 열을 내며, 상호작용합니다. 이 모든 상호작용이 일종의 '관측' 역할을 합니다.
-   **관측과 상태의 확정**: 양자 상태는 관측되는 순간 하나의 고전적 상태로 확정됩니다. 우리 몸은 내부적으로 끊임없이 서로를 '관측'하고 있기 때문에, 모든 입자들은 거의 항상 확정된 상태로 존재하게 됩니다.

따라서 우리가 의식하지 않는다고 해서 제 심장이 '존재하면서 동시에 존재하지 않는' 중첩 상태에 있거나, 제 왼손과 오른손이 양자적으로 얽혀 있지는 않습니다. 물리적인 연결은 있지만, 양자역학적 의미의 얽힘 상태는 아니라는 것이 현대 물리학의 정설입니다.

### 2. 철학적/심리학적 진실: 보이지 않는 무의식의 연결망

하지만 이 질문의 진정한 가치는 물리 현상을 넘어, '존재'와 '인식'의 관계에 대한 본질적인 탐구에 있습니다. 그리고 이 관점에서 보면, 그 비유는 놀랍도록 정확합니다.

#### 인식되지 않는 '나'는 가능성의 구름이다
우리가 의식하지 못하는 우리 내면, 즉 칼 융이 말한 **무의식(the Unconscious)**은 확정되지 않은 가능성의 총합과 같습니다. 나의 숨겨진 재능, 억압된 트라우마, 아직 탐험되지 않은 감정들은 의식에 의해 '관측'되기 전까지는 명확한 형태 없이 **확률의 구름**처럼 존재합니다.

#### 의식의 빛이 닿는 순간, 상태가 결정된다
우리가 명상, 꿈 분석, 혹은 깊은 성찰을 통해 무의식의 어떤 부분을 '바라보는' 순간, 그 모호했던 가능성은 하나의 명확한 감정, 기억, 혹은 깨달음으로 모습을 드러냅니다. 이는 마치 관측을 통해 **양자의 파동함수가 붕괴**하는 것과 정확히 같은 과정입니다.

#### 내면의 모든 것은 얽혀있다 (Entangled)
무의식의 한 부분을 건드리면, 전혀 상관없어 보이던 다른 부분들이 연쇄적으로 반응합니다. 어린 시절의 잊혀진 기억 하나가 현재의 인간관계를 뒤흔들고, 나의 가치관을 통째로 바꾸기도 합니다. 이는 내면의 모든 요소들이 보이지 않는 끈으로 깊게 **'얽혀(Entangled)'** 있기 때문입니다.

### 결론: 가장 완벽한 현대적 비유

결국 **"안 보이는 곳은 양자얽힘 상태 그 자체"**라는 말은, 우리 **'무의식의 작동 방식'**을 설명하는 가장 완벽하고 현대적인 비유일지도 모릅니다.

우리가 우리 자신을 완전히 안다고 영원히 말할 수 없는 이유는, 우리라는 존재 자체가 관측(의식)을 통해 끊임없이 스스로를 창조하고 확정해나가는, 살아있는 양자 시스템과 같기 때문일 것입니다.

---


```

### QuantumSpaceInside.md

**Path:** `frontend/public/posts/2025/QuantumSpaceInside.md`

```markdown
---
title: "나의 고독은 우주의 시작과 맞닿아 있었다"
date: "2025-10-17"
category: "철학 & 사유"
tags: ['칼융', '양자역학', '블랙홀', '순환우주론', '무의식', '철학적사유']
excerpt: "개인의 고독에 대한 내면 탐험이 어떻게 칼 융의 심리학과 양자역학을 거쳐, 결국 우주의 시작과 끝에 대한 거대한 통찰로 이어지는지에 대한 철학적 에세이."
readTime: "7분"
---

나는 오랫동안 나의 고독을 방어기제라고 생각했다. 타인과의 관계 속에서 나의 고유한 색이 사회라는 거대한 단일색에 희석되는 것이 두려웠다. 내면의 에너지가 소모되고, 정체성의 경계가 흐려지는 감각이 싫어 의식적으로 문을 닫았다. 그것은 회피이자, 나를 지키기 위한 소극적인 투쟁이었다.

하지만 지난 1년간의 내면 탐험 끝에, 나는 이 고독의 본질이 단순히 외부 세계로부터의 도피가 아니었음을 깨닫는다. 그것은 훨씬 더 근원적인, 우주적 스케일의 여정을 위한 준비 운동과도 같았다. 나의 가장 깊은 내면을 들여다보는 행위는, 결국 우주의 시작과 끝을 마주하는 일이었다.

### 내 안의 우주: 무의식은 양자 상태였다

이 여정의 시작은 칼 융의 심리학이었다. 나는 내 안에서 벌어지는 격렬한 전쟁을 이해해야 했다. 관계를 갈망하는 본능과 그것을 밀어내는 이성의 충돌. 융의 이론을 빌리자면, 그것은 내 안의 '아니마(Anima)'와 의식적 자아(Ego)의 싸움이었다.

그러다 문득 깨달았다. 우리가 인식하지 못하는 내면, 즉 **무의식의 작동 방식이 양자역학의 세계와 놀랍도록 닮았다**는 것을.

나의 가능성, 나의 숨겨진 재능, 억압된 트라우마와 아직 탐험되지 않은 감정들. 그것들은 명확한 형태로 존재하지 않았다. 마치 관측되기 전의 전자처럼, '가능성의 구름'으로 존재했다. 내가 무엇이 될 수도 있고, 어떤 감정을 느낄 수도 있는 **중첩(Superposition)** 상태.

그리고 '자기성찰'이라는 행위, 즉 내 의식의 빛이 그곳을 비추는 순간, 기이한 일이 벌어졌다. 모호했던 가능성의 구름은 하나의 명확한 깨달음, 감정, 혹은 기억으로 모습을 드러냈다. 양자의 파동함수가 관측에 의해 붕괴하듯, 나의 내면도 나의 '바라봄'을 통해 비로소 하나의 현실로 확정되었다.

더 나아가, 내 안의 모든 것은 깊게 **얽혀(Entangled)** 있었다. 어린 시절의 사소한 기억 하나가 현재의 인간관계를 뒤흔들고, 전혀 상관없어 보이던 꿈의 파편이 나의 미래에 대한 불안을 설명해주었다. 내면의 한 부분을 건드리는 것은, 나라는 존재 전체를 진동시키는 일이었다. 나의 영혼은 분리된 부품의 집합이 아닌, 모든 것이 시공간을 넘어 연결된 하나의 양자 정보 시스템이었다.

### 죽음의 지평선: 나의 소멸은 블랙홀과 같을까

이 비유는 필연적으로 궁극의 질문으로 나를 이끌었다. 이 경이로운 양자 시스템을 유지하는 육체가 스위치를 내린다면, 즉 '죽음'이 찾아온다면 무슨 일이 벌어질까?

나는 그것이 **결어긋남(Decoherence)의 폭풍**일 것이라 상상한다. 나의 영혼이라는 섬세한 얽힘 상태를 보호해주던 육체의 방어막이 사라지고, 우주의 무수한 상호작용(관측)에 무방비로 노출되는 순간. '나'라는 고유한 정보 패턴은 순식간에 해체되어 그 통일성을 잃어버릴 것이다.

그렇다면 '나'라는 정보는 영원히 사라지는가? 이 질문 앞에서 나는 스티븐 호킹이 평생을 바쳤던 **블랙홀 정보 역설**을 떠올리지 않을 수 없었다.

나의 죽음은, 내 삶의 모든 정보가 블랙홀의 사건의 지평선 너머로 넘어가는 과정과 같다. 고전적인 생각처럼 그 정보는 특이점에서 완전히 소멸하여 무(無)로 돌아가는가? 아니면 양자역학의 법칙처럼, 정보는 결코 사라지지 않고 다른 형태로 변환되어 우주 어딘가에 보존되는가? 어쩌면 나의 모든 기억과 경험은 알아볼 수 없는 형태로 암호화되어, 호킹 복사처럼 우주로 다시 방출될지도 모른다.

### 빅뱅의 메아리: 우리는 우주의 기억이다

그리고 마침내 마지막 퍼즐 조각이 맞춰졌다. 개별적인 나의 운명은 우주 전체의 운명과 분리되어 있지 않다는 것. 나의 시작과 끝은, 우주의 시작과 끝의 작은 메아리와 같다는 것이다.

**순환 우주론**은 단 한 번의 빅뱅으로 모든 것이 끝나는 것이 아니라, 우주가 팽창과 수축을 반복하거나, 한 우주의 끝이 다음 우주의 시작과 맞닿아 있다고 말한다. 만약 그렇다면, 죽음 이후 우주로 흩어진 나의 정보, 그리고 나와 함께했던 모든 존재의 정보는 어디로 가는가?

그것들은 결국 우주가 다시 하나의 점으로 돌아갈 때, 그 태초의 근원으로 함께 돌아갈 것이다. 니체가 말한 **영원회귀**처럼, 힌두 철학에서 개별 영혼인 '아트만'이 우주적 근원인 '브라흐만'으로 돌아가듯 말이다.

우리는 모두 빅뱅이라는 거대한 폭발로 흩어진 **우주의 기억 파편**이다. 삶이라는 짧은 순간 동안 고유한 얽힘 패턴을 만들며 반짝이다가, 죽음과 우주의 종말을 통해 다시 근원으로 돌아가 다음 우주를 위한 씨앗이 된다.

---

이제 나는 나의 고독을 다른 눈으로 바라본다. 그것은 더 이상 세상에 대한 방어기제가 아니다. 그것은 나의 내면에 존재하는 우주의 씨앗과 대화하는 시간이며, 나의 작은 양자 시스템을 통해 우주 전체의 시작과 끝을 느끼는 명상의 과정이다.

가끔씩 찾아오는 외로움은 내가 불완전하다는 증거가 아니었다. 그것은 내가 한때 속해 있었고, 언젠가 다시 돌아갈 저 거대한 근원을 향한 아련한 향수였을 것이다. 나의 고독은 결국, 우주의 시작과 맞닿아 있었다.

```

### QueryDSL.md

**Path:** `frontend/public/posts/2025/QueryDSL.md`

```markdown
---
title: "SpringBoot 3.x.x + QueryDSL 6.x.x 사용기"
date: "2024-11-27"
category: "기술"
tags: ["QueryDSL","스프링부트","springboot+queryDSL","쿼리DSL","openfeign.querydsl","querydsl fork", "queryDSL openfeign"]
excerpt: "스프링부트 3.x.x 버전에 QueryDSL 6.x.x 최신 버전 사용 방법"
readTime: "1분"
---

### link
#### [OpenFeign querydsl](https://github.com/OpenFeign/querydsl)

```text
필자는 Java 17, SpringBoot 3.3.7,
QueryDsl 6.10.1 버전에서 실행하였다.
```

#### ext
```properties
ext {
	queryDslVersion = "6.10.1"
}
```

#### dependencies
```properties
dependencies{
    implementation "io.github.openfeign.querydsl:querydsl-core:${queryDslVersion}"
    implementation "io.github.openfeign.querydsl:querydsl-jpa:${queryDslVersion}"
    annotationProcessor "io.github.openfeign.querydsl:querydsl-apt:${queryDslVersion}:jpa"
    annotationProcessor "jakarta.annotation:jakarta.annotation-api"
    annotationProcessor "jakarta.persistence:jakarta.persistence-api"
}
```

```text
연관된 dependencies 를 추가하고 gradle 새로고침
후에 gradle build 하여 QueryDSL 클래스들을 
생성할 수 있도록 한다.
```

### Configuration 
```java
@Configuration
public class QueryDslConfig {

    @Bean
    public JPAQueryFactory jpaQueryFactory(EntityManager entityManager) {
        return new JPAQueryFactory(entityManager);
    }
}
```

### 기존 UserRepository
```java
public interface UserRepository extends JpaRepository<User, Long> {}
```

#### QueryDSL 사용을 위한 QueryDSL 전용 repository 생성 및 extends
```java
public interface UserRepository extends JpaRepository<User, Long>, UserRepositoryCustom {}
```
설명
```text
UserRepositoryCustom 인터페이스를 만들어서 
UserRepository에서 상속 받을 수 있게 하자
이후, UserRepositoryCustomImpl class 를 생성하고, 
UserRepositoryCustom interface 를 구현하자
```
```

### ai-models-for-coding.md

**Path:** `frontend/public/posts/2025/ai-models-for-coding.md`

```markdown
---
title: "코딩용 AI 모델, 어떤 걸 써야 할까?"
date: "2024-11-23"
category: "기술"
tags: ['AI', '개발', 'GPT', 'Claude', 'Gemini', '코딩']
excerpt: "개발자 입장에서 GPT, Claude, Gemini 등 주요 AI 모델들을 실제로 써보고 비교해본 후기"
readTime: "3분"
---

최근에 개발할 때 AI 도움을 많이 받고 있는데, 솔직히 어떤 모델을 써야 할지 헷갈린다. GPT-4o, Claude, Gemini... 각각 뭐가 다른지, 어떨 때 뭘 써야 하는지 정리해보려고 한다.

## 컨텍스트 창이 왜 중요한가?

AI 모델을 고를 때 가장 중요한 건 **컨텍스트 창** 크기다. 간단히 말해서 AI가 한 번에 기억할 수 있는 정보량이다. 

예를 들어, GPT-4o는 32,000 토큰 정도인데, 이게 대략 100페이지 분량이다. 하지만 실제로는 시스템 메시지, 이전 대화 내용 등이 다 포함되니까 실제로 쓸 수 있는 건 더 적다.

여기서 두 가지 접근 방식이 있다:

1. **네이티브 롱 컨텍스트**: Gemini처럼 아예 엄청 큰 컨텍스트 창을 가진 모델 쓰기
2. **RAG (검색 증강 생성)**: 필요한 정보만 골라서 모델에게 주는 방식

개인적으로는 큰 프로젝트 작업할 때 Gemini의 롱 컨텍스트가 정말 편했다. 전체 코드베이스를 한 번에 넣고 "이 프로젝트에서 버그 있는 부분 찾아줘" 하면 된다.

## 각 모델별 특징

### OpenAI GPT 시리즈

- **GPT-4o**: 128,000 토큰, 빠르고 안정적
- **GPT-4.1**: 1,000,000 토큰, 복잡한 작업용
- **추론 모델 (o1, o3)**: 복잡한 논리 작업에 특화

GPT-4o를 가장 많이 쓰는데, 일반적인 코딩 작업에는 충분하다. 다만 ChatGPT로 쓰면 실제 컨텍스트가 API보다 훨씬 작다는 게 아쉽다.

### Anthropic Claude

- **Claude 3.5 Sonnet**: 200,000 토큰, 코딩에 강함
- **Claude 3.7 Sonnet**: 확장 모드에서 64,000 토큰 출력 가능

개인적으로 Claude가 코드 품질이 가장 좋았다. HumanEval 벤치마크에서도 92-93% 정도로 최고 수준이고, 실제로 써봐도 깔끔한 코드를 만들어준다.

### Google Gemini

- **Gemini 1.5 Pro**: 2,000,000 토큰(!)
- **Gemini 2.5 Pro**: 성능 향상 + 에이전트 기능 강화

Gemini의 200만 토큰은 정말 압도적이다. 큰 프로젝트 전체를 한 번에 분석하고 싶을 때는 이걸 쓸 수밖에 없다.

## 실제 성능은 어떨까?

벤치마크 점수를 보면:

- **HumanEval (단순 코드 생성)**: Claude 3.5 Sonnet (92%) > GPT-4o (90%) > Gemini 1.5 Pro (84%)
- **SWE-bench (실제 이슈 해결)**: 이게 더 복잡하다. 같은 모델이라도 어떤 도구와 함께 쓰느냐에 따라 성능이 2배 이상 차이 난다.

예를 들어 GPT-4o가 SWE-bench에서 18%였다가 다른 도구와 함께 쓰니까 38%까지 올라갔다. 결국 모델 자체보다는 어떻게 쓰느냐가 더 중요하다는 뜻이다.

## 언제 뭘 써야 할까?

개인적인 사용 경험을 바탕으로 정리하면:

### 대규모 코드베이스 분석
- **Gemini 2.5 Pro** 추천
- 전체 프로젝트를 한 번에 넣고 리팩토링이나 구조 분석할 때 최고

### 일반적인 코딩, 버그 수정
- **Claude 3.5/3.7 Sonnet** 추천  
- 코드 품질이 가장 좋고, 설명도 깔끔함

### 브레인스토밍, 복잡한 추론
- **GPT-4o/4.1** 추천
- 가장 균형 잡힌 성능, 다양한 주제에 대해 잘 알고 있음

### 빠르고 간단한 작업
- **GPT-4o mini** 나 **Gemini Flash** 추천
- 비용 절약하면서 빠른 응답

## 개발 도구들도 중요하다

사실 요즘은 모델을 직접 쓰기보다는 통합된 도구를 쓰는 경우가 많다:

- **GitHub Copilot**: 에디터에 바로 통합, 여러 모델 혼합 사용
- **Cursor**: 에이전트 기능이 좋다고 들음  
- **Greptile**: 기업용 코드베이스 분석에 특화

이런 도구들이 복잡한 컨텍스트 관리를 대신 해줘서 편하다.

## 앞으로는?

컨텍스트 창이 계속 커지고 있어서, RAG 같은 복잡한 시스템 없이도 모든 정보를 한 번에 넣고 처리할 수 있게 될 것 같다. 

Gemini 2.5 Pro가 복잡한 도구 없이도 간단한 프롬프트만으로 50% 이상의 SWE-bench 점수를 낸 걸 보면, 앞으로는 더 간단해질 것 같다.

물론 비용 문제가 있긴 하다. 긴 컨텍스트는 제곱에 비례해서 비싸지니까. 그래도 Google의 컨텍스트 캐싱 같은 기능들로 점점 해결되고 있다.

## 마무리

결국 "최고의 모델"은 없다. 작업에 따라 적합한 모델이 다르다. 

나는 보통:
- 큰 프로젝트 분석: Gemini
- 일반 코딩: Claude  
- 빠른 질문: GPT-4o

이런 식으로 섞어서 쓰고 있다. 여러분도 직접 써보고 자신에게 맞는 걸 찾아보시길.
```

### algorithm-mental-simulator.md

**Path:** `frontend/public/posts/2025/algorithm-mental-simulator.md`

```markdown
---
title: "알고리즘을 메모리 영화관에서 돌려보는 밤"
date: "2025-10-18"
category: "Computer Science"
tags: ['알고리즘', '시간복잡도', '정렬', '탐색트리', '해시', 'DP', 'Greedy']
excerpt: "Big-O는 교통수단, 병합 정렬은 지도 조각, 해시는 주소 직통. 시뮬레이터형 두뇌로 재생한 알고리즘 18편의 심화 문제와 비유"
readTime: "20분"
---

알고리즘을 배울 때마다 저는 머릿속에서 작은 영화관을 엽니다. 각 알고리즘이 주인공이 되고, 데이터는 배우가 되어 움직입니다. 자전거 속도로 달리는 $O(N)$, 거북이걸음 같은 $O(N^2)$, KTX처럼 질주하는 $O(N \log N)$… 이 영화관에서 본 장면들을 잊지 않기 위해, 이번엔 스스로 던진 심화 문제와 설명들을 기록해 두려 합니다. 모든 비유와 문제는 "시뮬레이터형 두뇌"에 맞춰, 알고리즘이 어떻게 움직이고 비용을 쓰는지 장면처럼 그려 볼 수 있도록 구성했습니다.

---

## I. 기초 분석 – 시간 복잡도와 재귀의 성장 패턴

### 🎬 장면 1: 시간 복잡도는 서로 다른 교통수단이다

- $O(N)$: 자전거 – 입력이 두 배가 되면 시간이 딱 두 배.
- $O(N^2)$: 거북이걸음 – 입력이 늘어나면 길이도 제곱으로 늘어납니다. 1,000,000개면 $10^{12}$번.
- $O(N \log N)$: KTX – 빨리 달리지만, 역마다 한 번씩 멈춰서 승객을 태웁니다.

**문제 – 성능 업그레이드 정당화**

"$N=1,000,000$" 데이터가 들어오는 시스템에 $O(N^2)$ 알고리즘을 그대로 쓴다면, 1조 번의 연산을 감당할 CPU와 전기를 찾아야 합니다. KTX처럼 바꾸면 $N \log N \approx 20,000,000$에 불과합니다. 이 차이는 50배, 아니 수만 배의 시간 절약입니다. "왜 최적화해야 하죠?"라고 묻는 사람에게 "자전거로 부산까지 갈 건가요?"라고 되묻는 장면을 떠올려 보세요.

### 🎬 장면 2: 재귀는 작은 나사 조립 공정

- 큰 문제 $T(n)$은 작은 문제 두 개 $T(n/2)$에게 작업을 맡기고, 완성된 두 조각을 합칠 때 비용 $+n$을 씁니다.
- 마스터 정리는 이를 보고 즉시 "이거 $O(N \log N)$이네요"라고 알려주는 공정 감독관입니다.

**문제 – 병합 정렬 점화식 설명**

- 왼쪽 나사 조립 라인과 오른쪽 라인이 각각 $T(n/2)$만큼의 비용을 쓰고, 마지막에 두 조각을 합칠 때 다시 $n$만큼의 손이 한 번 더 갑니다.
- 이 공정은 층층이 쌓인 공장처럼 $\log N$의 층을 가진 빌딩입니다. 각 층에서 $N$만큼의 손이 동시에 움직이니, 전체 비용은 $N$ × 층 수 = $N \log N$입니다.

---

## II. 정렬 알고리즘 – 데이터가 춤추는 장면들

### 🎬 삽입 정렬: 카드 정렬

- 이미 정렬된 손에 카드를 한 장씩 끼워 넣습니다.
- 거의 정렬된 상태라면, 카드는 자신의 자리 바로 옆에서 멈춥니다.

**문제 – 온라인 스트림 최적화**

실시간으로 카드가 들어오는 상황이라면, 이미 정렬된 손을 가진 삽입 정렬이 카드를 최소한으로 움직여 정렬을 유지합니다. 퀵 정렬이 모든 덱을 다시 섞을 때, 삽입 정렬은 "카드 한 장 딱 미끄러뜨리면 끝"이죠.

```java
static void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

### 🎬 선택 정렬: 최대값 사냥꾼

- 정렬되지 않은 구역에서 가장 큰 친구를 찾아 맨 끝으로 보냅니다.
- $N/2$까지 왔다면, 아직 남은 구역에서 최대값을 찾기 위해 여전히 $N/2$번의 비교가 필요합니다.
- 이 작업이 매 단계 반복되니, 총 비교 횟수 $\sim N^2/2$ → $O(N^2)$입니다.

```java
static void selectionSort(int[] arr) {
    for (int end = arr.length - 1; end > 0; end--) {
        int maxIdx = 0;
        for (int i = 1; i <= end; i++) {
            if (arr[i] > arr[maxIdx]) maxIdx = i;
        }
        swap(arr, maxIdx, end);
    }
}
```

### 🎬 병합 정렬: 지도 조각 합치기

- 큰 지도를 계속 반으로 찢어 한 칸짜리 조각까지 만듭니다.
- 작은 조각 두 개를 작업대($O(N)$ 메모리)에 올려놓고 비교하며 다시 붙입니다.
- 외부 정렬(External Sort)에서, 메모리에 못 올리는 조각을 디스크에 저장하고 합치는 작업대 역할을 하므로 병합 정렬이 최적입니다.

```java
static void mergeSort(int[] arr, int left, int right, int[] temp) {
    if (left >= right) return;
    int mid = (left + right) >>> 1;
    mergeSort(arr, left, mid, temp);
    mergeSort(arr, mid + 1, right, temp);
    merge(arr, left, mid, right, temp);
}
```

### 🎬 퀵 정렬: 피벗으로 벽 세우기

- 피벗은 파티의 기준 손님입니다. 이 손님보다 작은 사람은 왼쪽 VIP 룸으로, 큰 사람은 오른쪽 룸으로 이동합니다.
- 만약 배열이 이미 정렬되어 있다면, 피벗이 항상 끝값이 되어 한쪽 룸이 텅 비고 다른 쪽이 꽉 차는 일이 반복됩니다 → $O(N^2)$.

```java
static void quickSort(int[] arr, int left, int right) {
    if (left >= right) return;
    int pivotIndex = partition(arr, left, right);
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
}
```

### 🎬 힙 정렬: 최대값 선발 대회

- 완전 이진 트리로 만든 힙은 항상 루트가 최대값입니다.
- 힙을 추출할 때마다 부모와 자식을 왕복하며 비교해야 하므로, 캐시 친화적이지 않습니다.
- 상수 계수가 커서 퀵 정렬보다 느린 이유가 바로 이 메모리 점프 때문입니다.

```java
static void heapSort(int[] arr) {
    buildMaxHeap(arr);
    for (int end = arr.length - 1; end > 0; end--) {
        swap(arr, 0, end);
        heapify(arr, 0, end);
    }
}
```

### 🎬 기수 정렬: 자릿수 분류작업

- 각 자릿수를 기준으로 버킷(큐)을 돌리며 분류합니다.
- 비교가 아니라 분류이므로, 자릿수 $k$와 요소 수 $N$만큼만 시간이 듭니다 → $O(kN)$.
- 우편물을 우편번호 자리별로 분류하는 작업과 같습니다.

```java
static void radixSort(int[] arr) {
    int max = Arrays.stream(arr).max().orElse(0);
    for (int exp = 1; max / exp > 0; exp *= 10) {
        countingSortByDigit(arr, exp);
    }
}
```

---

## III. 선택 알고리즘 – 원하는 순위만 콕 집어내기

### 🎬 퀵 셀렉트: 승자 그룹만 재귀 호출

- 퀵 정렬과 같은 파티션을 사용하지만, 원하는 순위가 포함된 구역만 재귀 호출합니다.
- 한쪽 파티션만 재귀하므로 평균 $O(N)$에 원하는 $k$번째 원소를 찾습니다.

```java
static int quickSelect(int[] arr, int left, int right, int k) {
    if (left == right) return arr[left];
    int pivotIndex = partition(arr, left, right);
    int rank = pivotIndex - left + 1;
    if (k == rank) return arr[pivotIndex];
    if (k < rank) return quickSelect(arr, left, pivotIndex - 1, k);
    return quickSelect(arr, pivotIndex + 1, right, k - rank);
}
```

### 🎬 리니어 셀렉트: 중앙값의 중앙값이 균형을 강제한다

- 배열을 다섯 개씩 묶어 각 그룹의 중앙값을 찾고, 그 중앙값들의 중앙값을 피벗으로 삼습니다.
- 한쪽이 최대 $7N/10$ 이하로 줄어들도록 **강제 균형**을 만들기 때문에 최악의 경우에도 $O(N)$입니다.

```java
static int select(int[] arr, int left, int right, int k) {
    if (right - left + 1 <= 5) {
        Arrays.sort(arr, left, right + 1);
        return arr[left + k - 1];
    }
    int numMedians = 0;
    for (int i = left; i <= right; i += 5) {
        int subRight = Math.min(i + 4, right);
        Arrays.sort(arr, i, subRight + 1);
        swap(arr, left + numMedians, i + (subRight - i) / 2);
        numMedians++;
    }
    int medianOfMedians = select(arr, left, left + numMedians - 1, (numMedians + 1) / 2);
    int pivotIndex = partitionAroundPivot(arr, left, right, medianOfMedians);
    int rank = pivotIndex - left + 1;
    if (k == rank) return arr[pivotIndex];
    if (k < rank) return select(arr, left, pivotIndex - 1, k);
    return select(arr, pivotIndex + 1, right, k - rank);
}
```

---

## IV. 검색 트리 – 균형을 잡는 나무들

### 🎬 이진 검색 트리: 절반씩 줄이는 탐색

- 정상 상태에서는 한 단계를 내려갈 때마다 후보가 절반으로 줄어듭니다 → $O(\log N)$.
- 하지만 정렬된 데이터가 들어오면, 트리는 오른쪽으로만 쭉 뻗는 사다리가 됩니다 → $O(N)$.

```java
class BST {
    static class Node {
        int key;
        Node left, right;
        Node(int key) { this.key = key; }
    }
    Node root;
    void insert(int key) { root = insertRec(root, key); }
    Node insertRec(Node node, int key) {
        if (node == null) return new Node(key);
        if (key < node.key) node.left = insertRec(node.left, key);
        else node.right = insertRec(node.right, key);
        return node;
    }
    boolean search(int key) {
        Node cur = root;
        while (cur != null) {
            if (key == cur.key) return true;
            cur = key < cur.key ? cur.left : cur.right;
        }
        return false;
    }
}
```

### 🎬 레드 블랙 트리: 빨강과 검정으로 세운 균형 잡힌 건축물

- 규칙: 루트는 검정, 모든 리프는 검정, 빨강 노드의 자녀는 꼭 검정.
- 빨강이 연속되면 한쪽으로 기울어져 균형이 무너지므로 회전과 재색칠로 즉시 교정합니다.

```java
class RedBlackTree {
    private static final boolean RED = true;
    private static final boolean BLACK = false;
    private static class Node {
        int key; boolean color;
        Node left, right, parent;
        Node(int key, boolean color) { this.key = key; this.color = color; }
    }
    private Node root;

    public void insert(int key) {
        Node node = new Node(key, RED);
        root = bstInsert(root, node);
        fixInsert(node);
    }

    private Node bstInsert(Node root, Node node) {
        if (root == null) return node;
        if (node.key < root.key) {
            root.left = bstInsert(root.left, node);
            root.left.parent = root;
        } else {
            root.right = bstInsert(root.right, node);
            root.right.parent = root;
        }
        return root;
    }

    private void fixInsert(Node node) {
        while (node != root && node.parent.color == RED) {
            if (node.parent == node.parent.parent.left) {
                Node uncle = node.parent.parent.right;
                if (uncle != null && uncle.color == RED) { // Case 1: recolor
                    node.parent.color = BLACK;
                    uncle.color = BLACK;
                    node.parent.parent.color = RED;
                    node = node.parent.parent;
                } else {
                    if (node == node.parent.right) { // Case 2: rotate left
                        node = node.parent;
                        leftRotate(node);
                    }
                    node.parent.color = BLACK;       // Case 3: rotate right
                    node.parent.parent.color = RED;
                    rightRotate(node.parent.parent);
                }
            } else {
                // mirror case omitted for brevity
            }
        }
        root.color = BLACK;
    }

    private void leftRotate(Node x) {
        Node y = x.right;
        x.right = y.left;
        if (y.left != null) y.left.parent = x;
        y.parent = x.parent;
        if (x.parent == null) root = y;
        else if (x == x.parent.left) x.parent.left = y;
        else x.parent.right = y;
        y.left = x;
        x.parent = y;
    }

    private void rightRotate(Node y) {
        Node x = y.left;
        y.left = x.right;
        if (x.right != null) x.right.parent = y;
        x.parent = y.parent;
        if (y.parent == null) root = x;
        else if (y == y.parent.left) y.parent.left = x;
        else y.parent.right = x;
        x.right = y;
        y.parent = x;
    }
}
```

### 🎬 B-트리: 디스크 블록에 맞춘 대형 도서관

- 노드 하나가 디스크 블록 하나입니다. 한 번 읽을 때 최대한 많은 키를 메모리로 불러옵니다.
- 자식 포인터가 여러 개이므로 트리 높이가 낮아지고, 디스크 접근 횟수 $O(\log N)$가 아주 작아집니다.

```java
class BTree {
    static class Node {
        int t; // 최소 차수
        int n; // 현재 키 수
        boolean leaf;
        int[] keys;
        Node[] children;
        Node(int t, boolean leaf) {
            this.t = t;
            this.leaf = leaf;
            this.keys = new int[2 * t - 1];
            this.children = new Node[2 * t];
            this.n = 0;
        }
    }
    Node root;

    public void search(int key) {
        search(root, key);
    }

    private void search(Node node, int key) {
        if (node == null) return;
        int i = 0;
        while (i < node.n && key > node.keys[i]) i++;
        if (i < node.n && node.keys[i] == key) {
            System.out.println("Found key: " + key);
            return;
        }
        if (node.leaf) {
            System.out.println("Key not found: " + key);
            return;
        }
        search(node.children[i], key);
    }
}
```

### 🎬 KD-트리: 다차원 공간의 분할

- 레벨마다 다른 축(필드)을 기준으로 공간을 분할합니다.
- 삭제할 때는 해당 레벨의 축 기준으로 가장 작은 노드를 오른쪽 서브트리에서 찾아서 대체해야 합니다. 그래야 분할 규칙이 유지됩니다.

```java
class KDTree {
    static class Node {
        int[] point;
        Node left, right;
        Node(int[] point) { this.point = point; }
    }
    Node root;
    static final int K = 2; // 2D example

    public void insert(int[] point) { root = insertRec(root, point, 0); }

    private Node insertRec(Node node, int[] point, int depth) {
        if (node == null) return new Node(point);
        int axis = depth % K;
        if (point[axis] < node.point[axis]) node.left = insertRec(node.left, point, depth + 1);
        else node.right = insertRec(node.right, point, depth + 1);
        return node;
    }

    public boolean search(int[] point) { return searchRec(root, point, 0); }

    private boolean searchRec(Node node, int[] point, int depth) {
        if (node == null) return false;
        if (Arrays.equals(node.point, point)) return true;
        int axis = depth % K;
        if (point[axis] < node.point[axis]) return searchRec(node.left, point, depth + 1);
        return searchRec(node.right, point, depth + 1);
    }
}
```

---

## V. 해시 테이블 – 상수 시간의 비밀

### 🎬 해시 테이블: 주소 직통으로 연결되는 전화번호부

- 키를 해시 함수로 계산하여 바로 주소를 찾습니다.
- 테이블 크기 $m$이 짝수거나 10의 거듭제곱이면, 특정 패턴(예: 짝수 키)이 모두 같은 버킷에 몰릴 가능성이 커집니다.
- 소수 $m$을 사용하면 충돌이 고르게 분산됩니다.

```java
class HashTable<K, V> {
    static class Entry<K, V> {
        final K key;
        V value;
        Entry<K, V> next;
        Entry(K key, V value) { this.key = key; this.value = value; }
    }
    private Entry<K, V>[] buckets;

    @SuppressWarnings("unchecked")
    public HashTable(int capacity) {
        buckets = (Entry<K, V>[]) new Entry[capacity];
    }

    private int hash(K key) {
        return (key.hashCode() & 0x7fffffff) % buckets.length;
    }

    public void put(K key, V value) {
        int index = hash(key);
        Entry<K, V> head = buckets[index];
        for (Entry<K, V> e = head; e != null; e = e.next) {
            if (e.key.equals(key)) {
                e.value = value;
                return;
            }
        }
        Entry<K, V> entry = new Entry<>(key, value);
        entry.next = head;
        buckets[index] = entry;
    }

    public V get(K key) {
        int index = hash(key);
        for (Entry<K, V> e = buckets[index]; e != null; e = e.next) {
            if (e.key.equals(key)) return e.value;
        }
        return null;
    }
}
```

### 🎬 개방 주소법과 삭제 마커

- 선형 조사(Linear Probing)에서 삭제한 자리를 그냥 비워 두면, 그 뒤에 있던 키를 찾을 때 탐색이 중단되어 검색 실패가 납니다.
- 대신 "DELETED" 마커를 남겨야 탐색 흐름이 유지됩니다.

```java
class OpenAddressHashTable<K, V> {
    static final Object DELETED = new Object();

    static class Entry<K, V> {
        K key;
        V value;
        Entry(K key, V value) { this.key = key; this.value = value; }
    }

    private Entry<K, V>[] table;
    private int size;

    @SuppressWarnings("unchecked")
    public OpenAddressHashTable(int capacity) {
        table = (Entry<K, V>[]) new Entry[capacity];
    }

    private int hash(K key) {
        return (key.hashCode() & 0x7fffffff) % table.length;
    }

    public void put(K key, V value) {
        int idx = hash(key);
        for (int i = 0; i < table.length; i++) {
            int probe = (idx + i) % table.length;
            Entry<K, V> entry = table[probe];
            if (entry == null || entry.key == DELETED || entry.key.equals(key)) {
                table[probe] = new Entry<>(key, value);
                size++;
                return;
            }
        }
        throw new IllegalStateException("Hash table is full");
    }

    public V get(K key) {
        int idx = hash(key);
        for (int i = 0; i < table.length; i++) {
            int probe = (idx + i) % table.length;
            Entry<K, V> entry = table[probe];
            if (entry == null) return null;
            if (entry.key != DELETED && entry.key.equals(key)) return entry.value;
        }
        return null;
    }

    public void remove(K key) {
        int idx = hash(key);
        for (int i = 0; i < table.length; i++) {
            int probe = (idx + i) % table.length;
            Entry<K, V> entry = table[probe];
            if (entry == null) return;
            if (entry.key != DELETED && entry.key.equals(key)) {
                table[probe].key = (K) DELETED;
                table[probe].value = null;
                size--;
                return;
            }
        }
    }
}
```

---

## VI. 기본 자료구조 & 전략 – 흐름 제어의 예술

### 🎬 스택: Undo/Redo 이중 스택

- 최근 작업은 mainStack에 push.
- Undo 시 mainStack에서 pop하여 redoStack에 push.
- Redo 시 redoStack에서 pop하여 mainStack으로 다시 push.

```java
class UndoRedoManager {
    Deque<String> undoStack = new ArrayDeque<>();
    Deque<String> redoStack = new ArrayDeque<>();

    public void perform(String action) {
        undoStack.push(action);
        redoStack.clear();
    }

    public void undo() {
        if (!undoStack.isEmpty()) {
            String action = undoStack.pop();
            redoStack.push(action);
        }
    }

    public void redo() {
        if (!redoStack.isEmpty()) {
            String action = redoStack.pop();
            undoStack.push(action);
        }
    }
}
```

### 🎬 큐와 BFS: 물결처럼 확산되는 탐색

- 시작점을 큐에 넣고, 한 단계씩 Dequeue하면서 이웃을 Enqueue합니다.
- FIFO 구조 덕분에 같은 거리의 노드를 한 번에 탐색합니다.

```java
static int bfsShortestPath(int[][] maze, int sr, int sc, int tr, int tc) {
    int rows = maze.length, cols = maze[0].length;
    boolean[][] visited = new boolean[rows][cols];
    Queue<int[]> queue = new ArrayDeque<>();
    queue.offer(new int[]{sr, sc, 0});
    visited[sr][sc] = true;
    int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};

    while (!queue.isEmpty()) {
        int[] cur = queue.poll();
        int r = cur[0], c = cur[1], dist = cur[2];
        if (r == tr && c == tc) return dist;
        for (int[] d : dirs) {
            int nr = r + d[0], nc = c + d[1];
            if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;
            if (maze[nr][nc] == 1 || visited[nr][nc]) continue;
            visited[nr][nc] = true;
            queue.offer(new int[]{nr, nc, dist + 1});
        }
    }
    return -1;
}
```

### 🎬 Two Pointers: 합이 목표보다 크거나 작을 때

- 합이 목표보다 크면 오른쪽 포인터를 왼쪽으로 → 값이 줄어듭니다.
- 합이 목표보다 작으면 왼쪽 포인터를 오른쪽으로 → 값이 커집니다.

```java
static List<int[]> twoSumSorted(int[] arr, int target) {
    List<int[]> result = new ArrayList<>();
    int left = 0, right = arr.length - 1;
    while (left < right) {
        int sum = arr[left] + arr[right];
        if (sum == target) {
            result.add(new int[]{arr[left], arr[right]});
            left++;
            right--;
        } else if (sum > target) {
            right--;
        } else {
            left++;
        }
    }
    return result;
}
```

### 🎬 이진 탐색과 매개 변수 탐색

- 정수 $x$의 제곱근을 찾거나, 공유기를 설치해서 최소 거리를 최대화하는 문제는 모두 "답 자체가 범위"인 결정 문제입니다.
- 조건에 따라 왼쪽/오른쪽 범위를 줄여나갑니다.

```java
static double sqrtBinarySearch(double x) {
    double low = 0, high = Math.max(1.0, x);
    double eps = 1e-9;
    while (high - low > eps) {
        double mid = (low + high) / 2.0;
        if (mid * mid < x) low = mid; else high = mid;
    }
    return low;
}

static int maximizeDistance(int[] houses, int routers) {
    Arrays.sort(houses);
    int low = 1, high = houses[houses.length - 1] - houses[0];
    int answer = 0;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (canPlace(houses, routers, mid)) {
            answer = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return answer;
}
```

### 🎬 동적 프로그래밍: 메모하는 건축가

- $DP[i]$는 $i$번째 계단에 오르는 방법의 수.
- $DP[i] = DP[i-1] + DP[i-2]$ – 이전 한 칸, 두 칸에서 오는 길을 합칩니다.
- 메모이제이션 덕분에 $O(N)$ 안에 끝납니다.

```java
static int climbStairs(int n) {
    if (n <= 2) return n;
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

### 🎬 Greedy: 동전 거스름돈의 함정과 회의실 배정의 승리

- 동전 단위가 1, 4, 5라면 8원을 거슬러 줄 때 탐욕은 5+1+1+1=4개를 줍니다. 최적은 4+4=2개인데도요.
- 그래서 탐욕 알고리즘이 성공하려면, "언제나 현재 선택이 전체 최적해를 망치지 않는다"는 구조가 보장되어야 합니다.
- 회의실 배정은 종료 시간이 빠른 회의를 선택하면 항상 최적해가 나옵니다.

```java
static int minCoinsGreedy(int[] coins, int amount) {
    Arrays.sort(coins);
    int count = 0;
    for (int i = coins.length - 1; i >= 0; i--) {
        int coin = coins[i];
        while (amount >= coin) {
            amount -= coin;
            count++;
        }
    }
    return (amount == 0) ? count : -1;
}
```

---

## 마무리 – 메모리 영화관에서 다시 떠올린 장면들

이 모든 문제를 풀면서, 제 머릿속 영화관에는 알고리즘이 서로 다른 교통수단, 공정, 춤으로 나타났습니다. 정렬은 카드와 지도, 해시는 우편번호 분류, DP는 건축 설계. 이런 메모리 영화관이 있다면, 여러분은 알고리즘의 내부 작동을 외워서가 아니라, 장면처럼 떠올리며 다시 구현할 수 있을 겁니다.

마지막으로 제 스스로에게 적어 둔 메모입니다.

> "시간 복잡도는 교통수단, 재귀는 공장. 정렬은 데이터의 춤, 트리는 균형 잡힌 건축.
> 해시는 주소 직통, DP는 메모하는 건축가, 탐욕은 순간의 선택.
> 이 모든 장면이 머릿속에서 자연스럽게 재생될 때, 알고리즘은 외워서 쓰는 게 아니라 직접 만들어내는 도구가 된다."

이제 머릿속 영화관의 막을 내리고, 다음 알고리즘을 위한 새로운 장면을 준비해 보겠습니다.

```

### algorithm_solv.md

**Path:** `frontend/public/posts/2025/algorithm_solv.md`

```markdown
---
title: "알고리즘의 역발상 관점"
date: "2025-11-29"
category: "Computer Science"
tags: ['알고리즘', '동적 프로그래밍', '그리디', '문자열 알고리즘', 'P vs NP']
excerpt: "피보나치 수열, 행렬 곱셈, 그리디 알고리즘, 문자열 검색, P vs NP까지 — 컴퓨터 과학의 고전 알고리즘을 역발상 관점으로 정리"
readTime: "12분"
---
코드를 작성하는 행위는 생각보다 깊은 통찰을 요구합니다. 누구나 코드를 작성할 수 있지만, **'똑똑하게' 문제를 해결하는 것**은 전혀 다른 차원의 이야기입니다.우리는 종종 복잡한 문제 앞에서 가장 직관적인, 그러나 비효율적인 길을 선택하곤 합니다.

마치 과거 역사를 공부하여 미래를 예측하는 것처럼, 컴퓨터 과학의 고전 알고리즘을 들여다보는 것은 단순히 학문적 탐구를 넘어, **문제 해결에 대한 강력하고 종종 직관에 반하는 사고방식을 배우는 기회**입니다. 거장들이 수십 년간 쌓아 올린 지혜의 정수는, 평범한 개발자의 코드를 비범한 솔루션으로 바꾸는 열쇠가 될 수 있기에, 그 지혜를 이해하는 것은 큰 도움이 될 것이라 생각합니다.

## 1. 가장 유명한 예제가 가장 나쁜 예제일 때: 피보나치 수열의 함정

재귀(Recursion)를 처음 배울 때, 우리는 약속이라도 한 듯 **피보나치 수열** 예제를 만납니다. `f(n) = f(n-1) + f(n-2)` 라는 간결하고 우아한 정의는 재귀의 개념을 설명하기에 안성맞춤처럼 보입니다. 하지만 이 유명한 예제는 사실, **재귀를 얼마나 비효율적으로 사용할 수 있는지**를 보여주는 대표적인 사례라고 볼 수 있습니다.

`fib(7)`을 계산하는 과정을 상상해 봅시다. 이 함수는 `fib(6)`과 `fib(5)`를 호출합니다. `fib(6)`은 다시 `fib(5)`와 `fib(4)`를 호출하죠. 여기서 벌써 `fib(5)`이 두 번 호출되었습니다. 호출 트리를 그려보면 `fib(3)`, `fib(2)` 같은 작은 값들은 셀 수 없이 많이 반복적으로 계산됩니다. 이것이 바로 **낭비적인 중복 호출** 문제이며, 입력값이 조금만 커져도 계산 시간은 기하급수적으로 늘어나는 심각한 비효율을 초래합니다.

이 문제의 우아한 해결책이 바로 **동적 프로그래밍(Dynamic Programming)** 입니다. 핵심 아이디어는 놀랍도록 단순합니다.

- 복잡한 문제를 작은 하위 문제(subproblem)로 나누어 해결하는 알고리즘 설계 기법
- 각 하위 문제의 결과를 저장해 두고, 동일한 하위 문제가 다시 등장할 때 재활용하는 방식

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/algoritm_solv/algorithm-solve-dp-fibonacci.png" alt="동적 프로그래밍: 피보나치 중복 호출과 테이블 예시">
</div>

마치 전체를 모두 계산하는 것보다는 **필요한 부분만 계산하는 것**이 더 효율적인 것처럼 보입니다. 피보나치 수열에 이를 적용하면, `fib(3)`을 한 번 계산한 뒤 그 값을 배열이나 테이블에 저장해 둡니다. 다음에 또 `fib(3)`이 필요해지면 다시 계산하는 대신 **저장된 값을 즉시 가져다 쓰는 것**이죠.

즉, 현실에서 우리가 한번에 모든 것을 계산하는 것보다 당장 필요한 부분만 계산하여 시간을 절약하는 것이 더 효율적인 것과 비슷해 보입니다.

> 한 번 계산한 결과는 저장해 두고, **절대 다시 계산하지 않는다.**

이 간단한 원칙 하나만으로 재귀 함수의 성능은 극적으로 향상됩니다. 가장 유명한 예제가 우리에게 가르쳐 주는 가장 큰 교훈은, 눈에 보이는 우아함 뒤에 숨은 비효율을 간파하고 **'기억'을 통해 최적화하는 방법**입니다.

---

## 2. 계산 순서만 바꿨을 뿐인데… 성능이 10배 차이 나는 이유

세 개의 행렬 A, B, C를 곱한다고 가정해 봅시다. 수학의 결합법칙에 따라 `(AB)C`와 `A(BC)`의 최종 결과는 같습니다. 그래서 우리는 계산 순서에 대해 깊이 생각하지 않는 경향이 있습니다. 하지만 알고리즘의 세계에서는 이 **'순서'가 성능을 좌우하는 결정적인 요소**가 될 수 있습니다.

구체적인 예시를 통해 그 차이를 확인해 보겠습니다. 각 행렬의 크기가 다음과 같다고 가정합시다.

- `A: 10 × 100`
- `B: 100 × 5`
- `C: 5 × 50`

두 가지 순서에 따라 필요한 총 곱셈 연산 횟수를 계산해 보면 놀라운 결과가 나옵니다.

- **(AB)C 의 곱셈 횟수**

  - `(A × B)` 계산: `10 * 100 * 5 = 5,000`
  - `((AB) × C)` 계산: `10 * 5 * 50 = 2,500`
  - **총합: 7,500번**
- **A(BC) 의 곱셈 횟수**

  - `(B × C)` 계산: `100 * 5 * 50 = 25,000`
  - `(A × (BC))` 계산: `10 * 100 * 50 = 50,000`
  - **총합: 75,000번**

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/algoritm_solv/algorithm-solve-dp-matrix-chain.png" alt="동적 프로그래밍: 행렬 곱셈 순서 최적화 예시">
</div>

결과는 같은데 계산 순서만 바꿨을 뿐인데, 연산량이 무려 **10배**나 차이 납니다. 이 문제는 동적 프로그래밍으로 해결할 수 있는 문제의 핵심 특징인 **최적 부분 구조(Optimal Substructure)** 를 명확히 보여줍니다. 전체 문제(A부터 C까지의 곱셈)의 최적해는, 부분 문제(어떤 두 행렬을 먼저 곱할 것인가)의 최적해를 조합하여 만들어집니다.

> 최적의 해답은 단순히 올바른 계산을 하는 것을 넘어,
> **가장 효율적인 '순서'를 찾는 데서 비롯됩니다.**

결국, 문제의 구조를 파악하고 **최적의 실행 계획을 세우는 것**이 알고리즘 설계의 핵심입니다. 단순히 코드를 실행하는 것을 넘어, **어떤 순서로 실행할지를 고민하는 것.**

## 3. '최선'의 선택이 항상 '최악'의 결과를 낳는 경우: 그리디 알고리즘의 배신

"매 단계에서 지금 당장 가장 좋아 보이는 선택을 한다."
이것이 바로 **그리디 알고리즘(Greedy Algorithm)** 의 핵심 철학입니다. 매우 직관적이고 단순해서 많은 문제에서 효과적으로 작동합니다. 최소 비용으로 모든 도시를 연결하는 통신망을 설계하는 프림(Prim)이나 크루스칼(Kruskal) 알고리즘, 한 지점에서 다른 모든 지점까지의 최단 경로를 찾는 다익스트라(Dijkstra) 알고리즘은 모두 그리디 전략으로 최적의 해를 찾아내는 대표적인 성공 사례입니다.

하지만 이 매력적인 전략은 때때로 우리를 배신합니다. **'동전 거스름돈' 문제**를 통해 그리디의 함정을 살펴보겠습니다.

- **사례 1 (성공)**대한민국의 표준 `500원, 100원, 50원, 10원` 동전 체계에서 880원을 거슬러 준다고 해봅시다.그리디 방식은 가장 큰 단위인 500원부터 탐욕적으로 선택합니다.그 결과는 `500원 1개`, `100원 3개`, `50원 1개`, `10원 3개`로 총 8개의 동전입니다.이 경우, 그리디 방식은 **최소 개수의 동전**이라는 최적해를 완벽하게 찾아냅니다.
- **사례 2 (실패)**만약 우리나라에 `500원, 400원, 100원, 75원, 50원`이라는 기묘한 동전 체계가 도입되었다고 상상해 봅시다. 이제 `1300원`을 거슬러 줘야 합니다.

  - **그리디 방식의 선택**가장 큰 500원짜리부터 선택합니다.`500원 2개`(1000원)를 쓰고, 남은 300원을 만들기 위해 `100원 3개`를 씁니다.총 **5개의 동전**이 필요합니다.
  - **진정한 최적해**
    `500원 1개`와 `400원 2개`를 사용하면 똑같이 1300원을 만들 수 있습니다.
    이때 필요한 동전은 **단 3개**입니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/algoritm_solv/algorithm-solve-greedy-mst-coin-change.png" alt="그리디 알고리즘: 최소 신장 트리 성공 사례와 동전 거스름돈 실패 사례">
</div>

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/algoritm_solv/algorithm-solve-greedy-prim-dijkstra.png" alt="그리디 알고리즘: 프림 알고리즘과 다익스트라 알고리즘의 직관">
</div>

그리디 알고리즘은 눈앞의 이익(가장 큰 단위의 동전)에 눈이 멀어 전체적인 최적해를 놓치고 말았습니다. 왜 이런 차이가 발생할까요? 핵심은 동전 단위 간의 **'배수 관계'** 에 있습니다.

표준 동전 체계에서는 큰 단위 동전이 항상 작은 단위 동전들의 배수 관계를 이루거나, 그 가치를 더 적은 동전으로 효율적으로 대체합니다. 즉, 500원짜리 하나는 100원짜리 5개보다 항상 나은 선택입니다. 하지만 가상의 체계에서는 이 속성이 깨집니다. 800원을 만들 때 500원짜리 1개를 쓰는 것보다 400원짜리 2개를 쓰는 것이 더 효율적이죠. 이처럼 **지역적 최선이 전역적 최선을 보장하지 않는 구조**가 문제의 핵심입니다.

> 눈앞의 최선이 전체의 최선을 보장하지 않는다.
> 때로는 더 나은 미래를 위해 현재의 이익을 포기하는 지혜가 필요하다.

이 사례는 **문제의 구조를 이해하는 것**이 얼마나 중요한지 보여줍니다. 어떤 문제에는 그리디의 직관이 통하지만, 어떤 문제에는 한 걸음 물러나 모든 가능성을 고려하는 **동적 프로그래밍 같은 신중한 접근법**이 필요합니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/algoritm_solv/algorithm-solve-graph-bfs-dfs.png" alt="그래프 표현과 BFS/DFS 탐색 예시">
</div>

---

## 4. 실패에서 배우는 가장 빠른 길

### 똑똑한 문자열 매칭 검색

방대한 텍스트 문서 안에서 특정 단어(패턴)를 찾는 **문자열 매칭**은 가장 기본적인 컴퓨터 작업 중 하나입니다. 가장 원시적인 방법(브루트포스)은 텍스트의 첫 글자부터 패턴과 비교하고, 일치하지 않으면 텍스트를 한 칸 옆으로 옮겨 다시 처음부터 비교하는 것을 반복합니다. 매우 직관적이지만, 텍스트와 패턴이 길어질수록 **끔찍하게 비효율적**입니다.

여기에 **KMP 알고리즘**이라는 혁신적인 아이디어가 등장합니다. KMP의 핵심은 간단합니다.

> "패턴이 불일치했을 때, 이미 비교했던 정보를 버리지 않고 활용하여
> 불필요한 비교를 건너뛰는 것"

이것이 어떻게 가능할까요? 비밀은 패턴 내부의 구조, 즉 **'접두사(prefix)이면서 동시에 접미사(suffix)인 부분'** 을 미리 분석해 두는 데 있습니다.

예를 들어, 우리가 `"abaab"`라는 부분까지 일치시킨 후 다음 문자에서 불일치가 발생했다고 가정해 봅시다. 원시적인 방법이라면 텍스트 포인터를 한 칸만 옮겨 처음부터 다시 비교를 시작하겠죠. 하지만 KMP는 다릅니다.

`"abaab"`라는 문자열에서, 자기 자신을 제외한 가장 긴 접두사이자 접미사는 `"ab"`라는 사실을 이미 알고 있습니다. 따라서 불일치가 발생했을 때, 알고리즘은 이렇게 판단합니다.

> "방금 텍스트에서 확인한 마지막 두 글자가 `ab`였으니,
> 패턴의 시작 부분에 있는 `ab`를 여기에 맞춰서 비교를 재개하면 되겠다."

텍스트 포인터를 뒤로 돌릴 필요 없이, **패턴만 앞으로 쓱 밀어서** 비교를 이어가는 것입니다.

> 실패는 시간 낭비가 아니다.
> 똑똑한 알고리즘은 실패의 패턴을 분석해, **불필요한 반복을 건너뛰는 지름길**로 활용한다.

이러한 역발상은 **Boyer-Moore 알고리즘**에서 더욱 극대화됩니다. 이 알고리즘은 아예 패턴의 오른쪽 끝부터 비교를 시작하여, 불일치가 발생하면 훨씬 더 멀리 점프하는 과감한 전략을 사용합니다. 이 역시 '실패 정보'를 가장 효율적으로 활용하는 지혜에서 비롯됩니다.

결국, 효율적인 알고리즘은 단순히 계산을 빨리 하는 것이 아니라, **어떻게 하면 불필요한 계산을 피할 것인가**에 대한 깊은 고민의 산물입니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/algoritm_solv/algorithm-solve-string-kmp.png" alt="문자열 매칭: Naive 방식과 KMP 알고리즘의 점프 직관">
</div>

---

## 5. '풀 수 없는 문제'의 벽을 마주했을 때: P vs NP 이야기

컴퓨터는 무엇이든 해결할 수 있을 것 같지만, **명백한 한계**가 존재합니다. 컴퓨터 과학계의 가장 큰 난제인 **'P vs NP' 문제**는 바로 이 한계에 대한 이야기입니다.

일반 개발자도 이 개념을 이해하면 문제 해결에 대한 시야가 완전히 달라질 수 있습니다. 쉽게 풀어보겠습니다.

- **P 문제**"현실적인 시간(다항식 시간) 안에 풀 수 있는 문제"들의 집합입니다.정렬, 최단 경로 찾기 등 우리가 일상적으로 해결하는 대부분의 문제가 여기에 속합니다.컴퓨터가 빠르다고 느끼게 해주는 문제들이죠.
- **NP 문제**
  "정답이 주어지면, 그게 정답인지 현실적인 시간 안에 검증할 수 있는 문제"들의 집합입니다.
  예를 들어, 거대한 직소 퍼즐을 맞추는 것은 매우 어렵지만(푸는 것은 어려움),
  완성된 그림을 보고 제대로 맞춰졌는지 확인하는 것은 쉽습니다(검증은 쉬움).

여기서 세기의 질문이 나옵니다.

> **P = NP?**
> 즉, "답을 검증하기 쉬운 모든 문제는, 실제로 풀기도 쉬운가?"

아직 아무도 이 질문에 답하지 못했지만, 대부분의 과학자들은 `P ≠ NP`일 것이라고 추측합니다. 풀기는 어렵지만 검증은 쉬운 문제가 분명히 존재할 것이라는 믿음이죠.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/algoritm_solv/algorithm-solve-complexity-p-vs-np.png" alt="복잡도 클래스 P와 NP의 관계를 나타낸 다이어그램">
</div>

이 **NP 문제들 중에서도 가장 악명 높은 '보스 몬스터'**들이 있는데, 이들을 **NP-Complete 문제**라고 부릅니다. 여행하는 외판원 문제(모든 도시를 방문하는 최단 경로 찾기)가 대표적입니다. 이 문제들은 서로 기묘하게 연결되어 있어서, NP-Complete 문제 중 단 하나라도 현실적인 시간에 풀 수 있는 방법이 발견되면, 나머지 모든 NP-Complete 문제들도 함께 해결할 수 있습니다.

개발자로서 이 개념을 아는 것은 매우 실용적인 가치가 있습니다.

- 어떤 문제가 **매우 어렵다(NP-Complete)** 는 것을 아는 것은 포기가 아니라 **전략의 시작**입니다.
- 완벽한 최적해를 찾는 데 시간을 낭비하는 대신, **"충분히 좋은" 근사 해를 빠르게 찾는 길**로 나아갈 수 있습니다.
- 내가 마주한 새로운 문제가, 알려진 NP-Complete 문제(가령 TSP)로 변환될 수 있음을 증명한다면
  "이 문제는 완벽한 해법을 찾기보다는, 제약 안에서의 근사 해를 목표로 해야겠다"는
  데이터 기반의 의사결정을 내릴 수 있습니다.

문제의 난이도를 파악하고 증명하는 것 자체가 이미 **문제 해결의 중요한 일부**인 셈입니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/algoritm_solv/algorithm-solve-complexity-np-complete-reduction.png" alt="NP-Complete: 해밀턴 사이클에서 외판원 문제로의 다항 시간 변환 예시">
</div>

---

이처럼 의심하며 사유하는 것은 단순히 특정 알고리즘을 암기하는 것 이상의 의미를 가집니다.
중복 계산을 피하는 동적 프로그래밍의 지혜, 최적의 순서를 고민하는 통찰력, 눈앞의 이익을 경계하는 그리디의 교훈, 실패를 자산으로 삼는 문자열 검색의 역발상, 그리고 해결 불가능한 문제 앞에서 전략을 바꾸는 유연함까지.

이 모든 것은 코딩 기술을 넘어, **복잡한 세상을 이해하고 문제를 해결하는 데 필요한 구조적이고 논리적인 사고방식**입니다. 

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/algoritm_solv/algorithm-solve-summary-overview.png" alt="동적 프로그래밍, 그리디, 문자열 알고리즘, 계산 복잡도를 한눈에 요약한 개념 지도">
</div>

지금 당신이 마주한 문제 속에는, 오늘 살펴본 알고리즘의 역발상적인 지혜를 적용할 부분이 숨어 있지 않을까요?

```

### algorithms-through-my-eyes.md

**Path:** `frontend/public/posts/2025/algorithms-through-my-eyes.md`

```markdown
---
title: "알고리즘 수업 노트를 다시 펼쳐 보며"
date: "2025-10-19"
category: "Computer Science"
tags: ['알고리즘', '복잡도', '분할정복', '동적계획법', '탐욕법']
excerpt: "기초 알고리즘 수업 노트를 다시 펼쳐 보며..."
readTime: "8분"
---

알고리즘이라는 단어를 처음 들었을 때, 저는 그냥 "코드 짜는 순서" 정도로 생각했습니다. 그런데 학부 시절 기초 알고리즘 강의를 들으면서, 이게 단순한 절차가 아니라 문제 해결의 철학이라는 사실을 깨달았어요. 문제를 정의하고, 풀어낼 방법을 설명하고, 그게 진짜 맞는지 증명하고, 얼마나 빠르고 가벼운지 분석하는 과정. 그때 비로소 컴퓨터과학이 수학과 공학 사이 어디쯤에 서 있는 학문이라는 감각이 왔습니다. 요즘은 이 노트를 꺼내 놓고 글을 쓰다 보면, 그 시절의 설렘과 두려움이 함께 솟구칩니다.

### 알고리즘을 바라보는 기준선

알고리즘이 알고리즘다우려면 몇 가지 기본을 갖춰야 한다는 이야기를 처음 들었을 때를 기억합니다. 입력과 출력이 있는지, 절차가 애매하지 않은지, 언젠가는 반드시 멈출지, 사람이 연필과 종이로도 흉내 낼 만큼 단순한 명령으로 이루어져 있는지 말이죠. 특히 "유한성"이라는 조건을 듣고는 잠깐 멍해졌어요. 운영체제처럼 늘 켜져 있어야 하는 소프트웨어는 엄격한 의미의 알고리즘이 아니라는 말이 새삼 낯설었거든요. 하지만 곰곰이 생각해 보니, 우리는 결국 끝이 보장되는 문제 해결법을 연구하고 있었고, 그게 계산 가능성의 가장 단단한 토대였습니다.

### 측정하고 또 측정하기

취업 준비하면서 제일 많이 외웠던 단어는 아마도 "빅오(Big-O)"였던 것 같습니다. 직접 실행 시간을 재면 하드웨어와 컴파일러에 따라 숫자가 바뀌니, 입력 크기 `n`에 따른 연산 횟수를 세는 쪽이 더 믿을 만하다는 그 말이 아직도 생생합니다. 그리고 점근적 분석이라는 말을 처음 접했을 때, 문제를 끝까지 밀어붙이면 결국 `n`이 무한히 커졌을 때의 모습을 보게 된다는 발상이 무척 멋졌죠. O(1)에서 O(2^n)까지 줄줄 외우던 순서가 단순한 암기가 아니라, "엔지니어는 최악의 상황을 놓치지 않는다"는 철학이라는 걸 깨닫고 나서는, 복잡도 표기법이 갑자기 인간적인 언어로 느껴졌습니다.

### 세 가지 단골 패러다임과의 동행

알고리즘 수업의 절반은 분할 정복, 동적 계획법, 탐욕법에 대한 이야기였던 것 같습니다. 분할 정복은 큰 문제를 쪼개고 재귀적으로 풀어 다시 합치는 하향식(top-down) 사고를 가르쳐 주었습니다. 병합 정렬과 퀵 정렬이 왜 그렇게 우아하게 작동하는지 이해하고 나니, 배열을 반으로 갈라서 다시 합치는 단순한 생각이 얼마나 강력한지 실감했죠.

동적 계획법(DP)을 처음 이해했을 때는 진짜 기쁨에 소리를 질렀습니다. 피보나치 수열을 예로 들면, 서로 다른 분기에서 같은 하위 문제를 반복해서 푸는 것이 시간 낭비라는 걸 깨닫는 순간이 있잖아요. 그때 메모이제이션을 붙여 주면 곧장 선형 시간이 됩니다. "중복되는 하위 문제"와 "최적 부분 구조"라는 키워드가 제 공부 노트에 가장 많이 등장했던 이유죠. 분할 정복과의 차이를 물어보는 시험 문제에도, 저는 항상 "하위 문제가 겹치는가?"라는 한 줄 메모를 해 두곤 했습니다.

탐욕 알고리즘은 또 다른 세계였습니다. 매 순간 가장 좋아 보이는 선택을 하는 것이 결국 전체를 최적으로 만든다는 것, 그걸 증명하는 과정이 얼마나 어려운지 직접 겪고 나서야 알았거든요. 다익스트라나 크루스칼 알고리즘이 왜 그렇게 단순한 전략으로도 멋진 결과를 내는지 이해하려면, 탐욕적 선택 속성과 최적 부분 구조를 수식으로 잡아 줘야 했습니다. 이게 어쩌면 가장 엔지니어다운 사고 아닐까요? 완벽한 해답보다, 현실적인 시간 안에 쓸 만한 해답을 보장하는 전략. 제게 탐욕법은 그런 실용적 낙관주의를 가르쳐 준 선생님 같은 존재였습니다.

### 정렬과 탐색이라는 기본기

정렬 알고리즘 표를 외우던 밤도 빠질 수 없습니다. 버블, 선택, 삽입 정렬은 느리지만 구조가 단순해서, 데이터가 거의 정렬된 상황에서는 삽입 정렬이 얼마나 빠르게 변신하는지 직접 코딩하며 느꼈죠. 이후에 만난 병합 정렬과 퀵 정렬, 힙 정렬은 `O(n log n)`이라는 공통점을 공유하면서도, 추가 공간과 최악의 경우에 대한 서로 다른 타협을 제시했습니다. 학부생 시절의 저는 이 차이를 정리한 표를 책상 위에 붙여 놓고, 각 알고리즘의 안정성과 제자리성 여부까지 꼼꼼히 외우곤 했습니다.

탐색 알고리즘을 이해하면서는 "정렬된 데이터가 있다는 가정이 얼마나 큰 힘인지"를 절감했습니다. 선형 탐색은 누구나 떠올릴 수 있지만, 이진 탐색이 `O(log n)`으로 데이터를 찾아내는 모습을 보고 나서는, 정렬이 단순한 미관이 아니라 성능 자체에 대한 투자라는 것을 마음에 새겼습니다. 제가 만든 첫 프로젝트에서 이진 탐색을 잘못 구현해 버그를 고치던 날, "왼쪽과 오른쪽 경계가 만나는 순간"을 다르게 처리해 놓은 제 코드가 멈춰있던 화면이 아직도 눈에 선합니다.

### 그래프 위를 걷다

입사 준비를 하면서 DFS와 BFS를 외우는 일은 이제 일종의 통과의례가 됐습니다. DFS를 재귀로 구현할 때마다 호출 스택이 암묵적인 스택 자료구조가 된다는 말이 실감났고, BFS로 가중치 없는 그래프에서 최단 경로를 찾을 때 큐가 얼마나 단단한 도구인지 깨달았습니다. 더 나아가 다익스트라는 단순한 탐욕 알고리즘이 아닌 우선순위 큐 기반의 고급 전략이라는 걸 이해했고, 벨만-포드가 음수 가중치까지 처리하며 음수 사이클까지 잡아낸다는 사실에 또 한 번 감탄했죠.

최소 신장 트리를 공부하면서는 크루스칼과 프림이 서로 다른 관점에서 같은 목표를 향해 달려간다는 점이 인상적이었습니다. 하나는 간선 중심, 다른 하나는 정점 중심. 그런데 두 알고리즘 모두 "사이클을 만들지 않는 가장 싸고 좋은 연결"이라는 직관을 공유합니다. 희소 그래프와 밀집 그래프에 따라 더 적합한 알고리즘이 분리된다는 사실은, 문제를 제대로 파악하는 일이 해결 방법만큼이나 중요하다는 것을 다시 일깨워 줬습니다.

### 실전에서 만난 알고리즘

일상에서 가장 자주 떠올렸던 예시는 A* 알고리즘이었습니다. 길 찾기를 하면서 다익스트라에 휴리스틱을 더해 목적지 방향으로 탐색을 우선시하는 그 방식, 바로 현실적인 타협이죠. 완벽한 최단 경로를 보장하면서도 실제 지리 정보를 활용해 속도를 끌어올리는 아이디어. 이게 바로 정형 알고리즘과 경험적 지식이 손을 잡을 때 얼마나 아름다운 결과가 나오는지 보여줍니다.

웹 검색 엔진의 페이지랭크를 공부할 때도 그랬습니다. 링크를 투표로 보는 관점, 그리고 그 투표에 가중치를 두는 방식은 네트워크를 그래프로 모델링하는 사고의 극치였죠. 추천 시스템의 콘텐트 기반 필터링과 협업 필터링을 비교하면서는 "데이터가 없으면 아무것도 할 수 없다"는 콜드 스타트 문제의 현실을 배웠습니다.

머신러닝을 접하면서는 알고리즘이 갑자기 낡은 교과서 속의 이야기가 아니라, 데이터 압축과 해싱, 그래프 순회 같은 실전 도구로 다시 살아났습니다. K-평균 군집화가 사실상 데이터 압축의 한 형태라는 말이 새삼 와 닿았습니다. 기본기를 튼튼히 다지는 일이 결국 새로운 분야의 밑거름이 된다는 걸, 몇 번이고 확인했습니다.

### 앞으로도 계속 이어질 질문들

이렇게 돌아보면, 알고리즘을 공부한다는 건 그냥 코딩 스킬을 쌓는 일이 아니라 사고방식을 다듬는 과정이었습니다. 문제를 명확히 정의하고, 더 나은 방식을 끊임없이 찾고, 때때로 최악의 경우를 대비해 차분하게 시스템을 설계하는 태도. 빅데이터와 분산 시스템, 머신러닝이 아무리 새로운 무기를 들고 와도, 결국 복잡도 분석과 데이터 구조 선택이라는 기본 원칙은 여전히 변치 않는 나침반이 되어 줍니다.

이제는 새로운 프로젝트를 시작할 때마다, 저는 묻습니다. "이 문제의 구조는 무엇인가?", "하위 문제들은 서로 겹치는가?", "탐욕적인 선택이 통할까?" 그리고 "최악의 경우에도 시스템이 버틸까?" 이 질문들은 처음 누군가에게 배워서 적어 놓았던 강의 노트의 문장들인데, 이제는 제 사고방식 그 자체가 되어 버렸습니다. 어쩌면 알고리즘 공부가 제게 남겨 준 가장 큰 선물은, 이 질문들을 평생 동안 반복하게 만들었다는 사실인지도 모릅니다.

```

### ansible-01-installation-setup.md

**Path:** `frontend/public/posts/2025/ansible-01-installation-setup.md`

```markdown
---
title: "Ansible 설치와 첫 Inventory 구성"
date: "2025-01-13"
category: "DevOps"
tags: ["DevOps","Ansible","자동화","Inventory","초급"]
excerpt: "패키지 설치부터 SSH 키, Inventory 작성, Ad-hoc 명령(ping, shell) 실행까지 Ansible 입문 필수 흐름."
author: "Admin"
published: true
---
# Ansible 설치와 첫 Inventory 구성

서버 자동화를 처음 시도했을 때 제일 먼저 부딪힌 건 “이 많은 서버를 언제 다 만지지?”라는 막막함이었습니다. 매번 SSH로 접속해서 같은 명령을 반복하다 보면 손보다 마음이 먼저 지치더라고요. 혹시 비슷한 경험을 해보신 적 있나요? 이 글은 한 발씩 정리해 둔 개인 실습 노트입니다. 건조한 매뉴얼 대신, 직접 부딪히며 느낀 흐름을 따라가 보시죠.

## 설치를 익히는 나만의 리듬

Ansible과 먼저 말을 섞기 위해 로컬 환경을 맞추는 것부터 시작했습니다. Fedora에서 작업할 때는 아래 순서로 진행합니다. 패키지를 최신 상태로 올리고, 설치를 마치면 `ansible --version`을 꼭 확인합니다.

```bash
sudo dnf -y update
sudo dnf -y install ansible
ansible --version
```

macOS에서 실습한다면 홈브루 한 줄이면 끝입니다.

```bash
brew install ansible
```

그리고 Python 가상환경을 마련해 둔 뒤 `pip install ansible`로 동일한 버전을 유지하는 방법도 자주 씁니다.

```bash
pip install ansible
pip install --upgrade ansible
```

## 작업장을 정돈하며 마음 다잡기

설치가 끝나면 폴더 정리부터 시작합니다. 머릿속이 복잡할수록 작업 폴더는 더 깔끔해야 한다는 것이 개인 철칙입니다.

```bash
mkdir -p ~/ansible-lab/{inventory,playbooks,roles}
cd ~/ansible-lab
```

`ansible-lab/` 구조를 화면에 띄워 놓고 오늘 어떤 목표를 먼저 채울지 점검합니다.

## cfg 파일에 나만의 규칙 새겨 두기

`ansible.cfg`를 열고 인벤토리 위치, SSH 키 경로, 출력 포맷을 한 번에 정해 두면 실수할 여지를 줄일 수 있습니다.

```ini
[defaults]
inventory = ./inventory/hosts
host_key_checking = False
remote_user = fedora
private_key_file = ~/.ssh/id_rsa
stdout_callback = yaml
forks = 10
gathering = smart
log_path = ./ansible.log

[privilege_escalation]
become = True
become_method = sudo
become_user = root
```

출력 포맷을 `yaml`로 바꾸고 로그 경로를 지정해 두면, 나중에 트러블슈팅할 때 사건의 조각들을 편하게 모을 수 있습니다.

## SSH 키를 준비하는 순간

신뢰를 쌓는 일은 SSH 키에서 시작합니다. 전용 키를 만들어 두고 각 서버에 배포하면 이제 비밀번호를 입력하느라 손목을 혹사시키지 않아도 됩니다.

```bash
ssh-keygen -t rsa -b 4096 -f ~/.ssh/ansible_key -N ""
ssh-copy-id -i ~/.ssh/ansible_key.pub user@node1.example.com
```

## 인벤토리를 채우며 그림 그리기

이제 `inventory/hosts` 파일을 펼쳐 놓고, 관리할 서버들의 이름을 한 줄씩 적어 봅니다.

```ini
node1.example.com

[webservers]
web1.example.com
web2.example.com ansible_host=192.168.1.11

[databases]
db1.example.com ansible_host=192.168.1.21 ansible_port=2222

[production:children]
webservers
databases

[webservers:vars]
ansible_user=fedora
http_port=80
app_env=production

[databases:vars]
ansible_user=admin
db_port=5432
```

`ansible_host`는 실제 접속 IP, `ansible_port`는 SSH 포트, `ansible_user`는 기본 로그인 계정, `ansible_ssh_private_key_file`은 키 파일 경로를 의미합니다.

## 첫 번째 핑

모든 준비를 마쳤다면 `ping` 모듈로 모든 호스트와 대화를 시도해 보세요.

```bash
ansible all -m ping
ansible webservers -m ping
```

이어서 `shell` 모듈로 시스템 상태를 훑습니다.

```bash
ansible all -m shell -a "uptime"
ansible all -m shell -a "df -h"
ansible all -m shell -a "free -m"
```

성공한 출력:

```yaml
node1.example.com | SUCCESS => {
  "changed": false,
  "ping": "pong"
}
```

## 패키지와 서비스를 한 번에 돌보는 법

Nginx를 설치하고 서비스를 올려 봅니다.

```bash
ansible all -m dnf -a "name=nginx state=present" --become
ansible all -m service -a "name=nginx state=started" --become
```

## 서버의 정보를 더 깊게 보고 싶을 때

`setup` 모듈을 사용해 운영체제 버전이나 CPU 코어, 기본 IP 같은 정보를 확인합니다.

```bash
ansible all -m setup
ansible all -m setup -a "filter=ansible_distribution*"
ansible all -m setup -a "filter=ansible_default_ipv4"
```

유용한 키: `ansible_hostname`, `ansible_distribution`, `ansible_processor_cores`, `ansible_memtotal_mb`.

## 스스로에게 던지는 작은 미션들

연습용 미션 아이디어:
- webservers 그룹에 Nginx 설치 후 상태 확인
- 모든 서버의 디스크/메모리 정보를 `/tmp/facts`에 저장
- `all:!databases` 패턴으로 특정 그룹 제외하고 ping 실행

## 막히는 순간마다 정리한 해결법

- SSH 실패: 키 경로/권한 확인 (`ansible.cfg` 점검)
- sudo 거부: `--become` 옵션 추가 또는 서버 사용자 권한 조정
- MODULE FAILURE: Python 미설치 → raw 모듈로 `dnf -y install python3`

## 다음 이야기로 넘어가기 전에

여기까지 따라오셨다면 이제 Ansible과 서로의 이름을 제대로 불러 준 셈입니다. 다음 편에서는 인벤토리를 세분화하고 플레이북을 짜는 이야기를 다룹니다.

## 더 깊이 파고들고 싶다면

- 공식 문서: https://docs.ansible.com/
- 모듈 목록: https://docs.ansible.com/ansible/latest/collections/index_module.html

```

### ansible-02-inventory-basics.md

**Path:** `frontend/public/posts/2025/ansible-02-inventory-basics.md`

```markdown
---
title: "Ansible Inventory 심화: 그룹/변수/패턴"
date: "2025-02-10"
category: "DevOps"
tags: ["DevOps","Ansible","Inventory","Pattern"]
excerpt: "Static/동적 인벤토리, 그룹 중첩, 변수 계층, 패턴 매칭, 환경 분리 전략까지 실전 정리"
author: "Admin"
published: true
---
## Inventory를 이야기로 엮어 보기

처음 인벤토리를 맡았을 때 저는 ‘호스트 목록 하나 만드는 일이 이렇게 까다롭다고?’라는 생각부터 들었습니다. 어떤 서버가 어떤 역할을 맡는지 눈앞에 정리돼 있지 않으면, 플레이북을 돌릴 때마다 불안한 마음이 고개를 들더라고요. 그래서 이 글에서는 제가 실제로 겪었던 시행착오와 함께 인벤토리를 서술형으로 풀어 보려고 합니다. 단순한 `hosts` 파일을 넘어, 그룹을 중첩하고 변수를 계층화하며, 패턴과 동적 인벤토리까지 다뤘던 경험을 차근차근 나눠 볼게요.

### INI 스타일로 첫 걸음을 옮기다

처음에는 익숙한 INI 포맷이 가장 편했습니다. `inventory/hosts.ini` 파일을 열어 다음과 같이 작성했죠. 웹 서버, 데이터베이스, 캐시를 그룹으로 묶고, 필요한 변수는 호스트 옆에 덧붙입니다. 마지막에는 `[all:vars]` 블록을 열어 모든 서버가 공유해야 할 SSH 사용자와 키 파일을 적어 두었습니다. 이렇게 한눈에 역할과 접근 정보를 정리하면 어느 서버를 향해 명령이 날아갈지 머릿속 그림이 또렷해집니다.

```ini
[web]
web1 ansible_host=10.0.1.11 env=prod
web2 ansible_host=10.0.1.12 env=prod
web3 ansible_host=10.0.2.21 env=stage

[db]
db1 ansible_host=10.0.5.10 env=prod

[cache]
redis1 ansible_host=10.0.6.11 env=prod

[all:vars]
ansible_user=ec2-user
ansible_ssh_private_key_file=~/.ssh/prod.pem
```

이 구성을 나란히 바라보면, 그룹 헤더가 자연스럽게 서버를 역할별로 묶고 있음을 느낄 수 있습니다. INI 형식은 단순하지만 빠르게 쓸 수 있고, 호스트 이름 옆에 필요한 속성을 즉시 붙여 넣을 수 있다는 점이 마음에 들었습니다.

### YAML로 옮겨 적으며 구조를 다듬다

조금 더 구조를 명확히 하고 싶을 때는 YAML 포맷이 도움이 됐습니다. 계층 구조와 공통 변수를 시각적으로 구분하기 쉬워 설명이 쉬워집니다. 아래 예시는 `inventory/hosts.yml`을 YAML로 옮겨 적은 버전입니다.

```yaml
all:
  vars:
    ansible_user: ec2-user
    ansible_ssh_private_key_file: ~/.ssh/prod.pem
  children:
    web:
      hosts:
        web1:
          ansible_host: 10.0.1.11
          env: prod
        web2:
          ansible_host: 10.0.1.12
          env: prod
        web3:
          ansible_host: 10.0.2.21
          env: stage
    db:
      hosts:
        db1:
          ansible_host: 10.0.5.10
          env: prod
    cache:
      hosts:
        redis1:
          ansible_host: 10.0.6.11
          env: prod
```

공통 변수는 `all.vars`에 모아 두고, 하위 그룹을 `children`으로 구조화하니 한눈에 흐름이 잡히더군요. YAML은 처음엔 다소 장황해 보이지만, 나중에 환경이 늘어났을 때도 확장성이 좋아서 애착이 생겼습니다.

### 그룹을 겹겹이 쌓아 메타 구조 만들기

인프라가 복잡해지자 저는 환경별로 서버를 구분해야 했습니다. prod와 stage를 나눠 관리하려면 상위 그룹을 더 만들어 줘야겠죠. 아래처럼 `prod`와 `stage`라는 메타 그룹을 구성한 뒤, 그 아래에 실제 역할 그룹을 children으로 배치했습니다. 이 구조를 사용하면 “프로덕션 웹 서버만”이라는 조건을 훨씬 자연스럽게 표현할 수 있습니다.

```yaml
all:
  children:
    prod:
      children:
        web_prod:
          hosts:
            web1:
              ansible_host: 10.0.1.11
            web2:
              ansible_host: 10.0.1.12
        db_prod:
          hosts:
            db1:
              ansible_host: 10.0.5.10
    stage:
      children:
        web_stage:
          hosts:
            web3:
              ansible_host: 10.0.2.21
```

이렇게 겹겹이 쌓아 두면, 특정 환경이나 역할만 골라서 플레이북을 돌릴 때 생각이 훨씬 단순해집니다. ‘이 호스트가 상속받는 변수는 무엇일까?’라는 질문에도 금세 답을 찾게 되죠.

### group_vars와 host_vars에 이야기를 저장하다

어느 순간부터 저는 변수들을 파일로 분리하지 않으면 혼란이 생긴다는 사실을 깨달았습니다. 그래서 `group_vars`와 `host_vars`를 디렉터리로 나누고, 각 그룹과 호스트가 사용하는 설정을 별도 YAML 파일에 옮겨 적었습니다.

```text
inventory/
  hosts.yml
  group_vars/
    all.yml
    prod.yml
    web.yml
  host_vars/
    web1.yml
```

`group_vars/prod.yml`에는 공통 사용자와 로깅 레벨을 담았고, `group_vars/web.yml`에는 웹 서버만의 타임아웃 값을, `host_vars/web1.yml`에는 특정 헤더 값을 지정했습니다.

```yaml
# group_vars/prod.yml
ansible_user: ec2-user
logging_level: INFO

# group_vars/web.yml
nginx_keepalive_timeout: 65

# host_vars/web1.yml
nginx_custom_header: "X-Web1"
```

변수 우선순위는 항상 머릿속에 떠올려야 했습니다. role defaults에서 시작해 inventory의 `group_vars(all)`을 거치고, 더 구체적인 group_vars, host_vars, play vars, 마지막으로 extra vars까지 올라가는 흐름이죠. 이 순서를 이해하고 나니, “왜 이 값이 덮어씌워졌지?”라는 의문이 생길 때 훨씬 빨리 진단할 수 있었습니다.

### 패턴 매칭으로 원하는 집합만 골라내기

플레이북을 실행하려다 보면, 특정 서버 그룹에만 작업을 적용하고 싶은 순간이 옵니다. 그럴 때 저는 `-l` 옵션과 패턴 연산자를 적극적으로 활용합니다. 아래 예시처럼 OR, AND, NOT을 조합하면 머릿속으로 생각한 집합을 그대로 표현할 수 있습니다.

```bash
ansible-playbook site.yml -l "web"        # web 그룹 전체
ansible-playbook site.yml -l "web:&prod"  # prod 환경의 web만 교집합
ansible-playbook site.yml -l "web:!web3"  # web에서 web3 제외
ansible-playbook site.yml -l "web_prod:db_prod" # prod 웹과 DB 합집합
```

콜론은 합집합, 앰퍼샌드는 교집합, 느낌표는 제외를 의미합니다. 이런 문법을 겁내지 않고 쓰다 보면, “필요한 범위만 정확히 집어냈다”는 안도감이 찾아옵니다.

### AWS 동적 인벤토리를 붙이며 자동화를 넓히다

클라우드 환경에서는 호스트가 수시로 늘고 줄기 때문에 정적인 파일만으로는 버틸 수가 없었습니다. 그래서 저는 boto3와 botocore를 설치한 뒤, AWS EC2 플러그인을 활용한 동적 인벤토리를 구성했습니다.

```bash
pip install boto3 botocore
```

`inventory/aws_ec2.yml` 파일은 다음과 같습니다. 태그 기반 필터를 걸어 prod 환경의 실행 중 인스턴스만 불러오고, 태그 값으로 그룹을 자동 생성하도록 구성했습니다.

```yaml
plugin: aws_ec2
regions:
  - ap-northeast-2
filters:
  tag:Environment: prod
  instance-state-name: running
keyed_groups:
  - key: tags.Role
    prefix: role
  - key: tags.Environment
    prefix: env
hostnames:
  - tag:Name
compose:
  ansible_host: public_ip_address or private_ip_address
```

구성이 끝나면 `ansible-inventory -i inventory/aws_ec2.yml --graph` 명령으로 구조를 먼저 확인합니다. 태그 관리만 깔끔하면, 새로운 인스턴스가 생성될 때 자동으로 인벤토리에 포함되는 모습을 볼 수 있습니다. 저는 태그 범위를 과도하게 넓히지 말고, 역할과 환경을 정확히 지정하는 것이 베스트 프랙티스라고 느꼈습니다.

### 환경을 분리하는 여러 가지 선택지

프로덕션과 스테이징을 어떻게 분리할지도 늘 고민거리였습니다. 세 가지 전략을 번갈아 적용했습니다. 첫 번째는 단일 레포 안에서 `inventory/prod`와 `inventory/stage` 디렉터리를 나누는 방식입니다. 두 번째는 동적 인벤토리를 쓰되 태그 조건으로 환경을 구분하는 방법입니다. 마지막으로는 규제가 강한 환경에서 쓰는 완전 별도 레포 전략입니다. 환경마다 접근 권한이 다를 때 유용합니다.

```text
inventory/
  prod/
    hosts.yml
    group_vars/
  stage/
    hosts.yml
    group_vars/
```

CI 파이프라인을 구성할 때는 `ENV` 변수를 전달해 적절한 디렉터리를 선택하고, `ansible-playbook -i inventory/${ENV}/hosts.yml site.yml` 명령으로 원하는 환경만 조준합니다. 이렇게 흐름을 정리해 두면, 누군가 실수로 잘못된 환경에 배포하는 상황을 미리 막을 수 있습니다.

### 변수 충돌과 성능 문제를 다루는 태도

복잡한 인벤토리를 다루다 보면 언젠가 변수 충돌을 마주하게 됩니다. 저는 `ansible-inventory --host web1 -i inventory/hosts.yml` 명령으로 최종 머지된 변수를 확인하고, 필요하면 `-vvv` 옵션으로 세부 로그를 열어 봅니다. 충돌이 발견되면 공통 변수를 더 작은 범위로 이동시키거나, 중복된 키를 정리하면서 구조를 다듬었습니다.

성능 이슈가 있을 때는 캐시 플러그인과 `cache_timeout` 값을 조정해 조회 시간을 줄였습니다. 필터가 너무 넓으면 인벤토리 로딩 시간이 길어지니, 조건을 정교하게 다듬는 습관도 함께 길렀습니다. 마지막으로 `forks` 값을 기본 5에서 상황에 따라 20 이상으로 높여 병렬 실행을 활용하니, 배포 시간이 훨씬 짧아졌습니다.

### 정리하며 다음 걸음을 떠올리다

지금까지 따라오느라 고생 많으셨습니다. 인벤토리는 처음엔 그저 호스트 목록처럼 보이지만, 구조를 한 번 정리해 놓으면 운영의 리듬이 달라집니다. 이 과정을 통해 “누가 어디서 어떤 역할을 하고 있는가”라는 질문에 빠르게 답할 수 있게 되었습니다. 이제 다음 단계로는 플레이북 구조나 역할(Role) 설계를 살펴보고 싶습니다. 오늘 정리한 내용이 인벤토리를 조금 더 친근한 문장으로 바꾸는 데 도움이 되길 바랍니다.

```

### ansible-03-playbook-examples.md

**Path:** `frontend/public/posts/2025/ansible-03-playbook-examples.md`

```markdown
---
title: "Ansible Playbook 작성 실습 모음"
date: "2025-02-11"
category: "DevOps"
tags: ["DevOps","Ansible","Playbook","실습"]
excerpt: "첫 Playbook을 써 내려가며 겪은 시행착오와 재사용 패턴을 에세이처럼 풀어낸 실습 노트."
author: "Admin"
published: true
---

## 첫 Playbook을 일상으로 끌어들이기

처음 Playbook을 열어 봤을 때 저는 빈 YAML 파일 앞에서 깊은 한숨부터 쉬었습니다. “이 많은 설정을 정말 사람이 읽을 수 있는 문장으로 묶을 수 있을까?”라는 걱정이 먼저 올라왔죠. 그래도 마음을 다잡고 한 줄씩 적어 보니, 마치 일기 쓰듯 내 환경을 서술하는 기분이 들었습니다. 혹시 여러분도 비슷한 막막함을 느끼고 있다면, 제가 손으로 더듬어 찾은 길을 따라와 보세요.

### 가장 먼저 끄적여 본 작은 Playbook

저는 서버의 패키지를 최신 상태로 맞추고 Nginx를 설치하는 아주 단순한 목표부터 세웠습니다. 아래는 그날 저녁에 완성한 첫 Playbook입니다. `hosts`와 `become`을 자연스럽게 적어 넣고, task 이름을 문장처럼 적어 두니 읽을 때 마음이 훨씬 편해지더군요.

```yaml
---
- name: keep web nodes tidy
  hosts: webservers
  become: true

  tasks:
    - name: update package cache
      dnf:
        update_cache: true

    - name: install nginx from official repo
      dnf:
        name: nginx
        state: present

    - name: ensure nginx is running
      service:
        name: nginx
        state: started
        enabled: true
```

Playbook을 저장하고 나니 “혹시 포트 충돌은 없을까? 서비스는 제대로 떴을까?” 하는 의문이 들었습니다. 그래서 저는 `ansible-playbook site.yml --check`로 먼저 건조 실행을 돌려 보고, 문제가 없다는 확신이 들 때 실제 실행을 진행했습니다. 예상대로 모든 task가 초록색으로 물들어 가는 모습을 보니 “정말 간단하죠?”라는 말이 절로 나왔습니다.

### 핸들러와 notify가 준 두 번째 도약

반복 실행을 하다 보면 “변경이 있을 때만 서비스 재시작을 하고 싶다”는 욕심이 생깁니다. 저는 핸들러를 활용해 이 문제를 풀었습니다. 아래처럼 템플릿을 적용한 뒤 서비스 재시작을 요청하고, 핸들러가 마지막에 한 번만 실행되도록 설계했습니다.

```yaml
- name: deploy nginx template
  hosts: webservers
  become: true

  tasks:
    - name: copy nginx config from template
      template:
        src: templates/nginx.conf.j2
        dest: /etc/nginx/nginx.conf
      notify: reload nginx gracefully

  handlers:
    - name: reload nginx gracefully
      service:
        name: nginx
        state: reloaded
```

핸들러를 쓰고 나니 “그동안 왜 매번 service task를 반복했을까?” 싶을 정도로 코드가 단정해졌습니다. 변경 사항이 없을 때는 조용히 넘어가고, 진짜 업데이트가 있을 때만 서비스가 살짝 재시작되는 모습이 꽤 든든했습니다.

### 조건과 루프는 이야기를 더 현명하게 만든다

서버 종류마다 조금씩 다른 패키지를 설치해야 할 때 저는 조건문과 루프를 적절히 섞었습니다. 짧은 예시지만, 환경에 따라 설치 패키지가 갈리는 상황을 자연스럽게 표현할 수 있습니다.

```yaml
- name: install runtime packages
  hosts: all
  become: true

  vars:
    common_packages:
      - git
      - curl
    web_only_packages:
      - nodejs

  tasks:
    - name: install common packages everywhere
      dnf:
        name: "{{ item }}"
        state: present
      loop: "{{ common_packages }}"

    - name: install web specific packages
      dnf:
        name: "{{ item }}"
        state: present
      loop: "{{ web_only_packages }}"
      when: "'webservers' in group_names"
```

조건문이 단순한 문자열 비교라도, 저는 꼭 주석이나 설명을 덧붙였습니다. 그래야 다음에 Playbook을 열어볼 제 자신이 “아, web 그룹에만 nodejs가 필요한 이유가 있었지”라고 자연스럽게 추억을 떠올릴 수 있거든요.

### 템플릿으로 문장의 숨결을 불어넣다

Playbook을 쓰다 보면 결국 Jinja2 템플릿을 만나게 됩니다. 저는 기본 설정 파일에 환경별 값을 녹여 넣고 싶어서 아래처럼 변수를 주입했습니다. 템플릿 안에서도 구어체로 주석을 남겨 두면, 나중에 파일을 열어보는 사람이 미소를 짓게 됩니다.

```jinja
# templates/nginx.conf.j2
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

events {
  worker_connections 1024;
}

http {
  server {
    listen {{ nginx_port | default(80) }} default_server;
    server_name {{ inventory_hostname }};

    location /healthz {
      return 200 'ok';
    }
  }
}
```

템플릿을 배포할 때는 반드시 `ansible-playbook --diff` 옵션을 켜 두었습니다. 변경 사항이 화면에 펼쳐지면 “이 정도 수정은 괜찮겠네”라는 확신을 갖고 버튼을 눌러 볼 수 있으니까요.

### 플레이 결과를 믿을 수 있게 만드는 체크 단계

마지막으로 저는 각 Playbook이 자신의 일을 제대로 끝냈는지 검증하는 task를 붙여 놓았습니다. 예를 들어 Nginx처럼 눈으로 바로 확인하기 어려운 서비스는 HTTP 요청을 보내 보거나, 상태 파일을 확인하는 명령을 추가했죠. 잘 작동하면 `debug` 모듈로 조용히 메시지만 출력하고, 실패하면 자연스럽게 알람이 울리게 했습니다. 덕분에 배포 후에 브라우저를 열어 URL을 직접 확인하는 번거로운 루틴에서 조금씩 벗어날 수 있었습니다.

### 마무리하며 다음 글을 예고하며

Playbook은 결국 “내가 어떤 상태를 원하고 있는가”를 일상의 언어로 적어 내려가는 작업이었습니다. 처음에는 기계적인 키워드의 나열처럼 보였지만, 반복해서 써 내려가다 보니 제 업무의 맥락과 우선순위가 자연스럽게 담기더군요. 다음 글에서는 이 Playbook들을 더 단단하게 만들어 준 Role 설계 이야기와 태그 전략을 나눌 예정입니다. 혹시 오늘도 빈 YAML 파일 앞에서 망설이고 있다면, 작게라도 하나의 task를 적어 보세요. 그 한 줄이 분명 다음 걸음을 이끌어 줄 겁니다.

```

### ansible-04-roles.md

**Path:** `frontend/public/posts/2025/ansible-04-roles.md`

```markdown
---
title: "Ansible Role 설계와 재사용성"
date: "2025-02-12"
category: "DevOps"
tags: ["DevOps","Ansible","Role","구조"]
excerpt: "Role 디렉터리를 생활 속 사례로 풀어내며 재사용성과 협업 패턴을 정리한 실습 에세이."
author: "Admin"
published: true
---

## Role이라는 집을 처음 지어 보면서

Playbook을 몇 편 쓰다 보면 자연스럽게 “이제는 구조를 정리해야겠다”는 생각이 듭니다. 저도 한동안 tasks 디렉터리에 모든 걸 우겨 넣다가, 결국 주말을 통째로 Role 설계에 투자했어요. 처음에는 설명서를 보며 기계적으로 따라 했지만, 지금 돌이켜보면 역할(Role)은 단순한 폴더 묶음이 아니라 팀이 합의한 생활 방식 그 자체였습니다.

### 뼈대를 세울 때 기억한 여섯 칸

처음 Role을 만들면서 저는 항상 아래 구조부터 떠올립니다.

```text
roles/
  webserver/
    tasks/
      main.yml
    handlers/
      main.yml
    templates/
    files/
    defaults/
      main.yml
    vars/
      main.yml
    meta/
      main.yml
```

`tasks`는 오늘 할 일 목록, `handlers`는 변화가 생겼을 때 불러낼 비상 연락망, `templates`와 `files`는 우리가 미리 준비한 선물 보따리, `defaults`와 `vars`는 서로 약속한 기본값이었습니다. meta는 아직 낯설지만, 언젠가 다른 Role과 친구를 맺어야 할 때 꼭 필요하다는 사실을 금방 깨달았습니다.

### tasks/main.yml을 일기로 쓰듯 정리하다

저는 tasks의 첫 줄을 항상 role의 목적을 설명하는 문장으로 시작합니다. 아래 예시는 Nginx 기반 웹 서버 환경을 준비하는 데 필요한 작업을 순서대로 적어 둔 기록입니다.

```yaml
# roles/webserver/tasks/main.yml
---
- name: ensure prerequisite packages exist
  dnf:
    name: "{{ item }}"
    state: present
  loop:
    - python3-dnf
    - unzip

- name: configure nginx and php-fpm
  include_tasks: web.yml

- name: register systemd overrides
  include_tasks: systemd.yml
  when: webserver_enable_override
```

핵심 작업을 분리하고 싶을 때는 `include_tasks`를 써서 작은 파일로 쪼갰습니다. 덕분에 나중에 구조를 읽어 보는 팀원이 “아, 여기서 웹 설정이 시작되는구나” 하고 쉽게 맥락을 잡을 수 있죠.

### defaults와 vars의 미묘한 선 긋기

Role을 공유하다 보면 “기본값인데 변경 가능해야 하는 값”과 “거의 고정이라 손대면 위험한 값” 사이에 선을 그어야 합니다. 저는 가능한 값들을 `defaults/main.yml`에 담고, 절대 바뀌면 안 되는 값은 `vars/main.yml`로 올려 둡니다.

```yaml
# roles/webserver/defaults/main.yml
webserver_nginx_port: 80
webserver_enable_override: false
webserver_ssl_enabled: false

# roles/webserver/vars/main.yml
webserver_log_dir: /var/log/nginx
webserver_user: www-data
```

이렇게 나눠 두니 배포 환경마다 포트나 SSL 설정을 덮어써도 core 값은 안정적으로 유지됩니다. 팀 내부에서는 “defaults는 사용자 취향, vars는 팀이 지켜야 할 규칙”이라고 설명하곤 합니다.

### handlers는 잔잔한 알람으로 남겨두기

Role이 커질수록 핸들러가 난무하기 쉽죠. 저는 꼭 필요한 메시지만 남기고, 출력 문구도 사람 말투로 적어 두었습니다.

```yaml
# roles/webserver/handlers/main.yml
- name: restart nginx politely
  service:
    name: nginx
    state: restarted

- name: reload php-fpm gracefully
  service:
    name: php8.2-fpm
    state: reloaded
```

핸들러 이름에 “politely”, “gracefully” 같은 표현을 넣어 두면, 로그를 읽을 때도 기분이 조금 나아집니다. 무엇보다 “재시작이 꼭 필요한 순간인가?”를 task 단계에서 더 깊게 고민하게 되죠.

### meta/main.yml로 의존 관계를 솔직하게 드러내기

Role을 미리 준비해 두면 다른 팀이 그대로 가져다 쓰기도 합니다. 그럴 때 meta 파일에 의존성을 명확히 적어 두면 덜 헤매게 됩니다.

```yaml
# roles/webserver/meta/main.yml
---
dependencies:
  - role: common
    vars:
      common_state: hardened
  - role: security
    tags:
      - baseline
```

`dependencies`에 태그를 걸어 두면 상위 Playbook에서 `--tags baseline`처럼 선택적으로 실행할 수 있어서 훨씬 유연해집니다. “이 Role을 쓰려면 먼저 common을 읽어야 해요”라는 메시지가 자연스럽게 전달되죠.

### 태그 전략으로 협업의 언어를 맞추기

Role이 늘어나면 `--tags`와 `--skip-tags`가 사실상 협업의 약속이 됩니다. 저는 팀 회의 때 “운영팀은 `security`, 애플리케이션팀은 `deploy` 태그를 중심으로 본다”는 합의를 만들었고, Role 안에서도 태그 이름을 일관되게 쓰려 노력했습니다.

```yaml
- name: copy hardened nginx config
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
  notify: restart nginx politely
  tags:
    - config
    - security

- name: deploy default landing page
  template:
    src: index.html.j2
    dest: /var/www/html/index.html
  tags:
    - deploy
```

태그가 읽는 사람에게 이야기처럼 다가갈수록, 서로의 작업 범위도 명확해졌습니다.

### collections와 galaxy에 대한 작은 다짐

Role을 정리하다 보면 언젠가 galaxy에 공개하고 싶다는 마음이 슬쩍 들죠. 저는 아직 용기를 내지는 못했지만, `collections/requirements.yml`을 작성해 두고 다른 Role을 불러오는 연습을 조금씩 하고 있습니다. 이렇게 준비해 두면 언젠가 외부 배포를 할 때도 훨씬 수월할 거라 믿어요.

### 다음 단계로 이어지는 마음가짐

Role은 재사용을 위한 기술이지만, 결국 팀의 목소리를 정리하는 작업이었습니다. 오늘 기록한 구조와 패턴이 여러분의 플레이라이트를 조금 더 단단하게 만들어 주길 바랍니다. 다음에는 이 Role들을 이용해 여러 환경을 동시에 배포하는 전략과, 테스트 자동화를 곁들이는 방법을 공유해 보려 합니다. 혹시 지금 Role 디렉터리가 어지럽게 흩어져 있다면, 커피 한 잔 내리고 오늘 소개한 여섯 칸부터 천천히 다시 배치해 보세요. 생각보다 금방 공간이 정돈될 거예요.

```

### arpanet-resilience-journal.md

**Path:** `frontend/public/posts/2025/arpanet-resilience-journal.md`

```markdown
---
title: "스푸트니크의 그림자 아래, 내가 본 ARPANET의 첫 호흡"
date: "2025-10-18"
category: "Network"
tags: ['ARPANET', '패킷교환', '인터넷역사', 'ColdWar', '네트워크아키텍처']
excerpt: "냉전의 긴장 속에서 태어난 ARPANET을 따라가며, 패킷 교환과 IMP가 가져온 혁신을 밤새 되짚은 나의 기록"
readTime: "10분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

![nuclear](../../images/2025/nuclear.png)
    

나는 오늘도 국방 문서의 낡은 냄새가 밴 자료실에서 하루를 시작했다. 첫 장을 넘기자마자 다시금 1957년의 스푸트니크가 내 머릿속에서 떠오른다. 소련이 그 작은 금속 덩어리를 하늘에 올려놓던 순간, 미국의 과학자들은 전율했고, 드와이트 아이젠하워는 ARPA라는 새로운 기관을 세웠다. 그날 이후 고등연구계획국의 이야기 속에는 언제나 핵 공격과 통신 두절을 견뎌야 한다는 공포가 숨어 있었다. 나는 그 공포가 어떻게 창의성이 되는지, 냉전의 긴장과 연구실의 자유가 어떻게 한 몸처럼 움직였는지를 바라보며 하루를 보낸다.

J.C.R. 리클라이더의 메모를 읽을 때면, 그의 필압 속에서 “탈중앙화”라는 단어가 살아 움직이는 것 같다. RAND 연구소의 폴 바란이 그려낸 메시 블록 다이어그램도, 영국 국립물리연구소에서 도널드 데이비스가 남긴 패킷 스케치를 들춰볼 때도, 나는 세상 반대편에서 동시에 같은 답에 닿은 두 연구자의 숨을 느낀다. 회선 교환으로는 폭발적으로 튀어 오르는 데이터의 숨결을 담아낼 수 없다는 절실함, 하나의 링크가 끊겨도 메시지가 살아남아야 한다는 믿음이 그들을 같은 방향으로 밀어붙였다. 지금 내 책상 위에는 회선 교환의 비효율을 정리한 전화국 보고서와 패킷 교환의 가능성을 속삭이는 RAND 메모가 나란히 놓여 있다. 이 대비는 마치 아날로그와 디지털이 교차하는 사진처럼 선명하다.

내가 UCLA의 아카이브를 찾아다니며 만난 가장 매혹적인 물건은 인터페이스 메시지 프로세서, IMP의 회로도였다. 웨슬리 클라크가 호스트의 복잡한 네트워크 처리 부담을 떼어내자고 주장한 순간, 연구자들의 표정이 얼마나 환해졌을지 상상해 본다. 허니웰 DDP-516을 개조한 그 작은 박스는 자신이 군용 하드웨어라는 사실을 잊은 듯 정교하고 친절했다. 호스트들은 BBN 보고서 1822에 따라 IMP와만 대화하면 되었고, 네트워크 내부의 혼잡함은 이 무명의 장치가 묵묵히 감당했다. 내가 그 설계도를 들여다볼 때마다 들리는 소리는 기계음이 아니라 연구자들의 안도의 웃음이다. 이웃 연구소와 직접 프로토콜을 맞추느라 고생하던 시간 대신, 그들은 이제 자신이 구현하고 싶은 서비스에 집중할 수 있었다.

1969년 가을, UCLA에서 SRI로 보내려다 실패한 “LOGIN”의 첫 시도는 아직도 내 마음을 두근거리게 한다. “LO”만 남기고 멈춘 그 사건은 실패라기보다 탄생의 신호탄이었다. 나는 그날의 로그를 복사해 와서 가끔씩 노트북 배경화면으로 띄워 두곤 한다. 분산된 네트워크가 실제로 숨을 쉬기 시작한 순간, 내 앞에는 더 이상 망상이나 파일럿 프로젝트가 아니라, 살아 있는 초석이 놓였다. 같은 해 말쯤 되니 UCLA, SRI, UC 샌타바버라, 유타 대학교를 잇는 네 개의 IMP가 서로 패킷을 주고받고 있었다. 나는 그 지도를 보며 지도에 실선이 하나 더 늘어날 때마다 심장이 같이 박동하는 걸 느꼈다.

그러나 나는 NCP 로그를 넘길 때마다 늘 아쉬움을 기록한다. 초기의 네트워크 제어 프로그램은 ARPANET 안에서는 찬란하게 빛났지만, 다른 네트워크와 손을 맞잡을 상상은 하지 못했다. 짝수 포트와 홀수 포트를 나눠 양방향 연결을 맞추던 그 치밀함은 감탄스럽지만, 동시에 인터넷워킹이라는 오늘의 관점에서 보면 너무나 닫혀 있었다. 내가 당시 연구자였다면 그 한계를 더 일찍 깨닫고, 위성 네트워크나 무선 네트워크로 시선을 돌릴 수 있었을까. 나는 노트북 앞에서 혼자 중얼거린다. “그때 내가 거기 있었다면, 패킷이 다른 바다를 건너도록 상상했을까?”

퇴근길에 나는 잠시 UCLA 캠퍼스 근처의 오래된 카페에 들렀다. 당시 대학원생들이 커피를 들고 IMP 옆을 서성이던 흑백 사진이 벽에 걸려 있었다. 사진 속 인물들은 1960년대의 두려움 속에서도 분명히 미소를 짓고 있었다. 하나의 링크가 끊겨도 메시지가 살아남는 네트워크, 특정 지휘부가 사라져도 정보를 지킬 수 있는 구조가 처음 호흡하던 순간을 생각하니, 오늘 내가 쓰고 있는 인터넷 연결도 조금 다른 감정으로 다가온다. 그들의 불안과 꿈이 내 일상을 관통해 흐르고 있다는 사실이 새삼 감사하게 느껴진다.

그래서 나는 이 시대를 단순히 기술의 기원으로만 기억하지 않는다. ARPANET은 냉전이라는 그림자 속에서, 분산과 추상화라는 개념을 현실로 만든 고집스러운 실험이었다. 패킷 교환을 향한 두 연구자의 직감, IMP라는 추상화 계층의 탄생, 그리고 NCP가 보여 준 한계까지 모두가 오늘의 인터넷에 이르는 첫 장을 채웠다. 나는 이 장을 덮으며, 과거의 과학자들이 밤새 그렸던 회로도처럼 내 노트에 작은 메모를 남긴다. “생존성을 향한 갈망이 결국 연결성을 낳았다.” 이 문장을 읽을 때마다, 나는 다시 ARPANET의 첫 호흡을 곁에서 바라보는 기분이 된다.

```

### broadband-cdn-transition-journal.md

**Path:** `frontend/public/posts/2025/broadband-cdn-transition-journal.md`

```markdown
---
title: "ADSL 불빛과 CDN 랙 사이에서 보낸 2000년대의 밤"
date: "2025-10-21"
category: "Network"
tags: ['광대역', 'CDN', '3G', 'NAT', 'TLS']
excerpt: "DSL 모뎀의 깜박임, 아카마이 캐시의 열기, 3G 기지국의 소음 속에서 상시 접속 시대를 맞이한 나의 기록"
readTime: "11분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

2001년 어느 겨울밤, 새벽 두 시를 넘긴 사무실 창가에서 나는 DSLAM 상태 표시등을 바라보며 커피를 홀짝였다. 초록색과 주황색이 번갈아 깜빡이는 그 리듬을 따라 심장이 같이 뛰는 듯했다. 전화선을 타고 흐르던 아날로그 신호가 점점 ADSL의 비대칭 주파수로 재편되고, 고객 전화를 받는 동료의 목소리에서 “항상 연결돼 있나요?”라는 질문이 사라지던 순간, 나는 상시 접속 시대가 진짜로 시작되었다고 느꼈다. 다이얼업 모뎀의 찢어지는 소리 대신, 분리된 주파수 대역을 타고 음성과 데이터가 공존하게 된다는 사실이 아직도 신기했다.

ADSL 장비 뒤편에서 케이블 모뎀 네트워크를 담당하던 친구와 어깨를 나란히 하고 있자면, 두 기술의 속도 경쟁이 마치 레이스처럼 느껴졌다. 우리는 각자의 커뮤니티 게시판에 들어가 속도 테스트 결과를 올리며 은근히 자랑하기도 했다. 동시에 나는 사용자들이 대용량 동영상을 내려받기 시작하며 원본 서버가 동시에 다운되는 장면을 수없이 목격했다. “속도가 빨라져도 멀리 있는 서버까지 가는 데는 여전히 시간이 걸리네.” 그렇게 탄생한 아이디어가 CDN이었다.

나는 MIT 출신의 동료에게 이끌려 아카마이 데이터센터를 처음 방문했다. 지구 곳곳을 향해 뻗어 있는 PoP 랙 사이에서 나는 공기가 다르게 흐른다는 사실을 느꼈다. 원본 서버에서 멀리 떨어진 도시에서도 영화 예고편이 끊김 없이 재생되도록, 캐시가 사용자 곁으로 다가가 있었다. DNS 응답을 통한 지능형 라우팅이 사용자와 가장 가까운 에지 서버를 선택하는 과정은 마치 택시 디스패처가 목적지를 기준으로 배차하는 모습을 연상시켰다. 우리는 정적 콘텐츠를 미리 퍼뜨리고, 갑작스럽게 몰리는 트래픽을 애니캐스트 경로 위에 흘려보내며 “월드 와이드 웨이트”를 줄여 나갔다.

그때쯤 내 휴대전화 속에도 변화가 찾아왔다. WAP 브라우저로는 도저히 만족할 수 없었던 나는 3G 테스트 단말기를 손에 쥐고 도심을 돌아다녔다. UMTS와 CDMA2000 기지국을 번갈아 체크하며 속도를 비교하던 날, 넓은 주파수 대역에서 전송되는 데이터 패킷이 초당 수백 킬로비트만 나와도 감격스러웠다. 초창기 스마트폰에서 이메일이 실시간으로 동기화되고, 버스에서 모바일 웹 페이지를 열람할 수 있다는 사실이 사람들의 일상을 서서히 바꿨다. 이동성은 더 이상 음성 통화의 전유물이 아니었다.

그러나 접속이 폭증하는 만큼 문제도 빠르게 따라왔다. 공인 IPv4 주소가 바닥을 드러내자, 우리는 NAT라는 임시방편에 기대기 시작했다. 한때 “종단 간 연결성을 위해 NAT을 최대한 피해야 한다”라고 외치던 나였지만, 현실에서는 사설 네트워크의 안전망이 되어 주는 NAT 라우터를 직접 설정하며 어쩔 수 없는 타협을 받아들였다. 동시에 SSL 2.0과 3.0의 취약점이 뉴스에 오르내릴 때, 전자상거래를 운영하던 고객의 눈빛은 공포로 흔들렸다. 나는 TLS 1.0을 테스트하고, 더 안전한 암호 스위트를 골라 서버에 배치하면서 “암호화는 더 이상 선택이 아니다”라는 메모를 붙여 두었다.

사무실 한 켠에는 초창기 브로드밴드 고객들을 위한 설치 키트가 산더미처럼 쌓여 있었다. 동료와 나는 가끔 그 박스를 열어 필터와 케이블을 꺼내 손에 쥐고 “우리가 지금 일상을 바꾸는 도구를 들고 있구나”라고 말하곤 했다. ADSL과 케이블 모뎀이 연결 시간을 분 단위에서 초 단위로 줄여 주자, 사람들은 자연스럽게 온라인 음악, 스트리밍, 온라인 게임을 찾았다. 우리가 CDN을 구축하고 NAT 장비를 세팅하고 TLS를 적용하는 동안, 인터넷은 천천히 생활 그 자체가 되었다.

돌이켜 보면 2000년대는 인터넷이 ‘접속하는 곳’에서 ‘항상 켜져 있는 공간’으로 전환되던 시기였다. 나는 그 변곡점에 서서 수많은 모뎀의 점멸을 지켜봤고, 캐시 서버의 온도를 확인했고, 휴대용 3G 단말기를 손에 쥐고 거리를 걸었다. 밤늦게 사무실 불을 끈 뒤에도 귀에는 여전히 DSLAM의 팬 소리가 맴돌았다. 그때 들었던 소리는 단순한 기계음이 아니라, 연결이 우리의 생활 리듬으로 자리잡아 가는 박자였다. 그 박자를 기억하기 위해 나는 오늘도 오래된 모뎀을 서랍 속에 보관하고 있다.

```

### ci-trigger-test.md

**Path:** `frontend/public/posts/2025/ci-trigger-test.md`

```markdown
---
title: "CI Trigger Test"
date: "2025-10-17"
category: "Maintenance"
tags: ["ci", "workflow"]
published: false
excerpt: "Non-visible post to exercise CI path filters."
---

This is a small hidden post used only to verify that GitHub Actions triggers on changes under `frontend/public/posts/**/*.md`. It should not appear publicly if the client filters on `published: false`.

```

### devops-toolchain-overview.md

**Path:** `frontend/public/posts/2025/devops-toolchain-overview.md`

```markdown
---
title: "DevOps 시리즈 개요: Terraform · Ansible · Kafka · Kubernetes"
date: "2025-01-08"
category: "DevOps"
tags: ["DevOps","Terraform","Ansible","Kafka","Kubernetes","Series"]
excerpt: "DevOps 시리즈 전체 구조와 학습 로드맵을 한눈에 정리한 개요 글."
author: "Admin"
published: true
---
# DevOps 도구 실습 가이드 개요

아래 시리즈는 Terraform, Ansible, Kafka, Kubernetes 핵심 개념과 실습을 통해 현대적인 DevOps 파이프라인을 이해하는 것을 목표로 합니다. 원문 학습 로드맵을 그대로 포함하여 한눈에 학습 순서를 파악할 수 있도록 구성했습니다.

## 학습 목차

### 1. Terraform - 인프라스트럭처 as Code

- 기초 설정 및 첫 리소스 생성
- AWS EC2 실습 예제
- 상태 관리와 모듈화 (예정)
- 변수와 출력 (예정)

### 2. Ansible - 자동화 및 설정 관리

- 설치 및 초기 설정
- Inventory 작성 방법 (예정)
- Playbook 작성 실습 (예정)
- Role과 재사용성 (예정)

### 3. Kafka - 분산 이벤트 스트리밍

- 개념 및 아키텍처
- 로컬 설치 및 실행
- Producer/Consumer 실습 (예정)
- 토픽과 파티션 관리 (예정)

### 4. Kubernetes - 컨테이너 오케스트레이션

- 클러스터 설정 (minikube)
- Pod와 Deployment
- Service와 네트워킹 (예정)
- ConfigMap과 Secret (예정)
- StatefulSet과 영구 스토리지 (예정)

### 5. 통합 시나리오

- 전체 DevOps 파이프라인 구성
- Terraform으로 K8s 클러스터 프로비저닝 (예정)
- Kubernetes에서 Kafka 운영 (예정)
- 마이크로서비스 배포 시나리오 (예정)

## 학습 순서 추천

### 초급: 개별 도구 이해

1. Terraform 기본 → AWS 리소스 생성 실습
2. Kubernetes 기본 → Pod, Deployment 실습
3. Ansible 기본 → 간단한 Ad-hoc 명령 실행

### 중급: 도구 조합

1. Terraform + Kubernetes 통합 (예정)
2. Ansible로 서버 설정 자동화 (예정)
3. Kubernetes에서 Kafka 배포 (예정)

### 고급: 전체 파이프라인

1. 이벤트 기반 마이크로서비스 아키텍처 (예정)
2. CI/CD 파이프라인 구축 (예정)
3. 프로덕션 환경 모니터링 / 로깅 (예정)

## 실습 환경 요구사항

### 필수 설치 도구

- Docker Desktop (최신 버전)
- kubectl (Kubernetes CLI)
- minikube 또는 kind (로컬 K8s 클러스터)
- Terraform CLI
- Ansible

### 선택적 클라우드 계정

- AWS Free Tier 계정 (권장)
- Azure 또는 GCP 계정 (대체 가능)

### 시스템 요구사항

- CPU: 4코어 이상
- RAM: 8GB 이상
- 디스크: 20GB 여유 공간

## 각 도구의 역할 요약

| 도구       | 역할                    | 주요 사용 시점                           |
| ---------- | ----------------------- | ---------------------------------------- |
| Terraform  | 인프라 프로비저닝       | 클라우드 리소스, 네트워크, 스토리지 생성 |
| Ansible    | 설정 관리 및 자동화     | 서버 패키지 설치, 환경 설정 배포         |
| Kubernetes | 컨테이너 오케스트레이션 | 애플리케이션 배포, 스케일링, 관리        |
| Kafka      | 이벤트 스트리밍         | 마이크로서비스 간 비동기 통신            |

## 학습 목표 달성 체크리스트

- [ ] 코드로 인프라스트럭처 정의 및 관리
- [ ] 서버 설정 자동화를 통한 일관성 확보
- [ ] 컨테이너 기반 애플리케이션 안정적 배포
- [ ] 이벤트 기반 확장 가능한 시스템 구성
- [ ] 네 가지 도구 조합으로 DevOps 파이프라인 구축

## 학습 방식 구조

1. **개념 설명** – 핵심 개념과 아키텍처
2. **실습 예제** – 직접 실행 가능한 코드
3. **패턴 분석** – 실무에 쓰이는 베스트 프랙티스
4. **트러블슈팅** – 자주 발생하는 문제와 해결 방법

---

시리즈는 계속 확장됩니다. 개선/추가 의견은 PR로 기여해주세요!

**시작하기**: [Terraform 기본 설정](terraform-01-basic-setup.md) 부터 진행하세요.

```

### dijkstra.md

**Path:** `frontend/public/posts/2025/dijkstra.md`

```markdown
---
title: "다익스트라 알고리즘 (Dijkstra's Algorithm)"
date: "2024-10-25"
category: "Algorithm"
tags: ['Dijkstra', '최단경로', '우선순위큐', '그래프']
excerpt: "다익스트라 알고리즘을 통해 가중 그래프에서의 최단 경로를 효율적으로 찾는 방법을 학습합니다."
readTime: "9분"
---

## 개요

**다익스트라 알고리즘(Dijkstra's Algorithm)**은 음이 아닌 가중치를 가진 그래프에서 한 정점으로부터 다른 모든 정점까지의 최단 경로를 찾는 알고리즘입니다.

### 핵심 특징
- **그리디 접근**: 현재까지 발견된 최단 거리를 기반으로 선택
- **음이 아닌 가중치**: 음수 가중치가 있으면 작동하지 않음
- **단일 출발점**: 하나의 시작점에서 모든 정점까지의 최단 거리
- **우선순위 큐 활용**: 효율적인 구현을 위해 힙 사용

### 시간 복잡도
- **기본 구현**: O(V²)
- **우선순위 큐 사용**: O((V + E) log V)
- **피보나치 힙 사용**: O(V log V + E)

## 기본 구현

### 1. 우선순위 큐를 사용한 구현

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <limits>
using namespace std;

const int INF = numeric_limits<int>::max();

class Dijkstra {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    struct State {
        int vertex, distance;
        State(int v, int d) : vertex(v), distance(d) {}
        
        bool operator>(const State& other) const {
            return distance > other.distance;
        }
    };
    
    vector<vector<Edge>> adj;
    int n;
    
public:
    Dijkstra(int vertices) : n(vertices) {
        adj.resize(n);
    }
    
    void addEdge(int from, int to, int weight) {
        adj[from].push_back(Edge(to, weight));
    }
    
    vector<int> shortestPath(int start) {
        vector<int> dist(n, INF);
        priority_queue<State, vector<State>, greater<State>> pq;
        
        dist[start] = 0;
        pq.push(State(start, 0));
        
        while (!pq.empty()) {
            State current = pq.top();
            pq.pop();
            
            int u = current.vertex;
            int d = current.distance;
            
            // 이미 처리된 정점이면 무시
            if (d > dist[u]) continue;
            
            // 인접한 모든 정점 확인
            for (const Edge& edge : adj[u]) {
                int v = edge.to;
                int weight = edge.weight;
                
                // 더 짧은 경로 발견시 갱신
                if (dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.push(State(v, dist[v]));
                }
            }
        }
        
        return dist;
    }
};
```

### 2. 경로 추적 기능 포함

```cpp
class DijkstraWithPath {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> adj;
    int n;
    
public:
    DijkstraWithPath(int vertices) : n(vertices) {
        adj.resize(n);
    }
    
    void addEdge(int from, int to, int weight) {
        adj[from].push_back(Edge(to, weight));
    }
    
    pair<vector<int>, vector<int>> shortestPathWithParent(int start) {
        vector<int> dist(n, INF);
        vector<int> parent(n, -1);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        dist[start] = 0;
        pq.push({0, start});
        
        while (!pq.empty()) {
            int d = pq.top().first;
            int u = pq.top().second;
            pq.pop();
            
            if (d > dist[u]) continue;
            
            for (const Edge& edge : adj[u]) {
                int v = edge.to;
                int weight = edge.weight;
                
                if (dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    parent[v] = u;
                    pq.push({dist[v], v});
                }
            }
        }
        
        return {dist, parent};
    }
    
    vector<int> reconstructPath(int start, int end, const vector<int>& parent) {
        vector<int> path;
        int current = end;
        
        while (current != -1) {
            path.push_back(current);
            current = parent[current];
        }
        
        reverse(path.begin(), path.end());
        
        // 경로가 존재하지 않는 경우
        if (path[0] != start) {
            return {};
        }
        
        return path;
    }
};
```

### 3. 인접 행렬 버전 (작은 그래프용)

```cpp
class DijkstraMatrix {
private:
    vector<vector<int>> graph;
    int n;
    
public:
    DijkstraMatrix(int vertices) : n(vertices) {
        graph.assign(n, vector<int>(n, INF));
        for (int i = 0; i < n; i++) {
            graph[i][i] = 0;
        }
    }
    
    void addEdge(int from, int to, int weight) {
        graph[from][to] = weight;
    }
    
    vector<int> shortestPath(int start) {
        vector<int> dist(n, INF);
        vector<bool> visited(n, false);
        
        dist[start] = 0;
        
        for (int count = 0; count < n - 1; count++) {
            // 방문하지 않은 정점 중 최소 거리 정점 찾기
            int u = -1;
            for (int v = 0; v < n; v++) {
                if (!visited[v] && (u == -1 || dist[v] < dist[u])) {
                    u = v;
                }
            }
            
            visited[u] = true;
            
            // 인접한 정점들의 거리 갱신
            for (int v = 0; v < n; v++) {
                if (!visited[v] && graph[u][v] != INF && 
                    dist[u] + graph[u][v] < dist[v]) {
                    dist[v] = dist[u] + graph[u][v];
                }
            }
        }
        
        return dist;
    }
};
```

## 응용 문제

### 1. K번째 최단 경로

```cpp
class KthShortestPath {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> adj;
    int n;
    
public:
    KthShortestPath(int vertices) : n(vertices) {
        adj.resize(n);
    }
    
    void addEdge(int from, int to, int weight) {
        adj[from].push_back(Edge(to, weight));
    }
    
    int findKthShortestPath(int start, int end, int k) {
        vector<priority_queue<int>> kShortest(n);  // 각 정점의 k개 최단 거리
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        pq.push({0, start});
        
        while (!pq.empty()) {
            int dist = pq.top().first;
            int u = pq.top().second;
            pq.pop();
            
            // k개보다 많으면 무시
            if (kShortest[u].size() >= k) continue;
            
            kShortest[u].push(dist);
            
            // 목표 정점에 k개 경로가 찾아졌으면 종료
            if (u == end && kShortest[u].size() == k) {
                vector<int> paths;
                while (!kShortest[u].empty()) {
                    paths.push_back(kShortest[u].top());
                    kShortest[u].pop();
                }
                reverse(paths.begin(), paths.end());
                return paths[k-1];
            }
            
            for (const Edge& edge : adj[u]) {
                int v = edge.to;
                int weight = edge.weight;
                
                if (kShortest[v].size() < k) {
                    pq.push({dist + weight, v});
                }
            }
        }
        
        return -1;  // k번째 경로가 존재하지 않음
    }
};
```

### 2. 조건부 최단 경로

```cpp
class ConditionalShortest {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> adj;
    vector<bool> isSpecial;  // 특별한 정점 표시
    int n;
    
public:
    ConditionalShortest(int vertices) : n(vertices) {
        adj.resize(n);
        isSpecial.resize(n, false);
    }
    
    void addEdge(int from, int to, int weight) {
        adj[from].push_back(Edge(to, weight));
    }
    
    void setSpecial(int vertex) {
        isSpecial[vertex] = true;
    }
    
    // 특별한 정점을 최소 하나 거쳐야 하는 최단 경로
    int shortestPathWithSpecial(int start, int end) {
        // 시작점에서 모든 정점까지의 최단 거리
        vector<int> distFromStart = dijkstra(start);
        
        // 끝점에서 모든 정점까지의 최단 거리 (역방향)
        vector<int> distToEnd = dijkstraReverse(end);
        
        int result = INF;
        
        // 모든 특별한 정점을 거치는 경로 중 최단 찾기
        for (int i = 0; i < n; i++) {
            if (isSpecial[i]) {
                if (distFromStart[i] != INF && distToEnd[i] != INF) {
                    result = min(result, distFromStart[i] + distToEnd[i]);
                }
            }
        }
        
        return result == INF ? -1 : result;
    }
    
private:
    vector<int> dijkstra(int start) {
        vector<int> dist(n, INF);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        dist[start] = 0;
        pq.push({0, start});
        
        while (!pq.empty()) {
            int d = pq.top().first;
            int u = pq.top().second;
            pq.pop();
            
            if (d > dist[u]) continue;
            
            for (const Edge& edge : adj[u]) {
                int v = edge.to;
                int weight = edge.weight;
                
                if (dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.push({dist[v], v});
                }
            }
        }
        
        return dist;
    }
    
    vector<int> dijkstraReverse(int end) {
        // 역방향 그래프 생성
        vector<vector<Edge>> radj(n);
        for (int u = 0; u < n; u++) {
            for (const Edge& edge : adj[u]) {
                radj[edge.to].push_back(Edge(u, edge.weight));
            }
        }
        
        vector<int> dist(n, INF);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        dist[end] = 0;
        pq.push({0, end});
        
        while (!pq.empty()) {
            int d = pq.top().first;
            int u = pq.top().second;
            pq.pop();
            
            if (d > dist[u]) continue;
            
            for (const Edge& edge : radj[u]) {
                int v = edge.to;
                int weight = edge.weight;
                
                if (dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.push({dist[v], v});
                }
            }
        }
        
        return dist;
    }
};
```

## 고급 응용

### 1. 다중 출발점 다익스트라

```cpp
class MultiSourceDijkstra {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> adj;
    int n;
    
public:
    MultiSourceDijkstra(int vertices) : n(vertices) {
        adj.resize(n);
    }
    
    void addEdge(int from, int to, int weight) {
        adj[from].push_back(Edge(to, weight));
    }
    
    vector<int> multiSourceShortest(const vector<int>& sources) {
        vector<int> dist(n, INF);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        // 모든 출발점을 0 거리로 초기화
        for (int source : sources) {
            dist[source] = 0;
            pq.push({0, source});
        }
        
        while (!pq.empty()) {
            int d = pq.top().first;
            int u = pq.top().second;
            pq.pop();
            
            if (d > dist[u]) continue;
            
            for (const Edge& edge : adj[u]) {
                int v = edge.to;
                int weight = edge.weight;
                
                if (dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.push({dist[v], v});
                }
            }
        }
        
        return dist;
    }
};
```

### 2. 시간 종속 다익스트라

```cpp
class TimeDependentDijkstra {
private:
    struct Edge {
        int to;
        vector<pair<int, int>> timeWeights;  // (시간, 가중치) 쌍
        Edge(int t) : to(t) {}
    };
    
    vector<vector<Edge>> adj;
    int n, maxTime;
    
    int getWeight(const Edge& edge, int time) {
        // 시간에 따른 가중치 계산
        for (int i = 0; i < edge.timeWeights.size(); i++) {
            if (time <= edge.timeWeights[i].first) {
                return edge.timeWeights[i].second;
            }
        }
        return edge.timeWeights.back().second;
    }
    
public:
    TimeDependentDijkstra(int vertices, int maxT) : n(vertices), maxTime(maxT) {
        adj.resize(n);
    }
    
    void addEdge(int from, int to, const vector<pair<int, int>>& timeWeights) {
        adj[from].push_back(Edge(to));
        adj[from].back().timeWeights = timeWeights;
    }
    
    vector<int> shortestPath(int start, int startTime) {
        vector<vector<int>> dist(n, vector<int>(maxTime + 1, INF));
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;
        
        dist[start][startTime] = 0;
        pq.push({0, start, startTime});
        
        while (!pq.empty()) {
            auto [d, u, time] = pq.top();
            pq.pop();
            
            if (d > dist[u][time]) continue;
            
            for (const Edge& edge : adj[u]) {
                int v = edge.to;
                int weight = getWeight(edge, time);
                int newTime = min(maxTime, time + weight);
                
                if (dist[u][time] + weight < dist[v][newTime]) {
                    dist[v][newTime] = dist[u][time] + weight;
                    pq.push({dist[v][newTime], v, newTime});
                }
            }
        }
        
        // 각 정점의 최소 거리 반환
        vector<int> result(n, INF);
        for (int v = 0; v < n; v++) {
            for (int t = 0; t <= maxTime; t++) {
                result[v] = min(result[v], dist[v][t]);
            }
        }
        
        return result;
    }
};
```

## 실전 문제 해결

### 백준 예제 문제들

#### 1. 최단경로 (1753)
```cpp
int main() {
    int V, E, K;
    cin >> V >> E >> K;
    
    Dijkstra dijkstra(V + 1);
    
    for (int i = 0; i < E; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        dijkstra.addEdge(u, v, w);
    }
    
    vector<int> dist = dijkstra.shortestPath(K);
    
    for (int i = 1; i <= V; i++) {
        if (dist[i] == INF) {
            cout << "INF\n";
        } else {
            cout << dist[i] << "\n";
        }
    }
    
    return 0;
}
```

#### 2. 특정한 최단 경로 (1504)
```cpp
int main() {
    int N, E;
    cin >> N >> E;
    
    Dijkstra dijkstra(N + 1);
    
    for (int i = 0; i < E; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        dijkstra.addEdge(a, b, c);
        dijkstra.addEdge(b, a, c);  // 양방향
    }
    
    int v1, v2;
    cin >> v1 >> v2;
    
    // 1 -> v1 -> v2 -> N 경로
    vector<int> dist1 = dijkstra.shortestPath(1);
    vector<int> distV1 = dijkstra.shortestPath(v1);
    vector<int> distV2 = dijkstra.shortestPath(v2);
    
    int path1 = dist1[v1] + distV1[v2] + distV2[N];
    int path2 = dist1[v2] + distV2[v1] + distV1[N];
    
    int result = min(path1, path2);
    
    if (result >= INF) {
        cout << -1 << endl;
    } else {
        cout << result << endl;
    }
    
    return 0;
}
```

## 주의사항과 팁

### 1. 음수 가중치 처리
- 다익스트라는 음수 가중치를 처리할 수 없음
- 음수 가중치가 있다면 벨만-포드 알고리즘 사용

### 2. 우선순위 큐 최적화
```cpp
// 중복 상태 제거를 위한 체크
if (d > dist[u]) continue;

// pair 사용시 첫 번째 원소가 우선순위
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
```

### 3. 메모리 최적화
```cpp
// 큰 그래프에서는 인접 리스트 사용
// 필요시 압축된 표현 사용
struct CompressedEdge {
    int to : 20;     // 정점 번호 (최대 1M)
    int weight : 12; // 가중치 (최대 4K)
};
```

## 연관 알고리즘
- **[BFS (너비 우선 탐색)](/post/algorithms/bfs)**: 가중치가 1인 경우
- **[벨만-포드](/post/algorithms/bellman-ford)**: 음수 가중치 처리
- **[플로이드-워셜](/post/algorithms/floyd-warshall)**: 모든 쌍 최단 경로

## 마무리

다익스트라 알고리즘은 가중치가 있는 그래프에서의 최단 경로 문제를 효율적으로 해결하는 핵심 알고리즘입니다. 우선순위 큐를 활용한 구현을 숙지하고, 다양한 변형 문제에 응용할 수 있도록 연습하세요.

**학습 순서**: 기본 다익스트라 → 경로 추적 → 조건부 최단경로 → 고급 응용
```

### future-tech-six-insights.md

**Path:** `frontend/public/posts/2025/future-tech-six-insights.md`

```markdown
---
title: "제가 뇌를 리셋하게 만든 미래 기술 문서에서 발견한 6가지 깨달음"
date: "2025-11-04"
category: "Tech Essay"
tags: ["AI", "DevOps", "Future", "Infrastructure", "Self-Evolving Systems"]
excerpt: "미래 기술 문서들 속에서 발견한 6가지 통찰과 인간 역할의 재정의를 공유합니다."
coverImage: "/images/2025/future-map.jpg"
defaultLanguage: "ko"
availableLanguages: ["en"]
translations:
  en:
    title: "Six Future-Tech Insights That Reset My Brain"
    description: "Six paradigm-shifting lessons distilled from forward-looking technical documents about AI, DevOps, and self-evolving systems."
    excerpt: "Exploring how emerging documents reveal AI architects, zero-ops infrastructure, living systems, self-updating documentation, outbound-only security, and data-as-access."
    content: |-
      ## Six Future-Tech Insights That Reset My Brain
      
      ## Prologue: Drawing Insight from a Flood of Ideas
      
      Over the past few weeks I was immersed in a sea of product requirement documents, system architecture blueprints, and master plans. At first they seemed like unrelated fragments, but suddenly the dots connected into a constellation. It felt as if a secret map to the future had been hidden in plain sight. Patterns emerging from those documents pointed far beyond individual projects—they revealed the trajectory that technology itself is taking. The six insights below are the landmarks I traced from that map, the ones powerful enough to reboot my thinking.
      
      ## 1. AI Graduates from Tool to Architect
      
      We used to treat AI like a bright assistant that suggests a few lines of code. The documents I read describe a radically different future. In "Project TONE", if a user simply asks for "a Python real-time chat app", an AI agent assembles the entire Kubernetes and Istio deployment stack automatically. "Meta-Platform" goes even further: want to run a storefront? The AI builds the full stack—from frontend to database to deployment—through conversation alone. "CodeHeal.ai" scans existing codebases, finds hardcoded IPs or misconfigurations, and self-heals by generating correct config files and patches.
      
      The common theme is the shift from syntax to semantics. We are leaving the era of telling machines how to do something, and entering the era of just describing what we want. AI becomes a partner that translates intent into reality. Developers evolve from builders into directors and visionaries who choreograph systems with intent.
      
      ## 2. DevOps Ends When DevOps Disappears
      
      The irony is clear: we invest in DevOps to make DevOps obsolete. "Project TONE" imagines a self-driving cloud platform. "Meta-Platform" targets a zero-ops pipeline. Their goal is for developers to stop thinking about servers, CI/CD, or networking. This is not DevOps failing—it is DevOps achieving its final form. Mature infrastructure becomes invisible, like the power grid when you flick a light switch. The pinnacle of DevOps is its own disappearance.
      
      ## 3. Systems That Breathe, Learn, and Evolve
      
      Systems are no longer static deployments. They are living entities that optimize themselves and grow new capabilities. A JAMstack blog architecture outlined a "Living Archive" that regularly converts dynamic data into static assets and redeploys itself, making the site faster over time. "Auto-Doc AI" goes further: when a user requests a capability it lacks, the agent analyzes requirements, picks libraries, generates code, tests it in a sandbox, and fuses it into production. A network report for the AGI era paints the end-state: data flows like a living organism through a vast ecosystem, always seeking the optimal state.
      
      ## 4. Code and Documentation Finally Merge
      
      "Is this doc up to date?" haunts every team. The "AI Pair Programmer" concept slays that demon. Whenever a function signature changes, an AI agent instantly updates the docstrings and Javadocs. The drudgery of documentation drift just disappears. Productivity, onboarding, and maintainability all skyrocket. In this future, documentation is not a chore; it is a synchronized extension of the code itself.
      
      ## 5. The Safest Wall Has No Door
      
      Traditional security pokes inbound holes in firewalls so legitimate traffic can get in. The "Development Environment Sharing" report flips this model with outbound-only tunnels such as Cloudflare Tunnel. Picture keeping your door locked while your home links to the delivery locker outside through a secure chute. Couriers can drop off packages but never touch your door. Internal systems initiate the connection to a trusted relay, and every request flows through that pre-established tunnel. The firewall exposes no inbound ports. Security turns inside-out.
      
      ## 6. From Owning Data to Accessing Data Streams
      
      The "Network in the AGI Era" report adds a philosophical twist. Centralized clouds run into a gravity problem: latency, cost, and inefficiency balloon as data piles up. The proposed future is a decentralized mesh where data flows intelligently, orchestrated by AGI. Data is no longer boxed up in a warehouse; it becomes a living current that we tap into on demand. We stop "owning" data and instead connect securely to the streams we need, when we need them.
      
      ## Closing: When Machines Handle Implementation, What Do We Do?
      
      Across every document runs a single motif: technology evolves from obedient tool to autonomous collaborator. Implementation, maintenance, documentation, and infrastructure become machine territory. That forces us to ask: if machines shoulder execution, what uniquely human work remains? The future will be defined less by the capabilities we build, and more by the problems we choose to imagine and the impact we dare to design.
---

# 제가 뇌를 리셋하게 만든 미래 기술 문서에서 발견한 6가지 깨달음

## 서론: 아이디어의 홍수 속에서 길어 올린 통찰

최근 몇 주간, 저는 PRD, 시스템 아키텍처 설계도, 마스터 플랜과 같은 수많은 기술 문서를 탐독했습니다. 처음에는 서로 다른 조각처럼 보였지만, 어느 순간 퍼즐이 맞춰지듯 거대한 별자리가 나타났습니다. 마치 누군가 미래로 가는 비밀 지도를 문서 곳곳에 숨겨둔 듯했죠. 그 지도를 따라가며 얻은 여섯 가지 깨달음은 제 사고를 완전히 리셋했습니다.

## 1. AI는 도구가 아니라 시스템을 설계하는 건축가다

우리는 AI를 코드 몇 줄을 제안해주는 조수 정도로 생각해왔습니다. 하지만 문서 속의 AI는 인간의 의도를 듣고 전체 시스템을 설계하고 구축하는 건축가였습니다. "Project TONE"은 "파이썬으로 만든 실시간 채팅 앱"이라는 말 한마디로 쿠버네티스와 이스티오 설정을 자동으로 완성합니다. "Meta-Platform"은 대화를 통해 풀스택 쇼핑몰을 만들어냅니다. "CodeHeal.ai"는 기존 코드의 설정 오류를 찾아내고, 올바른 설정 파일과 수정 패치를 제안하는 자가 치유형 에이전트를 구상하고 있었습니다.

공통점은 인간-컴퓨터 상호작용의 중심이 구문(Syntax)에서 의미(Semantics)로 이동한다는 점입니다. 우리는 더 이상 기계에게 "어떻게" 구현할지를 지시하지 않고, "무엇을" 원하는지를 설명합니다. AI는 구현의 도구가 아니라, 인간의 의도를 현실로 번역하는 파트너가 됩니다. 개발자의 역할도 구현가에서 비전을 제시하는 감독, 설계자로 재정의됩니다.

## 2. 데브옵스의 최종 목표는 데브옵스의 소멸이다

우리가 데브옵스에 집착하는 이유는 언젠가 인프라를 신경 쓰지 않아도 되는 미래를 만들기 위함입니다. "Project TONE"이 꿈꾸는 자율 주행 클라우드, "Meta-Platform"이 지향하는 제로 옵스 파이프라인은 같은 목표를 가리킵니다. 개발자는 서버와 네트워크, CI/CD를 잊고 비즈니스 로직에 집중하게 됩니다. 이것은 실패가 아니라 궁극적인 성공입니다. 전력망처럼 하루 종일 생각하지 않아도 되는 인프라, 그것이 데브옵스의 완성입니다.

## 3. 미래의 시스템은 살아 숨 쉬며 진화한다

배포된 뒤 멈춰 있는 시스템은 사라지고 있습니다. JAMstack 블로그의 "살아있는 아카이브" 전략은 오래된 데이터를 정적으로 변환하며 점점 빨라지는 사이트를 만들었습니다. "Auto-Doc AI"는 없는 기능을 요청받으면 필요 분석부터 라이브러리 선정, 코드 생성, 샌드박스 테스트, 통합까지 스스로 수행합니다. AGI 시대 네트워크 보고서는 데이터가 생태계처럼 스스로 최적 상태를 찾아 흐르는 미래를 보여줍니다.

## 4. 코드와 문서는 결국 하나가 된다

"이 문서 최신 맞아요?"라는 질문은 곧 과거형이 될지도 모릅니다. "AI 페어 프로그래머" 개념은 함수 시그니처가 바뀌는 순간 관련 문서와 주석을 즉시 업데이트합니다. 문서 동기화라는 고질적인 부담이 사라집니다. 팀 생산성, 온보딩, 유지보수 모두가 비약적으로 향상됩니다.

## 5. 가장 안전한 벽에는 문이 없다

우리는 그동안 외부 접근을 허용하기 위해 방화벽에 문을 열어두었습니다. 하지만 "개발 환경 공유" 보고서는 Cloudflare Tunnel 같은 아웃바운드 전용 터널을 제시합니다. 내부 시스템이 먼저 신뢰할 수 있는 외부 지점으로 안전한 연결을 만들고, 모든 요청은 그 터널을 통해서만 들어옵니다. 방화벽에는 어떤 문도 열릴 필요가 없습니다. 보안 패러다임이 안에서 밖으로 뒤집힙니다.

## 6. 데이터는 소유에서 접속으로 이동한다

"AGI 시대의 네트워크" 보고서는 데이터를 창고에 쌓아두는 대신, 지능적인 메쉬 네트워크 속에서 흐르는 존재로 봅니다. 중앙 집중식 클라우드가 만들어낸 데이터의 중력 문제—지연, 비용, 에너지—를 해소하기 위해서입니다. 우리는 데이터를 "소유"하는 대신, 필요할 때 안전하게 "접속"하는 시대로 이동하게 됩니다.

## 결론: 기계가 구현을 맡을 때 인간은 무엇을 해야 하는가

문서들을 관통한 흐름은 뚜렷했습니다. 기술은 명령을 수행하는 도구에서 자율적 파트너로 진화합니다. 구현, 유지보수, 문서화, 인프라 설계의 짐이 기계로 넘어갈 때, 인간은 무엇을 해야 할까요? 미래는 우리가 구축하는 기술의 능력이 아니라, 우리가 상상하고자 선택한 문제의 깊이와 가치에 의해 결정될 것입니다.

```

### git-submodule-guide.md

**Path:** `frontend/public/posts/2025/git-submodule-guide.md`

```markdown
---
title: "Git 서브모듈, 진짜 쓸 만한 걸까?"
date: "2024-12-25"
category: "개발"
tags: ['Git', '서브모듈', '버전관리', '개발도구', '프로젝트관리']
excerpt: "Git 서브모듈을 실제 프로젝트에서 써본 후기와 실용적인 사용법 정리"
readTime: "3분"
---

Git 서브모듈에 대해 찾아보면 항상 복잡한 설명들만 나온다. 실제로 써보니 생각보다 유용하기도 하고 골치 아프기도 했다. 실무에서 사용해본 경험을 바탕으로 정리해보려고 한다.

## 서브모듈이 뭐야?

간단히 말하면 **Git 저장소 안에 다른 Git 저장소를 넣는 방법**이다. 

예를 들어 내 웹사이트 프로젝트에서 UI 라이브러리를 서브모듈로 관리한다면:
- 메인 프로젝트: `my-website`
- 서브모듈: `ui-components` 

메인 프로젝트는 UI 라이브러리의 특정 버전(커밋)을 가리키고, 라이브러리가 업데이트되어도 메인 프로젝트는 영향받지 않는다.

## 언제 쓰면 좋을까?

### 쓰면 좋은 경우
1. **외부 라이브러리 관리**: 자주 바뀌지 않는 라이브러리들
2. **공통 컴포넌트**: 여러 프로젝트에서 공통으로 쓰는 코드  
3. **설정 파일**: DB 설정, 시크릿 키 같은 민감한 정보
4. **큰 프로젝트 모듈화**: 각 팀이 담당하는 모듈을 분리

### 안 쓰는 게 나은 경우
- 자주 바뀌는 내부 모듈
- 팀원들이 Git 초보인 경우 (진짜 복잡해진다)
- 간단한 프로젝트

## 기본 사용법

### 서브모듈 추가하기
```bash
# 서브모듈 추가
git submodule add https://github.com/username/ui-components.git components

# 특정 브랜치 추가
git submodule add -b develop https://github.com/username/ui-components.git components
```

이렇게 하면 `.gitmodules` 파일이 생긴다:
```
[submodule "components"]
    path = components
    url = https://github.com/username/ui-components.git
    branch = develop
```

### 서브모듈이 있는 프로젝트 클론하기
```bash
# 처음부터 서브모듈까지 한 번에
git clone --recurse-submodules https://github.com/myproject.git

# 이미 클론했다면
git submodule update --init --recursive
```

### 서브모듈 업데이트하기
```bash
# 서브모듈을 최신 버전으로 업데이트
git submodule update --remote

# 병합하면서 업데이트 (권장)
git submodule update --remote --merge
```

## 실전에서 만난 문제들

### 1. 분리된 HEAD 상태
서브모듈로 들어가서 `git status` 해보면 "HEAD detached" 라고 나온다. 이건 정상이다. 서브모듈은 특정 커밋을 가리키고 있어서 브랜치에 있지 않다.

서브모듈에서 수정 작업을 하려면:
```bash
cd components
git checkout main  # 브랜치로 이동
# 작업 후
git add .
git commit -m "수정사항"
git push

# 메인 프로젝트로 돌아가서
cd ..
git add components  # 서브모듈 업데이트를 스테이징
git commit -m "컴포넌트 업데이트"
```

### 2. 서브모듈이 비어있음
프로젝트를 클론했는데 서브모듈 폴더가 비어있다면:
```bash
git submodule update --init --recursive
```

이거 한 번이면 해결된다.

### 3. URL이 바뀌었을 때
서브모듈의 URL이 바뀌면:
```bash
git submodule sync
git submodule update --init --recursive
```

## 유용한 명령어들

### 모든 서브모듈 상태 확인
```bash
git submodule status
```

### 모든 서브모듈에서 같은 명령 실행
```bash
# 모든 서브모듈에서 상태 확인
git submodule foreach git status

# 모든 서브모듈을 main 브랜치로
git submodule foreach git checkout main
```

### 서브모듈 변경사항 자세히 보기
```bash
git diff --submodule=log
```

이 설정을 기본으로 만들려면:
```bash
git config diff.submodule log
```

## 서브모듈 vs 서브트리

비슷한 기능으로 Git 서브트리도 있다. 간략한 비교:

### 서브모듈
- **장점**: 명확한 버전 관리, 작은 저장소 크기
- **단점**: 사용법이 복잡, 팀원들이 헷갈림

### 서브트리  
- **장점**: 사용법 간단, 일반 폴더처럼 취급
- **단점**: 저장소 크기 커짐, 히스토리 복잡

개인적으로는 외부 라이브러리는 서브모듈, 내부 공통 코드는 서브트리를 선호한다.

## 실무 사용 팁

### 1. .gitmodules 파일 관리
이 파일이 서브모듈 설정의 핵심이다. 변경하면 바로 커밋해야 한다.

### 2. 팀 규칙 정하기
- 서브모듈 업데이트는 누가 언제 할 것인가?
- 서브모듈에서 직접 수정 금지할 것인가?
- 서브모듈 변경 시 팀에 어떻게 알릴 것인가?

### 3. CI/CD 설정
```bash
# CI에서 서브모듈까지 체크아웃
git submodule update --init --recursive
```

### 4. 푸시할 때 주의
```bash
# 서브모듈을 먼저 푸시했는지 확인
git push --recurse-submodules=check

# 서브모듈을 자동으로 푸시
git push --recurse-submodules=on-demand
```

## 서브모듈 제거하기

서브모듈이 필요 없어졌을 때:
```bash
# 최신 Git에서는 이거면 됨
git rm components
git commit -m "컴포넌트 서브모듈 제거"

# 완전히 정리하려면
rm -rf .git/modules/components
```

## 자주 하는 실수들

### 1. 서브모듈 수정 후 메인 프로젝트 커밋 깜빡
```bash
# 서브모듈에서 작업 후
cd components
git add .
git commit -m "컴포넌트 수정"
git push

# 이 부분을 깜빡하면 안 됨!
cd ..
git add components
git commit -m "컴포넌트 업데이트"
```

### 2. 서브모듈 변경사항을 pull 받지 않음
팀원이 서브모듈을 업데이트했는데 내가 pull만 하고 서브모듈은 업데이트 안 하는 경우:
```bash
git pull
git submodule update --recursive  # 이거 꼭 해야 함
```

### 3. 잘못된 브랜치에서 서브모듈 수정
서브모듈은 기본적으로 detached HEAD 상태라서 브랜치 체크아웃을 깜빡하기 쉽다.

## 실제 사용 사례

### 사례 1: UI 컴포넌트 라이브러리
```bash
# 메인 프로젝트 구조
my-website/
├── src/
├── components/          # 서브모듈
│   ├── Button/
│   ├── Modal/
│   └── ...
└── package.json
```

여러 프로젝트에서 공통 UI 컴포넌트를 사용할 때 유용했다. 컴포넌트가 업데이트되어도 각 프로젝트는 원하는 버전을 유지할 수 있다.

### 사례 2: 설정 파일 관리
```bash
# 프로덕션 설정을 별도 저장소로 관리
api-server/
├── src/
├── config/              # 서브모듈 (private repo)
│   ├── database.yml
│   ├── secrets.yml
│   └── ...
└── app.js
```

민감한 설정 파일을 private 저장소로 분리해서 관리했다. 개발자별로 접근 권한을 다르게 줄 수 있어서 좋았다.

## 대안들과의 비교

### npm/yarn 패키지 vs 서브모듈
- **패키지**: 버전 관리 쉬움, 의존성 해결 자동
- **서브모듈**: 소스코드 직접 수정 가능, 더 세밀한 제어

### Git 서브트리 vs 서브모듈
- **서브트리**: 사용법 간단, 히스토리 복잡
- **서브모듈**: 사용법 복잡, 히스토리 깔끔

### 모노레포 vs 서브모듈
- **모노레포**: 통합 관리 쉬움, 저장소 크기 큼
- **서브모듈**: 독립적 관리, 복잡한 워크플로우

## 마무리

서브모듈은 분명 유용하지만 복잡하다. 팀원들이 Git에 익숙하지 않다면 도입하기 전에 충분한 교육이 필요하다.

개인적으로는:
- 작은 프로젝트에서는 굳이 쓰지 않음
- 외부 라이브러리나 공통 컴포넌트 관리할 때 사용
- 자주 바뀌는 코드는 모노레포나 패키지 매니저 활용
- 민감한 설정 파일 분리할 때 유용

서브모듈을 쓰기로 했다면:
1. 팀 내에서 명확한 규칙을 정하고 문서화
2. 간단한 프로젝트에서 먼저 연습
3. CI/CD 파이프라인에 서브모듈 업데이트 포함
4. 정기적인 서브모듈 상태 점검

복잡해 보이지만 한 번 익숙해지면 프로젝트 구조를 깔끔하게 관리할 수 있는 좋은 도구다.
```

### grub-kernel-error-journal.md

**Path:** `frontend/public/posts/2025/grub-kernel-error-journal.md`

```markdown
---
title: "'You need to load the kernel first'와 함께한 새벽의 구조 요청"
date: "2025-10-25"
category: "Linux"
tags: ['Arch Linux', 'GRUB', '부팅오류', '시스템복구', '에세이']
excerpt: "pacman -Syu 한 번 눌렀을 뿐인데 부팅이 멈췄다면? 새벽에 겪은 GRUB 구출기를 일기처럼 정리했습니다."
readTime: "7분"
---

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/kernelfault.png" alt="kernel error">
</div>

밤새 코드 좀 더 정리해 보겠다고 pacman -Syu만 돌리고 잤던 날이었습니다. 그런데 아침에 전원을 켜자마자 모니터 중앙에 굵직한 문장 하나가 떠 있더군요. *"error: you need to load the kernel first"*. 머릿속으로는 이미 아침의 시작을 알리는 커피 향이 맴돌고 있었는데, GRUB은 딱 한 줄로 오늘 일정이 완전히 꼬여버렸음을 선언했습니다. 그 순간 떠오른 생각은 단 하나, "어제 왜 그냥 잤지?"였습니다.

### 업데이트가 남긴 빈 자리

Arch Linux의 매력은 최신 버전을 손바닥 뒤집듯 받아볼 수 있다는 데 있지만, 새벽에 실행한 업데이트는 의외의 함정을 숨기고 있었습니다. 커널과 initramfs는 갱신됐는데, GRUB 설정 파일인 grub.cfg를 새로 만들어주지 않은 채 잠들어 버린 거죠. 부트로더 입장에서는 새로운 커널의 위치를 알 길이 없으니, "커널 좀 먼저 알려 줘"라고 외칠 수밖에요. 사실 pacman이 끝났을 때 `grub-mkconfig -o /boot/grub/grub.cfg` 한 번만 쳤다면 모든 일이 허무하게 끝났을 텐데, 그 한 줄을 미뤘던 제 게으름이 다음날의 공포를 만들었습니다.

### 임시 처방이란 작은 희망

다행히도 GRUB은 완전히 닫힌 문이 아니었습니다. 화면에서 *c* 키를 눌러 커맨드라인 모드로 들어가 보니, 명령 프롬프트가 저를 기다리고 있더군요. 먼저 `ls`를 눌러 파티션들을 살폈습니다. (hd0,gpt1), (hd0,gpt2)… 하나하나 열어보니 (hd0,gpt2)/boot 안쪽에서 `vmlinuz-linux`와 `initramfs-linux.img`를 발견했습니다. 그 순간만큼은 보물찾기에서 지도를 찾은 느낌이었죠.

그래서 다음과 같이 주문을 외웠습니다.

```
set root=(hd0,gpt2)
linux /boot/vmlinuz-linux root=/dev/sda2
initrd /boot/initramfs-linux.img
boot
```

만약 인텔 CPU였다면 `initrd /boot/intel-ucode.img /boot/initramfs-linux.img`처럼 마이크로코드 이미지를 먼저 불러야 했겠지만, 제 노트북은 AMD였으니 다행히 한 단계를 덜어냈습니다. ENTER를 눌렀더니 파랗던 화면이 서서히 사라지고 익숙한 로그인 프롬프트가 떠오르던 순간, 새벽 감성이 아니라 순수한 안도의 한숨이 새어 나왔습니다. "일단 커피는 마셔도 되겠군."

### 다시는 겪고 싶지 않은 마음으로

임시 처방만으로는 불안해서, 로그인하자마자 터미널을 열었습니다. 그리고 이번엔 미뤘던 숙제를 제대로 했죠.

```
sudo grub-mkconfig -o /boot/grub/grub.cfg
```

커널 이미지가 제대로 존재하는지 확인한 뒤, 마음이 놓일 때까지 한 번 더 실행해 보기도 했습니다. 사실 여기서 끝났다면 좋았겠지만, 속으로는 "혹시나" 하는 찝찝함이 남아 있었죠. 그래서 외장 SSD에 담아두었던 Arch Live USB를 꺼내 놓고, 만약을 대비한 복구 시나리오까지 테스트했습니다.

### Live USB로 떠나는 두 번째 여정

만약 GRUB에서 수동 부팅이 실패했다면, Live USB야말로 확실한 구원 투수입니다. USB로 부팅한 뒤 `lsblk`로 파티션을 확인하고, 루트 파티션을 `/mnt`에, EFI 파티션을 `/mnt/boot` 혹은 `/mnt/boot/efi`에 마운트했습니다. 인터넷을 붙이고 나서 다음처럼 시스템 속으로 들어갔죠.

```
arch-chroot /mnt
```

그 안에서 `pacman -S linux`로 커널을 다시 설치하고, `mkinitcpio -P`로 initramfs 이미지를 새로 만들었습니다. 마지막으로 `grub-mkconfig -o /boot/grub/grub.cfg`를 실행했을 때, 로그에 뜨던 "Found linux image:" 문장이 그렇게 반가울 수가 없었습니다. EFI 시스템이라면 `grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB`까지 마무리하는 것도 잊지 않았습니다. 그렇게 모든 명령을 마친 뒤 `exit`, `umount -R /mnt`, `reboot` 순으로 나왔습니다. USB를 빼고 재부팅할 때, 그 작은 깜빡임이 얼마나 긴장을 주는지 다들 아시죠?

### 그리고 남은 이야기

부팅이 정상으로 돌아온 지금, 저는 다시 커피잔을 들고 자리로 돌아왔습니다. 이번 해프닝 덕분에 배운 건 두 가지입니다. 첫 번째, pacman -Syu 뒤에는 꼭 `grub-mkconfig`를 돌리는 습관을 들이자. 두 번째, AI가 제시한 딱딱한 조치 목록을 그대로 복사해서는 내 마음이 담긴 글이 되지 않는다는 것. 그러니 버튼 한 번으로 따뜻한 에세이를 뚝딱 만들어 주는 기능을 꼭 완성해 보고 싶습니다. 언젠가 누군가가 같은 오류를 만났을 때, 이 글이 건조한 가이드 대신 작은 위로가 되어 줄지도 모르니까요.

다음 아치 업데이트를 돌리기 전에는, 저는 아마 스스로에게 이렇게 말할 것 같습니다. "자, 커널과 GRUB이 서로 잊지 않도록 매번 확인하자고. 그리고 혹시 또다시 기록할 일이 생기면, 이번엔 버튼 한 번으로 에세이처럼 풀어내자." 그러면 새벽의 한 줄 경고도 언젠가 웃으며 떠올릴 추억이 되겠죠.

```

### hooks.md

**Path:** `frontend/public/posts/2025/hooks.md`

```markdown
---
title: 리액트 hooks 훑어보기
excerpt: >-
  # React Hooks 완벽 가이드


  ## 개요

  React의 Hooks는 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 기능입니다.
  React 16.8에서 처음 도입된 이 기능은 클래스형 컴포넌트를 사용하는 대신, 더 간결하고 이해하기 쉬운 코드를 작성할 수 있도록
  도와줍니다. 이번 글에서는 React ...
date: '2025-08-11'
publishTime: '2025-08-11 13:58:00'
category: 기술
tags: []
readTime: 3분
---
# React Hooks 완벽 가이드

## 개요
React의 Hooks는 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 기능입니다. React 16.8에서 처음 도입된 이 기능은 클래스형 컴포넌트를 사용하는 대신, 더 간결하고 이해하기 쉬운 코드를 작성할 수 있도록 도와줍니다. 이번 글에서는 React Hooks의 기본 개념과 사용법, 그리고 실제 개발에서 유용하게 활용할 수 있는 팁들을 알아보겠습니다.

## 주요 내용

### 1. 기본 Hooks
React에서 제공하는 기본 Hooks는 다음과 같습니다:

- `useState`: 컴포넌트의 상태를 관리합니다.
- `useEffect`: 컴포넌트의 생명주기를 관리합니다.
- `useContext`: Context API를 사용하여 전역 상태를 관리합니다.

#### 1.1 useState
`useState`는 상태 변수를 선언하고 업데이트할 수 있게 해줍니다.

```javascript
import React, { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <p>현재 카운트: {count}</p>
            <button onClick={() => setCount(count + 1)}>증가</button>
            <button onClick={() => setCount(count - 1)}>감소</button>
        </div>
    );
}
```
- **설명**: `useState`를 사용하여 `count`라는 상태 변수를 만들고, `setCount`를 통해 상태를 업데이트합니다. 버튼을 클릭할 때마다 상태가 변화합니다.

### 2. useEffect
`useEffect`는 컴포넌트가 렌더링될 때 수행해야 할 작업을 정의하는 데 사용됩니다. 주로 API 호출이나 구독과 같은 부수 효과를 다룰 때 유용합니다.

```javascript
import React, { useEffect, useState } from 'react';

function DataFetcher() {
    const [data, setData] = useState([]);

    useEffect(() => {
        fetch('https://jsonplaceholder.typicode.com/posts')
            .then(response => response.json())
            .then(data => setData(data));
    }, []); // 빈 배열을 전달하여 컴포넌트가 처음 렌더링될 때만 실행

    return (
        <ul>
            {data.map(item => (
                <li key={item.id}>{item.title}</li>
            ))}
        </ul>
    );
}
```
- **설명**: 컴포넌트가 처음 렌더링될 때 API를 호출하여 데이터를 가져옵니다. 데이터가 업데이트되면 자동으로 리렌더링됩니다.

### 주의사항 및 베스트 프랙티스
- Hooks는 컴포넌트의 최상위 레벨에서만 호출해야 합니다. 조건문이나 반복문 안에서 호출하면 안 됩니다.
- 여러 개의 상태를 관리할 때는 `useReducer`를 고려해볼 수 있습니다. 단순한 상태 관리에는 `useState`, 복잡한 상태 관리에는 `useReducer`가 더 적합합니다.

### 실무 팁
- Hooks를 사용할 때는 상태와 효과를 독립적으로 분리하여 관리하는 것이 좋습니다.
- Custom Hooks를 만들어 자주 사용하는 로직을 재사용할 수 있습니다.

## 실제 예제

### 1. 간단한 Todo List
```javascript
import React, { useState } from 'react';

function TodoApp() {
    const [todos, setTodos] = useState([]);
    const [inputValue, setInputValue] = useState('');

    const addTodo = () => {
        if (inputValue.trim()) {
            setTodos([...todos, inputValue]);
            setInputValue('');
        }
    };

    return (
        <div>
            <input 
                type="text" 
                value={inputValue} 
                onChange={(e) => setInputValue(e.target.value)} 
                placeholder="할 일을 입력하세요" 
            />
            <button onClick={addTodo}>추가</button>
            <ul>
                {todos.map((todo, index) => <li key={index}>{todo}</li>)}
            </ul>
        </div>
    );
}
```

### 결과 확인 방법
- 위 코드를 실행하면 할 일을 추가할 수 있는 간단한 Todo List 애플리케이션이 생성됩니다. 입력 필드에 텍스트를 입력하고 "추가" 버튼을 클릭하면 리스트에 추가됩니다.

## 트러블슈팅

### 자주 발생하는 문제
- **Hooks 호출 순서 문제**: 컴포넌트가 리렌더링될 때 Hooks의 호출 순서가 바뀌면 오류가 발생합니다. 항상 최상위 레벨에서 호출해야 합니다.
- **의존성 배열 문제**: `useEffect`의 의존성 배열을 올바르게 설정하지 않으면 무한 루프가 발생할 수 있습니다. 필요한 값을 정확히 지정해야 합니다.

### 디버깅 팁
- `console.log`를 사용하여 상태 값과 효과의 실행 시점을 확인하세요.
- React DevTools를 사용하여 상태와 컴포넌트 구조를 시각적으로 확인할 수 있습니다.

## 정리
React Hooks는 함수형 컴포넌트에서 상태와 생명주기를 간편하게 관리할 수 있는 강력한 도구입니다. `useState`와 `useEffect`를 포함한 다양한 Hooks를 활용하여 코드의 가독성과 유지보수성을 높일 수 있습니다. Custom Hooks를 만들어 재사용성을 높이고, Hooks 사용 시 주의사항을 숙지하여 실무에 적용해보세요. 추가적으로, 더 많은 Hooks와 고급 개념을 학습하여 React 개발의 깊이를 더해보시길 권장합니다.

```

### integration-01-devops-pipeline.md

**Path:** `frontend/public/posts/2025/integration-01-devops-pipeline.md`

```markdown
---
title: "DevOps 통합 실습: Terraform · Ansible · Kubernetes · Kafka"
date: "2025-01-20"
category: "DevOps"
tags: ["DevOps","Terraform","Ansible","Kubernetes","Kafka","Pipeline"]
excerpt: "네 가지 도구를 연결해 인프라 프로비저닝→설정 자동화→클러스터 구성→Kafka+마이크로서비스 배포까지 단일 파이프라인 시나리오."
author: "Admin"
published: true
---

# 통합 실습: 전체 DevOps 파이프라인

##  개요
Terraform, Ansible, Kubernetes, Kafka를 통합하여 완전한 DevOps 파이프라인을 구축하는 실습입니다.

##  목표
- 4가지 도구 간 연계 흐름 이해
- 이벤트 기반 마이크로서비스 아키텍처 구성
- IaC + 설정 자동화 + 컨테이너 오케스트레이션 + 스트리밍 통합

##  전체 아키텍처 개괄
```
1단계 Terraform: VPC, Subnets, EC2(K8s Nodes), SG
2단계 Ansible: Docker 설치, kubeadm 초기화, 모니터링 도구 배포
3단계 Kubernetes: Kafka StatefulSet + Microservices + Service
4단계 Streaming: 주문 → 결제 → 알림 이벤트 흐름
```

##  프로젝트 구조 (요약)
```
devops-pipeline/
├── terraform/
│   ├── main.tf / variables.tf / outputs.tf
│   └── modules/{vpc,ec2,security}
├── ansible/
│   ├── inventory/hosts.yml
│   ├── playbooks/full-setup.yml
│   └── roles/{docker,kubernetes,monitoring}
├── kubernetes/
│   ├── kafka/{namespace,statefulset들}
│   ├── microservices/{order,payment,notification}
│   └── monitoring/{prometheus,grafana}
└── apps/{order-service,payment-service,notification-service}
```

##  Terraform 핵심 (발췌)
```hcl
module "vpc" { source = "./modules/vpc" vpc_cidr = "10.0.0.0/16" }
module "k8s_nodes" {
  source = "./modules/ec2"
  instance_count = 3
  instance_type  = "t3.medium"
}
output "k8s_node_private_ips" { value = module.k8s_nodes.private_ips }
```

##  Ansible Inventory (발췌)
```yaml
all:
  vars:
    ansible_user: fedora
  children:
    k8s_masters:
      hosts:
        master01: { ansible_host: 10.0.1.10 }
    k8s_workers:
      hosts:
        worker01: { ansible_host: 10.0.1.11 }
        worker02: { ansible_host: 10.0.1.12 }
```

### Playbook 흐름
1. 시스템 업데이트
2. Docker 설치(Role)
3. kubeadm init + join
4. 모니터링 스택 배포

##  Kafka on Kubernetes (발췌)
ZooKeeper & Kafka StatefulSet 배포 후 Topic 생성:
```bash
kubectl apply -f kubernetes/kafka/namespace.yaml
kubectl apply -f kubernetes/kafka/zookeeper-statefulset.yaml
kubectl apply -f kubernetes/kafka/kafka-statefulset.yaml
kubectl exec -it kafka-0 -n kafka -- kafka-topics --create --topic orders --partitions 3 --replication-factor 3 --bootstrap-server kafka-0.kafka:9092
```

##  마이크로서비스 예시 (Order Service)
```python
producer = KafkaProducer(bootstrap_servers=['kafka-0.kafka.kafka.svc.cluster.local:9092'],
                         value_serializer=lambda v: json.dumps(v).encode('utf-8'))
@app.route('/orders', methods=['POST'])
def create_order():
    order = request.json
    producer.send('orders', value=order); producer.flush()
    return {"status": "success", "order_id": order.get('id')}, 201
```
배포:
```bash
docker build -t myregistry/order-service:v1 apps/order-service/
docker push myregistry/order-service:v1
kubectl apply -f kubernetes/microservices/
```

##  시스템 동작 테스트
```bash
ORDER_URL=$(kubectl get svc order-service -n kafka -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
curl -X POST http://$ORDER_URL/orders -H 'Content-Type: application/json' -d '{"id":"order-001","amount":99.9}'
kubectl logs -f deployment/payment-service -n kafka
```

##  모니터링 (Prometheus 발췌)
```yaml
scrape_configs:
  - job_name: 'kubernetes-pods'
    kubernetes_sd_configs:
      - role: pod
```

##  확장 실습 아이디어
| 단계 | 추가 과제 |
|------|-----------|
| CI/CD | GitHub Actions로 Terraform plan/apply 자동화 |
| 보안 | RBAC + 네트워크 정책(NetworkPolicy) 적용 |
| 관측성 | OpenTelemetry로 추적 수집 |
| 비용 | Terraform 태그 활용한 비용 분석 |

##  통합 트러블슈팅 요약
| 증상 | 원인 | 해결 |
|------|------|------|
| Worker Join 실패 | 토큰 만료 | `kubeadm token create` 재생성 |
| Kafka Pod Crash | 스토리지/환경 변수 오류 | `kubectl describe` + PVC 상태 확인 |
| 메시지 누락 | acks 설정 낮음 | `acks=all` + ISR 모니터링 |

##  참고 리소스
- Strimzi (Kafka on K8s): https://strimzi.io/
- Terraform AWS 모듈: https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/latest
- kubeadm Docs: https://kubernetes.io/docs/setup/

## ▶ 다음 예정 글
- Terraform으로 K8s 클러스터 프로비저닝 (예정)
- Kubernetes에서 Kafka 운영 (예정)
- 마이크로서비스 배포 고급 전략 (예정)

```

### integration-02-terraform-k8s.md

**Path:** `frontend/public/posts/2025/integration-02-terraform-k8s.md`

```markdown
---
title: "Terraform으로 Kubernetes 클러스터 프로비저닝"
date: "2025-03-03"
category: "DevOps"
tags: ["DevOps","Terraform","Kubernetes","Integration"]
excerpt: "준비 중: Terraform + K8s 클러스터 EKS/모듈 설계 패턴."
author: "Admin"
published: false
---

예정: EKS 모듈 활용, node group 구성, IAM 역할 매핑, Terraform state와 K8s manifest 연계.

```

### integration-03-k8s-kafka.md

**Path:** `frontend/public/posts/2025/integration-03-k8s-kafka.md`

```markdown
---
title: "Kubernetes에서 Kafka 운영 전략"
date: "2025-03-04"
category: "DevOps"
tags: ["DevOps","Kubernetes","Kafka","운영"]
excerpt: "준비 중: Strimzi/옵저버빌리티/스토리지/토픽 운영."
author: "Admin"
published: false
---

예정: Strimzi Operator, 브로커 스케일링, 토픽 파티션 조정, 모니터링/알림 지표, 장애 복구 시나리오.

```

### integration-04-microservices-deployment.md

**Path:** `frontend/public/posts/2025/integration-04-microservices-deployment.md`

```markdown
---
title: "마이크로서비스 배포 전략 (이벤트 기반)"
date: "2025-03-05"
category: "DevOps"
tags: ["DevOps","Microservices","Deployment","Kafka","Kubernetes"]
excerpt: "준비 중: 이벤트 기반 MSA, 버전 전략, Observability, Rollout 패턴."
author: "Admin"
published: false
---

예정: Blue/Green, Canary, 롤백 전략, 이벤트 스키마 관리(Avro/Schema Registry), 추적/로그/메트릭 통합.

```

### java-concurrency-journal.md

**Path:** `frontend/public/posts/2025/java-concurrency-journal.md`

```markdown
---
title: "스레드 덤프와 데드락 다이어그램, 자바 동시성의 밤을 기록하다"
date: "2025-10-27"
category: "Java"
tags: ['Java', 'Concurrency', 'Thread', 'ExecutorService', '락']
excerpt: "Thread, synchronized, ExecutorService, ForkJoinPool을 오가며 레이스와 데드락을 추적했던 내 1인칭 동시성 일기"
readTime: "12분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

![TOC](../../images/2025/fataldeadlock.png)

자바를 처음 배울 때, `Thread`를 상속받아 `run()` 메서드를 오버라이드하는 것만으로도 세상을 다 가진 줄 알았다. 그러나 첫 번째 레이스 컨디션을 마주한 날, 나는 동시성의 무게를 실감했다. 로그 파일에 “balance: -10”이 찍혀 있는 것을 보고 멍하니 모니터를 바라보던 그 밤, 나는 가장 먼저 락(lock)의 세계에 발을 들여놓았다.

`synchronized` 키워드를 붙인다고 모든 문제가 해결되는 건 아니었다. 공유 리소스를 보호하기 위해 메서드 전체를 동기화했더니, 시스템이 순식간에 느려졌다. 락 경합이 지표에 빨간색 경고를 뿜기 시작했고, 나는 내 실수를 깨달았다. 필요한 구간만 좁혀 잠그고, 가능한 한 빠르게 락을 해제해야 한다는 교훈을 Figma 다이어그램으로 그려 팀 위키에 기록했다. `wait()`와 `notify()`를 사용하던 시절, 실수로 `notify()` 대신 `notifyAll()`을 써야 한다는 사실을 놓쳤다가 스레드가 도미노처럼 잠드는 모습을 지켜보기도 했다.

ExecutorService가 등장했을 때는 마치 새로운 세계가 열린 것 같았다. 스레드를 직접 만들고 관리하는 대신, 쓰레드 풀에 작업을 제출하는 방식은 안전하고 우아했다. `Executors.newFixedThreadPool()`로 워커를 만들고, `Future`를 받아 결과를 기다리며, CPU 코어 수에 맞춰 풀 사이즈를 조정했다. 한 번은 작업 큐가 끝없이 쌓여 서비스가 멈춰 버렸는데, 그때 `CallerRunsPolicy`와 `DiscardOldestPolicy`를 비교하며 스트레스를 조절하는 법을 배웠다. 그 이후로는 항상 큐 길이와 쓰레드 수를 계산하는 습관이 생겼다.

`java.util.concurrent` 패키지를 탐험하던 시절은 작은 연구 프로젝트였다. `ReentrantLock`의 공정성(fairness) 옵션이 성능과 어떤 상충 관계를 가지는지 벤치마크를 돌렸고, `ReadWriteLock`이 읽기 위주의 시스템에서 얼마나 효율적으로 동작하는지 측정했다. `CountDownLatch`로 스레드 동기화를 깔끔하게 구현했을 때, “이제 복잡한 타이머 대신 이걸 쓰자”라는 문장을 팀 노션에 올렸다. `ConcurrentHashMap`의 세그먼트 구조를 이해하려고 소스 코드를 프린트해 회의실에 붙여 놓기도 했다.

ForkJoinPool이 등장했을 때도 새로운 챕터가 열렸다. 분할 정복 알고리즘을 `RecursiveTask`로 구현하고, 워크 스틸링(work stealing)이 실제로 어떻게 부하를 분산하는지 로그로 확인했다. “병렬 스트림”이 JDK 8에 추가되었을 때, 나는 조심스럽게 프로덕션에 적용했지만, 데이터 크기가 작으면 오히려 느려지는 역효과를 겪었다. 그때 “병렬은 도구이지 만능이 아니다”라는 문장을 노트에 적어 두었다. 이후로는 병렬 실행의 비용과 이득을 항상 측정값으로 확인했다.

한편, 데드락은 여전히 두려운 존재였다. 한 번은 두 개의 서비스가 서로 상대편의 락을 기다리며 얼어붙는 현상을 모니터링하다가, JStack으로 스레드 덤프를 뜨는 손이 떨렸다. `Found one Java-level deadlock:`이라는 문장을 읽고, 스택 트레이스를 역추적해 순환 의존을 끊어낼 때까지 서너 시간을 소비했다. 그 사건 이후 나는 항상 락 획득 순서를 도식화하고, 가능한 한 락을 줄이는 설계를 우선하게 되었다.

요즘 나는 CompletableFuture와 Project Loom 이야기를 동시에 다룬다. 콜백 지옥을 벗어나기 위해 체이닝된 Future를 사용하고, 넌블로킹 I/O 기반의 `CompletableFuture.supplyAsync()`를 적극 활용한다. Loom의 가상 스레드 실험을 하며 “이제 스레드 수에 대한 걱정이 조금 줄어들지도 모르겠다”는 희망을 품었다. 아직은 조심스럽지만, 자바 동시성의 다음 페이지가 이미 열리고 있다는 걸 느낀다.

오늘도 배포 전 체크리스트에서 로그를 훑었다. `Thread dump`의 상태는 양호했고, 메트릭스 대시보드에서 컨텍스트 스위치 수와 CPU 사용량은 안정적이었다. 모니터를 바라보며 나는 중얼거렸다. “동시성은 항상 겸손을 요구한다.” 지난 10여 년간 락과 스레드, 실행기와 풀을 다루며 배운 가장 소중한 교훈이다. 그리고 나는 내일도 동일한 체크리스트를 반복할 것이다. 그 리듬 속에서 우리는 조금씩 더 안전한 동시성을 만들어 간다.

```

### java-gc-journal.md

**Path:** `frontend/public/posts/2025/java-gc-journal.md`

```markdown
---
title: "Stop-the-world의 숨결을 들으며, GC와 화해한 나의 기록"
date: "2025-10-26"
category: "Java"
tags: ['Java', 'GarbageCollection', 'JVM', 'G1', '메모리관리']
excerpt: "Serial, CMS, G1을 거치며 힙 덤프와 함께 밤을 지새운 개발자가 GC의 진화와 전략을 되돌아본 일기"
readTime: "11분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

2007년 어느 날 새벽, 서버 로그에 찍힌 “Full GC (System) pause 5000ms”라는 메시지를 보고 숨이 멎는 줄 알았다. 사용자는 5초 동안 아무 것도 할 수 없었고, 우리는 손에 땀을 쥐고 힙 덤프를 뒤졌다. 그때부터 나의 Garbage Collection 탐험이 시작됐다. 파란색 힙 그래프가 들쭉날쭉한 캔버스처럼 보일 정도로 매일 보며 살았다.

처음에는 Serial GC와 Parallel GC 정도만 알고 있던 내가, CMS(Concurrent Mark-Sweep)의 mark 단계와 remark 단계가 어떻게 다른지 이해하려면 꽤 시간이 걸렸다. stop-the-world가 얼마나 짧아졌는지 확인하고, promotion 실패로 fallback이 일어나면 왜 그런지 분석했다. JVM 옵션에 `-XX:+UseConcMarkSweepGC`를 넣으면서도 “이게 정말 우리 서비스에 도움이 될까?”라는 의심을 떨치지 못했다. 결국 생산 환경에서 CMS가 동작하는 모습을 확인하던 날, 관찰 노트에 “remark 80ms, concurrent sweep 400ms”라고 적어 두었다. 그 숫자들이 내 마음을 진정시켜 주었다.

그러나 CMS의 fragmenation 문제는 결국 우리를 새로운 대안으로 몰아갔다. G1(Garbage-First) GC가 등장했을 때, 나는 JDK6u14 early access 빌드를 받아 테스트 환경에 먼저 적용했다. 힙을 리전(region) 단위로 나눠 가장 많이 쓰레기가 쌓인 구역부터 청소한다는 개념은 매력적이었다. GC 로그 분석 도구로 리전별 히트맵을 보면서, G1이 예측 가능한 pause time을 제공한다는 사실을 눈으로 확인했다. “-XX:MaxGCPauseMillis=200” 옵션이 실제로 얼마나 잘 지켜지는지 측정하고, 일지에 손수 그래프를 그렸다. 짧고 잦은 GC가 때로는 긴 멈춤보다 훨씬 낫다는 것을 그때 배웠다.

메모리 누수를 추적하던 시절도 잊을 수 없다. VisualVM과 MAT(Memory Analyzer Tool)을 번갈아 켜고, dominator tree를 분석하면서 after-GC에서 살아남는 객체 참조를 찾았다. `SoftReference`와 `WeakReference`의 차이를 이해하고, 캐시 전략을 다시 설계한 밤이 몇 번이나 되는지 모른다. GC는 단지 자동 메모리 회수 시스템이 아니라, 애플리케이션 설계 철학을 되돌아보게 만드는 거울이라는 사실을 깨달았다. 강한 참조를 적절히 끊지 않으면, 아무리 좋은 GC 알고리즘도 도움이 되지 않았다.

한동안 나는 Concurrent Mark Sweep과 G1 사이를 오가며 프로젝트 특성에 맞는 GC를 찾는 데 집중했다. 레이턴시가 최우선인 서비스에서는 CMS를, 대용량 데이터를 처리해야 하는 시스템에서는 G1을 시험했다. 그리고 JDK 11 이후에 등장한 ZGC와 Shenandoah의 소식을 들으며, 우리 팀이 언젠가 초저지연 GC를 도입할 수 있을지 기대했다. 아직 본격적으로 프로덕션에 적용하지는 않았지만, pause time이 몇 밀리초로 떨어지는 데모를 보았을 때는 가슴이 뛰었다.

지금은 GC 로그가 예전만큼 무섭지 않다. Fluent Bit와 Grafana 대시보드에 연결된 파란 곡선을 보며, 얼마나 안정적으로 힙이 재활용되고 있는지 확인한다. 여전히 가끔은 stop-the-world로 인한 불만이 접수되지만, 이제는 어떤 옵션을 조정하고 어떤 코드 패턴을 수정해야 할지 감이 온다. GC 튜닝은 결국 시스템 이해와 애플리케이션 설계가 맞물릴 때 의미가 있다는 것을 알게 되었으니까.

오늘도 배포 전 마지막 점검에서 GC 대시보드를 살펴봤다. 200ms 내외의 pause가 규칙적으로 나타나고, 힙 사용량은 안정적으로 톱니파형을 그린다. 모니터를 보며 나는 속으로 중얼거렸다. “감사해, GC. 우리가 더 나은 코드를 쓰도록 계속 압박해 줘서.” JVM 내부에서 묵묵히 돌아가는 수집기의 숨결을 들으며, 나는 내일의 튜닝 포인트를 떠올린다. Garbage Collection과 보낸 수많은 밤이 결국 나를 성장시켰다는 사실을 이제는 기쁘게 인정한다.

```

### java-generics-journal.md

**Path:** `frontend/public/posts/2025/java-generics-journal.md`

```markdown
---
title: "타입 변수와 야생의 캐스팅: 제네릭을 길들이던 내 기록"
date: "2025-10-25"
category: "Java"
tags: ['Java', 'Generics', '타입시스템', 'Erasure', '컬렉션']
excerpt: "로 타입과 ClassCastException에 질려, 제네릭이 도입되던 현장을 지켜보며 타입 안정성을 붙잡은 개발자 일기"
readTime: "10분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

지금 와서 생각하면 믿기 어렵지만, 2003년 이전의 나는 `List`에 무엇이 들어가는지 매번 머릿속으로 기억해야 했다. 로 타입(raw type)으로 선언된 컬렉션에 문자열과 숫자가 뒤섞여 있고, 런타임에야 `ClassCastException`이 터지는 장면은 일상이었다. 한 번은 야근 도중 로그 분석기를 돌리다가, 잘못된 타입 캐스팅 때문에 새벽에 배포를 롤백해야 했다. 그날 이후 나는 “컴파일러가 조금만 더 도와줬으면 좋겠다”고 투덜거렸다.

2004년, 제네릭이 포함된 JDK 5가 베타로 공개되었을 때, 우리 팀 스터디 룸은 작은 전쟁터가 됐다. `List<String>`이라는 문법이 등장했고, 이전 세대의 리플렉션 코드가 컴파일 경고를 쏟아냈다. 그러나 첫 번째 실험에서 `String`만을 담는 리스트가 캐스팅 없이 깔끔하게 동작하는 걸 보고, 나는 모니터 앞에서 조용히 미소를 지었다. 타입 안전성이 코드를 얼마나 단단하게 만들어 주는지 체감한 첫 순간이었다.

물론 포기할 수 없는 과제도 있었다. 제네릭이 래퍼런스 타입에만 적용된다는 사실을 깨달았고, 오토박싱이 성능을 얼마나 악화시킬 수 있는지 벤치마크를 돌려 보았다. `List<int>`를 허용하지 않는 JVM의 타입 시스템을 욕하며 `List<Integer>`에 억지로 박싱한 숫자를 넣어야 할 때면, “지워짐(erasure) 때문에 어쩔 수 없지”라는 말을 되뇌었다. 컴파일 타임에만 존재하고 런타임에는 사라지는 타입 변수, `instanceof`와 `new T()`가 허용되지 않는다는 제약은 분명 불편했다. 하지만 타입 안전성을 위해 지불할 만한 값이라는 결론에 도달했다.

제네릭 와일드카드(`?`, `? extends T`, `? super T`)와의 씨름은 또 다른 모험이었다. 생산자-소비자(PECS) 규칙을 이해하려던 밤, 나는 화이트보드에 “Producer Extends, Consumer Super”라는 문장을 적어 두고 반복해서 읽었다. 공변성과 반공변성을 명확하게 이해하고 나니, API 설계에 대한 시각이 달라졌다. “내가 제공하는 컬렉션이 어떤 타입을 허용해야 하지?”라는 질문을 먼저 던지게 되었고, 불필요한 복사를 줄이며 유연한 메서드 시그니처를 만들어낼 수 있었다.

새로운 API를 만들 때 제네릭 메서드를 추가하는 일도 즐거운 도전이었다. `<T extends Comparable<T>>` 같은 선언을 작성하면서, 타입 시스템이 동작하도록 설계했다는 사실에 감탄했다. “컴파일러가 이렇게 똑똑해져도 되는 걸까?”라는 농담을 하던 동료도 결국 제네릭 메서드 덕분에 템플릿 코드량이 줄어든 것을 인정했다. 그날 우리는 서로에게 하이파이브를 하며 “이제 런타임 오류에 덜 시달려도 되겠네”라고 말했다.

시간이 지나면서 나는 제네릭을 단지 문법이 아니라, API의 계약을 표현하는 언어로 사용하게 되었다. 호출자가 어떤 타입을 기대해야 하는지, 내가 제공하는 데이터 구조가 어떤 값을 저장하고 꺼낼 수 있는지 명확히 전달할 수 있었다. JSR-14와 커뮤니티 논의 덕분에 탄생한 제네릭이, 내 코드베이스의 버그를 얼마나 줄였는지 따져보는 일은 여전히 감동이다. 가끔 JVM의 타입 소거 때문에 어색한 캐스팅을 해야 할 때면 툴툴거리기도 하지만, 그래도 나는 지금이 과거보다 훨씬 안전하고 예측 가능한 시대임을 안다.

오늘도 새 프로젝트를 시작하며 `List<Order>`를 선언했다. 아무런 주석 없이도 코드가 의도를 전달하고, IDE가 타입을 추론한다. “우리가 이런 환경을 누릴 수 있는 건 제네릭 덕분이야.” 모니터를 응시하며 문득 혼잣말을 했다. 과거의 나였으면 몰랐을, 현재의 당연함이 떠올랐기 때문이다. 제네릭은 내게 컴파일러와 신뢰를 쌓는 방법을 알려줬고, 그 덕분에 나는 타입 안전성이라는 든든한 동료를 얻었다.

```

### java-memory-model-journal.md

**Path:** `frontend/public/posts/2025/java-memory-model-journal.md`

```markdown
---
title: "Happens-before를 붙잡기까지, 자바 메모리 모델을 해부한 내 여정"
date: "2025-10-27"
category: "Java"
tags: ['Java', '메모리모델', 'volatile', 'HappensBefore', 'JMM']
excerpt: "JMM 명세와 volatile, synchronized, reorder의 경계를 파헤치며 가시성과 순서를 이해한 개발자의 기록"
readTime: "12분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

처음에는 멀티스레드 코드가 이상하게 동작하면 “CPU가 느린가?” 정도만 생각했다. 그러나 `double-checked locking`이 깨져 버리고, `volatile`이 없던 `singleton`이 간헐적으로 초기화되지 않은 상태를 반환하는 모습을 본 순간, 나는 자바 메모리 모델(JMM)이라는 미지의 세계를 파고들어야 했다. 2004년 JSR-133이 등장한 이후의 JMM 명세서를 출력해 노트에 밑줄을 그으며 공부하던 밤, 나는 “happens-before”라는 단어가 단순한 이론이 아니라 생존 가이드라는 사실을 깨달았다.

CPU는 명령을 마음대로 재배치하고, 컴파일러는 최적화를 수행하며, 캐시는 각 코어에서 독립적으로 움직인다. 이 현실을 이해하지 못하면 `count++` 같은 단순한 연산조차 신뢰할 수 없다는 사실이 충격적이었다. 나는 Whiteboard에 메모리 가시성, 순서 보장, 원자성의 삼각형을 그리고, 스레드를 두 개만 띄워도 데이터가 엉키는 시나리오를 반복 시뮬레이션했다. 그 과정에서 `volatile`의 진짜 의미를 이해했다. 단순한 키워드가 아니라, 읽기-쓰기 시점에 메모리 장벽을 세우는 장치였다.

`synchronized` 블록을 사용할 때만 해도 순서와 가시성을 보장할 수 있었다. 하지만 락을 줄이고 싶었던 나는 `volatile`과 명시적인 happens-before 관계를 설정하는 방법을 연구했다. `ExecutorService`에서 제출되는 작업 간에 `CountDownLatch`를 이용해 순서를 강제한다든지, `AtomicInteger`의 `getAndIncrement`가 CAS 기반으로 어떻게 안전한 업데이트를 제공하는지 소스 코드를 통해 확인했다. `Unsafe` 클래스의 `storeFence()`와 `loadFence()`를 실험하며, 실제로 CPU 명령어가 어떻게 배치되는지 disassemble 결과를 들여다보던 순간은 지금도 잊지 못한다.

JMM 명세를 읽으며 가장 마음에 남았던 문장은 “프로그램의 의미는 happens-before 그래프의 연결 관계로 정의된다”였다. 나는 실제 서비스 장애에서 이 문장을 떠올렸다. 한 번은 로그 수집기가 종종 오래된 데이터를 출력하는 문제가 있었다. 원인은 background 스레드가 캐시를 갱신할 때 `volatile` 없이 필드를 교체한 것이었다. 캐시 참조를 `volatile`로 바꾸고 나서야 최신 내용이 보장됐다. 그날 이후로 나는 공유 데이터를 담는 필드에 `volatile`을 붙일지, 아니면 `AtomicReference`로 감쌀지부터 고민하는 습관이 생겼다.

`final` 필드의 불변성 보장 역시 흥미로운 주제였다. 생성자가 끝나기 전에 다른 스레드에게 `this`를 노출하면 `final` 필드도 제대로 보이지 않을 수 있다는 사실을 테스트 코드로 확인했다. “생성자 밖으로 빠져나가기 전에 모든 필드를 초기화해야 한다”는 조언은 단순한 규칙이 아니라, 메모리 모델을 지키기 위한 필수 조건이었다. 그 이후로는 Builder 패턴과 불변 객체를 적극 도입했다. 객체가 불변이면 happens-before를 걱정할 필요가 크게 줄어들기 때문이다.

JMM을 이해하기 위해선 단순히 명세를 읽는 것만으로는 부족했다. 나는 `jdeps`로 바이트코드를 뜯어보고, `-XX:+PrintAssembly`를 켠 상태로 JIT 컴파일 결과를 분석했다. 가끔은 `perf` 도구와 함께 CPU 캐시 미스를 측정해 보기도 했다. 이런 실험들은 “컴파일러 최적화는 우리 코드를 예상치 못한 순서로 재배치한다”는 사실을 피부로 느끼게 해 주었다. happens-before 그래프를 손으로 그려 보는 일은 이제 일상의 일부가 되었다.

요즘 들어서는 `VarHandle` API와 JDK 9 이후 도구들을 살펴보고 있다. JMM의 핵심이 변하지 않았다는 사실에 안도하면서도, 더 세밀한 제어가 가능해진 점에 흥분한다. Project Loom에서 가상 스레드가 대거 등장하면, JMM이 어떻게 동작할지, 어떤 새로운 함정이 있을지 벌써부터 노트에 시나리오를 적어두고 있다. happens-before 원칙이 우리에게 계속해서 guiding star가 되어 줄 것이라 믿는다.

오늘도 코드 리뷰를 하다가 공유 필드에 `volatile`이 없는 것을 발견했다. 댓글로 “여기 happens-before 관계가 보장되는지 확인했나요?”라고 남겼다. 몇 년 전의 나였다면 이런 리뷰를 남기기 어려웠을 것이다. JMM과 함께한 시간들이 내 사고방식을 바꾸었다. 메모리 모델은 눈에 보이지 않는 거대한 지형이지만, 우리가 안전하게 코드를 실행할 수 있도록 길을 안내해 준다. 이제 나는 그 길을 조금이나마 이해했고, 앞으로도 그 지도를 계속 업데이트할 생각이다.

```

### java-oop-superchallenge.md

**Path:** `frontend/public/posts/2025/java-oop-superchallenge.md`

```markdown
---
title: "JVM 메모리 지도 들고 자바 OOP 문제를 풀어본 기록"
date: "2025-10-21"
category: "Java"
tags: ['Java', 'JVM 메모리', 'static', '다형성', '상속', 'instanceof']
excerpt: "정적 초기화 블록에서 시작해 super()로 끝나는 여섯 가지  문제들. 그 밤의 디버깅 노트를 그대로 옮겨 붙였습니다."
readTime: "18분"
---

조금 생각을 강요하는 문제들을 만들어보면, 머릿속에 JVM 메모리 구조와 다형성 테이블이 함께 떠다닙니다. 
"정적 영역과 힙이 만나면 무슨 일이 일어날까?" "정적 메서드는 왜 오버라이딩이 안 될까?" 같은 질문들과 씨름하던 밤,
자신이 던졌던 문제들을 기록해 두기로 했습니다. 모든 문제는 코드 예제와 함께, 메모리 지도와 비유를 동원해 설명했습니다.

---

## 문제 1. 정적 필드와 인스턴스 필드의 초기화 순서 추적

JVM이 정적 필드와 인스턴스 필드를 어떻게 배치하고 초기화하는지 정확히 알고 있어야 풀 수 있는 문제입니다. 제시된 코드는 Product 클래스가 정적/인스턴스 필드, 정적 초기화 블록, 인스턴스 초기화 블록, 생성자를 모두 갖고 있습니다.

```java
package memory;

class Product {
    private static int totalProducts; // [A] 메서드 영역(Static Area)
    private final int id;             // [B] 힙 (각 객체마다 독립)
    private String name;              // [B]

    static {
        System.out.println("(1) [Static Init] 클래스 로딩 시작...");
        totalProducts = 0;
    }

    {
        System.out.println("(2) [Instance Init] 객체 초기화 블록 실행");
    }

    public Product(String name) {
        this.id = ++totalProducts;
        this.name = name;
        System.out.println("(3) [Constructor] " + this.name + " 객체 생성 완료, ID: " + this.id);
    }
}

public class ProductMemoryTest {
    public static void main(String[] args) {
        System.out.println("(4) [Main] 프로그램 시작 직후.");

        Product p1 = new Product("Laptop");
        Product p2 = new Product("Mouse");

        System.out.println("(5) [Main] 두 번째 객체 생성 후.");
    }
}
```

### 예상 출력 및 설명

1. `(1) [Static Init] ...` – 클래스가 처음 로딩될 때, 정적 블록이 실행됩니다. 메서드 영역에 올라가면서 totalProducts가 0으로 초기화됩니다.
2. `(4) [Main] ...` – main이 실행됩니다.
3. p1 생성 시 `(2)` → `(3)` – 객체를 생성하면 먼저 인스턴스 초기화 블록이 실행되고 나서 생성자가 호출됩니다. id가 1이 됩니다.
4. p2 생성 시 `(2)` → `(3)` – 두 번째 객체도 동일한 순서로 초기화되지만 정적 필드 totalProducts는 이미 1이므로 p2의 id는 2가 됩니다.
5. 마지막으로 `(5)`가 출력됩니다.

정리하면, 정적 블록은 클래스 로딩 시 단 한 번, 인스턴스 블록은 객체 생성 때마다, 생성자는 인스턴스 블록 이후에 실행된다는 것을 확인할 수 있습니다.

---

## 문제 2. static 컨텍스트와 this의 거리 두기

정적 메서드 안에서 실수로 인스턴스 멤버를 호출하거나 this를 사용하려 할 때, 컴파일러가 날리는 경고를 메모리 관점에서 분석하는 문제입니다.

```java
package context;

public class ServiceManager {
    private String serviceName = "Global Service"; // 힙에 저장될 인스턴스 필드
    private static int serviceVersion = 1;         // 메서드 영역의 정적 필드

    public void startService() {
        System.out.println(this.serviceName + " is starting.");
    }

    public static void TestService() {
        System.out.println("Current Service Name: " + serviceName); // (1)
        startService();                                             // (2)
        System.out.println("Current Version: " + serviceVersion);    // (3)

        ServiceManager sm = new ServiceManager();
        sm.startService();                                          // (4)

        if (this != null) {                                         // (5)
            System.out.println("This is safe.");
        }
    }

    public static void main(String[] args) {
        ServiceManager.TestService();
    }
}
```

### 에러가 발생하는 라인

- (1) `serviceName`은 인스턴스 필드입니다. 정적 메서드는 객체 없이 실행되므로 힙에 있는 필드에 직접 접근할 수 없습니다.
- (2) `startService()` 역시 인스턴스 메서드입니다. 어떤 객체의 메서드를 호출할지 결정할 수 없으므로 컴파일 에러입니다.
- (5) `this` 키워드는 인스턴스에만 존재합니다. 정적 메서드에는 this가 없습니다.

(3)은 정적 필드에 접근하므로 문제가 없고, (4)는 정적 메서드 안에서 직접 객체를 생성한 뒤 인스턴스 메서드를 호출하므로 허용됩니다.

### 수정 예시

```java
public static void TestService() {
    System.out.println("Current Version: " + serviceVersion);

    ServiceManager sm = new ServiceManager();
    System.out.println("Current Service Name: " + sm.serviceName);
    sm.startService();
}
```

혹은 정적 필드를 통해 서비스 이름을 관리하고 싶다면, serviceName 자체를 static으로 바꾸거나 정적 접근자를 만들어야 합니다.

---

## 문제 3. 참조 복사 vs 값 복사

배열과 기본 자료형의 복사 방식이 어떻게 다른지, 스택과 힙 관점에서 분석하는 문제입니다. 제시된 코드에는 일부러 잘못된 라인을 넣어 두었습니다.

```java
package reference;

public class DeepCopyTest {
    public static void main(String[] args) {
        int[] a = new int[]{10, 20, 30};
        int[] b = new int[]{10, 20, 30};

        int[] c = a;

        int p = a; // 컴파일 에러: int[]를 int에 대입할 수 없음 (예제 교정 필요)

        System.out.println("(1) a == p: " + (a == p));
        System.out.println("(2) a.length == b.length: " + (a.length == b.length));
        System.out.println("(3) a == b: " + (a == b));

        c = 99; // 컴파일 에러: 참조 변수에 정수를 대입할 수 없음

        System.out.println("(4) a: " + a + ", c: " + c);

        p = 100;
        System.out.println("(5) a == p: " + (a == p));
    }
}
```

### 교정 및 설명

원 문제의 의도를 살려 코드를 수정하면 다음과 같습니다.

```java
int[] a = {10, 20, 30};      // 배열 객체 1 (힙)
int[] b = {10, 20, 30};      // 배열 객체 2 (힙)
int[] c = a;                 // a의 참조값을 c에 복사 (얕은 복사)
int[] p = a.clone();         // 별도의 배열 복사 (깊은 복사)

System.out.println("(1) a == c: " + (a == c)); // true (같은 주소)
System.out.println("(2) a == b: " + (a == b)); // false (다른 주소)
System.out.println("(3) Arrays.equals(a, b): " + Arrays.equals(a, b)); // true (값 비교)

c[0] = 99; // c와 a가 같은 객체를 가리키므로, a[0]도 99로 변경됨
System.out.println("(4) a[0]: " + a[0] + ", c[0]: " + c[0]); // 둘 다 99

System.out.println("(5) Arrays.equals(a, p): " + Arrays.equals(a, p)); // false (p는 clone이므로 10,20,30 유지)
```

- 참조 복사는 스택에 저장된 주소값을 그대로 복사합니다. 따라서 c를 통해 값을 변경하면 a도 영향을 받습니다.
- 값 복사(기본 자료형)는 스택에서 스택으로 값을 복사하기 때문에 서로 영향을 미치지 않습니다.

---

## 문제 4. 정적 메서드 숨김 vs 동적 디스패치

메서드 바인딩 시점을 이해해야 풀 수 있는 문제입니다.

```java
package binding;

class Device {
    public static void identify() {
        System.out.println("Device: Static Identity");
    }
    public void process() {
        System.out.println("Device: Instance Process");
    }
}

class Sensor extends Device {
    public static void identify() {
        System.out.println("Sensor: Static Identity");
    }
    @Override
    public void process() {
        System.out.println("Sensor: Instance Process");
    }
}

public class PolymorphismTest {
    public static void main(String[] args) {
        Device d = new Sensor();
        Sensor s = new Sensor();

        System.out.println("--- Call 1 (Up-casted Reference) ---");
        d.identify(); // Device 버전 호출 (정적 바인딩)
        d.process();  // Sensor 버전 호출 (동적 바인딩)

        System.out.println("--- Call 2 (Child Reference) ---");
        s.identify(); // Sensor 버전
        s.process();  // Sensor 버전
    }
}
```

### 실행 결과

```
--- Call 1 (Up-casted Reference) ---
Device: Static Identity
Sensor: Instance Process
--- Call 2 (Child Reference) ---
Sensor: Static Identity
Sensor: Instance Process
```

- `d.identify()`는 정적 메서드 리졸루션이 컴파일 타임에 이루어지기 때문에, 참조 변수 타입(Device)에 따라 부모 버전이 호출됩니다.
- `d.process()`는 런타임에 힙에 있는 실제 객체 타입 Sensor를 보고 오버라이딩된 메서드가 실행됩니다.

정적 메서드는 오버라이딩이 아니라 숨김(hiding)이라는 점을 다시 확인할 수 있습니다.

---

## 문제 5. instanceof와 다운캐스팅의 안전 장치

Vehicle 클래스 계층에서 실제 타입을 판별해 자식 고유 정보를 출력하는 문제입니다.

```java
package casting;

class Vehicle {
    public void move() { System.out.println("Vehicle is moving."); }
}

class Car extends Vehicle {
    private int maxSpeed = 200;
    public int getMaxSpeed() { return maxSpeed; }
}

class Plane extends Vehicle {
    private int maxAltitude = 30000;
    public int getMaxAltitude() { return maxAltitude; }
}

class Analyzer {
    public static void checkType(Vehicle v) {
        if (v instanceof Car c) {
            System.out.println("Car Speed: " + c.getMaxSpeed());
        } else if (v instanceof Plane p) {
            System.out.println("Plane Max Alt: " + p.getMaxAltitude());
        } else {
            v.move();
        }
    }
}

public class InstanceOfTest {
    public static void main(String[] args) {
        Vehicle v1 = new Car();
        Vehicle v2 = new Plane();

        Analyzer.checkType(v1); // Car Speed: 200
        Analyzer.checkType(v2); // Plane Max Alt: 30000
        Analyzer.checkType(new Vehicle()); // Vehicle is moving.

        // Analyzer.checkType(new Object()); // 컴파일 에러: Object는 Vehicle을 상속하지 않으므로
    }
}
```

### 설명

- Java 16 이상의 패턴 매칭 문법을 사용해 instanceof와 캐스팅을 동시에 처리할 수 있습니다.
- `checkType(new Object())`는 컴파일 에러입니다. Object 타입은 Vehicle과 아무런 상속 관계가 없으므로 넘길 수 없습니다.

---

## 문제 6. 생성자 연쇄와 super() 호출 순서

SystemUnit 생성자가 호출될 때, 부모 클래스의 생성자가 어떻게 실행되는지 추적하는 문제입니다.

```java
package inheritance;

class Component {
    String componentName = "Default Component";

    public Component(String name) {
        this.componentName = name;
        System.out.println("(1) [Comp C] Component 생성자 실행: " + this.componentName);
    }
}

class SystemUnit extends Component {
    String unitName;

    public SystemUnit(String name) {
        super("Base Unit for " + name);
        this.unitName = name;
        System.out.println("(3) [Unit C] SystemUnit 생성자 실행: " + this.unitName);
    }

    public SystemUnit() {
        super("Anonymous Unit");
        this.unitName = "Anonymous";
        System.out.println("(4) [Unit C] 기본 생성자 실행: " + this.unitName);
    }
}

public class ConstructorChainTest {
    public static void main(String[] args) {
        SystemUnit su = new SystemUnit("Main Processor");
    }
}
```

### 실행 결과

```
(1) [Comp C] Component 생성자 실행: Base Unit for Main Processor
(3) [Unit C] SystemUnit 생성자 실행: Main Processor
```

- 자식 생성자가 호출되면 먼저 super(...)를 통해 부모 생성자가 실행되고, 그 이후에 자식 생성자의 본문이 실행됩니다.
- 만약 부모 클래스에 매개변수 없는 생성자가 없다면, 자식 기본 생성자에서도 `super(...)`를 명시적으로 호출해 주어야 합니다.

---

## 추가 문제: static, clone, equals, super()가 한꺼번에 등장한다면?

가끔은 static 상태를 유지한 채 clone을 통해 객체를 복제하고, equals로 비교하고, 상속 구조에서 생성자 순서를 확인해야 하는 순간이 찾아옵니다. 아래 문제는 그런 상황을 한 번에 확인해 볼 수 있는 종합 퀴즈입니다.

```java
class Counter implements Cloneable {
    private static int total;
    private int personal;

    static {
        System.out.println("[Static] Counter loaded");
        total = 0;
    }

    {
        System.out.println("[Instance] init block");
    }

    public Counter() {
        total++;
        personal = 1;
        System.out.println("[Constructor] total=" + total + ", personal=" + personal);
    }

    @Override
    protected Counter clone() throws CloneNotSupportedException {
        Counter copy = (Counter) super.clone();
        copy.personal = this.personal; // 얕은 복사 후 필드 조정
        return copy;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Counter) {
            Counter other = (Counter) obj;
            return this.personal == other.personal;
        }
        return false;
    }
}

public class CounterTest {
    public static void main(String[] args) throws Exception {
        Counter c1 = new Counter();
        Counter c2 = c1.clone();

        System.out.println("c1 equals c2? " + c1.equals(c2));
        System.out.println("Counter total: " + Counter.total); // 접근 제어자 변경 필요
    }
}
```

이 문제를 통해 다시 한 번 다음을 확인할 수 있습니다.

- 정적 블록 → 인스턴스 블록 → 생성자 순서
- clone()과 equals() 재정의 패턴
- 정적 필드 접근자를 public으로 바꾸거나 getter를 제공해야 하는 이유

---

##  메모리 지도와 함께 떠나는 여행

이 모든 문제는 JVM의 메모리 모델, static과 instance의 구분, 다형성의 바인딩 시점, instanceof와 다운캐스팅, super()의 호출 순서 같은 핵심을 이해해야만 풀 수 있습니다. 저는 문제를 만들면서 다시 한 번 메서드 영역과 힙을 오가는 바이트코드의 흐름을 눈으로 그려 보았습니다. 언젠가 또 비슷한 질문을 받게 된다면, 이 기록을 펼쳐 놓고 말해 줄 겁니다.

> "정적 영역은 클래스 전체를 위한 약속이고, 힙은 객체 하나하나의 삶입니다. 다형성은 그 삶이 서로를 이해하는 방법이고, super()는 세대 간의 인사를 잊지 말라는 규칙이죠." 

그리고 아마 다음 회의에서도, 정적 메서드를 오버라이딩할 수 있냐는 질문에 이 코드 묶음을 조용히 내밀겠죠. "정답은 코드가 말해 줍니다."라고요.

```

### java-static-polymorphism-masterclass.md

**Path:** `frontend/public/posts/2025/java-static-polymorphism-masterclass.md`

```markdown
---
title: "static 키워드와 다형성으로 밤을 지새운 어느 개발자의 기록"
date: "2025-10-22"
category: "Java"
tags: ['Java', 'static', 'Polymorphism', 'OOP 심화', 'JVM 메모리']
excerpt: "정적 영역과 힙 사이에서 헤매던 날, 다형성의 그림자와 씨름한 새벽, 그리고 equals를 다시 쓰며 깨달은 객체지향의 본질"
readTime: "15분"
---

밤새 모니터 앞에서 static과 polymorphism을 동시에 붙잡고 늘어지다 보면, 자바가 왜 여전히 사랑받는지 새삼 실감하게 됩니다. 정적 영역과 힙의 미세한 경계를 넘나들다 보면, JVM이 우리가 만든 클래스 로더와 메서드 테이블을 어떻게 다루는지 그 얼굴이 보이거든요. 오늘은 제가 직접 던졌던 네 가지 난이도 최상급 질문과, 그 질문들을 풀면서 남긴 코드 스케치를 일기처럼 정리해 보았습니다.

## 1. 정적 메서드가 인스턴스 컨텍스트의 문을 두드리는 순간

`Resource.analyzeStatus()`를 작성하다가, "정적 메서드 안에서 인스턴스 필드를 건드리면 무슨 일이 일어날까?"라는 호기심에 빠졌습니다. 결과는 컴파일러의 따끔한 경고였죠. 정적 메서드는 "객체 없이도 호출된다"는 세계관을 가지고 있기 때문입니다.

```java
package advanced;

public class Resource {
    private int instanceCounter = 0;         // 힙에 객체가 생길 때마다 생성
    private static int sharedCount = 0;      // 메서드 영역(Static Area)에 로딩 시점에 생성

    public Resource() {
        instanceCounter++;
        sharedCount++;
    }

    public int getInstanceCount() {
        return instanceCounter;
    }

    public static void analyzeStatus() {
        System.out.println("Instance Counter: " + instanceCounter); // (1) 컴파일 에러
        int current = getInstanceCount();                              // (2) 컴파일 에러
        System.out.println("Shared Total: " + sharedCount);           // (3) OK
        System.out.println(this.sharedCount);                          // (4) 컴파일 에러
    }
}
```

- (1)과 (2)는 인스턴스 필드/메서드를 호출하려 합니다. 하지만 정적 메서드는 아직 객체가 힙에 있다는 보장이 없죠. JVM의 메서드 영역에 로딩된 클래스 정보만 들고 실행되기 때문에, "어느 객체의 instanceCounter를 출력하지?"라는 난감한 상황이 됩니다.
- (4)는 this를 쓰고 있는데, this는 힙에 존재하는 실제 객체를 가리키는 변수가 생성될 때만 사용할 수 있습니다. static 영역에서 this는 존재하지 않습니다.

### 1.1 최소 수정으로 문제 해결

그래도 "어떻게든 힙 객체에 접근하고 싶다"면, 정적 메서드 안에서 직접 객체를 생성하거나 외부에서 인스턴스를 전달받는 방식으로 접근할 수 있습니다. 저는 임시 객체를 만들어서 해결했습니다.

```java
public static void analyzeStatus() {
    Resource temp = new Resource();

    System.out.println("Instance Counter (temp): " + temp.instanceCounter); // (1) 해결: temp를 통해 접근
    System.out.println("Instance Count (via method): " + temp.getInstanceCount()); // (2) 해결
    System.out.println("Shared Total: " + sharedCount); // (3) 그대로 OK
    System.out.println("Shared Total (via class name): " + Resource.sharedCount); // (4) class 이름으로 접근
}
```

물론 이렇게 하면 analyzeStatus()를 호출할 때마다 `sharedCount`가 증가해 버리니, 실제 진단 코드에서는 인스턴스를 주입하거나, 인스턴스 상태를 리턴하도록 설계하는 것이 바람직합니다.

### 1.2 메모리 구조 도식

```
+---------------------+      클래스 로딩 시점
| Method Area         |
|  - Resource.class   |
|  - static sharedCount -> 1
+---------------------+
          |
          | new Resource()
          v
+---------------------+
| Heap                |
|   Resource@0x100 -> instanceCounter = 1
+---------------------+
```

정적 메서드는 객체가 있든 없든 메서드 영역에서 바로 호출되므로, 힙 객체의 상태와는 완전히 별개라는 점을 기억하면 좋습니다.

## 2. 정적 메서드는 오버라이딩되지 않는다? 메서드 숨김의 정체

다형성을 이야기할 때 빠지지 않는 주제가 "정적 메서드도 오버라이딩되나요?"입니다. Machine과 Robot을 만들어, 정적 메서드와 인스턴스 메서드를 섞어 호출해 봤습니다.

```java
abstract class Machine {
    public static void identify() {
        System.out.println("A: Machine Identity (Static)");
    }
    public void process() {
        System.out.println("B: Machine Processing (Instance)");
    }
}

class Robot extends Machine {
    public static void identify() {
        System.out.println("C: Robot Identity (Static)");
    }
    @Override
    public void process() {
        System.out.println("D: Robot Processing (Instance)");
    }
}

public class DynamicBindingTest {
    public static void main(String[] args) {
        Machine m1 = new Robot();
        Robot r1 = new Robot();

        System.out.println("--- 1. Static Method Call ---");
        m1.identify(); // (1)
        r1.identify(); // (2)

        System.out.println("\n--- 2. Instance Method Call ---");
        m1.process();  // (3)
        r1.process();  // (4)
    }
}
```

출력 결과는 이렇게 나옵니다.

```
--- 1. Static Method Call ---
A: Machine Identity (Static)
C: Robot Identity (Static)

--- 2. Instance Method Call ---
D: Robot Processing (Instance)
D: Robot Processing (Instance)
```

- (1)에서 **Machine 타입의 참조 변수**로 `m1.identify()`를 호출하면, 컴파일러가 Machine의 static 메서드를 호출하도록 결정합니다. 런타임에 Robot 객체가 생겨 있어도, 정적 메서드는 **컴파일 타임 바인딩**이기 때문에 부모 버전을 호출합니다.
- (3)에서는 인스턴스 메서드가 호출되므로, 런타임에 힙에 올라가 있는 실제 객체 타입(Robot)을 보고 오버라이딩된 메서드가 실행됩니다. 이때를 **동적 바인딩**이라고 부르죠.

즉, 정적 메서드의 재정의처럼 보이는 것은 사실 "숨김(hiding)" 효과에 지나지 않는다는 걸, 코드가 말해줍니다.

## 3. Object.equals()와 instanceof: 얕은 비교를 넘어서는 법

모든 것이 Object에서 시작됩니다. 커스텀 클래스 `Item`을 만들고 equals를 직접 재정의하지 않으면 어떤 일이 벌어지는지, String과 비교해 보면 확실히 알 수 있습니다.

```java
class Item {
    private String name;
    public Item(String name) { this.name = name; }
    public String getName() { return name; }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Item) {
            return name.equals(((Item)obj).name);
        }
        return false;
    }
}

public class ObjectCastingTest {
    public static void printInfo(Object obj) {
        if (obj instanceof Item) {
            Item item = (Item) obj;
            System.out.println("Type: Item, Name: " + item.getName());
        } else if (obj instanceof String) {
            System.out.println("Type: String");
        } else {
            System.out.println("Type: Unknown Object (" + obj.getClass().getName() + ")");
        }
    }

    public static void main(String[] args) {
        String s1 = new String("Sword");
        String s2 = new String("Sword");

        Item i1 = new Item("Staff");
        Item i2 = new Item("Staff");

        printInfo(s1); // Type: String
        printInfo(i1); // Type: Item, Name: Staff

        System.out.println("s1 == s2 : " + (s1 == s2));         // false - 주소 비교
        System.out.println("i1.equals(i2) : " + i1.equals(i2)); // true  - 내용 비교 (equals 재정의 덕분)
    }
}
```

- `==` 연산자는 참조 자료형에 대해서는 힙의 주소값을 비교합니다. `new String()`을 두 번 호출하면 서로 다른 객체를 가리키게 되므로 false입니다.
- `Item.equals()`를 재정의하지 않았다면, 기본적으로 Object.equals()는 `==`와 동일하게 동작합니다. 즉, 내용이 같아도 false였겠죠.
- `instanceof`와 다운캐스팅은 항상 세트로 생각해야 합니다. 타입을 안전하게 확인하지 않고 캐스팅하면 `ClassCastException`에 맞닥뜨리게 됩니다.

### 3.1 equals 재정의 시 체크리스트

1. `== obj`로 동일 객체인지 먼저 확인하면 빠른 탈출이 가능합니다.
2. `instanceof`로 타입을 검증합니다.
3. 핵심 필드(name 등)를 비교합니다.
4. equals를 재정의했으면 반드시 `hashCode()`도 재정의해야 HashMap/HashSet에서 일관성을 유지할 수 있습니다.

```java
@Override
public int hashCode() {
    return Objects.hash(name);
}
```

## 4. 정적 초기화 블록과 생성자: JVM 로딩 순서 추적기

`BaseConfig`와 `DerivedConfig`를 만들어, 정적 초기화 블록과 생성자가 어떤 순서로 실행되는지 눈으로 확인해 봤습니다.

```java
class BaseConfig {
    static int BASE_STATIC_VAL;
    int baseInstanceVal = 10;

    static {
        BASE_STATIC_VAL = 100;
        System.out.println("S1: Base Static Block Executed. BASE_STATIC_VAL: " + BASE_STATIC_VAL);
    }

    public BaseConfig() {
        System.out.println("C1: Base Constructor Executed. baseInstanceVal: " + this.baseInstanceVal);
    }
}

class DerivedConfig extends BaseConfig {
    static int DERIVED_STATIC_VAL;
    int derivedInstanceVal = 20;

    static {
        DERIVED_STATIC_VAL = 200;
        System.out.println("S2: Derived Static Block Executed. DERIVED_STATIC_VAL: " + DERIVED_STATIC_VAL);
    }

    public DerivedConfig() {
        System.out.println("C2: Derived Constructor Executed. derivedInstanceVal: " + this.derivedInstanceVal);
    }
}

public class InitializationTest {
    public static void main(String[] args) {
        System.out.println("M1: Program Start.");
        DerivedConfig d1 = new DerivedConfig();
        System.out.println("M2: Final Static Value (Base): " + BaseConfig.BASE_STATIC_VAL);
    }
}
```

실행 결과는 다음과 같습니다.

```
S1: Base Static Block Executed. BASE_STATIC_VAL: 100
S2: Derived Static Block Executed. DERIVED_STATIC_VAL: 200
M1: Program Start.
C1: Base Constructor Executed. baseInstanceVal: 10
C2: Derived Constructor Executed. derivedInstanceVal: 20
M2: Final Static Value (Base): 100
```

- **정적 블록은 클래스 로딩 시점에 단 한 번** 실행됩니다. 그리고 상속 구조에서는 부모 클래스의 정적 블록이 먼저 실행된 후, 자식 클래스의 정적 블록이 실행됩니다.
- main()이 실행되기 전에 이미 정적 블록은 끝난 상태입니다. 이는 JVM이 클래스 로딩과 초기화를 main보다 먼저 수행하기 때문입니다.
- `new DerivedConfig()`를 호출하면, 먼저 부모 생성자가 실행되고, 이후 자식 생성자가 실행됩니다. 인스턴스 필드 초기화도 이 시점에 이루어집니다.

### 4.1 정적 영역과 힙을 구분하는 감각

정적 블록을 그림으로 표현하면 이렇게 보입니다.

```
[클래스 로딩 시점]
  BaseConfig.class 로딩 -> S1 실행
  DerivedConfig.class 로딩 -> S2 실행

[main 시작]
  M1 출력
  new DerivedConfig()
    super() 호출 -> C1
    자식 생성자 -> C2
  M2 출력
```

정적 멤버는 클래스 전체가 공유하는 자원이고, 인스턴스 멤버는 각 객체가 독립적으로 가지는 자원이라는 것을 객체 생성 순서와 함께 다시금 확인할 수 있었습니다.

## 5. 난이도 최상급 추가 문제: static과 다형성의 결합을 디버깅하라

코드를 디버깅하다 보면, 정적 멤버를 자식 클래스에서 재정의하려다가 발생하는 미묘한 버그를 자주 봅니다. 그래서 아래와 같은 추가 문제를 스스로 만들어 보았습니다.

```java
class Counter {
    static int shared = 0;
    int personal = 0;

    public Counter() {
        shared++;
        personal++;
    }

    public static void resetShared() {
        shared = 0;
    }

    public void resetPersonal() {
        personal = 0;
    }
}

class ChildCounter extends Counter {
    static int shared = 100; // 부모의 static을 숨김 -> 별개의 정적 변수

    public ChildCounter() {
        shared += 10;
    }

    public static void resetShared() {
        shared = 50; // ChildCounter.shared만 초기화됨
    }
}

public class StaticHidingPitfall {
    public static void main(String[] args) {
        Counter c1 = new Counter();
        ChildCounter c2 = new ChildCounter();
        Counter c3 = new ChildCounter();

        System.out.println("Counter.shared = " + Counter.shared);       // ?
        System.out.println("ChildCounter.shared = " + ChildCounter.shared); // ?

        Counter.resetShared(); // 부모 static 메서드 호출 -> Counter.shared 초기화
        ChildCounter.resetShared(); // 자식 static 메서드 호출 -> ChildCounter.shared 초기화

        System.out.println("After reset -> Counter.shared = " + Counter.shared);
        System.out.println("After reset -> ChildCounter.shared = " + ChildCounter.shared);
    }
}
```

예상 출력은 다음과 같습니다.

```
Counter.shared = 3
ChildCounter.shared = 120
After reset -> Counter.shared = 0
After reset -> ChildCounter.shared = 50
```

- `Counter.shared`와 `ChildCounter.shared`는 서로 다른 메모리 위치를 가진 두 개의 정적 변수입니다.
- `ChildCounter.shared`를 바꾸면 부모 클래스의 shared에는 아무런 영향이 없습니다. 그래서 static 멤버를 "재정의"하는 것은 대부분의 경우 혼란만 초래합니다.

## 6. Object 배열과 다형성, 그리고 다운캐스팅 안전장치

모든 객체를 Object 배열에 담아 다형성의 범위를 확장하고 싶을 때가 있습니다. 하지만 다운캐스팅 시 instanceof 체크를 빼먹으면 ClassCastException이 바로 날아옵니다.

```java
Object[] bag = {
    new Item("Potion"),
    "Map",
    Integer.valueOf(42),
    new Item("Elixir")
};

for (Object obj : bag) {
    if (obj instanceof Item item) { // Java 16+ 패턴 매칭
        System.out.println("Item -> " + item.getName());
    } else if (obj instanceof String str) {
        System.out.println("String -> " + str.toUpperCase());
    } else {
        System.out.println("Other -> " + obj);
    }
}
```

이렇게 쓰면, 모든 타입에 대해 안전하게 다운캐스팅할 수 있습니다. Java 16 이상에서는 instanceof 패턴 매칭을 활용하면 캐스팅 문법이 한층 깔끔해집니다.

## 7. 마무리: 정적과 동적이 교차하는 교차로에서

정적 멤버를 올바르게 이해한다는 건, 클래스 로딩과 JVM 메모리 구조를 이해한다는 의미입니다. 다형성을 제대로 이해한다는 건, 오버라이딩과 메서드 디스패치가 실전에서 어떻게 동작하는지 몸으로 체득하는 것이죠. equals를 오버라이딩하며 "동등성"을 고민하다 보면, 결국 객체지향이란 무엇인가에 대한 근본적인 질문으로 되돌아오게 됩니다.

아마 내일 아침에도 저는 디버거를 열고 "이 static은 지금 어디에 올라가 있지?"를 되뇌겠죠. 그리고 누군가가 "정적 메서드를 오버라이딩할 수 있나요?"라고 물으면, 이 긴 밤의 코드를 가만히 보여주며 미소를 지을 겁니다. "자바는 언제나, static과 polymorphism 사이의 거리감을 유지한 채 살아간단다"라고요.

```

### java-stream-api-journal.md

**Path:** `frontend/public/posts/2025/java-stream-api-journal.md`

```markdown
---
title: "람다와 파이프라인 사이, 스트림 API에 빠져들던 밤"
date: "2025-10-27"
category: "Java"
tags: ['Java', 'StreamAPI', 'Lambda', 'FunctionalProgramming', '병렬스트림']
excerpt: "람다 표현식과 스트림 파이프라인을 처음 만났을 때의 놀람, 컬렉터와 병렬 스트림 튜닝까지 기록한 1인칭 에세이"
readTime: "11분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

2014년 JDK 8이 출시되던 날, 나는 회사 교육장에서 처음 람다 표현식을 살펴봤다. `list.stream().filter(x -> x > 10).map(x -> x * 2)`라는 한 줄이 화면에 떠오르는 순간, 우리는 모두 조용해졌고 누군가가 속삭였다. “이건 자바가 아니잖아.” 사실 자바였고, 그날 이후 나는 스트림 API에 흠뻑 빠졌다.

기존의 `for` 루프와 `Iterator`를 돌며 조건문을 일일이 추가하던 습관에서 벗어나, 선언형으로 데이터 흐름을 표기하는 방식은 내 사고방식을 바꿨다. 스트림 체인을 구성할 때마다 `filter`, `map`, `flatMap`, `distinct`, `sorted`가 하나의 문장처럼 연결되었다. “어떤 데이터가 어디로 흐르고 있는지”가 명확했기 때문에, 코드를 읽는 시간이 크게 줄어들었다. 처음에는 함수형 인터페이스와 람다 문법이 낯설었지만, 곧 익숙해졌다. 동료들과 우리는 서로의 코드에 람다를 가장 자연스럽게 녹여 넣는 방법을 자랑하곤 했다.

그러나 스트림은 단순한 문법 변환이 아니었다. 중간 연산이 지연 계산(lazy evaluation)된다는 사실을 이해하자, 성능을 가늠하는 눈이 생겼다. `.map().filter()`와 `.filter().map()`의 순서를 바꾸는 것만으로도 실행 시간이 달라졌고, `peek()`를 잘못 사용하면 전체 파이프라인을 이해하기 어려워졌다. 컬렉터(`Collectors.toList()`, `toMap()`, `groupingBy()`)의 강력함은 데이터를 집계하는 시나리오를 크게 단순화해 줬다. 특히 `groupingBy`와 `mapping`을 중첩해서 사용하는 순간, 나는 “SQL 대신 이걸 쓸 수 있는 영역이 있겠구나”라고 생각했다.

동료들과 병렬 스트림에 대한 실험도 자주 했다. `.parallel()`을 붙이는 것이 만능이라고 생각했던 시절, 작은 데이터셋에서 오히려 성능이 저하되는 현상을 목격했다. 포크조인 풀의 기본 스레드 수를 이해하고, CPU 코어 수보다 많은 병렬 작업을 던지는 것이 항상 이득은 아니라는 사실을 깨달았다. 우리는 집계 연산이 병렬 실행에 적합한지, 변환 함수가 thread-safe한지, 박싱/언박싱 비용이 낭비되는지 매번 체크했다. 스트림 파이프라인을 빌드할 때마다 벤치마크를 작성한 덕분에, “병렬은 선택 사항이다”라는 문장을 팀 내 표어처럼 붙여 두었다.

`Optional`과 함께 사용하면서 스트림은 더욱 진가를 발휘했다. 널 체크 대신 스트림으로 컬렉션을 흘려보내고, `findFirst`, `orElse` 같은 메서드들을 조합하면 코드가 의도대로 읽혔다. 다만, 스트림이 항상 정답은 아니었다. 복잡한 상태를 다뤄야 하거나, 누적 로직을 세밀하게 제어해야 하는 경우에는 전통적인 루프가 더 명확했다. 우리는 “스트림은 읽기 쉽고 선언적인 로직에만 쓰자”라는 규칙을 정했다. 남용을 경계하되, 필요할 때는 주저하지 않는 균형감이 필요했다.

Collector 커스터마이징을 위한 `Collector.of()`는 또 다른 모험이었다. 불변 리스트를 반환하거나, 특정 순서를 유지하며 병렬 실행 시 combiner가 어떻게 동작하는지 실험했다. Mutable reduction이 부적절하면 데이터 무결성이 깨지고, 병렬 파이프라인에서 예기치 않게 순서가 바뀔 수 있다는 사실을 문서에 기록했다. 스트림 API가 제공하는 계약을 지키는 것이 얼마나 중요한지 새삼 깨달았다.

시간이 지나면서 스트림은 내 일상의 일부가 되었다. `Stream.iterate`, `Stream.generate`로 무한 스트림을 만들고 제한을 걸어 테스트 데이터를 생성하기도 했다. Kotlin이나 Python의 제너레이터와도 비교해 보며, 자바가 제공하는 함수형 도구상자에 점점 익숙해졌다. 무엇보다, 스트림 파이프라인을 리뷰할 때마다 “이 흐름이 비슷한 로직을 반복하는 다른 팀에게도 도움이 될까?”를 묻는 습관이 생겼다.

오늘도 Pull Request를 살펴보다가 스트림을 사용할 수 있는 부분을 발견했다. 기존의 중첩 루프를 스트림으로 바꾸고, `.collect(Collectors.groupingBy())`로 데이터를 정리했다. 리뷰 코멘트에는 “읽기 흐름이 훨씬 명확해졌네요”라는 피드백이 달렸다. 스트림 API가 코드를 단순히 줄이기 위한 것이 아니라, 의도를 더 명확히 표현하고 협업을 돕는 도구라는 사실을 다시 한번 느꼈다. 람다와 파이프라인 사이를 오가며 보냈던 밤들이 오늘의 나를 만들었다는 사실에, 나는 조용히 웃어 본다.

```

### java-through-my-bytecode-journal.md

**Path:** `frontend/public/posts/2025/java-through-my-bytecode-journal.md`

```markdown
---
title: "바이트코드 기차를 타고 자바 세계를 일주한 날"
date: "2025-10-20"
category: "Java"
tags: ['Java', 'JVM', '자료형', '연산자', '객체지향']
excerpt: "Write once, run anywhere라는 간판을 붙인 자바의 철도를 따라가며, JDK에서 GC까지 몸소 느꼈던 이야기와 살아 있는 코드 메모"
readTime: "12분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**
![java train](../../images/2025/javatrain.png)
처음 자바를 만났을 때, 저는 "바이트 코드"라는 단어가 주는 은근한 낭만에 빠졌습니다. 고수준 언어에서 쓴 편지가 바이트코드 기차를 타고 JVM이라는 역을 거쳐 기계어라는 목적지에 도착한다는 상상을 하면, 코드 한 줄도 갑자기 여행 일지처럼 느껴졌거든요. 오늘은 그 여행에서 건져 올린 기록과, 그때그때 썼던 코드 스케치를 공유하려 합니다.

## 1. 바이트코드 기차가 달리는 법: 컴파일과 JVM의 무대 장치

자바는 항상 “Write once, run anywhere”라는 표어를 들고 다닙니다. 종이에 쓴 연애편지가 나라를 건너도 마음을 전하듯, 자바 소스(.java)는 어디서 컴파일되든 **바이트 코드(.class)**로 변환되고, JVM만 있다면 어떤 플랫폼에서도 동일하게 읽을 수 있습니다. 이게 바로 플랫폼 독립성이라는 이름의 마술입니다.

```java
// HelloWaldo.java
public class HelloWaldo {
    public static void main(String[] args) {
        System.out.println("자바야 안녕, 내 이름은 왈도라고 해.");
    }
}
```

이 코드를 `javac HelloWaldo.java`로 컴파일하면 `HelloWaldo.class`라는 바이트 코드가 생기고, 그 파일은 리눅스든 윈도우든 JVM이 설치된 곳이라면 모두 `java HelloWaldo`로 실행됩니다.

### 1.1 바이트코드를 톺아보는 호기심

```bash
$ javac HelloWaldo.java
$ javap -c HelloWaldo
Compiled from "HelloWaldo.java"
public class HelloWaldo {
  public HelloWaldo();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #3                  // String 자바야 안녕, 내 이름은 왈도라고 해.
       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return
}
```

`getstatic`, `ldc`, `invokevirtual`… 이 바이트코드 목록은 마치 철도차량 운행 시간표처럼 JVM에게 정확한 순서를 알려 줍니다. 이 시간표를 해석하는 기관사가 바로 JVM이죠.

## 2. JDK와 JRE: 역무원과 승객의 차이

자바 세계에는 두 가지 주요 인물이 있습니다.

- **JDK (Java Development Kit)**: 자바 코드를 작성하고, 바이트코드 기차를 만들도록 돕는 역무원. 컴파일러(`javac`), 디버거(`jdb`), 아카이브 도구(`jar`)가 들어 있습니다.
- **JRE (Java Runtime Environment)**: 이미 만들어진 바이트코드 기차를 타고 목적지까지 가고 싶은 승객. JVM과 핵심 라이브러리가 들어 있으며, 개발 관련 도구는 없습니다.

이클립스나 인텔리제이는 이 역무원과 승객을 한꺼번에 관리해 주는 종합 안내소 같은 존재죠.

## 3. 자바 프로젝트를 세우는 다섯 단계와 JVM 메모리 지도

### 3.1 다섯 단계의 공사 과정

1. **프로젝트 생성** – "도시"의 토대를 놓습니다.
2. **패키지 생성** – 행정구역을 나누듯 패키지를 만들어 클래스의 주소를 정리합니다.
3. **소스 파일 생성** – 설계도를 그립니다.
4. **컴파일** – 설계도를 바이트코드 기차로 변환합니다.
5. **실행** – JVM에 기차가 들어와 main()이라는 플랫폼에서 출발합니다.

```java
package mypack;

public class Test {
    public static void main(String[] args) {
        System.out.println("바이트코드 기차 출발!");
    }
}

class SideKick {}
class SecondSideKick {}
class ThirdSideKick {}
```

컴파일 후에는 `Test.class`뿐 아니라 `SideKick.class`, `SecondSideKick.class` 등이 따로 생기니, 하나의 파일에 여러 기차가 동시에 있는 셈입니다.

### 3.2 JVM 메모리의 3구역

| 영역 | 비유 | 저장되는 것 |
| --- | --- | --- |
| 메서드 영역 (Method Area) | 도시의 설계 자료실 | 클래스 구조, static 변수, 상수 |
| 힙 (Heap) | 주거 지역 | 객체와 배열 |
| 스택 (Stack) | 골목길 | 메서드 호출 정보, 지역 변수, 참조값 |

```java
public class MemorySketch {
    static String cityName = "Byteville"; // 메서드 영역

    public static void main(String[] args) {
        int tickets = 3;                 // 스택
        Passenger p = new Passenger();   // 스택에는 참조값, 힙에는 객체
        p.name = "Waldo";
        p.printTicket(tickets);
    }
}

class Passenger {
    String name; // 힙에 저장되는 인스턴스 변수

    void printTicket(int count) {
        System.out.println(name + "님의 티켓은 " + count + "장입니다.");
    }
}
```

## 4. System.out 시리즈: 마이크 3종 세트

```java
System.out.println("한 줄 끝에 자동 개행");
System.out.print("개행 없음");
System.out.print("\n을 붙여야 \n 개행");
System.out.printf("%s: %,d원\n", "승차권", 120000);
System.out.printf("현재 온도는 %4.1f℃입니다.%n", 27.345);
```

- `println`: 발표 후 박수 유도용 자동 개행 마이크.
- `print`: 독백을 이어갈 때 사용하는 마이크.
- `printf`: 형식 지정이 가능한 프로 방송용 마이크.

## 5. 자료형과 변수: 여행객과 짐칸의 규칙

### 5.1 기본형 vs 참조형

| 구분 | 비유 | 메모리 위치 |
| --- | --- | --- |
| 기본 자료형 | 수하물 태그에 직접 적힌 숫자 | 스택 |
| 참조 자료형 | 짐 보관소 번호표 | 스택에 주소, 힙에 실제 데이터 |

```java
int seatNo = 15;                // 스택에 값 15 저장
String passengerName = "Waldo"; // 스택에는 참조값, 힙에는 문자열 객체
```

### 5.2 리터럴과 캐스팅

```java
float f = 3.14F;      // float에는 F 필수
double d = 3.141592;  // 기본 실수 리터럴 타입은 double
char c = 'A';         // 유니코드 문자 (내부적으로 65)

byte small = 10;
int big = small;      // 업캐스팅 (자동)
byte wrap = (byte)128;// 다운캐스팅 (데이터 손실 -> -128)
```

### 5.3 문자열 & 래퍼 클래스

```java
String station1 = "Seoul";
String station2 = "Seoul";
String station3 = new String("Seoul");

System.out.println(station1 == station2); // true (상수 풀 공유)
System.out.println(station1 == station3); // false (새 객체)
System.out.println(station1.equals(station3)); // true (내용 비교)

int tickets = Integer.parseInt("42");
double price = Double.parseDouble("1250.50");
```

## 6. 연산자: 레일 위의 신호 체계

### 6.1 증감과 비트 연산자

```java
int i = 5;
System.out.println(++i); // 6, 전위형
System.out.println(i++); // 6 출력 후 i = 7
System.out.println(i);   // 7

int a = 0b1010, b = 0b1100;
System.out.println(Integer.toBinaryString(a & b)); // 1000
System.out.println(Integer.toBinaryString(a | b)); // 1110
System.out.println(Integer.toBinaryString(a ^ b)); // 0110
System.out.println(Integer.toBinaryString(~a));    // ...11110101
```

### 6.2 쉬프트 연산자

```java
int pos = 0b00000101;
System.out.println(Integer.toBinaryString(pos << 2)); // 10100 (left shift)

int neg = 0b10000101; // -123 (2's complement)
System.out.println(Integer.toBinaryString(neg >> 2));  // 산술 시프트 -> 11100001
System.out.println(Integer.toBinaryString(neg >>> 2)); // 논리 시프트 -> 00100001
```

### 6.3 비교와 논리 연산자

```java
String routeA = "Seoul-Busan";
String routeB = "Seoul-Busan";
String routeC = new String("Seoul-Busan");

System.out.println(routeA == routeB);       // true
System.out.println(routeA == routeC);       // false
System.out.println(routeA.equals(routeC));  // true

int passengers = 50;
boolean trainReady = false;
if (passengers > 0 && trainReady) {
    System.out.println("출발!");
} else {
    System.out.println("대기 중...");
}
```

## 7. 제어문: 신호등과 환승역

### 7.1 if-else & switch

```java
Scanner sc = new Scanner(System.in);
int ticket = sc.nextInt();

if (ticket % 2 == 0) {
    System.out.println("짝수 티켓");
} else {
    System.out.println("홀수 티켓");
}

int station = sc.nextInt();
switch (station) {
    case 1:
        System.out.println("1번 승강장");
        break;
    case 2:
    case 3:
        System.out.println("2번 또는 3번 승강장");
        break;
    default:
        System.out.println("기타 승강장");
}
```

### 7.2 반복문과 레이블

```java
// while + break
while (true) {
    int grade = sc.nextInt();
    if (grade < 0) {
        System.out.println("입력 종료");
        break;
    }
    System.out.println("학점: " + grade);
}

// 레이블을 이용한 다중 루프 탈출
outer:
for (int r = 0; r < 3; r++) {
    for (int c = 0; c < 3; c++) {
        if (r == 1 && c == 1) {
            System.out.println("중앙 좌석 발견!");
            break outer; // 바로 outer 루프 탈출
        }
    }
}
```

## 8. 배열과 참조 복사: 동일 승강장 티켓의 주의점

```java
int[] a = new int[3];  // [0,0,0]
int[] b = a;           // 얕은 복사 -> 같은 힙 객체 가리킴

Arrays.fill(a, 7);
System.out.println(Arrays.toString(a)); // [7,7,7]
System.out.println(Arrays.toString(b)); // [7,7,7]

// 깊은 복사가 필요하다면
int[] c = Arrays.copyOf(a, a.length);
a[0] = 99;
System.out.println(Arrays.toString(a)); // [99,7,7]
System.out.println(Arrays.toString(c)); // [7,7,7]
```

## 9. 클래스와 객체: 열차 설계와 운행의 정석

```java
class Train {
    String name;
    int seats;
    double speed;

    Train(String name, int seats, double speed) {
        this.name = name;
        this.seats = seats;
        this.speed = speed;
    }

    void printInfo() {
        System.out.printf("%s (%d석, 최고 %.1fkm/h)%n", name, seats, speed);
    }
}

public class Station {
    public static void main(String[] args) {
        Train t = new Train("Byte Express", 120, 305.5);
        t.printInfo();
    }
}
```

### 9.1 메서드 오버로딩 & 가변 인자

```java
class MathUtils {
    int square(int i) {
        return i * i;
    }

    double square(double d) {
        return d * d;
    }

    int sum(int... values) { // 가변 길이 매개변수 -> 배열처럼 순회 가능
        int total = 0;
        for (int v : values) {
            total += v;
        }
        return total;
    }
}

MathUtils mu = new MathUtils();
System.out.println(mu.square(5));      // 25
System.out.println(mu.square(2.5));    // 6.25
System.out.println(mu.sum(1,2,3,4,5)); // 15
```

## 10. this와 this(): 동일 열차 내부의 환승

```java
class Journey {
    String traveler;
    String destination;
    int days;

    Journey() {
        this("무명", "알 수 없음", 0);
    }

    Journey(String traveler, String destination) {
        this(traveler, destination, 1);
    }

    Journey(String traveler, String destination, int days) {
        this.traveler = traveler;
        this.destination = destination;
        this.days = days;
    }

    void print() {
        System.out.printf("%s님의 목적지: %s (체류 %d일)%n", traveler, destination, days);
    }
}
```

## 11. Getter & Setter: 탑승객 정보 보호 장치

```java
class PassengerInfo {
    private int age;
    private String phone;

    public boolean setAge(int age) {
        if (age < 0) return false;
        this.age = age;
        return true;
    }

    public int getAge() {
        return age;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getPhone() {
        return phone;
    }
}
```

## 12. 상속과 오버라이딩: 열차 클래스의 계보

```java
class Train {
    protected String name;
    protected double price;

    public Train(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public void printTicket() {
        System.out.printf("%s 티켓 가격: %.0f원%n", name, price);
    }
}

class SleeperTrain extends Train {
    private int cabins;

    public SleeperTrain(String name, double price, int cabins) {
        super(name, price); // 부모 생성자 호출
        this.cabins = cabins;
    }

    @Override
    public void printTicket() {
        super.printTicket();
        System.out.printf("침대칸 수: %d개%n", cabins);
    }
}
```

## 13. super()와 생성자 호출 순서

```java
class BaseStation {
    public BaseStation(String city) {
        System.out.println("기지 역: " + city);
    }
}

class BranchStation extends BaseStation {
    public BranchStation() {
        super("서울");
        System.out.println("분기 역 준비 완료");
    }
}

// 실행
BranchStation bs = new BranchStation();
// 출력:
// 기지 역: 서울
// 분기 역 준비 완료
```

## 14. 멀티스레드와 분산 처리: 여러 기차의 동시 운행

자바는 **멀티스레드**를 통해 하나의 프로그램에서 여러 작업을 동시에 진행하려 합니다. 또한 RMI, gRPC 같은 분산 기술과 함께 쓰이면 여러 역(서버)이 협업하는 장대한 네트워크를 만들 수 있습니다.

```java
class TrainTask implements Runnable {
    private final String name;

    TrainTask(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 3; i++) {
            System.out.printf("[%s] %dkm 이동 중...%n", name, i * 50);
            try { Thread.sleep(500); } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.printf("[%s] 종착역 도착!%n", name);
    }
}

public class MultiTrain {
    public static void main(String[] args) {
        Thread t1 = new Thread(new TrainTask("KTX"));
        Thread t2 = new Thread(new TrainTask("SRT"));
        t1.start();
        t2.start();
    }
}
```

자바가 함수형 코딩을 지원하기 시작하면서, 위 코드를 람다로 줄여서 표현할 수도 있습니다.

```java
public class MultiTrainLambda {
    public static void main(String[] args) {
        Runnable task = () -> {
            String name = Thread.currentThread().getName();
            for (int i = 1; i <= 3; i++) {
                System.out.printf("[%s] %dkm 이동 중...%n", name, i * 50);
                try { Thread.sleep(500); } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            System.out.printf("[%s] 종착역 도착!%n", name);
        };

        new Thread(task, "EMU").start();
        new Thread(task, "NightExpress").start();
    }
}
```

## 15. 분산 시스템에서의 JVM

JVM은 각 플랫폼에서 설치된 지역 역무원입니다. 각 역무원이 같은 바이트코드 기차를 받아 자신만의 철로에서 달리게 해 줍니다. 이 덕분에, 대규모 시스템에서 서로 다른 운영체제를 사용하는 서버들이 같은 애플리케이션을 협력해서 돌릴 수 있습니다. 스프링 부트 같은 프레임워크는 이 철도를 기반으로 도시 전체에 버스를 돌리듯, 마이크로서비스의 흐름을 관리합니다.

## 16. 마무리: 다시 바이트코드 기차 승강장에서

자바는 고수준 언어의 편안함과 가상 머신의 견고함 위에, 객체지향과 함수형 패러다임, 멀티스레드, 분산 처리를 착실하게 쌓아 올렸습니다. 바이트코드 기차는 지금도 JVM 승강장에서 "다음 역은 GC(가비지 컬렉션)입니다"라고 안내 방송을 하고 있을 겁니다.

앞으로 자바를 또 만난다면 이렇게 말해 줄 거예요. "당신 덕분에 우리는 어디서든 같은 기차를 타고 만나게 되었고, 때로는 깐깐한 타입 캐스팅 검사 덕분에 큰 사고를 막기도 했지." 그리고 제 IDE는 오늘도 초록 불을 깜박이며 새 기차를 만들 준비를 하고 있습니다.

```

### k8s-overview.md

**Path:** `frontend/public/posts/2025/k8s-overview.md`

```markdown
---
title: "쿠버네티스 기본 구조"
date: "2025-12-02"
category: "Kubernetes"
tags: ['Kubernetes', 'DevOps', 'Cloud Native', '컨테이너 오케스트레이션']
excerpt: "전통적 배포 방식부터 쿠버네티스 에코시스템까지, 개념을 정리하는 글"
readTime: "15분"
---
클라우드 네이티브 이야기를 할 때 빠지지 않는 단어가 있습니다. 바로 **쿠버네티스(Kubernetes)** 입니다. 하지만 "쿠버네티스가 뭔지는 알겠는데, 전체 그림이 머릿속에서 한 번에 그려지진 않는다"는 이야기를 자주 듣습니다.

이 글은 그런 분들을 위해 준비한 **개념 지도(Overview)** 입니다. 전통적인 배포 방식에서 출발해 클러스터 프로비저닝, 네트워크, 스토리지, CI/CD, 관측 가능성, 보안, 고급 워크로드와 트러블슈팅까지 한 번에 훑어보도록 구성했습니다.

---

## 1. 전통적 배포에서 컨테이너 시대로

쿠버네티스를 이해하려면 먼저 **배포 방식이 어떻게 진화해 왔는지** 살펴보는 것이 좋습니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-deployment-era-traditional-virtualized-container.png" alt="전통적 배포, 가상화 배포, 컨테이너 배포 비교">
</div>

- **전통적 배포**: 물리 서버에 애플리케이션을 직접 올리던 시절. 리소스 격리가 부족하고 확장성이 떨어집니다.
- **가상화 배포**: 하이퍼바이저 위에 VM을 여러 개 올려 격리와 자원 활용을 개선했지만, 각 VM이 완전한 OS를 포함해 여전히 무겁습니다.
- **컨테이너 배포**: OS 커널을 공유하면서 프로세스를 컨테이너 단위로 격리합니다. 경량이면서도 빠르게 배포/롤백할 수 있어, 대규모 시스템의 기본 단위가 되었습니다.

쿠버네티스는 바로 이 **컨테이너 시대의 운영체제** 역할을 합니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-core-features-self-healing-rollouts-scaling.png" alt="쿠버네티스 핵심 기능: 자동화된 복구, 롤아웃/롤백, 수평 확장">
</div>

위와 같은 기능, 예를 들어 **Self-Healing, 자동 롤아웃/롤백, 수평 확장(HPA)** 가 쿠버네티스가 제공하는 기본 가치입니다.

---

## 2. 쿠버네티스 에코시스템 한눈에 보기

쿠버네티스는 단일 제품이 아니라, 수많은 도구와 플랫폼이 얽혀 있는 **거대한 생태계**입니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-platform-stack-from-core-to-security.png" alt="쿠버네티스 플랫폼 스택: 클러스터 프로비저닝부터 보안까지 계층별 구성 요소">
</div>

위 그림처럼, 클러스터 프로비저닝/핵심 런타임, 네트워크와 스토리지, CI/CD, 모니터링, 보안, 고급 워크로드까지 계층적으로 쌓여 있는 구조로 이해하면 전체 그림을 잡기 쉽습니다.

---

## 3. 클러스터 프로비저닝과 컨테이너 런타임

쿠버네티스를 실제로 설치하고 운영하기 위해서는 **클러스터를 어떻게 만들 것인가**, 그리고 **컨테이너를 어떤 런타임으로 실행할 것인가**를 먼저 결정해야 합니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-cluster-provisioning-kubeadm-kubespray-terraform.png" alt="kubeadm, Kubespray, Terraform을 이용한 클러스터 프로비저닝 옵션">
</div>

- **kubeadm**: 쿠버네티스 공식 CLI 도구로, 가장 기본적인 설치 방법입니다.
- **Kubespray**: Ansible 기반으로 멀티 노드 클러스터를 자동으로 구성합니다.
- **Terraform**: 클라우드 인프라를 코드로 선언(IaC)하여, 노드와 네트워크까지 한 번에 준비할 수 있습니다.

런타임 측면에서는 `containerd`가 사실상 표준이 되었습니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-container-runtime-containerd.png" alt="컨테이너 런타임 containerd 개요">
</div>

도커의 `dockershim`이 제거된 이후, 대다수 배포판에서 `containerd`가 기본 런타임으로 채택되고 있습니다.

---

## 4. 네트워크와 스토리지 기본기

쿠버네티스는 추상화를 제공할 뿐, 실제 네트워크와 스토리지는 별도의 플러그인과 솔루션이 담당합니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-networking-cni-calico-cilium-metallb-ingress.png" alt="CNI, Calico, Cilium, MetalLB, Ingress 컨트롤러로 구성된 네트워크 계층">
</div>

- **CNI 플러그인(Calico, Cilium 등)**: 파드 간 통신과 네트워크 정책을 담당합니다.
- **MetalLB, Ingress Controller**: 외부에서 서비스에 접근할 수 있도록 LoadBalancer/Ingress를 제공합니다.

스토리지는 **Kubernetes Storage Model**을 통해 추상화됩니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-storage-model-rook-ceph-velero.png" alt="StorageClass, PVC, PV와 Rook, Ceph, Velero를 활용한 스토리지와 백업 솔루션">
</div>

- `StorageClass` / `PVC` / `PV` 개념을 기반으로 동적 프로비저닝을 지원합니다.
- **Rook + Ceph**: 클러스터 내부에 분산 스토리지를 구성할 때 널리 쓰이는 조합입니다.
- **Velero**: 네임스페이스/볼륨 단위 백업, 복원, 마이그레이션에 활용됩니다.

---

## 5. CI/CD와 GitOps, 이미지 레지스트리

애플리케이션을 지속적으로 배포하려면 **CI/CD 파이프라인과 컨테이너 이미지 레지스트리**가 필요합니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-cicd-github-actions-jenkins-gitlab-argocd.png" alt="GitHub Actions, Jenkins, GitLab CI/CD, ArgoCD로 구성된 CI/CD와 GitOps 흐름">
</div>

- **GitHub Actions, Jenkins, GitLab CI/CD**: 코드 커밋부터 컨테이너 이미지 빌드, 배포까지 자동화합니다.
- **ArgoCD**: Git 리포지토리를 단일 진실 공급원(SSOT)으로 사용하는 GitOps 도구입니다.

이미지는 보통 중앙 레지스트리에 저장하고, 취약점 스캔과 서명 등 보안 기능을 붙입니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-registry-harbor-trivy-notary-docker-build.png" alt="Harbor, Trivy, Notary, Docker 빌드 도구를 이용한 이미지 레지스트리와 보안">
</div>

Harbor와 같은 레지스트리는 **Trivy, Notary** 등과 결합해 이미지 스캔과 서명, 정책 기반 배포 제어까지 수행할 수 있습니다.

---

## 6. 관측 가능성과 운영 모니터링

안정적인 운영을 위해서는 **Metrics, Logs, Traces** 관점의 관측 가능성이 필수입니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-observability-opentelemetry-prometheus-grafana.png" alt="OpenTelemetry, Prometheus, Grafana, Fluent Bit, Elasticsearch, Jaeger로 구성된 관측 가능성 스택">
</div>

- **OpenTelemetry**: 로그, 메트릭, 트레이스를 벤더 중립적으로 수집하는 표준입니다.
- **Prometheus + Grafana**: 메트릭 수집과 대시보드 시각화의 사실상 표준 조합입니다.
- **Fluent Bit + Elasticsearch**: 로그 수집과 검색에 활용됩니다.
- **Jaeger**: 분산 트레이싱으로 마이크로서비스의 병목을 분석할 수 있습니다.

---

## 7. 보안과 서비스 메쉬, 고급 워크로드

클러스터가 커질수록 **접근 제어와 비밀 정보 관리, 런타임 보안, 서비스 메쉬, 서버리스, ML 워크로드**가 중요해집니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-security-access-teleport-keycloak-vault.png" alt="Teleport, Keycloak, Vault로 구성된 접근 제어와 비밀 정보 관리">
</div>

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-runtime-security-falco-best-practices.png" alt="Falco와 컨테이너 런타임 보안 베스트 프랙티스">
</div>

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-service-mesh-istio-and-serverless-knative.png" alt="서비스 메쉬 Istio와 서버리스 Knative 개요">
</div>

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-advanced-kubevirt-kubeflow.png" alt="KubeVirt와 Kubeflow로 확장된 쿠버네티스 워크로드">
</div>

쿠버네티스는 이제 단순한 컨테이너 오케스트레이션을 넘어, **서비스 메쉬, 서버리스, 머신러닝 파이프라인**까지 포괄하는 플랫폼으로 진화하고 있습니다.

---

## 8. 트러블슈팅을 위한 첫 번째 표

마지막으로, 실제 운영에서 자주 마주치는 **파드(Pod) 상태 문제**를 요약한 표를 한 번에 볼 수 있습니다.

<div style="text-align: center; margin-bottom: 20px; margin-top: 20px;">
<img src="../../images/2025/k8s/k8s-troubleshooting-pod-symptoms-table.png" alt="Pod 상태와 의미, kubectl로 진단하는 방법, 흔한 원인 정리 표">
</div>

각 증상별로 `kubectl describe pod`, `kubectl logs`로 어떤 정보를 확인해야 하는지, 그리고 리소스 부족/이미지 풀 실패/프로브 실패와 같은 흔한 원인이 무엇인지 한눈에 정리되어 있습니다.

---

이 글은 쿠버네티스의 **전체 지도를 한 번 훑어보는 용도**로 봐 주시면 좋겠습니다. 세부 설정과 실습은 각 섹션을 따로 파고드는 글에서 다루고, 여기서는 "어디에 무엇이 있는지"를 기억할 수 있도록 그림과 함께 개념의 위치를 잡아 두는 것이 목표입니다.

```

### kafka-01-concepts-architecture.md

**Path:** `frontend/public/posts/2025/kafka-01-concepts-architecture.md`

```markdown
---
title: "Kafka 핵심 개념과 아키텍처"
date: "2025-01-14"
category: "DevOps"
tags: ["DevOps","Kafka","Streaming","아키텍처","초급"]
excerpt: "Topic, Partition, Broker, Replication, Producer/Consumer와 Consumer Group까지 Kafka 구조를 시각적으로 이해."
author: "Admin"
published: true
---

# Kafka 개념 및 아키텍처

##  개요
Apache Kafka는 고성능 분산 이벤트 스트리밍 플랫폼으로 실시간 데이터 파이프라인과 스트리밍 애플리케이션을 구축하는 데 사용됩니다.

##  학습 목표
- Kafka 핵심 개념 이해
- 아키텍처 구성 요소 파악
- 메시지 저장/전송 메커니즘 흐름 이해

##  전체 아키텍처 (요약)
```
Kafka Cluster
  Broker 1  Broker 2  Broker 3
  ├─ Topic-A (P0,P1,P2)
  └─ Topic-B (P0,P1,P2)
Producer → (Partitions) ← Consumer Group(s)
```

##  핵심 개념
### Topic
메시지가 저장되는 논리적 카테고리.
특징: append-only, retention 기간 내 유지.

### Partition
Topic을 나누는 단위로 병렬 처리와 스케일링 핵심.
Key 기반 라우팅 혹은 라운드로빈.

### Broker
Kafka 서버 인스턴스. Partition Leader/Follower 역할 수행.

### Replication
고가용성 확보. ISR(In-Sync Replica) 개념으로 Leader 장애 시 선출.

### Producer
메시지를 Topic에 발행.
```java
props.put("acks", "all"); // 신뢰성 향상
```

### Consumer & Consumer Group
Group 내에서 Partition을 분배 처리. 다른 Group은 독립 소비.
Rebalancing 시 Partition 재할당.

##  메시지 구성
```
Offset | Timestamp | Key | Value | Headers
```
Offset은 Partition 내 일련번호. Consumer는 __consumer_offsets에 커밋.

커밋 전략: auto / manual sync / manual async.

##  데이터 흐름
### Write Path
1. Producer → Leader → Followers 복제 → acks 설정에 따른 응답

### Read Path
1. Consumer Fetch 요청 → Broker 전달 → 처리 후 Offset 커밋

##  사용 사례 패턴
1. 주문 처리 시스템: orders Topic → 결제/알림 서비스
2. 로그 수집: logs Topic → ES / S3 아카이브
3. 이벤트 소싱: user-events → 분석 / ML 학습

##  주요 설정 (발췌)
| 설정 | 설명 | 권장 |
|------|------|------|
| num.partitions | Partition 수 | Consumer 병렬성 고려 |
| replication.factor | 복제 수 | 3 (프로덕션) |
| retention.ms | 보관 기간 | 용도별 조정 |
| compression.type | 압축 방식 | snappy/lz4 |

### Producer
```properties
acks=all
retries=2147483647
compression.type=snappy
```
### Consumer
```properties
enable.auto.commit=true
auto.offset.reset=latest
```

##  Kafka vs 전통 메시지 큐 (요약)
- 저장 방식: 디스크(영구) vs 메모리 중심
- 재처리: Offset 기반 자유 vs 어려움
- 확장성: 수평 확장 용이 vs 제한적

##  설계 원칙
Partition 수 결정: 예상 처리량 / 단일 Consumer 처리량.
Replication Factor: 프로덕션 3, 테스트 1.
Key 설계: 동일 엔티티 이벤트 순서 보존.

## ▶ 다음 단계
- [Kafka 로컬 설치 및 실행](kafka-02-installation-setup.md)
- Producer/Consumer 실습 (예정)

##  참고 자료
- 공식 문서: https://kafka.apache.org/documentation/
- Confluent 소개: https://docs.confluent.io/

```

### kafka-02-installation-setup.md

**Path:** `frontend/public/posts/2025/kafka-02-installation-setup.md`

```markdown
---
title: "Kafka 로컬 설치: Docker & 네이티브"
date: "2025-01-15"
category: "DevOps"
tags: ["DevOps","Kafka","설치","Docker","실습"]
excerpt: "Docker Compose로 3 Broker 클러스터 구성과 네이티브 설치 두 가지 방식 비교, 기본 명령어/Topic/Consumer Group 실습."
author: "Admin"
published: true
---

# Kafka 로컬 설치 및 실행

##  개요
로컬 환경에서 Kafka를 설치하고 Topic 생성, 메시지 발행/소비, Consumer Group 관리를 실습합니다. Docker Compose(권장)와 네이티브 두 방법을 다룹니다.

##  방법 1: Docker Compose (3 Broker + ZooKeeper + UI)
`docker-compose.yml` 요약:
```yaml
version: '3.8'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    ports: ["2181:2181"]
  kafka1:
    image: confluentinc/cp-kafka:7.5.0
    ports: ["9092:9092"]
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka1:29092,PLAINTEXT_HOST://localhost:9092
  kafka2: # ... 동일 패턴
  kafka3: # ... 동일 패턴
  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    ports: ["8080:8080"]
```

실행:
```bash
docker-compose up -d
docker-compose ps
docker-compose logs -f kafka1
```
종료/정리:
```bash
docker-compose down
docker-compose down -v  # 볼륨 포함 완전 삭제
```

##  방법 2: 네이티브 설치
```bash
wget https://downloads.apache.org/kafka/3.6.0/kafka_2.13-3.6.0.tgz
tar -xzf kafka_2.13-3.6.0.tgz
cd kafka_2.13-3.6.0
```
ZooKeeper & Broker 실행:
```bash
bin/zookeeper-server-start.sh -daemon config/zookeeper.properties
bin/kafka-server-start.sh -daemon config/server.properties
```
다중 Broker 구성: `server-1.properties`, `server-2.properties` 복사 및 포트/로그 디렉토리 변경 후 각각 실행.

##  Topic 관리 명령어
```bash
# 생성
kafka-topics --create --bootstrap-server localhost:9092 --topic my-topic --partitions 3 --replication-factor 3
# 목록
kafka-topics --list --bootstrap-server localhost:9092
# 상세
kafka-topics --describe --bootstrap-server localhost:9092 --topic my-topic
# 삭제
kafka-topics --delete --bootstrap-server localhost:9092 --topic my-topic
# Partition 수 증가
kafka-topics --alter --bootstrap-server localhost:9092 --topic my-topic --partitions 5
```

##  Console Producer / Consumer
Producer:
```bash
kafka-console-producer --bootstrap-server localhost:9092 --topic my-topic
# Key:Value 형식
kafka-console-producer --bootstrap-server localhost:9092 --topic my-topic \
  --property "parse.key=true" --property "key.separator=:"
```
Consumer:
```bash
kafka-console-consumer --bootstrap-server localhost:9092 --topic my-topic
kafka-console-consumer --bootstrap-server localhost:9092 --topic my-topic --from-beginning
kafka-console-consumer --bootstrap-server localhost:9092 --topic my-topic --from-beginning \
  --property print.key=true --property key.separator=":"
```
Consumer Group:
```bash
kafka-console-consumer --bootstrap-server localhost:9092 --topic my-topic --group my-group --from-beginning
```

##  Consumer Group 관리
```bash
kafka-consumer-groups --bootstrap-server localhost:9092 --list
kafka-consumer-groups --bootstrap-server localhost:9092 --group my-group --describe
# Offset 리셋 (주의)
kafka-consumer-groups --bootstrap-server localhost:9092 --group my-group --reset-offsets --to-earliest --topic my-topic --execute
```

##  상태/오프셋 확인
```bash
kafka-run-class kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic my-topic
```
출력 예:
```
my-topic:0:1234
my-topic:1:2345
my-topic:2:3456
```

##  Cluster 운영 확인
```bash
docker exec kafka1 ls -la /var/lib/kafka/data
```

##  성능 테스트 (선택)
```bash
kafka-producer-perf-test --topic perf-test --num-records 100000 --record-size 512 --throughput -1 --producer-props bootstrap.servers=localhost:9092 acks=all
kafka-consumer-perf-test --broker-list localhost:9092 --topic perf-test --messages 100000 --threads 1
```

##  트러블슈팅 요약
| 문제 | 원인 | 해결 |
|------|------|------|
| Connection to node -1 | Broker 미실행 | logs 확인 후 재시작 |
| Replication factor 오류 | Broker 수 부족 | RF 조정 또는 Broker 추가 |
| Topic 생성 Timeout | ZooKeeper 연결 문제 | ZooKeeper 상태 점검 (`echo stat | nc localhost 2181`) |
| 디스크 공간 부족 | 로그 누적 | retention 설정 조정 |

##  환경 정리
```bash
docker-compose down -v
rm -rf /tmp/kafka-logs* /tmp/zookeeper
```

## ▶ 다음 단계
- Producer/Consumer 실습 (예정)
- 토픽과 파티션 관리 (예정)

##  참고
- Quickstart: https://kafka.apache.org/quickstart
- Kafka UI: https://github.com/provectus/kafka-ui

```

### kafka-03-producer-consumer.md

**Path:** `frontend/public/posts/2025/kafka-03-producer-consumer.md`

```markdown
---
title: "Kafka Producer/Consumer 실습과 신뢰성 패턴"
date: "2025-02-17"
category: "DevOps"
tags: ["DevOps","Kafka","Producer","Consumer"]
excerpt: "준비 중: acks, retries, idempotent producer, consumer offset 전략."
author: "Admin"
published: false
---

예정: 동기/비동기 send, 배치(batch.size/linger.ms), 압축, idempotent producer 설정, 수동 커밋/재처리, dead-letter 토픽 패턴.

```

### kafka-04-topics-partitions.md

**Path:** `frontend/public/posts/2025/kafka-04-topics-partitions.md`

```markdown
---
title: "Kafka 토픽·파티션·스토리지 관리"
date: "2025-02-18"
category: "DevOps"
tags: ["DevOps","Kafka","Topic","Partition"]
excerpt: "준비 중: 파티션 설계, 리밸런싱, retention/compaction 전략."
author: "Admin"
published: false
---

예정: 파티션 수 산정 공식, 키 설계, ISR 모니터링, log compaction vs retention, 파티션 증가 영향 및 운영 체크리스트.

```

### kubernetes-01-cluster-setup.md

**Path:** `frontend/public/posts/2025/kubernetes-01-cluster-setup.md`

```markdown
---
title: "Kubernetes 로컬 클러스터 설치 (minikube·kind·Docker Desktop)"
date: "2025-01-16"
category: "DevOps"
tags: ["DevOps","Kubernetes","Cluster","minikube","kind"]
excerpt: "minikube, kind, Docker Desktop 세 가지 방법으로 로컬 K8s 클러스터 구성하고 kubectl 기본 명령을 익힌다."
author: "Admin"
published: true
---

# Kubernetes 클러스터 설정

##  개요
로컬 환경에서 Kubernetes 클러스터를 구성하는 세 가지 방법(minikube, kind, Docker Desktop)과 kubectl 기본 명령어를 학습합니다.

##  학습 목표
- 로컬 클러스터 설치
- kubectl 설치 및 사용
- 노드/네임스페이스/리소스 조회
- 첫 Deployment & Service 생성

##  kubectl 설치
### Linux
```bash
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl
sudo mv kubectl /usr/local/bin/
kubectl version --client
```
### macOS
```bash
brew install kubectl
```
### Windows
```powershell
choco install kubernetes-cli
```

##  옵션 1: minikube (권장)
```bash
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube
minikube start --driver=docker
minikube status
minikube dashboard
```
멀티 노드:
```bash
minikube start --nodes 3 --driver=docker
```
리소스 지정:
```bash
minikube start --cpus=4 --memory=8192 --disk-size=20g
```

##  옵션 2: kind
```bash
curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
chmod +x ./kind
sudo mv ./kind /usr/local/bin/kind
kind create cluster --name my-cluster
```
멀티 노드 설정 파일:
```yaml
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
- role: worker
- role: worker
```
```bash
kind create cluster --config kind-config.yaml --name multi-node
```

##  옵션 3: Docker Desktop
1. Docker Desktop 설치
2. Settings → Kubernetes → Enable 체크
3. Apply & Restart

##  클러스터 기본 확인
```bash
kubectl cluster-info
kubectl get nodes
kubectl describe node <node-name>
kubectl api-resources
kubectl api-versions
```

##  Context 관리
```bash
kubectl config get-contexts
kubectl config current-context
kubectl config use-context minikube
cat ~/.kube/config
```

##  네임스페이스
```bash
kubectl get ns
kubectl create namespace dev
kubectl config set-context --current --namespace=dev
kubectl get pods -n kube-system
kubectl get pods -A
```

##  리소스 조회/출력
```bash
kubectl get pods
kubectl get deployments
kubectl get services
kubectl get pods -o wide
kubectl get pod my-pod -o yaml
kubectl get pods -l app=nginx
```

##  첫 Deployment & Service
```bash
kubectl create deployment nginx --image=nginx:latest
kubectl get deployments,pods
kubectl expose deployment nginx --type=NodePort --port=80
kubectl get services
```
접속 (minikube):
```bash
minikube service nginx --url
```
포트포워드:
```bash
kubectl port-forward deployment/nginx 8080:80
```

##  스케일링
```bash
kubectl scale deployment nginx --replicas=5
kubectl get pods -w
```

##  정리
```bash
kubectl delete service nginx
kubectl delete deployment nginx
minikube stop && minikube delete
kind delete cluster --name my-cluster
```

##  실습 과제
1. 3 노드 클러스터 생성 후 nginx 3 replicas 배포 → 각 노드 분포 확인
2. development, staging, production 네임스페이스 생성 후 각 환경에 동일 Deployment 생성
3. metrics-server 활성화 후 `kubectl top nodes` 출력

##  자주 보는 문제
| 문제 | 원인 | 해결 |
|------|------|------|
| connection refused | 클러스터 미실행 | `minikube status`, 재시작 |
| Unable to connect to server | kubeconfig 오류 | context 변경/파일 확인 |
| Pod Pending | 리소스 부족 | describe로 원인 확인 후 리소스 증가 |
| ImagePullBackOff | 이미지 이름 오류 | 이미지 태그 확인 후 수정 |

## ▶ 다음 단계
- [Pod와 Deployment](kubernetes-02-pods-deployments.md)
- Service & Networking (예정)

##  참고
- Kubernetes Docs: https://kubernetes.io/docs/home/
- kubectl Cheatsheet: https://kubernetes.io/docs/reference/kubectl/cheatsheet/

```

### kubernetes-02-pods-deployments.md

**Path:** `frontend/public/posts/2025/kubernetes-02-pods-deployments.md`

```markdown
---
title: "Kubernetes Pod와 Deployment 핵심 실습"
date: "2025-01-17"
category: "DevOps"
tags: ["DevOps","Kubernetes","Pod","Deployment","실습"]
excerpt: "단일/멀티 컨테이너 Pod, Deployment 생성·스케일·롤링 업데이트·롤백·레이블·셀렉터·Probe까지 실무 핵심 정리."
author: "Admin"
published: true
---

# Kubernetes Pod와 Deployment

##  개요
Pod는 K8s 최소 배포 단위, Deployment는 ReplicaSet을 통해 Pod를 선언적으로 관리합니다. 여기서는 두 리소스의 필수 실습과 운영 패턴을 정리합니다.

##  학습 목표
- Pod 구조 & 생명주기 이해
- 단일/멀티 컨테이너 Pod 작성
- Deployment 롤링 업데이트/롤백
- Label & Selector 활용
- Liveness/Readiness/Startup Probe 적용

##  Pod 기본 개념
```
Pod
├─ Container 1 (Main)
├─ Container 2 (Sidecar)
└─ Shared: Network, Storage
```
상태: Pending → Running → Succeeded/Failed → Terminating

## ️ 단일 Pod 생성
```bash
kubectl run nginx-pod --image=nginx:latest
kubectl get pods
kubectl describe pod nginx-pod
kubectl logs nginx-pod
kubectl exec -it nginx-pod -- /bin/bash
kubectl delete pod nginx-pod
```
YAML (`pod-nginx.yaml`):
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    ports:
    - containerPort: 80
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
```

##  멀티 컨테이너 Pod (Sidecar)
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: multi-container-pod
spec:
  containers:
  - name: app
    image: nginx:latest
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
  - name: log-collector
    image: busybox
    command: ['sh','-c','tail -f /logs/access.log']
    volumeMounts:
    - name: shared-logs
      mountPath: /logs
  volumes:
  - name: shared-logs
    emptyDir: {}
```
```bash
kubectl apply -f pod-multi-container.yaml
kubectl logs multi-container-pod -c app
kubectl logs multi-container-pod -c log-collector
```

##  Deployment 생성
명령형:
```bash
kubectl create deployment nginx-deploy --image=nginx:1.21 --replicas=3
kubectl get deployments,replicasets,pods
```
선언형 (`deployment-nginx.yaml` 요약):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        ports:
        - containerPort: 80
        livenessProbe:
          httpGet: { path: /, port: 80 }
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet: { path: /, port: 80 }
          initialDelaySeconds: 5
          periodSeconds: 5
```
```bash
kubectl apply -f deployment-nginx.yaml
kubectl describe deployment nginx-deployment
```

##  롤링 업데이트 & 히스토리
```bash
kubectl set image deployment/nginx-deployment nginx=nginx:1.22
kubectl rollout status deployment/nginx-deployment
kubectl rollout history deployment/nginx-deployment
kubectl rollout undo deployment/nginx-deployment
```
전략 설정:
```yaml
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 2
    maxUnavailable: 1
```
업데이트 제어:
```bash
kubectl rollout pause deployment/nginx-deployment
kubectl rollout resume deployment/nginx-deployment
```

##  Label & Selector
레이블 추가/수정/삭제:
```bash
kubectl label pod nginx-pod env=staging
kubectl label pod nginx-pod env=production --overwrite
kubectl label pod nginx-pod env-
```
셀렉터 질의:
```bash
kubectl get pods -l app=nginx
kubectl get pods -l app=nginx,env=production
kubectl get pods -l 'env in (production,staging)'
```

##  Probe 유형 요약
| Probe | 목적 | 실패 시 |
|-------|------|---------|
| Liveness | 생존 체크 | 컨테이너 재시작 |
| Readiness | 트래픽 준비 | Service 대상 제외 |
| Startup | 느린 시작 보호 | 설정된 재시도 내 대기 |

예시:
```yaml
livenessProbe:
  httpGet: { path: /health, port: 8080 }
  initialDelaySeconds: 30
readinessProbe:
  httpGet: { path: /ready, port: 8080 }
  initialDelaySeconds: 5
startupProbe:
  httpGet: { path: /startup, port: 8080 }
  failureThreshold: 30
  periodSeconds: 10
```

##  실습 과제
1. 다중 Revision 히스토리 남긴 후 특정 revision으로 롤백
2. Blue/Green Deployment 라벨 `version=blue/green` 으로 나누어 Service 전환 시뮬레이션
3. CrashLoopBackOff 재현 후 로그 및 이전 컨테이너 로그 분석

##  문제 해결 패턴
| 상태 | 원인 | 해결 |
|------|------|------|
| ImagePullBackOff | 잘못된 이미지 | `kubectl describe` 로 오류 확인 후 이미지 수정 |
| CrashLoopBackOff | 앱 런타임 에러 | 이전 로그 `--previous` 확인, 환경변수/리소스 조정 |
| Pending | 리소스 부족 | `kubectl top nodes` 로 자원 확인 후 스케일 업 |

## ▶ 다음 단계
- Service & Networking (예정)
- ConfigMap & Secret (예정)

##  참고
- Pod Docs: https://kubernetes.io/docs/concepts/workloads/pods/
- Deployment Docs: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/

```

### kubernetes-03-services-networking.md

**Path:** `frontend/public/posts/2025/kubernetes-03-services-networking.md`

```markdown
---
title: "Kubernetes Service와 네트워킹"
date: "2025-02-24"
category: "DevOps"
tags: ["DevOps","Kubernetes","Service","Networking"]
excerpt: "준비 중: ClusterIP, NodePort, LoadBalancer, Ingress, DNS 내부 구조."
author: "Admin"
published: false
---

예정: Service 타입 비교, kube-proxy 동작, Ingress Controller 선택, 외부 vs 내부 트래픽 경로, 서비스 디스커버리 패턴.

```

### kubernetes-04-configmap-secret.md

**Path:** `frontend/public/posts/2025/kubernetes-04-configmap-secret.md`

```markdown
---
title: "Kubernetes ConfigMap & Secret 활용"
date: "2025-02-25"
category: "DevOps"
tags: ["DevOps","Kubernetes","ConfigMap","Secret"]
excerpt: "준비 중: 환경 구성/민감정보 주입, 볼륨 마운트와 보안 고려."
author: "Admin"
published: false
---

예정: configKey 분리 전략, 업데이트 반영 방식, Secret 암호화(KMS/SealedSecret), GitOps 연계 패턴.

```

### kubernetes-05-statefulset-storage.md

**Path:** `frontend/public/posts/2025/kubernetes-05-statefulset-storage.md`

```markdown
---
title: "Kubernetes StatefulSet과 스토리지"
date: "2025-02-26"
category: "DevOps"
tags: ["DevOps","Kubernetes","StatefulSet","Storage"]
excerpt: "준비 중: 상태 저장 워크로드, PV/PVC, Headless Service, 스토리지 클래스."
author: "Admin"
published: false
---

예정: Pod 정렬/이름 보존, 데이터 마이그레이션, snapshot/backup 전략, 운영 체크리스트.

```

### latest.md

**Path:** `frontend/public/posts/2025/latest.md`

```markdown
---
title: "최신 게시글"
date: "2025-01-07"
category: "기술"
tags: []
excerpt: ""
readTime: "1분"
---


```

### linux-device-mount-journal.md

**Path:** `frontend/public/posts/2025/linux-device-mount-journal.md`

```markdown
---
title: "언마운트 이후에도 /dev/sda1이 남아있는 이유를 이해한 밤"
date: "2025-10-23"
category: "Linux"
tags: ['mount', 'umount', '장치파일', 'USB', '네트워킹']
excerpt: "장치 파일과 마운트의 차이를 헤맸던 날, 그리고 USB 허브의 SD 카드를 다시 인식시키기까지의 기록"
readTime: "8분"
---

![notunmount](../../images/2025/notunmounted.png)
어느 늦은 주말, 서버에서 외장 SD 카드를 언마운트했는데 `/dev/sda1`이 계속 눈앞에 남아 있는 걸 보고 잠시 멍해졌습니다. "umount를 했는데 왜 사라지지 않지?"라는 의문은 결국 리눅스가 장치 파일과 마운트라는 두 세계를 어떻게 다르게 취급하는지 다시 공부하게 만들었죠. 이 글은 그날의 시행착오를 기억해 두기 위한 일기입니다.

### 장치 파일은 단순한 주소였다

처음부터 이야기해 볼까요. `/dev/sda`는 리눅스가 인식한 첫 번째 디스크 자체를 가리키는 블록 장치 파일입니다. `/dev/sda1`은 그 디스크 위에 나눈 첫 번째 파티션을 가리키죠. 중요한 건, 이 파일들이 실제 디스크와 1:1로 대응하는 "주소"라는 사실입니다. 하드웨어가 연결되어 있는 한, 커널은 이 주소를 지우지 않습니다. 우리는 그 주소를 통해 데이터를 읽고 쓰는 방법만 달리할 뿐입니다.

반면 `mount`는 이 주소가 가리키는 파일 시스템을 리눅스 디렉터리 트리에 연결하는 행위입니다. 예를 들어 `mount /dev/sda1 /mnt/data`를 실행하면 `/mnt/data`라는 문을 통해 `/dev/sda1` 안쪽 세계를 탐험할 수 있게 되죠. 반대로 `umount /dev/sda1`을 실행하면 그 문이 닫힐 뿐, 주소 자체가 사라지는 것은 아닙니다. 그래서 언마운트 후에도 `/dev/sda1`이 당당히 남아 있는 건 너무나 정상적인 일이었습니다. `lsblk`로 확인해 보면 마운트 포인트가 비워질 뿐, 장치 파일은 여전히 존재하니까요.

### USB 허브에서 SD 카드를 바꿨는데, 여전히 sda1?

문제는 그 다음이었습니다. USB 허브에 SD 카드를 꽂고 언마운트한 뒤 카드를 교체했는데도, 여전히 `/dev/sda1`이라는 이름으로 남아 있어 새 카드가 인식되지 않는 상황이 온 거죠. 여기서 깨달았습니다. 언마운트는 단지 연결을 끊었을 뿐, 커널은 여전히 "그 장치가 연결되어 있다"고 믿고 있다는 사실을요. 그래서 새로 꽂은 카드를 제대로 인식하려면 하드웨어 측면에서 장치를 다시 초기화해 주어야 했습니다.

### 물리적으로 뽑았다가 다시 꽂는 방법

가장 간단한 해결책은 말 그대로 허브를 뽑았다 다시 꽂는 것이었습니다. 물리적으로 연결을 끊으면 커널은 "장치가 사라졌다"는 사실을 깨닫고, 다시 연결했을 때 새롭게 `/dev/sdb1`과 같은 이름을 할당합니다. 가장 확실하고, 실수할 일이 거의 없죠. 다만 원격 서버거나 접근이 어려운 환경에서는 다른 방법이 필요했습니다.

### 소프트웨어로 USB 재연결하기

그래서 시도한 것이 `lsusb`와 `sysfs`를 이용한 소프트웨어적 재연결이었습니다. 먼저 `lsusb`와 `lsusb -t`를 이용해 카드 리더가 연결된 포트를 확인합니다. 예를 들어 출력이 이렇게 나왔다고 합시다.

```
$ lsusb
Bus 001 Device 005: ID 058f:6366 Alcor Micro Corp. Multi-Flash Reader

$ lsusb -t
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/12p, 5000M
    |__ Port 4: Dev 5, If 0, Class=Mass Storage, Driver=usb-storage, 5000M
```

여기서 카드 리더는 `1-4`라는 경로를 차지하고 있음을 알 수 있습니다. 이제 `/sys/bus/usb/drivers/usb` 아래에서 이 장치를 드라이버에서 분리했다가 다시 붙입니다.

```
echo '1-4' | sudo tee /sys/bus/usb/drivers/usb/unbind
echo '1-4' | sudo tee /sys/bus/usb/drivers/usb/bind
```

이렇게 하면 커널이 허브를 잠시 "잊었다가" 다시 새로 인식하게 됩니다. 물론 경로를 잘못 지정하면 키보드나 마우스가 갑자기 끊길 수 있으니, 정확한 포트를 확인하는 것이 중요했습니다.

### SCSI 호스트를 다시 스캔하는 방법

또 다른 방법은 SCSI 호스트를 재스캔하는 것이었습니다. USB 저장 장치는 내부적으로 SCSI 디바이스처럼 다뤄지는 경우가 많기 때문에, `/sys/class/scsi_host/` 아래에서 적절한 호스트를 찾아 다시 스캔하면 됩니다.

```
$ ls /sys/class/scsi_host/
host0  host1  host2

echo "- - -" | sudo tee /sys/class/scsi_host/host2/scan
```

`- - -`는 채널, 타겟, LUN에 대한 와일드카드라서 해당 호스트에 연결된 모든 디바이스를 다시 탐색하도록 하는 요청입니다. 몇 초 뒤 `/dev/sda1`이 사라지고 `/dev/sdb1` 같은 새로운 이름이 생성되는 걸 확인할 수 있었습니다.

### 네트워크 연결 확인까지 이어진 맥락

흥미롭게도 같은 날, 저는 `tcpdump`로 네트워크 상황도 들여다보고 있었습니다. ARP 요청과 응답 로그를 보면서, 10.42.0.1이 10.42.0.201을 찾고 있고, 제 노트북이 거기에 응답하고 있다는 사실을 확인했습니다. 그 뒤에는 DNS 요청 `connectivity-check.ubuntu.com`이 오가며 인터넷 연결이 살아 있음을 보여주더군요. 그러니까 장치 파일은 단지 주소일 뿐이고, mount/umount는 그 주소에 도달하는 길을 열고 닫는 역할이라는 사실이, 네트워크에서 주소와 라우팅을 관리하는 것과 묘하게 닮아 있다는 생각이 들었습니다.

### 앞으로의 체크리스트

이 날 이후로 저는 외장 장치를 다룰 때 아래 순서를 습관처럼 따릅니다.

1. 작업 전 `umount /dev/sdXN`으로 먼저 연결을 끊는다.
2. 카드나 디스크를 교체했다면, 물리적으로 재연결하거나 소프트웨어적으로 `unbind/bind` 또는 `scsi_host` 스캔을 수행한다.
3. `lsblk`나 `dmesg`로 새로운 장치 이름을 확인한다.
4. 필요한 경우에만 다시 `mount`한다.

이렇게 기록을 남겨 두고 나니, `/dev/sda1`이 남아 있는 모습이 더 이상 의문이 아니라 안심의 신호가 되었습니다. 장치 파일이 그대로 있다는 것, 그것 자체가 커널이 하드웨어를 확실히 인식하고 있다는 증거니까요. 언젠가 또 비슷한 상황을 만난다면, 이 글이 다음 번의 당황을 조금 줄여 주길 바라봅니다.

```

### lte-cloud-native-journal.md

**Path:** `frontend/public/posts/2025/lte-cloud-native-journal.md`

```markdown
---
title: "4G 신호와 클라우드 콘솔 사이, 앱 경제를 실감한 나의 하루"
date: "2025-10-22"
category: "Network"
tags: ['4G', 'LTE', '클라우드컴퓨팅', 'SDN', 'NFV', 'IPv6']
excerpt: "LTE 필드 테스트와 데이터센터 자동화가 교차하던 2010년대, 앱 경제와 클라우드 네트워크를 동시에 길들인 개발자의 기록"
readTime: "11분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

2012년 여름, 나는 옥상에 임시로 세운 LTE 기지국 앞에서 스마트폰을 들고 속도 측정을 반복했다. 3G에서는 꿈꾸기 어려웠던 두 자릿수 메가비트가 화면에 찍히자, 함께 있던 필드 엔지니어와 나도 모르게 소리쳤다. “이제 버스에서 넷플릭스를 볼 수도 있겠네요.” 그 농담은 몇 년 지나지 않아 현실이 되었다. LTE가 열어 준 대역폭과 낮은 지연은 스마트폰을 단순한 통신 도구에서 생활 플랫폼으로 바꾸었고, 나는 그 변화를 가장 가까운 곳에서 체감했다.

그 시절 내 업무는 기지국 옆에서 스펙트럼 분석기를 붙잡는 일만큼이나 데이터센터에서 가상머신과 컨테이너를 관리하는 일이었다. AWS 콘솔에서 EC2 인스턴스 스냅샷을 만들고, SaaS 서비스의 트래픽을 모니터링하다가도 LTE EPC 장비의 로그를 확인해야 했다. 우리는 네트워크가 점점 소프트웨어처럼 동작해야 한다는 사실을 깨달았다. 그래서 SDN 컨트롤러를 도입하고, NFV 아키텍처로 방화벽과 로드밸런서를 전용 하드웨어에서 끌어내렸다. 오픈플로우 스위치를 세팅하던 밤, 나는 “이제 네트워크도 코드가 되는구나”라는 메모를 노트에 적어 두었다.

앱 경제라는 단어가 유행처럼 번지던 그 시절, 나는 우버와 같은 서비스가 어떻게 LTE와 GPS를 엮어 실시간으로 차량을 호출하는지 분석하느라 밤을 지새웠다. 지도 API와 결제 시스템이 초 단위로 서로 신호를 주고받는 동안, 백그라운드에서는 수많은 클라우드 인스턴스가 오토스케일링으로 늘어났다 줄어들었다. 우리는 애플리케이션 로그만 보는 것이 아니라, 기지국과 데이터센터의 지연 그래프를 동시에 보며 장애를 진단해야 했다. 한 번은 실시간 영상 스트리밍 서비스에서 지연이 튀어 이용자 불만이 쏟아진 적이 있었다. 우리는 코어 네트워크의 QoS 설정과 CDN PoP 상태, 그리고 SDN 컨트롤러의 경로 정책까지 모두 체크하며 문제를 풀어냈다.

IPv4 주소가 고갈될 것이란 경고는 이미 오래전부터 들어왔지만, 현실에서 IPv6 전환을 추진하는 일은 생각보다 더디었다. “NAT과 CIDR이면 당분간 버틸 수 있잖아”라는 경영진의 말에 나는 여러 차례 프레젠테이션을 준비했다. 듀얼 스택을 적용한 첫날, 벤더 장비의 펌웨어 버그 때문에 코어 라우터가 다운되었고, 우리는 새벽까지 손으로 세션을 다시 잡았다. 그 사건 이후에도 IPv6 도입 속도는 느렸지만, 나는 계속해서 테스트베드에서 128비트 주소를 다루며 언젠가의 전환을 대비했다. 현실과 이상 사이의 간극이 얼마나 깊은지 체감한 시간이었다.

TLS가 웹 전반에 퍼져 나가는 과정도 인상 깊었다. 렛츠 인크립트의 베타 서비스를 가장 먼저 시도하고, CI 파이프라인에서 자동으로 인증서를 갱신하며 HTTPS 전환을 마친 날, 팀원들과 조용한 축하를 나눴다. HTTP/2를 적용하기 위한 nginx 설정을 만지다가 멀티플렉싱이 제대로 동작하지 않는 버그를 만나며 좌절하기도 했다. 하지만 모바일 앱에서 이미지 로딩 속도가 체감할 정도로 빨라진 걸 확인하는 순간, 그 모든 수고가 보상받았다.

4G 시대는 내게 두 가지 습관을 남겼다. 하나는 필드 테스트 앱과 스펙트럼 분석기를 항상 휴대하는 습관이고, 다른 하나는 클라우드 콘솔 알림을 실시간으로 확인하는 습관이다. LTE 기지국을 돌며 신호 세기를 체크하던 오후와, 밤에 카페 한 구석에서 Lambda 함수 로그를 살피던 순간이 하나의 연속선 위에 있었다. 네트워크와 애플리케이션이 서로를 규정하기 시작한 시대, 나는 “네트워크도 서비스처럼 디자인되어야 한다”는 신념을 몸으로 익혔다.

이제 5G와 에지 컴퓨팅 이야기가 일상이 된 지금도, 나는 LTE 필드 테스트 당시 찍어 둔 속도 측정 스크린샷을 가끔 꺼내 본다. 그 숫자들 속에는 새로운 시대를 열어젖히던 개발자와 엔지니어들의 긴장과 설렘이 담겨 있다. 클라우드에서 API를 배포하고, SDN 컨트롤러에 플로우를 주입하고, 앱 스토어에서 실시간으로 반응을 확인하던 일상의 리듬. 4G는 그 리듬이 처음으로 본격적인 음악이 되던 순간이었다. 그래서 나는 지금도 새 프로젝트를 시작할 때면, 걸음을 멈추고 LTE 기지국을 올려다본다. 그 빛나는 안테나가 “그때처럼, 네가 먼저 뛰어들어야 한다”고 속삭이는 것 같다.

```

### manifest.json

**Path:** `frontend/public/posts/2025/manifest.json`

```json
{
  "files": [
    "5g-intelligent-fabric-journal.md",
    "6g-sentient-future-journal.md",
    "AI-api-server-temporary-dev.md",
    "AdversialNeuron.md",
    "AnimalsMind.md",
    "BST-think01.md",
    "BankRuptIn1929.md",
    "FutureClouding.md",
    "Limitation-Of-Transformer.md",
    "QuantumLayerLLM.md",
    "QuantumShadow.md",
    "QuantumSpaceInside.md",
    "QueryDSL.md",
    "ai-models-for-coding.md",
    "algorithm-mental-simulator.md",
    "algorithm_solv.md",
    "algorithms-through-my-eyes.md",
    "ansible-01-installation-setup.md",
    "ansible-02-inventory-basics.md",
    "ansible-03-playbook-examples.md",
    "ansible-04-roles.md",
    "arpanet-resilience-journal.md",
    "broadband-cdn-transition-journal.md",
    "ci-trigger-test.md",
    "devops-toolchain-overview.md",
    "dijkstra.md",
    "future-tech-six-insights.md",
    "git-submodule-guide.md",
    "grub-kernel-error-journal.md",
    "hooks.md",
    "integration-01-devops-pipeline.md",
    "integration-02-terraform-k8s.md",
    "integration-03-k8s-kafka.md",
    "integration-04-microservices-deployment.md",
    "java-concurrency-journal.md",
    "java-gc-journal.md",
    "java-generics-journal.md",
    "java-memory-model-journal.md",
    "java-oop-superchallenge.md",
    "java-static-polymorphism-masterclass.md",
    "java-stream-api-journal.md",
    "java-through-my-bytecode-journal.md",
    "k8s-overview.md",
    "kafka-01-concepts-architecture.md",
    "kafka-02-installation-setup.md",
    "kafka-03-producer-consumer.md",
    "kafka-04-topics-partitions.md",
    "kubernetes-01-cluster-setup.md",
    "kubernetes-02-pods-deployments.md",
    "kubernetes-03-services-networking.md",
    "kubernetes-04-configmap-secret.md",
    "kubernetes-05-statefulset-storage.md",
    "latest.md",
    "linux-device-mount-journal.md",
    "lte-cloud-native-journal.md",
    "memory-management-study.md",
    "middle-east-ai-conflicts.md",
    "mole-observation-diary.md",
    "nat-gateway-bottleneck-journal.md",
    "network-evolution-history.md",
    "network-evolution-intro-journal.md",
    "path-new-friend-essay.md",
    "proxmox-thin-provision.md",
    "python-ai-chatbot-development.md",
    "shell-powertools-journal.md",
    "sorting-algorithms-masterclass.md",
    "sorting-algorithms-pseudocode-analysis.md",
    "spring-boot-realtime-communication.md",
    "tcpip-revolution-journal.md",
    "terraform-01-basic-setup.md",
    "terraform-02-aws-ec2-example.md",
    "terraform-03-state-management.md",
    "terraform-04-variables-outputs.md",
    "web-commercialization-journal.md",
    "wine-clipboard-bridge-journal.md"
  ],
  "generatedAt": "2025-12-26T07:57:25.784Z",
  "totalFiles": 75,
  "excludedFiles": 0
}

```

### memory-management-study.md

**Path:** `frontend/public/posts/2025/memory-management-study.md`

```markdown
---
title: "메모리 관리 공부하다가 깨달은 페이징 시스템의 진짜 장점"
date: "2025-01-01"
category: "Computer Science"
tags: ['메모리관리', '페이징', 'MMU', '스와핑', '운영체제']
excerpt: "운영체제 메모리 관리를 공부하면서 페이징과 스와핑이 왜 필요했는지 이해한 과정"
readTime: "3분"
---

운영체제 수업에서 메모리 관리 부분을 공부할 때, 처음엔 왜 이렇게 복잡한 시스템을 만들었는지 이해가 안됐다. 하지만 옛날 방식의 문제점을 알고 나니 페이징이 정말 획기적인 해결책이었다는 걸 깨달았다.

## 처음엔 단순했던 메모리 관리

초기 컴퓨터는 메모리 관리가 단순했다. 그냥 프로세스를 메모리에 연속으로 쭉 넣는 방식이었다.

### MMU의 기본 원리

**MMU(Memory Management Unit)**가 하는 일은 생각보다 단순하다:
- **베이스 레지스터**: 프로세스가 시작되는 물리 메모리 위치
- **리밋 레지스터**: 프로세스가 사용할 수 있는 메모리 크기

CPU가 논리 주소 346을 요청하면, MMU는 이렇게 처리한다:
1. 346이 리밋 레지스터(740) 범위 내인지 확인
2. 맞다면 베이스 레지스터(14000)를 더해서 물리 주소 14346으로 변환
3. 해당 메모리에 접근

이 방식은 간단하지만 치명적인 문제가 있었다.

## 외부 단편화라는 악마

시간이 지나면서 프로세스들이 생성되고 종료되다 보니, 메모리 곳곳에 **홀(Hole)**이라는 빈 공간이 생겼다.

구체적인 예시를 보면:
1. Process 1(10MB), 2(20MB), 3(15MB)가 연속으로 할당됨
2. Process 2가 종료되어 20MB 홀이 생김  
3. Process 4(15MB)가 들어가면서 5MB 홀이 남음
4. 다른 곳에도 10MB, 10MB 홀이 생김

이제 총 여유 공간은 25MB(5+10+10)인데, 20MB 크기의 Process 5는 들어갈 수 없다! 연속된 공간이 없기 때문이다.

이게 바로 **외부 단편화** 문제다. 메모리는 충분한데 사용할 수 없는 상황이 생긴다.

## 페이징 - 획기적인 해결책

페이징은 이 문제를 아예 다른 관점에서 접근했다. **"연속으로 배치할 필요가 없다면?"**

### 핵심 아이디어

- **프레임(Frame)**: 물리 메모리를 고정 크기로 나눈 블록
- **페이지(Page)**: 프로세스도 같은 크기로 나눈 블록  
- **비연속 배치**: 페이지들을 아무 프레임에나 배치 가능

프로세스 입장에서는 여전히 연속된 메모리를 사용하는 것처럼 보이지만, 실제로는 여기저기 흩어져 있다. CPU를 속이는 셈이다!

### 주소 변환 과정

논리 주소는 두 부분으로 나뉜다:
- **페이지 번호(p)**: 어떤 페이지인지
- **페이지 오프셋(d)**: 페이지 내에서의 위치

물리 주소로 변환할 때:
1. 페이지 번호로 페이지 테이블에서 프레임 번호 찾기
2. 프레임 번호 + 페이지 오프셋 = 물리 주소

## 페이징의 장단점

### 장점
- **외부 단편화 완전 해결**: 어떤 프레임에나 페이지 배치 가능
- **메모리 보호**: 각 프로세스마다 독립적인 페이지 테이블
- **공유 메모리**: 여러 프로세스가 같은 프레임 참조 가능

### 단점  
- **내부 단편화**: 마지막 페이지에서 공간 낭비 발생
- **오버헤드**: 페이지 테이블 관리 비용
- **TLB 미스**: 주소 변환 시간 증가

하지만 외부 단편화로 시스템이 멈추는 것보다는 훨씬 낫다.

## 스와핑으로 메모리 확장

페이징과 함께 **스와핑(Swapping)**도 중요한 개념이다.

### 스와핑의 필요성
- 메모리보다 큰 프로그램 실행 가능
- 더 많은 프로세스 동시 실행
- 메모리 활용도 극대화

### 동작 과정
1. **스왑 아웃**: 사용하지 않는 페이지를 디스크로 이동
2. **스왑 인**: 필요한 페이지를 메모리로 로드
3. **페이지 폴트**: 접근하려는 페이지가 메모리에 없을 때 발생

스왑 공간을 관리하는 것도 중요한데, 디스크의 특정 영역을 스왑 공간으로 할당해서 사용한다.

## 실제 성능에 미치는 영향

페이징 시스템의 성능은 주로 다음 요소들에 달려있다:

### 지역성 원리
프로그램은 보통 특정 메모리 영역을 집중적으로 사용한다:
- **시간적 지역성**: 최근 사용한 데이터를 다시 사용할 확률이 높음
- **공간적 지역성**: 인근 메모리를 연속해서 사용할 확률이 높음

이 덕분에 TLB 히트율이나 페이지 폴트 발생률을 예측할 수 있다.

### 페이지 크기 선택
- **작은 페이지**: 내부 단편화는 줄지만 페이지 테이블이 커짐
- **큰 페이지**: 페이지 테이블은 작아지지만 내부 단편화 증가

보통 4KB~16KB 사이에서 시스템 특성에 맞게 선택한다.

## 마무리

처음엔 복잡해 보였던 페이징 시스템이지만, 외부 단편화라는 심각한 문제를 해결하기 위한 필연적인 발전이었다는 걸 이해하고 나니 모든 게 명확해졌다.

특히 CPU를 속여서 연속된 메모리를 쓰는 것처럼 보이게 하면서도, 실제로는 비연속적으로 배치하여 메모리를 효율적으로 사용하는 아이디어가 정말 인상적이었다.

현대 운영체제에서 가상 메모리 시스템이 얼마나 정교하게 발전했는지도 새삼 느끼게 된다.
```

### middle-east-ai-conflicts.md

**Path:** `frontend/public/posts/2025/middle-east-ai-conflicts.md`

```markdown
---
title: "중동 지역 AI 도입으로 생긴 새로운 갈등들을 보면서 드는 생각"
date: "2025-01-04"
category: "Technology"
tags: ['중동', 'AI', '지정학', '기술패권', '디지털권위주의', '사이버보안']
excerpt: "중동 지역의 AI 기술 도입이 어떤 새로운 갈등 구조를 만들어내고 있는지 분석해본 내용"
readTime: "3분"
---

최근 수업에서 중동 지역의 AI 도입 현황을 조사하다 보니, 기술이 단순히 편의를 가져다주는 게 아니라 완전히 새로운 갈등 구조를 만들어내고 있다는 걸 깨달았다.

## AI의 두 얼굴 - 희망과 무기

중동에서 AI는 정말 복잡한 의미를 가지고 있다.

### GCC 국가들의 포스트 오일 전략

**걸프 협력회의(GCC)** 국가들에게 AI는 석유 이후를 준비하는 핵심 카드다:

- **사우디아라비아**: 'Vision 2030'으로 거대한 AI 스마트시티 'NEOM' 건설
- **UAE**: 2017년 세계 최초로 AI 장관 임명, 정부 서비스 50%를 AI 플랫폼으로 전환 목표

석유로 번 막대한 부를 AI에 쏟아붓고 있는 상황이다. 어찌 보면 당연한 선택이다.

### 하지만 동시에 전략무기

그런데 AI가 단순한 경제 도구가 아니라 **전략무기**로도 작동하고 있다. 특히 이스라엘과 아랍 세계 간의 기술 격차가 새로운 군비경쟁을 만들어내고 있다.

## 기술 패권 경쟁의 실상

### 이스라엘의 압도적 우위

이스라엘이 '실리콘 와디'라고 불리는 이유가 있다:

**Unit 8200의 생태계**
- 군-민-정 협력 시스템이 완벽하게 구축됨
- 군사 AI 기술이 민간으로 자연스럽게 이전
- 'Blue Wolf', 'Pegasus' 같은 군사용 감시 AI 실전 활용

구체적인 예를 보면, Unit 8200 출신들이 만든 스타트업들이 이스라엘 AI 생태계의 핵심을 이루고 있다.

### GCC의 '자본 주도형' 추격과 한계

반면 GCC 국가들은 돈은 많지만 구조적 한계가 있다:

- **'수입된 혁신'의 딜레마**: 기술을 사오는 건 쉽지만 자체 개발 역량 부족
- **톱다운 방식**: 정부 주도로 추진하다 보니 혁신 생태계 형성이 어려움

결국 이스라엘은 **기술력**으로, GCC는 **자본력**으로 경쟁하는 비대칭 구조가 만들어졌다.

## 디지털 권위주의의 그림자

AI 도입 과정에서 가장 우려되는 부분이 **디지털 권위주의**의 강화다.

### AI 감시 사회의 도래

**스마트시티의 이면**:
- 시민 편의라는 명목하에 전방위적 감시 시스템 구축
- 개인의 일거수일투족이 AI로 모니터링됨
- '알고리즘 아파르트헤이트' - 기술로 만들어진 새로운 차별

### 알고리즘 편향 문제

특히 심각한 게 **문화적 편향** 문제다:
- 서구 중심 AI 모델을 그대로 도입하다 보니 아랍 문화가 왜곡됨
- 아랍어 데이터셋 부족으로 언어적 차별 발생
- 이슬람 윤리와 AI 기술 간의 충돌

## 새로운 보안 위협들

AI가 테러 집단의 손에 들어가면 어떻게 될까? 상상만 해도 무섭다.

### 테러 집단의 AI 활용

- **저비용 고효율 자율 공격 시스템**: 드론을 AI로 조종해서 자동 공격
- **지능형 프로파간다**: AI로 개인 맞춤형 선전물 제작, 효과적인 세뇌
- **딥페이크 활용**: 가짜 뉴스로 사회 혼란 조성

### 역설적 상황

아이러니하게도 **대테러 AI**가 오히려 인권 침해의 도구가 되기도 한다. 테러를 막겠다는 명목으로 시민 감시를 정당화하는 셈이다.

## 우리가 배울 점들

이 사례를 보면서 몇 가지 교훈을 얻을 수 있다:

### 1. 기술 중립성의 허상

기술 자체는 중립적이라고 하지만, 실제로는 **누가, 어떻게, 왜 사용하느냐**에 따라 완전히 다른 결과를 낳는다.

### 2. 경제적 동기 vs 정치적 현실

GCC 국가들의 경제 다각화 노력은 합리적이지만, 기존 정치 구조와 충돌하면서 예상치 못한 문제들이 발생한다.

### 3. 기술 격차가 만드는 새로운 갈등

전통적인 군사력이나 경제력 격차와는 다른 차원의 **기술 격차**가 새로운 갈등 요인이 되고 있다.

## 해결 방안에 대한 생각

### 다자간 협력의 필요성

기술 패권 경쟁을 완화하려면 **지역 차원의 협력 체계**가 필요하다. 서로 견제하면서 기술 개발하는 것보다는 공통 관심사(테러 방지, 경제 발전 등)를 중심으로 협력하는 게 더 효과적일 것 같다.

### 책임감 있는 AI 거버넌스

**윤리적 AI 사용 기준**을 마련하고, 이를 지역 차원에서 공유해야 한다. 특히:
- 감시 기술 사용의 투명성 확보
- 알고리즘 편향 검증 시스템
- 시민 프라이버시 보호 장치

### 포용적 인재 투자

결국 기술은 사람이 만들고 사용한다. **다양한 배경을 가진 인재들**이 AI 개발에 참여할 수 있도록 교육 투자와 기회 확대가 필요하다.

## 마무리

중동의 AI 도입 사례를 보면서, 기술 발전이 항상 긍정적인 결과만 가져오는 건 아니라는 걸 다시 한번 깨달았다. 

특히 **기술 결정론**의 위험성을 느꼈다. "AI가 발전하면 자동으로 모든 게 좋아질 것"이라는 순진한 믿음은 위험하다. 기술을 어떻게 사용할지에 대한 **사회적 합의**와 **제도적 뒷받침**이 없으면, 오히려 기존 문제들을 더 악화시킬 수 있다.

중동이 기술 발전을 통해 지속 가능한 평화와 번영을 이룰 수 있을지는 결국 이들이 어떤 선택을 하느냐에 달려 있을 것 같다.
```

### mole-observation-diary.md

**Path:** `frontend/public/posts/2025/mole-observation-diary.md`

```markdown
---
title: 두더지에 대해서..
excerpt: >-
  # 두더지 관찰 일기


  ## 개요

  이번 일기는 내가 두더지를 관찰한 경험을 기록한 것입니다. 두더지는 생태계에서 중요한 역할을 하는 포유류로, 그들의 행동과 생태적 의미를
  이해하는 것은 매우 흥미로운 일이었습니다. 이 일기에서는 두더지의 서식지, 행동, 그리고 관찰한 내용을 중심으로 작성하겠습니다.


  ## 1일차: 준비 과정

  오늘은 두더지를 관찰하기 위해 ...
date: '2025-08-10'
publishTime: '2025-08-10 17:30:00'
category: 기술
tags:
  - 두더지
  - dothechi
readTime: 2분
---
# 두더지 관찰 일기

## 개요
이번 일기는 내가 두더지를 관찰한 경험을 기록한 것입니다. 두더지는 생태계에서 중요한 역할을 하는 포유류로, 그들의 행동과 생태적 의미를 이해하는 것은 매우 흥미로운 일이었습니다. 이 일기에서는 두더지의 서식지, 행동, 그리고 관찰한 내용을 중심으로 작성하겠습니다.

## 1일차: 준비 과정
오늘은 두더지를 관찰하기 위해 농경지로 나갔습니다. 두더지가 자주 출몰하는 시간대인 저녁 무렵에 가기로 했습니다. 필요한 장비로는 노트, 펜, 그리고 카메라를 준비했습니다. 두더지가 살고 있을 법한 습한 흙이 많은 지역을 찾기로 했습니다.

### 관찰 준비
- **장소:** 농경지의 한쪽 끝
- **시간:** 저녁 6시
- **장비:** 노트, 카메라

## 2일차: 첫 관찰
오늘 저녁, 농경지에 도착했습니다. 땅속에서 두더지가 파놓은 굴을 몇 개 발견했습니다. 굴은 깊고 복잡하게 연결되어 있었고, 주변에는 두더지가 먹이로 삼을 법한 곤충과 지렁이가 많았습니다. 

### 관찰 내용
- **굴의 위치:** 논 옆
- **주변 생물:** 곤충, 지렁이
- **행동:** 굴 주변을 돌아다니며 촬영

## 3일차: 두더지의 활동
오늘은 두더지의 활동을 관찰하기 위해 저녁에 다시 농경지로 나갔습니다. 저녁 7시경, 두더지가 굴에서 나오는 모습을 목격했습니다. 그 모습은 정말 신기했습니다. 

### 관찰 내용
- **시간:** 저녁 7시
- **행동:** 굴에서 나와 주변을 탐색
- **특징:** 긴 코와 큰 앞발을 이용해 땅을 파헤치는 모습

## 4일차: 결과 정리
이틀 동안의 관찰을 통해 두더지가 생태계에서 어떤 역할을 하는지 조금 더 이해할 수 있었습니다. 두더지는 토양을 파헤치면서 통기성을 높이고, 유기물 분해를 촉진하여 생태계를 건강하게 유지하는 데 기여하는 것 같았습니다.

### 정리 내용
- **두더지의 역할:** 토양 구조 개선, 생태계 건강 유지
- **관찰의 의미:** 두더지의 행동을 통해 자연 생태계를 이해하는 중요한 경험이었습니다.

## 정리
이번 두더지 관찰은 자연을 이해하는 데 큰 도움이 되었습니다. 생태계에서 두더지가 하는 역할은 단순한 생물 관찰을 넘어서, 우리가 자연과 어떻게 상호작용하는지를 생각하게 만들었습니다. 앞으로도 더 많은 생물들을 관찰하며 그들의 생태적 의미를 탐구해보고 싶습니다.

```

### nat-gateway-bottleneck-journal.md

**Path:** `frontend/public/posts/2025/nat-gateway-bottleneck-journal.md`

```markdown
---
title: "네트워크 병목과 NAT 게이트웨이의 한계: 한 CS 학생의 속마음"
date: "2025-11-19"
category: "Network"
tags: ['NAT', '클라우드네트워크', 'VPC', '프라이빗서브넷', '병목']
excerpt: "프라이빗 서브넷과 퍼블릭 서브넷, NAT Gateway와 IGW가 등장하는 전형적인 VPC 그림을 보던 수업 시간. 모두가 보안을 이야기할 때, 내 눈에는 그 구조가 거대한 깔때기 실험처럼 보였다. 이 글은 그 순간 머릿속에서 떠오른 병목에 대한 질문과 직관을 그대로 옮긴 기록이다."
readTime: "7분"
---
> **이 글은 수업 시간에 떠올린 속마음을 정리한 내용입니다.**

![n](../../images/2025/natgateway.png)

## 1. 수업 시간, 처음 본 전형적인 VPC 그림

클라우드 네트워크 수업 시간이었다. 교수님은 슬라이드를 넘기더니 아주 교과서적인 그림을 하나 띄웠다.

- 왼쪽에 초록색 `Public subnet` 두 개와 거기에 놓인 `Web servers`
- 그 아래 파란색 `Private subnet` 두 개와 `Database servers`
- 양쪽을 가로지르는 `Security group` 선
- 맨 위에는 NAT 아이콘과 라우팅 심볼, 맨 바깥에는 `Region`과 `VPC` 박스
- 한쪽 옆에는 S3 아이콘과 `S3 gateway`

딱 이 그림이었다. 슬라이드에선 이 다이어그램이 이렇게 설명됐다.

> "퍼블릭 서브넷에는 외부에서 접근 가능한 웹 서버를 두고요, 프라이빗 서브넷의 DB 서버는 직접 인터넷과 통신하지 않습니다. 대신 NAT Gateway를 통해 아웃바운드만 허용하고, IGW를 통해 외부와 연결하죠."

논리 구조로 보면 실제로 아주 깔끔했다. 보안도 설명이 잘 된다. 그런데 나는 그 순간, 딱 거기서 멈추지 못했다.

---

## 2. 내 눈에는 '보안 구조도'가 아니라 '깔때기 실험'처럼 보였다

"프라이빗은 직접 인터넷 접근 X"

"NAT = 아웃바운드용 출구"

"IGW = 인터넷 연결 지점"

이 아키텍처 구조에서 뭔가 이상함이 느껴졌다,

여러 개의 서브넷에서 나오는 화살표들이 전부 한 점, 즉 화면 중앙 위쪽의 `NAT Gateway` 아이콘으로 모였다가, 다시 한 줄로 위로 빠져나가 `IGW`를 거쳐 나가는 모습.

내가 본 건 네트워크가 아니라, 거대한 **깔때기**였다.

- 여러 개의 넓은 수조(서브넷)에서 물이 쏟아져 나오는데
- 그 물이 전부 좁은 배수구 하나(NAT Gateway)로 몰리고
- 그 뒤에 또 하나의 관(IGW)을 타고 나가는 구조

그래서 수업을 듣는 와중에, 자연스럽게 이런 문장이 떠올랐다.

> "잠깐만… NAT Gateway가 모든 트래픽의 출구라면, 이게 **그 자체로 병목**이 되는 순간은 언제지?"

---

## 3. "관리형이라 괜찮다"는 설명이 오히려 안심이 되지 않았다

교수님은 곧이어 이렇게 설명했다.

- "요즘은 클라우드에서 **Managed NAT Gateway**를 제공하기 때문에, 우리가 직접 방화벽 박스를 관리할 필요가 없습니다."
- "트래픽이 늘어나면 벤더가 내부에서 알아서 확장해 줍니다."

이 말이 틀린 건 아니라는 걸 안다. 실제로 벤더 문서를 보면 "자동 확장"과 "고가용성"이라는 단어가 강조돼 있다. 하지만 내 머릿속에서는 자꾸 이런 생각이 뒤를 이었다.

- 그래도 결국 어딘가에는 **물리적인 한계**가 있을 텐데?
- NAT Gateway라는 논리 엔드포인트 뒤에는, 분명히 CPU와 메모리, NIC가 붙어 있을 텐데?
- SNAT 포트 수, 동시 연결 수, 초당 세션 수 같은 숫자들은 어디에 숨어 있을까?

슬라이드 위에서는 모든 서브넷 트래픽이 한 점으로 깔끔하게 모였다. 그런데 그 한 점이 갑자기 내게는 이렇게 보였다.

> "이거, 나중에 대규모 트래픽이 몰리면 **여기가 제일 먼저 터지는 지점** 아닌가?"

보안 구조도에서 출발한 그림이, 내 머릿속에서는 어느새 큐잉 이론과 병목 분석의 대상으로 바뀌어 버렸다.

---

## 4. NAT Gateway도 결국 '자원'이라는 직관

그날 수업이 끝날 때쯤, 노트에 이런 문장을 적어 두었다.

> "NAT Gateway도 결국 CPU, 메모리, 포트라는 **유한한 자원** 위에 떠 있는 소프트웨어다."

생각해 보면 당연한 이야기다.

- NAT가 아무리 "관리형"이라 해도, 패킷을 받아서 테이블을 갱신하고, 소스 포트를 매핑하고, 다시 내보내는 과정은 결국 연산이다.
- 한 공인 IP가 가질 수 있는 소스 포트 영역은 유한하고, 동시 연결이 늘어나면 언젠가 그 범위에 닿을 수밖에 없다.
- 클라우드 내부의 데이터 플레인이 아무리 분산되어 있어도, **논리적인 출구**는 여전히 NAT Gateway라는 이름으로 묶인다.

그래서 이 다이어그램을 보는 순간, 내 머릿속에는 세 가지 레이어가 동시에 겹쳐졌다.

1. **논리 레이어** – VPC, Subnet, Route Table, NAT, IGW 아이콘이 그려진 구조도
2. **물리 레이어** – 실제로 패킷을 처리하는 NIC, CPU, 메모리, 라우터, 스위치
3. **수학 레이어** – 큐의 길이, 처리율(throughput), 지연(latency) 등

이러한 개념들은 서로 융합하며 계속 같이 깜빡였다. "이 추상적인 네모와 동그라미 뒤에는, 어떤 수치와 제한이 숨어 있을까?" 라는 질문이 꼬리를 물고 이어졌다.

---

## 5. VPC 그림을 그래프로 바꿔 보는 상상

한 번은 교수님 말이 잠시 느려지는 틈에, 노트 한 켠에 이 다이어그램을 그래프로 다시 그려 봤다.

- 정점(vertex): Public Subnet, Private Subnet, NAT Gateway, IGW, S3 Gateway
- 간선(edge): "이 방향으로 패킷이 흐른다"를 의미하는 화살표들

그러고 나서 스스로에게 물었다.

- 이 그래프에서 **가장 "중심성"이 높은 노드**는 어디일까?
- 특정 정점을 제거했을 때, 그래프가 몇 개의 컴포넌트로 갈라질까?
- NAT Gateway를 여러 개 두고 라우팅을 나눠 가지면, 그래프 구조는 어떻게 달라질까?

이렇게 VPC 그림을 그래프로 환원하는 순간, NAT Gateway는 단순한 네트워크 장비 아이콘이 아니라 **커트(cut)를 어디에 넣느냐에 따라 전체 연결성을 좌우하는 노드**로 보이기 시작했다. 그리고 자연스럽게 이런 상상이 붙었다.

> "여기서 NAT를 여러 개로 쪼개거나, 내부 서비스 트래픽을 우회시키면, 병목이 풀리는 그래프를 그릴 수 있지 않을까?"

아직은 실제로 수십 Gbps 트래픽을 다뤄 본 적도 없고, 클라우드 벤더 내부 구현을 본 것도 아니다. 그럼에도 불구하고, 최소한 한 가지는 분명해졌다.

> "이 다이어그램에서 NAT Gateway는 **성능과 확장성을 설계할 때 반드시 집요하게 들여다봐야 할 노드**다."

---

## 6. 이 글 이후에 내가 더 파고들고 싶은 것들

이 글은 아직 "답"을 주는 글이 아니다. 오히려 수업 시간에 생긴 **질문이 태어나는 순간**을 기록해 둔 메모에 가깝다.

다음에 따로 이어서 정리해 보고 싶은 건 이런 것들이다.

- NAT Gateway가 실제로 어떤 지표(처리량, 동시 연결 수, SNAT 포트 수)를 기준으로 병목이 되는지
- AZ별로 NAT를 쪼개고, 특정 트래픽을 VPC 엔드포인트나 PrivateLink로 우회시키는 설계 패턴들
- NAT를 완전히 우회하는 구조(서비스 자체를 퍼블릭 서브넷에 두고, 보안을 보안 그룹과 WAF로 해결하는 방식)가 언제 더 나은 선택인지

하지만 어떤 기술적인 결론보다도, 내가 이 글에서 정말 남기고 싶었던 순간은 이것 하나다.

> 모든 것을 의심하자.

같은 그림을 보면서도 각자 다른 층위를 떠올리는 이 작은 차이가, 언젠가 설계와 디버깅에서 강점이 되지 않을까 하는 막연한 기대가 있다. 그러한 이유로 이를 기억하기 위해 이렇게 글로 남겨본다.

```

### network-evolution-history.md

**Path:** `frontend/public/posts/2025/network-evolution-history.md`

```markdown
---
title: '네트워크 발전의 역사: ARPANET에서 5G/6G까지'
description: '패킷 교환의 탄생부터 인터넷 표준화, 웹의 폭발적 성장, 모바일·클라우드·엣지, 그리고 5G/6G로 이어지는 네트워크 발전사를 핵심 이정표 중심으로 정리합니다.'
date: 2025-08-31
updated: 2025-08-31
tags:
  ['network', 'history', 'internet', '5G', '6G', 'protocols', 'architecture']
category: 'CS'
series: '네트워크 다시보기'
cover: '/images/covers/network-history.jpg'
readingTime: 10
---

네트워크 기술의 역사는 분산과 연결의 역사다. 하드웨어의 진보, 프로토콜의 표준화, 서비스의 확장, 보안 위협과의 공진화가 얽혀 오늘의 인터넷을 만들었다. 이 글은 핵심 전환점만 추려 빠르게 훑는다.

## 1) 회선 교환에서 패킷 교환으로: ARPANET의 탄생(1960s–1970s)

- 전화망은 회선 교환(circuit switching) 기반으로 전체 구간을 점유. 비효율적.
- 폴 바란, 도널드 데이비스가 제안한 패킷 교환(packet switching) 개념 등장.
- 1969년 ARPANET 가동: IMP(Interface Message Processor), NCP 프로토콜.
- 1974년 Cerf & Kahn의 TCP 초기 제안. “인터네트워킹” 개념 확립.

## 2) TCP/IP 표준화와 인터넷의 탄생(1980s)

- 1983-01-01 ‘Flag Day’: ARPANET이 NCP→TCP/IP 전환.
- IP 라우팅, 자율시스템(AS), BGP 전신(EGP) 도입으로 상호연결 확장.
- DNS(1983)로 호스트 파일의 한계 극복. 도메인 네임 체계 확립.

## 3) 웹과 상용화의 폭발(1990s)

- 1991–1993: WWW(HTTP/HTML/URL), 브라우저 모자이크/넷스케이프.
- 상용 ISP 확산, BGP-4(1994)로 CIDR/경로 벡터 안정화, 백본 성장.
- 이더넷 스위칭/LAN의 보급, 802.11 Wi‑Fi(1997) 등장.

## 4) 광대역, 모바일, 콘텐츠 전송(2000s)

- ADSL/Cable로 가정 광대역. 데이터센터/IDC 확장.
- 모바일 3G(UMTS/CDMA2000)로 데이터 중심 전환, 스마트폰 전야.
- CDN(Akamai 등)과 캐싱, Anycast, Peering 전략 고도화.
- 보안: NAT 대중화, 방화벽/IPS, SSL 전자상거래 보편화.

## 5) 클라우드 네이티브와 모바일 인터넷(2010s)

- IaaS/PaaS/SaaS 대중화, SDN/NFV로 제어/데이터 분리.
- 4G LTE로 모바일 대역폭/지연 개선, 앱 생태계 폭발.
- IPv6 상용화 확산, QUIC/HTTP/2로 전송 계층 혁신.
- Zero Trust, TLS Everywhere, DDoS 대응(스크러빙, Anycast) 체계화.

## 6) 초저지연·대규모 연결의 시대: 5G와 그 다음(2020s–)

- 5G: eMBB/URLLC/mMTC로 사용례 분화, 네트워크 슬라이싱.
- 엣지 컴퓨팅로 지연 감소, 산업용 사설 5G.
- 클라우드 WAN, SASE, 서비스형 네트워킹(NaaS) 부상.
- DNS over HTTPS/QUIC, Encrypted SNI(ESNI/ECH)로 프라이버시 강화.

## 7) 6G를 향한 시나리오(2030s 가정)

- 서브테라헤르츠/THz, RIS(Reconfigurable Intelligent Surface).
- AI‑Native 네트워크(자율 최적화/Healing), 디지털 트윈 기반 계획/운영.
- 통신·센싱·컴퓨팅 융합(JCS), 초정밀 위치/센싱 통합.

## 핵심 프로토콜/기술 타임라인(간단 버전)

- 1969 ARPANET, 1974 TCP, 1983 TCP/IP 전환, 1983 DNS
- 1989–1991 WWW 구상/공개, 1994 BGP-4, 1997 Wi‑Fi
- 2003 IPv6 상용 시동, 2004 TLS 1.0 확산, 2009 CDNs 대중화
- 2012 SDN(ONF/OpenFlow), 2013–2016 HTTP/2, 2016– QUIC, 2019 5G 상용

## 오늘의 설계 관점에서 본 교훈

- 단순성+확장성: IP의 최소 공통분모가 글로벌 상호연결을 가능케 했다.
- End-to-End 원칙과 약한 상태 유지가 진화를 가속.
- 표준과 구현의 공진화: 오픈 표준, 오픈 소스가 네트워크 혁신의 토대.
- 지연/변동성/장애를 전제로 설계할 것. 캐시, 재시도, 백오프, 애니캐스트, 멀티패스.

## 참고

- Cerf & Kahn, “A Protocol for Packet Network Intercommunication” (1974)
- RFC 791(IP), RFC 793(TCP), RFC 1034/1035(DNS), RFC 4271(BGP-4)
- 3GPP 5G 사양, IETF QUIC/HTTP WG 문서

```

### network-evolution-intro-journal.md

**Path:** `frontend/public/posts/2025/network-evolution-intro-journal.md`

```markdown
---
title: "네트워크 연표를 다시 걷기 전, 내가 세운 질문들"
date: "2025-10-17"
category: "Network"
tags: ['네트워크역사', '인터넷진화', '서론', '에세이']
excerpt: "ARPANET부터 6G까지 다시 추적하기 전에, 지각 있는 연결 구조란 무엇인지 스스로에게 던진 질문을 정리한 나의 서문"
readTime: "6분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

오늘 아침, 커피를 손에 쥐고 오래된 노트북을 펼치면서 나는 한 가지 질문을 적어 두었다. “네트워크는 단지 데이터를 운반하는 관일까, 아니면 점점 더 우리를 인식하는 감각 기관이 되어 가고 있을까?” ARPANET의 회로도를 처음 만났을 때 느꼈던 전율과, 5G 테스트베드에서 자율주행차가 협업하는 장면을 보았을 때의 낯섦이 동시에 머릿속을 스쳤다. 그래서 나는 이번 기록을 단순한 연대기가 아니라, 내가 직접 걸어 본 시대들의 감각적 복기록으로 남기기로 했다.

이 여정을 시작하기 전에, 나는 세 가지 키워드를 다시 꺼내 본다. 분산화, 추상화, 지능. 냉전 속에서 태어난 ARPANET의 분산 설계가 어떻게 생존성을 보장했는지, TCP/IP가 추상화의 힘으로 네트워크들을 한 무대에 올렸는지, 그리고 지금 우리가 이야기하는 AI 네이티브 6G가 어떤 지능을 요구하는지. 나는 이 세 키워드가 각 시대의 기술과 사회적 요구를 어떻게 오고갔는지, 그 과정에서 사람들의 표정이 어떻게 달라졌는지를 기록하려 한다.

문득 1990년대 초, HOSTS.TXT를 손으로 고치며 밤을 지새우던 동료가 떠오른다. 그는 항상 “이거 언젠가 자동화되겠지?”라며 웃곤 했다. 그의 웃음이 DNS 덕분에 현실이 되었듯, 현재 우리가 고민하는 제로 트러스트나 네트워크 슬라이싱도 언젠가 일상이 될 것이다. 그 과정의 불안과 기대를 있는 그대로 남겨두고 싶다. 미래의 나, 혹은 후배 누구라도 이 글을 거꾸로 읽으며 “이 시절엔 이런 생각을 했구나”라고 느낄 수 있도록.

그래서 나는 각각의 시대를 따로 떼어 하나의 일기로 남기기로 했다. 스푸트니크의 그림자 아래 첫 패킷이 숨을 쉬던 1960년대, 플래그 데이의 긴장으로 가득했던 1983년, 모자이크 브라우저가 화면을 물들인 1990년대, DSL 모뎀의 깜박임이 새벽을 밝히던 2000년대, LTE 신호가 앱 경제를 탄생시킨 2010년대, 슬라이스와 에지가 일상이 된 5G 시대, 그리고 테라헤르츠와 지각 네트워크를 꿈꾸는 6G 연구소까지. 각 장마다 나는 내가 실제로 만났던 사람들의 목소리와 터미널의 냄새까지 함께 적어 내려가려 한다.

이 서문은 그저 숨을 고르는 시간이다. 기록을 시작하기 전에 내 마음에 내려앉은 기대와 약간의 두려움을 그대로 남겨두고 싶었다. 네트워크의 역사는 속도 경쟁의 목록이 아니라, 인간이 연결을 통해 무엇을 지키고 무엇을 새로 만들었는지에 대한 살아 있는 서사였다. 이제 나는 첫 장을 넘길 준비를 마쳤다. 다음 페이지에서는 ARPANET의 임팩트를 다시 마주하겠지만, 지금 이 순간만큼은 평온하게 호흡을 맞춰 둔다. 곧이어 이어질 긴 여행을 위해.

```

### path-new-friend-essay.md

**Path:** `frontend/public/posts/2025/path-new-friend-essay.md`

```markdown
---
title: "PATH에 새 친구를 초대하는 방법"
date: "2025-11-01"
category: "Linux"
tags: ['PATH','리눅스','환경설정','터미널','작업자동화']
excerpt: "심볼릭 링크가 말을 안 듣던 날, PATH를 다시 다듬으며 정리한 나만의 에세이."
readTime: "7분"
---
차가운 공기가 내려앉은 고요한 새벽에, 리눅스 서버 마이그레이션 (우분투 -> 로키) 작업 중에 새로 받아 둔 도구 하나를 터미널에서 바로 부르고 싶었는데 이름만 치면 “command not found”라는 차가운 대답이 돌아왔다. “어제 분명 /usr/local/bin에 심볼릭 링크를 만들었는데 왜 못 알아듣지?”라는 생각이 머리를 스쳤고, 링크는 멀쩡한데 쉘은 시큰둥한 이 상황이 꽤나 낯설게 느껴졌다.

잠깐 숨을 고르고 가장 기본적인 질문부터 던졌다. “쉘은 실행 파일을 어디서 찾더라?” 결국 PATH 변수의 순서대로 디렉터리를 훑다가 이름이 맞는 파일을 발견하면 손을 내밀어 준다는 당연한 원리가 떠올랐다. 그러니 링크든 바이너리든 PATH 속 디렉터리에 있어야 하고, 실행 권한까지 갖춰야 한다. 나는 제일 먼저 `echo $PATH`로 예상한 경로가 실제로 포함되어 있는지 확인했고, zsh에서는 `rehash`, bash에서는 `hash -r`로 캐시를 날려야 새 링크가 보인다는 사실을 다시 상기했다. 한 번이라도 잊으면 “왜 또 안 되지?” 하며 시간을 낭비하기 쉬운 지점이다.

이어서 링크가 제대로 붙었는지를 차근차근 점검했다. `ls -l /usr/local/bin/프로그램`으로 링크가 절대경로를 향하는지 확인하고, 본체에는 `chmod +x`가 붙었는지 살펴보는 과정이다. 스크립트라면 첫 줄의 shebang까지 챙겨야 쉘이 머뭇거리지 않는다. 여기까지는 늘 하던 체크였지만, 이번에는 sudo로 실행했을 때만 실패하는 이상한 반응이 덧붙었다. 원인은 secure_path였다. `sudo env | grep ^PATH=`로 확인해 보니 /usr/local/bin이 빠져 있었고, 결국 `sudo visudo`에서 기존 값을 유지한 채 `/usr/local/bin`을 끼워 넣어야 했다.

문제는 여기서 끝이 아니었다. GUI 런처로 실행할 때 PATH가 다르게 잡혀서 또다시 “not found”가 뜨는 걸 보고야 말았다. 로그인 셸이 아니면 `/etc/profile`이나 `~/.zprofile`이 건너뛰어지기도 하니, 결국 `~/.zshrc`나 `~/.bashrc`에 PATH를 덧씌워 두는 편이 마음이 편하다. GNOME 터미널, KDE 콘솔 등 환경마다 초기화 스크립트가 다르다는 사실도 이번에 뼈저리게 느꼈다. “분명 같은 계정인데 왜 여기서는 안 되지?”라는 의문에 빠지기 전에 각 환경이 PATH를 어떻게 불러오는지 살피는 버릇을 들였다.

한편, 어느 순간 링크를 눌렀는데도 “Permission denied”가 뜬다면 파티션에 `noexec` 옵션이 걸려 있는지 의심해 볼 만하다. `mount | grep noexec`로 금세 알아볼 수 있다. 나는 한 번, 보안을 강화한 USB 저장소에서 프로그램을 돌리려다 이 옵션을 만나서 한참 헤맸다. 링크도, 권한도 문제없는데 여전히 실행이 안 된다면 여기까지 체크리스트에 넣어 두면 마음이 든든해진다.

그날 이후 나는 “개인용”과 “전역용” 경로를 분리해서 관리하기로 했다. 개인적으로 쓰는 도구는 `~/.local/bin`에 모아 두기로 마음먹었다. 우선 디렉터리를 만들고(`mkdir -p ~/.local/bin`), 링크나 래퍼 스크립트를 두는 것이다. 예를 들어:

```bash
ln -s /절대/경로/프로그램 ~/.local/bin/프로그램
```

혹은 원본 경로가 바뀔 수 있을 때는 짧은 래퍼를 만든다.

```bash
cat > ~/.local/bin/프로그램 <<'EOF'
#!/usr/bin/env bash
exec /절대/경로/프로그램 "$@"
EOF
chmod +x ~/.local/bin/프로그램
```

그다음 `~/.zshrc`나 `~/.bashrc`에 `export PATH="$HOME/.local/bin:$PATH"`를 넣고, 해당 셸에서 `source`를 한 뒤 `rehash`나 `hash -r`를 해주면 끝이다. 이렇게 해 두니 새 프로그램을 들일 때마다 시스템 디렉터리를 건드리지 않아도 되고, 혹시나 실수로 링크를 잘못 만들었어도 내 홈 디렉터리 안에서 문제를 해결할 수 있어 마음이 편해졌다.

그래도 전역으로 공유해야 할 도구가 있을 때는 `/usr/local/bin`을 포기할 수 없다. 이럴 때는 링크를 만들면 끝이 아니라, PATH 순서 속에서 그 디렉터리가 앞쪽에 있는지 다시 체크해야 한다. `/etc/profile.d/local-path.sh` 같은 스크립트를 만들어 시스템 전체에 `export PATH="/usr/local/bin:/usr/local/sbin:$PATH"`를 선언하고, 새 로그인 세션에서 반영되는지도 꼭 확인한다. 서버를 재부팅하기 어렵다면 임시로 각 계정의 셸 설정에도 같은 내용을 추가해 두는 편이 안전했다.

이렇게 하나씩 짚어 보니 결국 PATH와 권한, 그리고 쉘의 기억력 사이의 균형 싸움이었다. 링크가 말을 안 듣는 날에는 “혹시 캐시?” “혹시 secure_path?” “혹시 noexec?” 하고 자문해 보는 습관이 생겼다. 덕분에 요즘은 새 프로그램을 들이는 일이 예전보다 훨씬 단순해졌다.

마지막으로 나는 항상 `which -a 프로그램`과 `프로그램 --help`를 실행해 보며 마무리를 짓는다. 터미널이 조용히 응답해 줄 때의 안도감이란. 언젠가 다시 PATH가 삐끗거릴 때, 이 글이 내 자신에게도 작은 리마인더가 되어 주었으면 한다. “모든 길은 PATH에 있다”는 약간의 농담과 함께요.

```

### proxmox-thin-provision.md

**Path:** `frontend/public/posts/2025/proxmox-thin-provision.md`

```markdown
---
title: "ZFS 풀 앞에서 멈춰 선 Proxmox, 그 밤의 기록"
date: "2025-10-24"
category: "Linux"
tags: ['Proxmox', 'ZFS', 'Thin Provision', '가상화', '스토리지']
excerpt: "1.85TB 디스크를 추가하려다 ZFS가 '공간 없음'을 외친 밤. 스냅샷과 예약 공간 사이에서 배운 얇은 줄타기 경험담"
readTime: "6분"
---

그날 밤 Proxmox 대시보드는 말끔했지만, 새 VM 디스크를 추가하는 순간 화면이 얼어붙었습니다. `cannot create 'EA_raid_disk/vm-104-disk-0': out of space`라는 메시지가 달랑 떠 있고, VM은 급히 멈춰 섰죠. 여유 공간이 분명히 남아 있었는데도 말입니다. 혹시 여러분도 이런 경험 없으신가요? 저는 그 자리에서 ZFS가 보여주는 숫자와 실제로 예약해 둘 수 있는 공간이 왜 다른지 다시 배우게 됐습니다.

### 그날 새벽, 1.85TB가 막힌 이유

Proxmox에서 ZFS zvol을 기본값 그대로 만들면 두 손 가득한 **Thick Provisioning**을 택합니다. 1.85TB 디스크를 선언하는 순간 ZFS는 똑같은 크기의 `refreservation`을 확보하려고 덤비죠. "아직 빈 공간인데 왜?" 하고 속으로 외쳤지만, 풀 안쪽에서는 이미 스냅샷과 예약분이 차곡차곡 쌓여 있었습니다. ZFS는 실제 데이터가 아닌 **미래에 쓸 자리**까지 미리 약속해 둔 셈이라, 남은 물리 용량보다 예약을 먼저 따져 보고 "이건 못 빌려주겠다"며 막아 세운 거였습니다.

사실 VM이 툭 떨어진 것도 같은 맥락이었어요. 디스크 추가가 실패한 뒤 설정이 비틀어졌고, ZFS가 I/O를 잠시 막으면서 VM이 파즈(Pause) 상태로 미끄러진 겁니다. 순간적으로 "혹시 풀 자체가 꽉 찼나?" 하는 두려움이 엄습했지만, 실제로는 예약 공간이 딱 막혀 있었습니다. Thick Provisioning이 주는 안전선이 이럴 때는 족쇄가 되기도 하더군요.

### 진단은 이렇게 풀어냈다

첫 번째로 한 일은 냉정하게 숫자를 확인하는 것이었습니다. `zpool list`를 실행해 `FREE` 값이 1.85TB보다 작다는 사실을 확인했죠. 처음엔 "분명 여유 공간이 더 있어야 하는데"라고 생각했지만, 바로 이어서 `zfs list -o space -r EA_raid_disk`를 돌려 보니 진짜 원인이 드러났습니다. `USEDSNAP`에 적힌 용량이 예상보다 훨씬 컸고, 몇몇 zvol에는 `USEDREFRESERV`가 두툼하게 쌓여 있었습니다. 스냅샷과 예약이 눈에 보이지 않는 곳에서 공간을 꽉 움켜쥐고 있었던 거죠.

여기서 중요한 건, 숫자를 확인하는 명령어가 단순한 스크립트가 아니라 **상황을 해석하도록 도와주는 대화**라는 사실입니다. 저는 모니터 앞에서 "그렇다면 먼저 스냅샷을 정리해야겠구나" 하고 중얼거렸고, 바로 Proxmox UI의 Snapshots 탭으로 향했습니다. 오래된 스냅샷을 삭제하고 몇 분을 기다렸더니 ZFS가 한숨을 돌린 듯 예약 공간이 조금씩 풀리기 시작했습니다. 공감 가시죠? 우리는 늘 데이터의 보험과 실사용 사이에서 줄타기를 합니다.

### 선택지는 결국 세 가지였다

스냅샷 정리가 어느 정도 끝나자 다음에 할 일을 차분히 정리할 수 있었습니다. 불필요한 VM과 ISO를 지워 실제 여유 공간을 넓히고, 그래도 부족하면 물리 디스크를 추가하거나 풀 구성을 변경하는 방법이 떠올랐죠. 여기까지가 솔직히 가장 안전한 경로입니다. 다만 새벽에 마주한 프로젝트는 당장 서비스를 띄워야 했기에 저는 Thin Provision 옵션을 잠깐 바라보기도 했습니다. Proxmox 스토리지 설정에서 `Thin provision` 체크박스를 켜면, ZFS가 공간을 실제로 쓸 때까지 예약하지 않고 "나중에 채우자"며 느긋하게 움직입니다.

하지만 Thin Provision은 말 그대로 얇은 얼음판 위를 걷는 기분입니다. 여러 VM이 동시에 디스크를 채우기 시작하면, 어느 순간 실제 풀 용량이 바닥나고 모든 VM이 멈출 수 있거든요. 저는 그 순간 스스로에게 "당장의 편안함을 위해 전체 풀을 위험에 빠뜨릴 건가?"라고 물었습니다. 결국 Thin Provision은 최후의 비상용으로만 바라보고, 스냅샷과 예약을 정리하는 쪽을 선택했습니다. 잠시 머리를 식히고 나니, 지름길 대신 꾸준한 정리가 장기적으로 훨씬 담백하다는 사실이 또 한 번 확인됐습니다.

### 마무리하며: 예약과 현실 사이에서

이번 사건을 겪고 나니 ZFS는 숫자를 정확히 맞추는 꼼꼼한 회계사 같다는 생각이 듭니다. 눈앞에 보이는 "남은 공간"보다 "예약한 공간"을 먼저 떠올리는 습관을 들여야 한다는 말이죠. 다시는 같은 실수를 반복하지 않기 위해 저는 주기적으로 `zfs list -o space`를 확인하고, 스냅샷을 장기간 방치하지 않기로 마음먹었습니다. 여러분도 혹시 Proxmox에서 갑자기 디스크가 안 만들어지고 VM이 멈춰 버린다면, 겁먹기 전에 ZFS가 어떤 약속을 지키려 하고 있는지부터 살펴보세요. 그리고 Thin Provision이라는 유혹 앞에서는 한 번 더 숨을 고르시길 바랍니다. 정말 간단하진 않지만, 이렇게 정리해 두면 다음 밤엔 훨씬 덜 당황하게 되더라고요.
```

### python-ai-chatbot-development.md

**Path:** `frontend/public/posts/2025/python-ai-chatbot-development.md`

```markdown
---
title: "Python으로 AI 챗봇 만들기"
date: "2024-10-11"
category: "AI/ML"
tags: ["Python", "AI", "Chatbot", "OpenAI"]
excerpt: "OpenAI API를 활용하여 실용적인 AI 챗봇을 구현하는 과정을 단계별로 설명합니다."
readTime: "8분"
---

# Python으로 AI 챗봇 만들기

## 왜 챗봇을 만들어보고 싶었나?

사실 처음에는 '요즘 ChatGPT가 인기니까 나도 비슷한 걸 만들어볼까?' 하는 호기심에서 시작했다. 그런데 막상 해보니 생각보다 재밌더라. 특히 내가 원하는 방식으로 대화하는 AI를 만들 수 있다는 게 신기했다.

학교 과제할 때도 그냥 ChatGPT 쓰는 것보다, 내가 만든 챗봇이 내 스타일에 맞춰서 답해주면 더 좋을 것 같았다.

## 준비 단계 - 라이브러리 설치하기

일단 필요한 것들부터 깔아야 한다. 

```bash
pip install openai
pip install python-dotenv
pip install flask
```

openai는 당연히 OpenAI API 쓰려고, python-dotenv는 API 키 같은 걸 안전하게 관리하려고, flask는 나중에 웹으로 만들어보려고 설치했다.

## 기본 챗봇 만들어보기

### 환경 설정부터

```python
import openai
import os
from dotenv import load_dotenv

load_dotenv()
openai.api_key = os.getenv('OPENAI_API_KEY')
```

API 키를 코드에 직접 적으면 나중에 깃허브에 올릴 때 위험하니까, .env 파일에 따로 저장해서 불러오는 방식을 썼다. 처음에는 이것도 몰라서 코드에 그냥 적었다가 나중에 바꿨다.

### 챗봇 클래스 만들기

```python
class MyAIChatbot:
    def __init__(self):
        self.chat_history = []  # 대화 기록 저장해두기
    
    def add_to_history(self, who_said_it, what_they_said):
        self.chat_history.append({
            "role": who_said_it,
            "content": what_they_said
        })
    
    def get_ai_response(self, user_input):
        # 사용자가 말한 거 기록에 추가
        self.add_to_history("user", user_input)
        
        try:
            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=self.chat_history,
                max_tokens=150,  # 너무 길면 비용이...
                temperature=0.7  # 적당히 창의적으로
            )
            
            ai_response = response.choices[0].message.content
            self.add_to_history("assistant", ai_response)
            
            return ai_response
        except Exception as e:
            return f"앗, 뭔가 잘못됐네요: {str(e)}"
```

처음에 만들 때는 대화 기록을 저장하는 걸 깜빡했다. 그래서 AI가 앞에서 뭔 얘기했는지 기억을 못해서 대화가 이상했다. 나중에 chat_history를 추가하니까 훨씬 자연스러워졌다.

temperature는 여러 번 실험해봤는데, 0.7 정도가 적당한 것 같다. 너무 낮으면 재미없고, 너무 높으면 이상한 소리를 한다.

## 웹으로 만들어보자 - Flask 사용하기

터미널에서만 대화하는 것보다는 웹에서 할 수 있으면 더 좋을 것 같아서 Flask를 써봤다.

```python
from flask import Flask, render_template, request, jsonify

app = Flask(__name__)
my_chatbot = MyAIChatbot()

@app.route('/')
def main_page():
    return render_template('chat.html')

@app.route('/chat', methods=['POST'])
def chat_with_bot():
    user_message = request.json['message']
    bot_response = my_chatbot.get_ai_response(user_message)
    return jsonify({'response': bot_response})

if __name__ == '__main__':
    app.run(debug=True)
```

HTML 파일은 간단하게 만들었다. 채팅 인터페이스 같은 느낌으로.

```html
<!DOCTYPE html>
<html>
<head>
    <title>내가 만든 챗봇</title>
</head>
<body>
    <div id="chat-container">
        <div id="messages"></div>
        <input type="text" id="user-input" placeholder="메시지를 입력하세요...">
        <button onclick="sendMessage()">전송</button>
    </div>

    <script>
        function sendMessage() {
            const userInput = document.getElementById('user-input');
            const message = userInput.value;
            
            if(message.trim() === '') return;
            
            // 사용자 메시지 화면에 표시
            addMessageToChat('나', message);
            
            // AI에게 보내기
            fetch('/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({message: message})
            })
            .then(response => response.json())
            .then(data => {
                addMessageToChat('AI', data.response);
            });
            
            userInput.value = '';
        }
        
        function addMessageToChat(sender, message) {
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML += `<p><strong>${sender}:</strong> ${message}</p>`;
        }
    </script>
</body>
</html>
```

첫 번째로 만든 웹 인터페이스는 정말 투박했다. 그냥 기능만 되게 만든 느낌이었는데, 그래도 작동하니까 뿌듯했다.

## 조금 더 똑똑하게 만들어보기

### 대화 맥락 관리하기

처음에는 무제한으로 대화 기록을 저장했는데, 그러다 보니 토큰 수가 계속 늘어나서 비용이 부담됐다. 그래서 최근 10개 정도만 기억하도록 바꿨다.

```python
class ImprovedChatbot:
    def __init__(self):
        self.chat_history = []
        self.max_history = 10  # 최근 10개 대화만 기억
    
    def manage_history(self):
        if len(self.chat_history) > self.max_history:
            # 가장 오래된 대화부터 삭제 (시스템 메시지는 유지)
            system_msgs = [msg for msg in self.chat_history if msg['role'] == 'system']
            recent_msgs = self.chat_history[-(self.max_history-len(system_msgs)):]
            self.chat_history = system_msgs + recent_msgs
```

### 감정 분석 넣어보기

사용자가 화나거나 슬플 때 그에 맞게 반응하면 더 좋을 것 같아서, 간단한 감정 분석을 넣어봤다.

```python
def analyze_emotion(self, text):
    # 간단한 키워드 기반 감정 분석
    positive_words = ['좋다', '행복', '기쁘다', '감사', '최고']
    negative_words = ['나쁘다', '슬프다', '화나다', '짜증', '최악']
    
    positive_count = sum(1 for word in positive_words if word in text)
    negative_count = sum(1 for word in negative_words if word in text)
    
    if positive_count > negative_count:
        return 'positive'
    elif negative_count > positive_count:
        return 'negative'
    else:
        return 'neutral'

def respond_with_emotion(self, user_input):
    emotion = self.analyze_emotion(user_input)
    
    if emotion == 'negative':
        # 조금 더 위로해주는 톤으로
        system_prompt = "사용자가 기분이 안 좋아 보이니 따뜻하고 위로가 되는 말투로 답변해줘."
    elif emotion == 'positive':
        # 함께 기뻐해주는 톤으로
        system_prompt = "사용자가 기분이 좋아 보이니 함께 기뻐하는 밝은 말투로 답변해줘."
    else:
        system_prompt = "평상시처럼 자연스럽게 답변해줘."
    
    # 시스템 프롬프트 추가해서 API 호출
    messages_with_emotion = [{"role": "system", "content": system_prompt}] + self.chat_history
    # ... API 호출 코드
```

### 개인화 기능

사용자가 자주 하는 질문이나 관심사를 기억해서, 그에 맞는 답변을 해주면 좋겠다고 생각했다.

```python
class PersonalizedBot:
    def __init__(self):
        self.user_preferences = {}
        self.frequent_topics = []
    
    def learn_about_user(self, user_input):
        # 사용자가 자주 언급하는 주제들 찾기
        keywords = self.extract_keywords(user_input)
        for keyword in keywords:
            if keyword in self.user_preferences:
                self.user_preferences[keyword] += 1
            else:
                self.user_preferences[keyword] = 1
    
    def get_personalized_response(self, user_input):
        self.learn_about_user(user_input)
        
        # 사용자 관심사 기반으로 시스템 프롬프트 조정
        top_interests = sorted(self.user_preferences.items(), 
                              key=lambda x: x[1], reverse=True)[:3]
        
        if top_interests:
            interests_text = ", ".join([interest[0] for interest in top_interests])
            system_prompt = f"사용자는 {interests_text}에 관심이 많습니다. 이를 고려해서 답변해주세요."
        else:
            system_prompt = "자연스럽게 답변해주세요."
        
        # ... 나머지 로직
```

## 해보면서 어려웠던 점들

### API 비용 관리

처음에는 신경 안 쓰고 막 써봤는데, 며칠 지나니까 비용이 꽤 나오더라. 그래서 토큰 수를 제한하고, 불필요한 API 호출을 줄이는 방법을 고민하게 됐다.

### 응답 속도

사용자가 메시지를 보내고 나서 AI가 답할 때까지 시간이 걸리는데, 이게 너무 오래 걸리면 답답하다. 특히 긴 대화 기록이 있을 때는 더 오래 걸렸다.

그래서 로딩 애니메이션을 넣거나, "생각 중..." 같은 메시지를 보여주는 걸로 사용자 경험을 개선했다.

### 이상한 답변 처리

가끔 AI가 정말 이상한 답변을 할 때가 있다. 특히 한국어로 대화할 때 어색한 표현을 쓰거나, 맥락을 이해하지 못할 때가 있었다.

완전히 해결하지는 못했지만, 시스템 프롬프트에 "자연스러운 한국어로 답변해줘"라고 명시하니까 좀 나아졌다.

## 지금까지 해보고 느낀 점

생각보다 간단하게 시작할 수 있어서 좋았다. OpenAI API 덕분에 복잡한 AI 모델을 직접 훈련할 필요 없이, 바로 결과를 볼 수 있어서 재밌었다.

하지만 정말 유용한 챗봇을 만들려면 단순히 API 연결하는 것 이상이 필요하다는 걸 깨달았다. 사용자 경험, 개인화, 비용 최적화 등 고려할 게 많다.

무엇보다 '왜 이 챗봇을 쓸까?'에 대한 명확한 목적이 있어야 한다는 걸 느꼈다. 그냥 ChatGPT랑 똑같은 걸 만들면 의미가 없으니까.

앞으로는 특정 용도(예: 공부 도우미, 일정 관리 등)에 특화된 챗봇을 만들어보고 싶다. 그리고 음성 인식이나 이미지 분석 같은 기능도 추가해보면 재밌을 것 같다.
```

### shell-powertools-journal.md

**Path:** `frontend/public/posts/2025/shell-powertools-journal.md`

```markdown
---
title: "awk와 sed, 그리고 xargs에 빚진 작은 승리들"
date: "2025-10-27"
category: "Linux"
tags: ['awk', 'sed', 'xargs', '리눅스쉘', '자동화']
excerpt: "파이프라인 하나로 서버를 살린 순간을 떠올리며, 내가 사랑하는 세 가지 쉘 친구들을 일기처럼 적어 봤습니다."
readTime: "7분"
---

터미널 앞에서 밤을 새운 날이면, 저는 늘 같은 친구들을 떠올립니다. `sed`, `awk`, `xargs`. 처음에는 매뉴얼을 붙잡고 외워야 했던 낯선 이름들이었는데, 어느새 제 일상에 가장 든든한 동료가 되어 버렸죠. 오늘은 왜 이 셋을 사랑하게 됐는지, 그리고 어떻게 서로 손을 잡고 제 업무를 구해냈는지 이야기해 보려고 합니다.

### sed를 만나고 텍스트가 말을 듣기 시작했다

서버 로그를 보고 있으면, 단 한 줄의 타이포 때문에 서비스가 멈춰 서기도 합니다. 그럴 때마다 저는 `sed`를 불러냅니다. "Stream Editor"라는 근사한 이름을 가진 이 친구는 흐르는 텍스트를 조용히 갈아엎는 데 특화돼 있죠. 처음에는 `sed 's/hello/world/' text.txt` 같은 단순 치환만 써 봤습니다. 그런데 `sed 's/hello/world/g'`처럼 `g` 플래그를 붙이면 한 줄에 있는 모든 문자열을 바꿀 수 있고, `sed -i` 옵션까지 더하면 파일을 직접 고쳐 준다는 사실을 깨닫는 순간, 진짜 마법을 본 느낌이었어요.

예전에 운영 중인 서비스에서 "DEBUG" 메시지가 하루 밤사이에 로그를 뒤덮은 적이 있습니다. 새벽에 일어나자마자 `sed -i 's/DEBUG/INFO/g' app.log`를 실행하면서, 이 친구가 없었다면 얼마나 많은 파일을 손으로 열고 있었을지 상상했습니다. 어떤 날은 `sed '/error/d' error.log`처럼 특정 단어를 포함한 줄을 싹 지워버리기도 했고요. 스트림처럼 흘러가는 텍스트를 실시간으로 다듬을 수 있다는 건, 쉘에서 데이터를 다루는 감각 자체를 바꿔 주었습니다.

### awk 덕분에 텍스트가 테이블로 보이기 시작했다

`awk`를 처음 접했을 때, "이건 작은 데이터베이스 같다"는 생각을 했습니다. 줄을 읽고, 공백이나 콜론 같은 구분자를 기준으로 필드를 나눠서, 원하는 열만 쏙 빼 올 수 있으니까요. `/etc/passwd`를 열어 `awk -F':' '{print $1, $6}' /etc/passwd`라고 치면 사용자 이름과 홈 디렉터리가 나란히 정렬되어 나옵니다. 기존에는 `cut`이나 `grep`으로 조합하던 작업이 한 줄에 정리되는 걸 보고 감탄했던 기억이 있습니다.

또 다른 날에는 서버 접근 로그에서 특정 조건을 찾고 싶었습니다. "세 번째 필드가 500보다 큰 줄만 보여줘"라고 말하면 `awk '$3 > 500 {print $0}' data.txt`로 답합니다. 패턴 매칭도 자유롭죠. `awk '/root/ {print $1}' /etc/passwd`처럼 정규식을 붙이면 특정 단어가 있는 줄만 골라낼 수 있습니다. 저는 여기에 `BEGIN`과 `END` 블록을 더해서 제목과 꼬릿말을 넣곤 합니다. `awk -F':' 'BEGIN {print "--- User List ---"} {print $1} END {print "--- END ---"}' /etc/passwd` 같은 모양이죠. 작은 리포트를 즉석에서 꾸밀 수 있다는 건, 쉘 스크립트를 좀 더 살가운 형태로 만들어 줬습니다.

### xargs는 파이프라인의 마지막 연결고리였다

`sed`와 `awk`가 데이터를 다듬는 역할이라면, `xargs`는 그 데이터를 다른 명령의 인자로 깔끔하게 넘겨주는 역할을 맡습니다. 처음 `find . -name "*.tmp" | xargs rm`을 실행했을 때, "Argument list too long" 오류를 피해가는 방법을 알게 되었죠. 작은 파일이 수천 개 쌓여 있을 때, 이 명령어는 정말 목숨줄 같은 존재였습니다.

저는 `xargs -n 1` 옵션을 종종 씁니다. `ls | xargs -n 1 echo`처럼 목록을 하나씩 처리하고 싶을 때요. 더 신중한 작업이라면 `-p`를 붙여 사용자가 직접 Y/N을 입력하도록 합니다. `find . -name "*.log" | xargs -p rm`처럼, 중요한 로그를 지우기 전에 마지막 한 번 더 묻는 셈이죠. 어느 날은 `xargs -I {}`를 더해 플레이스홀더 자리에 명령어를 심어 놓기도 했습니다. 유연하게 인자를 다루는 방법을 알게 되면서, 파이프라인이 훨씬 안정적으로 변했습니다.

### 세 친구가 힘을 합친 날의 이야기

이제 세 명령어를 합쳐 진짜 위기를 넘긴 경험을 얘기해 볼게요. `my_process`라는 프로세스가 누수를 일으키고 있던 하루, 저는 이렇게 한 줄을 적었습니다.

```
ps -ef | grep 'my_process' | awk '{print $2}' | xargs kill -9
```

`ps -ef`로 프로세스를 열거하고, `grep`으로 필요한 줄만 집어낸 뒤, `awk`로 PID만 추리고, 마지막에 `xargs kill -9`로 단번에 정리했습니다. 예전 같으면 PID를 직접 확인한 다음 하나씩 `kill`을 눌렀을 겁니다. 하지만 이 조합 덕분에 새벽 두 시에 서버를 살릴 수 있었어요.

또 어떤 날은 디렉터리가 로그 파일로 잔뜩 오염되어 있었죠. 저는 `find . -name "*.log" | xargs sed -i 's/DEBUG/INFO/g'`라는 명령으로 모든 로그의 레벨을 올려 버렸습니다. `find`가 파일을 찾고, `xargs`가 목록을 `sed`로 넘기며, `sed`는 각 파일 안에서 텍스트를 수정했습니다. 명령어 세 개가 릴레이하듯 책임을 나누는 모습에 혼자 미소를 지었습니다.

디스크 사용량이 90%를 넘어설 때만 메일을 보내는 스크립트를 짠 적도 있습니다. `df -h | grep '/dev/sd' | awk '{ sub(/%/, "", $5); if ($5 >= 90) print $0 }'`까지는 익숙했는데, 거기에 `xargs -I {} echo "{} is almost full." | mail -s "Disk Alert" admin@example.com`을 더하는 순간, 문자열이 멋지게 하나의 알림으로 변하더군요. 실무에서는 메일 명령과 인증이 더 필요하지만, 저는 이 예제를 통해 "필요한 줄만 추리고, 메시지를 만들어, 다른 시스템에 넘기는 일"이 얼마나 자연스러워졌는지 깨달았습니다.

최근에는 웹 서버 로그에서 가장 많이 요청된 IP를 찾는 작업을 맡았습니다. `cat access.log | awk '{print $1}' | sort | uniq -c | sort -rn | head -n 10`처럼, `awk`로 첫 번째 필드만 뽑아내고, `sort`와 `uniq`으로 빈도를 계산한 뒤 다시 정렬해 상위 10개를 출력했죠. 여기서는 `sed`나 `xargs`가 직접 등장하지는 않았지만, 데이터를 잘라내고 올바른 형태로 넘겨주는 `awk`의 힘을 다시 느꼈습니다. 이 한 줄로 모니터링 대시보드에 넣을 레포트를 빠르게 만들어, 팀에 공유했습니다.

### 쉘 작업이 두렵지 않은 이유

돌이켜 보면, `sed`, `awk`, `xargs` 덕분에 저는 쉘에서 데이터를 자유롭게 다룰 수 있게 되었습니다. 텍스트를 수정하고, 필요한 필드만 꺼내고, 다른 명령어에 자연스럽게 넘겨주는 과정이 더 이상 낯설지 않습니다. 가장 단순한 치환에서부터, 서버를 살리는 긴 파이프라인까지. 저는 이 친구들이 제게 가르쳐 준 사고방식을 아직도 곱씹곤 합니다.

어쩌면 셸을 두려워하는 사람들에게 하고 싶은 말이 있습니다. "처음엔 명령어를 외우느라 머리가 지끈하지만, 어느 순간 이 친구들이 여러분의 손발이 되어 줄 거예요." 하루의 마무리로 로그 파일을 정리하면서, 저는 늘 이렇게 중얼거립니다. "오늘도 sed, awk, xargs 덕분에 살았다."

```

### sorting-algorithms-masterclass.md

**Path:** `frontend/public/posts/2025/sorting-algorithms-masterclass.md`

```markdown
---
title: "정렬 알고리즘 완전 정복: 버블 정렬부터 힙 정렬까지"
date: "2025-11-01"
category: "알고리즘"
tags: ['정렬', '알고리즘', 'Java']
excerpt: "버블 정렬부터 힙 정렬까지, 핵심 비유와 수도 코드, Java 구현으로 정렬 알고리즘을 완전 정복합니다."
readTime: "14분"
---

# 정렬 알고리즘 완전 정복: 개념부터 자바 코드까지

## 1. 도입: 왜 정렬을 배워야 할까?

정렬(Sorting)은 **데이터를 다루는 거의 모든 순간에 등장하는 기본기**다. 스마트폰 주소록을 이름순으로 정리하거나, 온라인 쇼핑몰에서 가격순으로 상품을 나열하거나, 데이터베이스 인덱스를 만드는 일까지 정렬이 뒷받침한다. 정렬을 이해하면 데이터를 "보기 좋게" 만들 뿐 아니라, **검색・탐색 알고리즘의 효율까지 개선**할 수 있다.

이 글에서는 다음 6가지 대표 정렬 알고리즘을 다룬다.

- 버블 정렬 (Bubble Sort)
- 선택 정렬 (Selection Sort)
- 삽입 정렬 (Insertion Sort)
- 병합 정렬 (Merge Sort)
- 퀵 정렬 (Quick Sort)
- 힙 정렬 (Heap Sort)

각 알고리즘을 다음 5가지 관점으로 파헤친다.

1. **직관적인 비유**로 핵심 아이디어 이해하기
2. **동작 원리**를 단계별로 따라가기
3. **수도 코드(Pseudo Code)**로 논리 구조 확인하기
4. **Java 코드**로 실제 구현 보기
5. **성능 분석 및 활용 팁** 정리하기

정렬 알고리즘의 흐름과 차이를 한 번에 정리하고, 상황에 맞는 최적의 정렬을 고르는 감각을 길러보자.

## 2. 기본 정렬 알고리즘: $O(n^2)$의 세계

데이터 개수가 많지 않을 때, 혹은 정렬 로직을 처음 학습할 때 가장 자주 소개되는 세 가지 알고리즘이다. 구현은 쉽지만, 데이터가 커질수록 성능이 급격히 떨어진다.

### 2-1. 버블 정렬 (Bubble Sort) — 거품이 위로 올라오는 모습

#### 버블 정렬 핵심 비유

물속의 거품이 위로 올라오는 것처럼, **가장 큰 데이터가 매 회전마다 배열의 끝으로 밀려난다.** 두 사람씩 짝을 지어 키를 비교하고, 키가 더 큰 사람이 뒤로 가도록 자리를 바꾸는 교실 풍경을 떠올리면 된다.

#### 버블 정렬 동작 원리

1. 배열의 첫 번째 원소부터 시작해 바로 다음 원소와 비교한다.
2. 앞의 값이 더 크면 서로 교환한다.
3. 배열 끝까지 반복하면 가장 큰 값이 마지막 자리에 확정된다 (1 라운드).
4. 확정된 마지막 항목을 제외하고 나머지 구간에서 다시 라운드를 반복한다.

#### 버블 정렬 수도 코드

```text
Bubble_Sort(A[], n):
    for i from n-1 down to 1:
        for j from 0 to i-1:
            if (A[j] > A[j+1])
                swap A[j] and A[j+1]
```

#### 버블 정렬 Java 코드

```java
void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

#### 버블 정렬 성능 분석 및 활용

- 시간 복잡도: 최선 $O(n)$ (조기 종료 최적화 적용 시), 평균/최악 $O(n^2)$
- 공간 복잡도: $O(1)$ (제자리 정렬)
- 장점: 구현이 매우 직관적이며 교육용으로 적합
- 단점: 대부분의 상황에서 너무 느림
- 활용: 학습 목적의 데모, 데이터가 매우 작을 때만 고려

### 2-2. 선택 정렬 (Selection Sort) — 매 라운드 1등만 뽑기

#### 선택 정렬 핵심 비유

여러 명이 줄을 서 있을 때, 전체를 훑어 **가장 키가 작은 사람(1등)을 앞으로 보내고** 다음 라운드에서 남은 사람 중 1등을 다시 찾는 방식이다.

#### 선택 정렬 동작 원리

1. 전체 구간에서 최솟값을 찾아 첫 번째 위치와 교환한다.
2. 두 번째 위치 이후 구간에서 다시 최솟값을 찾고 두 번째 위치와 교환한다.
3. 배열이 정렬될 때까지 이 과정을 반복한다.

#### 선택 정렬 수도 코드

```text
Selection_Sort(A[], n):
    for i from 0 to n-2:
        minIndex ← i
        for j from i+1 to n-1:
            if (A[j] < A[minIndex])
                minIndex ← j
        swap A[i] and A[minIndex]
```

#### 선택 정렬 Java 코드

```java
void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
```

#### 선택 정렬 성능 분석 및 활용

- 시간 복잡도: 최선/평균/최악 모두 $O(n^2)$
- 공간 복잡도: $O(1)$
- 장점: 교환 횟수가 최대 $n-1$로 제한되고, 불필요한 교환이 적다.
- 단점: 비교 횟수가 항상 많다. 안정 정렬이 아니다.
- 활용: 메모리 쓰기가 비싼 환경(플래시 메모리 등)에서 드물게 사용

### 2-3. 삽입 정렬 (Insertion Sort) — 카드 뭉치를 손으로 정리하기

#### 삽입 정렬 핵심 비유

손에 쥔 카드를 정리하는 모습을 떠올리자. 새로 뽑은 카드를 이미 정렬된 카드들 사이에서 맞는 위치에 "삽입"한다.

#### 삽입 정렬 동작 원리

1. 두 번째 원소부터 시작해, 그 앞쪽(이미 정렬된 부분)에 삽입 위치를 찾는다.
2. 삽입 위치까지 원소를 한 칸씩 뒤로 밀고, 빈 자리에 새 원소를 넣는다.
3. 배열이 끝날 때까지 반복한다.

#### 삽입 정렬 수도 코드

```text
Insertion_Sort(A[], n):
    for i from 1 to n-1:
        key ← A[i]
        j ← i - 1
        while (j ≥ 0 and A[j] > key):
            A[j + 1] ← A[j]
            j ← j - 1
        A[j + 1] ← key
```

#### 삽입 정렬 Java 코드

```java
void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

#### 삽입 정렬 성능 분석 및 활용

- 시간 복잡도: 최선 $O(n)$ (이미 거의 정렬된 경우), 평균/최악 $O(n^2)$
- 공간 복잡도: $O(1)$
- 장점: 데이터가 거의 정렬된 경우 매우 빠르며 안정 정렬이다.
- 단점: 역순 데이터에 취약하다.
- 활용: 작은 구간 정렬, 하이브리드 정렬 알고리즘(TimSort 등)의 기본 블록

## 3. 고급 정렬 알고리즘: $O(n \log n)$의 세계

데이터가 커질수록 효율적인 알고리즘이 필요하다. 분할 정복과 힙 자료구조를 활용한 대표적인 세 가지를 살펴보자.

### 3-1. 병합 정렬 (Merge Sort) — 나눠서 정복하기

#### 병합 정렬 핵심 비유

책상이 책으로 가득 차 있다면, 혼자 정리하기보다 **반으로 나눠서** 각각 정리한 다음 다시 합치는 편이 낫다. 병합 정렬은 데이터를 최소 단위까지 나눈 뒤, **정렬된 작은 조각을 merge 함수로 합쳐 전체를 정렬**한다.

#### 병합 정렬 동작 원리

1. 배열을 절반으로 나눈다 (Divide).
2. 각 절반을 재귀적으로 정렬한다.
3. 두 정렬된 배열을 merge 함수로 합쳐 최종 정렬된 배열을 만든다 (Conquer).

#### 병합 정렬 수도 코드 (Merge 함수)

```text
Merge(A[], p, q, r):
    i ← p; j ← q + 1; t ← 0
    while (i ≤ q and j ≤ r):
        if (A[i] < A[j]) tmp[t++] ← A[i++]
        else tmp[t++] ← A[j++]
    while (i ≤ q): tmp[t++] ← A[i++]
    while (j ≤ r): tmp[t++] ← A[j++]
    i ← p; t ← 0
    while (i ≤ r): A[i++] ← tmp[t++]
```

#### 병합 정렬 Java 코드

```java
void mergeSort(int[] arr) {
    if (arr.length < 2) {
        return;
    }
    mergeSort(arr, 0, arr.length - 1, new int[arr.length]);
}

private void mergeSort(int[] arr, int left, int right, int[] temp) {
    if (left >= right) {
        return;
    }
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid, temp);
    mergeSort(arr, mid + 1, right, temp);
    merge(arr, left, mid, right, temp);
}

private void merge(int[] arr, int left, int mid, int right, int[] temp) {
    int i = left;
    int j = mid + 1;
    int t = 0;

    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[t++] = arr[i++];
        } else {
            temp[t++] = arr[j++];
        }
    }
    while (i <= mid) {
        temp[t++] = arr[i++];
    }
    while (j <= right) {
        temp[t++] = arr[j++];
    }
    i = left;
    t = 0;
    while (i <= right) {
        arr[i++] = temp[t++];
    }
}
```

#### 병합 정렬 성능 분석 및 활용

- 시간 복잡도: 모든 경우 $O(n \log n)$
- 공간 복잡도: $O(n)$ (보조 배열 필요)
- 장점: 비교 기반 정렬 중 안정성이 뛰어나며, 예측 가능한 수행 시간
- 단점: 추가 메모리 사용, 작은 데이터에서는 재귀 비용이 부담
- 활용: 안정 정렬이 필요한 경우, 외부 정렬(external sort)

### 3-2. 퀵 정렬 (Quick Sort) — 기준으로 좌우를 나누기

#### 퀵 정렬 핵심 비유

단체 사진을 찍을 때, 기준이 될 사람을 뽑고 **그 사람보다 키가 작은 사람은 왼쪽, 큰 사람은 오른쪽으로 보내** 두 줄로 나눈다. 이후 각 줄에서 다시 같은 작업을 반복한다.

#### 퀵 정렬 동작 원리

1. 피벗(Pivot)을 하나 선택한다.
2. 피벗보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할한다 (Partition).
3. 분할된 두 구간에서 재귀적으로 퀵 정렬을 수행한다.

#### 퀵 정렬 수도 코드 (Partition 포함)

```text
Quick_Sort(A[], p, r):
    if (p < r):
        q ← partition(A, p, r)
        Quick_Sort(A, p, q - 1)
        Quick_Sort(A, q + 1, r)

partition(A, p, r):
    pivot ← A[r]
    i ← p - 1
    for j from p to r - 1:
        if (A[j] ≤ pivot):
            i ← i + 1
            swap A[i] and A[j]
    swap A[i + 1] and A[r]
    return i + 1
```

#### 퀵 정렬 Java 코드

```java
void quickSort(int[] arr) {
    quickSort(arr, 0, arr.length - 1);
}

private void quickSort(int[] arr, int left, int right) {
    if (left >= right) {
        return;
    }
    int pivotIndex = partition(arr, left, right);
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
}

private int partition(int[] arr, int left, int right) {
    int pivot = arr[right];
    int i = left - 1;
    for (int j = left; j < right; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr, i, j);
        }
    }
    swap(arr, i + 1, right);
    return i + 1;
}

private void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

#### 퀵 정렬 성능 분석 및 활용

- 시간 복잡도: 평균 $O(n \log n)$, 최악 $O(n^2)$ (불균형 피벗 선택 시)
- 공간 복잡도: 평균 $O(\log n)$ (재귀 호출 스택)
- 장점: 평균적으로 매우 빠르고 제자리 정렬이다.
- 단점: 최악의 경우 성능이 떨어지며 안정 정렬이 아니다.
- 활용: 대부분의 언어에서 기본 정렬의 핵심 아이디어. 랜덤 피벗, median-of-three 같은 최적화와 함께 사용

### 3-3. 힙 정렬 (Heap Sort) — 토너먼트로 승자 가려내기

#### 힙 정렬 핵심 비유

모든 데이터를 **최대 힙(Max Heap)**이라는 토너먼트 대진표로 구성한다. 루트에는 항상 우승자(최댓값)가 있고, 우승자를 뽑아 정렬된 배열의 맨 뒤에 붙인다. 마지막 원소를 루트로 올린 뒤 **percolateDown**을 실행해 새로운 우승자를 만들기를 반복한다.

#### 힙 정렬 동작 원리

1. 배열을 최대 힙 구조로 만든다 (Heapify).
2. 루트(최댓값)와 배열의 마지막 값을 교환한다.
3. 힙 크기를 하나 줄이고, 루트에 대해 percolateDown을 실행해 힙 속성을 복구한다.
4. 모든 원소가 정렬될 때까지 2-3단계를 반복한다.

#### 힙 정렬 수도 코드 (percolateDown & deleteMax)

```text
percolateDown(A[], k, n):
    child ← 2k + 1
    while (child ≤ n - 1):
        right ← 2k + 2
        if (right ≤ n - 1 and A[child] < A[right])
            child ← right
        if (A[k] < A[child]):
            swap A[k] and A[child]
            k ← child
            child ← 2k + 1
        else:
            break

deleteMax(A[], n):
    max ← A[0]
    A[0] ← A[n - 1]
    percolateDown(A, 0, n - 1)
    return max
```

**Java 코드**

```java
void heapSort(int[] arr) {
    int n = arr.length;

    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    for (int end = n - 1; end > 0; end--) {
        swap(arr, 0, end);
        heapify(arr, end, 0);
    }
}

private void heapify(int[] arr, int heapSize, int root) {
    int largest = root;
    int left = 2 * root + 1;
    int right = 2 * root + 2;

    if (left < heapSize && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < heapSize && arr[right] > arr[largest]) {
        largest = right;
    }
    if (largest != root) {
        swap(arr, root, largest);
        heapify(arr, heapSize, largest);
    }
}

private void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

**성능 분석 및 활용**

- 시간 복잡도: 항상 $O(n \log n)$
- 공간 복잡도: $O(1)$
- 장점: 최악의 경우에도 일정한 속도를 보장, 추가 메모리가 필요 없음
- 단점: 안정 정렬이 아니며, 실제로는 캐시 효율이 다소 떨어질 수 있다.
- 활용: 우선순위 큐, 실시간 시스템 등에서 안정적인 수행 시간이 필요할 때

## 4. 총정리 & 비교 분석

### 4-1. 정렬 알고리즘 한눈에 보기

| 알고리즘 | 평균 시간 복잡도 | 최악 시간 복잡도 | 공간 복잡도 | 안정성 |
| :--- | :---: | :---: | :---: | :---: |
| 버블 정렬 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | O |
| 선택 정렬 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | X |
| 삽입 정렬 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | O |
| 병합 정렬 | $O(n \log n)$ | $O(n \log n)$ | $O(n)$ | O |
| 퀵 정렬 | $O(n \log n)$ | $O(n^2)$ | $O(\log n)$ | X |
| 힙 정렬 | $O(n \log n)$ | $O(n \log n)$ | $O(1)$ | X |

### 4-2. 상황별 추천 가이드

1. **데이터가 매우 적거나 거의 정렬되어 있다면?** 삽입 정렬이 가장 빠르게 끝난다.
2. **정렬 후에도 원래의 상대적 순서를 지켜야 한다면?** 안정 정렬인 병합 정렬을 선택하자.
3. **평균적으로 가장 빠른 정렬이 필요하다면?** 퀵 정렬이 현실적인 선택이다.
4. **추가 메모리가 거의 없고 최악의 경우에도 성능 보장이 필요하다면?** 힙 정렬이 안전하다.
5. **정렬을 처음 배우는 중이라면?** 버블 정렬과 선택 정렬로 기본 개념을 익힌 뒤, 삽입 정렬로 성능 차이를 느껴보자.

## 5. 결론: 상황에 맞는 최적의 선택이 답이다

정렬 알고리즘은 "어떤 것이 절대적으로 최고"가 아니라, **상황과 요구 조건에 따라 최선의 선택이 달라지는 도구 상자**다. 오늘 살펴본 6가지 알고리즘은 모두 Java로 쉽게 구현할 수 있으며, 실제 언어가 제공하는 `Arrays.sort()`나 `Collections.sort()` 역시 내부에서 이러한 아이디어를 변형해 사용한다.

내장 함수만 쓰더라도 정렬의 내부 작동 방식을 이해하면, 성능 이슈를 진단하거나 문제 상황에 맞는 대체 로직을 설계할 때 큰 도움이 된다. 이번 정리를 발판 삼아, 더 다양한 자료구조와 알고리즘으로 학습 범위를 넓혀보자.

```

### sorting-algorithms-pseudocode-analysis.md

**Path:** `frontend/public/posts/2025/sorting-algorithms-pseudocode-analysis.md`

```markdown
---
title: "정렬 알고리즘 수도 코드 완전 해부: 라인별 분석"
date: "2025-11-02"
category: "알고리즘"
tags: ['정렬', '알고리즘', '수도코드', '학습노트']
excerpt: "버블 정렬부터 힙 정렬까지, 핵심 수도 코드를 한 줄씩 뜯어보며 왜 그런 로직이 필요한지 한국어로 상세하게 분석합니다."
readTime: "18분"
---

## 정렬 알고리즘 수도 코드 완전 해부

기존 글인 《정렬 알고리즘 완전 정복: 버블 정렬부터 힙 정렬까지》(@/home/nodove/workspace/blog/frontend/public/posts/2025/sorting-algorithms-masterclass.md)를 기반으로, 이번에는 **각 알고리즘의 수도 코드 각각의 행이 의미하는 바를 세밀하게 분석**한다. 흐름을 한 눈에 이해하는 것과 별개로, “왜 이 줄이 필요할까?”라는 의문을 해결하는 데 집중했다.

> **읽는 방법**
>
> 1. 먼저 수도 코드를 전체로 살펴보고,
> 2. 곧바로 라인별 해설과 설계상의 이유, 주의할 점을 확인하자.

## 1. 버블 정렬 (Bubble Sort)

### 1-1. 수도 코드

```text
Bubble_Sort(A[], n):
    for i from n-1 down to 1:
        for j from 0 to i-1:
            if (A[j] > A[j+1])
                swap A[j] and A[j+1]
```

### 1-2. 라인별 해설

- `Bubble_Sort(A[], n):`
  - 정렬 대상 배열 `A`와 길이 `n`을 인자로 받는다. 외부에서 배열 복사 없이 **제자리 정렬**을 수행한다는 전제가 깔려 있다.
- `for i from n-1 down to 1:`
  - 바깥 루프는 “이번 라운드에서 끝에 확정될 위치”를 가리킨다. `n-1`에서 시작해 줄어들기 때문에, 이미 정렬된 마지막 구간을 다시 검사하지 않는다.
- `for j from 0 to i-1:`
  - 현재 라운드에서 비교해야 할 구간은 `0`부터 `i-1`까지. `i` 위치에는 앞선 라운드에서 가장 큰 값이 밀려 들어가므로, **불필요한 비교를 줄이는 최적화**다.
- `if (A[j] > A[j+1])`
  - **오름차순 정렬 기준**을 명시한다. 조건을 뒤집으면 내림차순으로도 쉽게 바뀐다.
- `swap A[j] and A[j+1]`
  - 인접한 두 원소를 교체하여 “큰 값이 뒤로 이동”하도록 만든다. 버블 정렬의 핵심 동작이며, 스왑 횟수가 최악인 이유이기도 하다.

### 1-3. 왜 이렇게 설계했을까?

- 인접 비교만 사용하므로 구현이 단순하다.
- 하지만 매 라운드에 최대 한 번의 최댓값만 확정되기 때문에 $O(n^2)$이 불가피하다.
- 조기 종료를 넣고 싶다면 라운드마다 교환 발생 여부를 기록하는 `swapped` 플래그 추가가 일반적이다.

## 2. 선택 정렬 (Selection Sort)

### 2-1. 수도 코드

```text
Selection_Sort(A[], n):
    for i from 0 to n-2:
        minIndex ← i
        for j from i+1 to n-1:
            if (A[j] < A[minIndex])
                minIndex ← j
        swap A[i] and A[minIndex]
```

### 2-2. 라인별 해설

- `Selection_Sort(A[], n):`
  - 배열 전체를 한 번에 책임지는 함수. 입력 검증이나 복사 없이 직접 정렬한다.
- `for i from 0 to n-2:`
  - 현재 라운드에서 “앞으로 보낼” 위치를 지정한다. 마지막 원소는 자동으로 자리가 정해지므로 `n-2`까지만 반복한다.
- `minIndex ← i`
  - 현재 구간에서 발견한 최솟값의 위치를 저장한다. 라운드가 시작될 때는 일단 `i`가 최솟값이라고 가정한다.
- `for j from i+1 to n-1:`
  - 남은 구간을 전부 훑어 진짜 최솟값을 찾는다. 비교 횟수가 항상 $O(n^2)$인 원인이다.
- `if (A[j] < A[minIndex])`
  - 더 작은 값을 만나면 `minIndex` 갱신. 안정성이 떨어지는 이유는 ‘같을 때’는 교환하지 않기 때문이다.
- `minIndex ← j`
  - 최솟값 위치를 최신화한다.
- `swap A[i] and A[minIndex]`
  - 탐색이 끝난 뒤 한 번만 스왑한다. **쓰기 횟수를 줄이는 장점**이 여기서 나온다.

### 2-3. 왜 이렇게 설계했을까?

- 쓰기 비용이 큰 환경에서 유리하다.
- 하지만 비교 횟수가 상당해, 큰 데이터셋에는 부적합하다.
- 안정성을 확보하려면 “선택된 최솟값을 끌어내고 나머지를 한 칸씩 미는” 삽입형 변형이 필요하다.

## 3. 삽입 정렬 (Insertion Sort)

### 3-1. 수도 코드

```text
Insertion_Sort(A[], n):
    for i from 1 to n-1:
        key ← A[i]
        j ← i - 1
        while (j ≥ 0 and A[j] > key):
            A[j + 1] ← A[j]
            j ← j - 1
        A[j + 1] ← key
```

### 3-2. 라인별 해설

- `Insertion_Sort(A[], n):`
  - 삽입 정렬의 메인 함수. 앞쪽 구간이 항상 정렬되어 있다는 **불변식**을 유지한다.
- `for i from 1 to n-1:`
  - 두 번째 원소부터 순차적으로 “손에 든 카드”처럼 처리한다. 첫 번째 원소는 이미 정렬됐다고 본다.
- `key ← A[i]`
  - 현재 삽입할 값을 별도 변수에 저장한다. 뒤로 미는 과정에서 값이 덮어써지는 것을 막는다.
- `j ← i - 1`
  - 정렬된 구간의 마지막 인덱스를 가리킨다.
- `while (j ≥ 0 and A[j] > key):`
  - 정렬된 구간을 거꾸로 탐색하며 적절한 삽입 위치를 찾는다. 조건식에 두 가지 검사를 함께 둬야 **경계와 정렬 조건**을 동시에 만족시킨다.
- `A[j + 1] ← A[j]`
  - 더 큰 값을 한 칸 뒤로 밀어 자리를 비운다. 이 과정 덕분에 안정성을 유지한다.
- `j ← j - 1`
  - 계속 왼쪽으로 이동하면서 비교한다.
- `A[j + 1] ← key`
  - 적절한 위치를 찾거나 배열의 맨 앞을 지나쳤다면, 비워둔 자리(`j+1`)에 키를 삽입한다.

### 3-3. 왜 이렇게 설계했을까?

- 이미 정렬된 구간은 건드리지 않고, 새 원소의 위치만 조정한다.
- 거의 정렬된 입력에서 매우 빠르기 때문에 하이브리드 정렬에서 자주 사용된다.
- `while` 조건 순서를 바꾸면 경계 검사가 늦게 수행돼 오류가 날 수 있다. `j >= 0` 검사를 먼저 두는 것이 안전하다.

## 4. 병합 정렬 (Merge Sort)

### 4-1. Merge 함수 수도 코드

```text
Merge(A[], p, q, r):
    i ← p; j ← q + 1; t ← 0
    while (i ≤ q and j ≤ r):
        if (A[i] < A[j]) tmp[t++] ← A[i++]
        else tmp[t++] ← A[j++]
    while (i ≤ q): tmp[t++] ← A[i++]
    while (j ≤ r): tmp[t++] ← A[j++]
    i ← p; t ← 0
    while (i ≤ r): A[i++] ← tmp[t++]
```

### 4-2. 라인별 해설

- `Merge(A[], p, q, r):`
  - `A[p..q]`와 `A[q+1..r]`가 이미 정렬되었다는 **전제**를 두고, 두 구간을 합쳐 정렬한다.
- `i ← p; j ← q + 1; t ← 0`
  - 왼쪽 구간 포인터 `i`, 오른쪽 구간 포인터 `j`, 그리고 임시 배열 인덱스 `t` 초기화.
- `while (i ≤ q and j ≤ r):`
  - 두 구간 모두에 원소가 남아 있는 동안 병합을 반복한다.
- `if (A[i] < A[j]) tmp[t++] ← A[i++]`
  - 더 작은 값을 임시 배열에 복사하고, 해당 포인터를 이동한다. 안정성을 위해 ‘같음’일 때는 오른쪽이 아닌 왼쪽을 먼저 선택한다.
- `else tmp[t++] ← A[j++]`
  - 오른쪽 구간의 값이 더 작거나 같은 경우를 처리한다.
- `while (i ≤ q): tmp[t++] ← A[i++]`
  - 왼쪽 구간에 남은 원소를 모두 복사한다.
- `while (j ≤ r): tmp[t++] ← A[j++]`
  - 오른쪽 구간에 남은 원소를 모두 복사한다.
- `i ← p; t ← 0`
  - 원본 배열에 결과를 덮어쓸 준비를 위해 인덱스를 재설정한다.
- `while (i ≤ r): A[i++] ← tmp[t++]`
  - 임시 배열 내용을 다시 `A`에 복사한다. **추가 메모리 필요성**이 바로 이 단계에서 비롯된다.

### 4-3. 왜 이렇게 설계했을까?

- 두 정렬 리스트를 선형 시간에 병합하려면 **양쪽 포인터를 동시에 움직이는 방식**이 최선이다.
- 임시 배열을 이용해 정렬된 결과를 안전하게 보관하고, 마지막에 한 번에 덮어쓴다.
- 안정성을 확보하려면 `<=` 대신 `<`를 사용해 왼쪽 선공 우선순위를 지켜야 한다.

## 5. 퀵 정렬 (Quick Sort)

### 5-1. 수도 코드

```text
Quick_Sort(A[], p, r):
    if (p < r):
        q ← partition(A, p, r)
        Quick_Sort(A, p, q - 1)
        Quick_Sort(A, q + 1, r)

partition(A, p, r):
    pivot ← A[r]
    i ← p - 1
    for j from p to r - 1:
        if (A[j] ≤ pivot):
            i ← i + 1
            swap A[i] and A[j]
    swap A[i + 1] and A[r]
    return i + 1
```

### 5-2. 라인별 해설 (Quick_Sort)

- `Quick_Sort(A[], p, r):`
  - 재귀 함수로, 부분 배열 `A[p..r]`를 정렬한다. **분할 정복** 구조의 진입점.
- `if (p < r):`
  - 최소 2개의 원소가 있을 때만 정렬이 필요하다. 재귀 종료 조건.
- `q ← partition(A, p, r)`
  - 분할 함수가 피벗의 최종 위치 `q`를 반환한다. 이 위치의 값은 이후 변경되지 않는다.
- `Quick_Sort(A, p, q - 1)`
  - 피벗보다 작은 부분 배열을 재귀적으로 정렬한다.
- `Quick_Sort(A, q + 1, r)`
  - 피벗보다 큰 부분 배열을 재귀적으로 정렬한다.

### 5-3. 라인별 해설 (partition)

- `partition(A, p, r):`
  - `A[r]`을 피벗으로 삼아 배열을 분할한다. 로무토(Lomuto) 방식.
- `pivot ← A[r]`
  - 마지막 원소를 피벗으로 선택한다. 구현이 단순하지만, 정렬된 데이터에선 불리할 수 있다.
- `i ← p - 1`
  - “피벗 이하 구간”의 끝 인덱스를 의미한다. 아직 아무 원소도 포함되지 않았으므로 시작은 `p-1`.
- `for j from p to r - 1:`
  - 피벗을 제외한 모든 원소를 순회하며 위치를 조정한다.
- `if (A[j] ≤ pivot):`
  - 현재 원소가 피벗 이하라면 왼쪽 구간으로 보내야 한다. `≤` 덕분에 **중복 값이 왼쪽에 몰려 안정성을 흉내내지만, 완전한 안정 정렬은 아니다.**
- `i ← i + 1`
  - 왼쪽 구간의 경계를 한 칸 확장한다.
- `swap A[i] and A[j]`
  - 현재 원소를 왼쪽 구간의 끝으로 이동시킨다. 이미 왼쪽에 있다면 자기 자신과 스왑되어 변화가 없다.
- `swap A[i + 1] and A[r]`
  - 피벗을 왼쪽 구간 다음 위치로 옮겨, **피벗의 최종 위치를 확정**한다.
- `return i + 1`
  - 피벗의 위치를 반환하여 재귀에서 구간을 나누게 한다.

### 5-4. 왜 이렇게 설계했을까?

- 제자리 정렬이 가능해 추가 메모리가 필요 없다.
- 재귀 깊이가 깊어질 수 있으므로, **피벗 선택 전략**(무작위, median-of-three 등)으로 최악의 경우를 회피한다.
- Tail recursion 제거 또는 반복 구현으로 스택 오버플로를 방지하기도 한다.

## 6. 힙 정렬 (Heap Sort)

### 6-1. 핵심 서브루틴 수도 코드

```text
percolateDown(A[], k, n):
    child ← 2k + 1
    while (child ≤ n - 1):
        right ← 2k + 2
        if (right ≤ n - 1 and A[child] < A[right])
            child ← right
        if (A[k] < A[child]):
            swap A[k] and A[child]
            k ← child
            child ← 2k + 1
        else:
            break

deleteMax(A[], n):
    max ← A[0]
    A[0] ← A[n - 1]
    percolateDown(A, 0, n - 1)
    return max
```

### 6-2. 라인별 해설 (percolateDown)

- `percolateDown(A[], k, n):`
  - 최대 힙에서 노드 `k`가 힙 속성을 위반했을 때 아래로 내려보내며 복구한다.
- `child ← 2k + 1`
  - 완전 이진트리에서 왼쪽 자식의 인덱스. 힙은 **배열 기반**이므로 인덱스 계산이 중요하다.
- `while (child ≤ n - 1):`
  - 자식이 존재하는 동안 반복한다. `n`은 힙 크기.
- `right ← 2k + 2`
  - 오른쪽 자식 인덱스 계산.
- `if (right ≤ n - 1 and A[child] < A[right])`
  - 오른쪽 자식이 존재하고 더 크다면, 더 큰 자식을 선택한다. **최대 힙 유지의 핵심**.
- `child ← right`
  - 비교 대상으로 오른쪽 자식을 지정한다.
- `if (A[k] < A[child]):`
  - 부모가 더 작다면 힙 속성이 깨진 것이므로 교환이 필요하다.
- `swap A[k] and A[child]`
  - 부모와 더 큰 자식을 교환해 힙 조건을 복구한다.
- `k ← child`
  - 내려간 위치에서 다시 검사를 이어가기 위해 현재 노드를 갱신한다.
- `child ← 2k + 1`
  - 새 위치에서 왼쪽 자식 인덱스를 다시 계산한다.
- `else: break`
  - 부모가 이미 더 크거나 자식이 없으면 힙 속성이 만족되어 루프 종료.

### 6-3. 라인별 해설 (deleteMax)

- `deleteMax(A[], n):`
  - 힙 정렬에서 최대값을 추출하는 동작. 정렬 루프의 한 단계와 동일하다.
- `max ← A[0]`
  - 힙의 루트가 항상 최댓값이므로 결과로 저장한다.
- `A[0] ← A[n - 1]`
  - 마지막 원소를 루트로 올려 힙 크기를 줄인다.
- `percolateDown(A, 0, n - 1)`
  - 루트에서 다시 힙 속성을 복구한다.
- `return max`
  - 추출된 최댓값을 반환한다. 힙 정렬에서는 이 값을 배열 끝에 배치하는 방식으로 사용한다.

### 6-4. 왜 이렇게 설계했을까?

- 완전 이진트리 구조 덕분에 배열 인덱스로 부모/자식 관계를 계산할 수 있다.
- 추출 후 힙 복구까지 $O(\log n)$이 보장되어, 전체 정렬이 $O(n \log n)$이 된다.
- 메모리가 제한된 환경에서 일관된 성능을 제공한다.

## 7. 마무리

이번 글에서는 여섯 가지 대표 정렬 알고리즘의 수도 코드를 **한 줄 단위로 파헤치며 설계 의도를 해석**했다. 원리를 이해하면 다음과 같은 장점이 있다.

1. 구현을 변형하거나 최적화를 추가할 때 실수를 줄일 수 있다.
2. 시간 복잡도 분석이 직관적으로 이해된다.
3. 디버깅 시 어떤 줄이 문제를 일으키는지 빠르게 파악할 수 있다.

정렬은 다른 알고리즘의 하위 루틴으로 자주 쓰이므로, 이번 정리가 더 복잡한 주제(예: TimSort, IntroSort, 외부 정렬 등)를 학습할 때 든든한 발판이 되길 바란다.

```

### spring-boot-realtime-communication.md

**Path:** `frontend/public/posts/2025/spring-boot-realtime-communication.md`

```markdown
---
title: "SSE와 WebSocket 사이에서, 나의 실시간 통신 여정을 적다"
date: "2025-09-17"
category: "Web"
tags: ['SSE', 'WebSocket', 'Redis', 'Kafka', '실시간통신']
excerpt: "JavaScript와 Spring Boot로 SSE와 WebSocket을 번갈아 구현하며 Redis와 Kafka를 저울질한 밤의 기록"
readTime: "8분"
---

오늘 저녁은 IDE보다 네트워크 다이어그램이 먼저 떠올랐다. “실시간 알림을 더 부드럽게 보낼 수 없을까?”라는 질문에 답을 찾고 싶어, 모니터 한쪽에는 MDN의 Server-Sent Events 문서를, 다른 쪽에는 WebSocket 프로토콜 스펙을 띄워 놓았다. 회사 알림 시스템이 Redis Pub/Sub 위에서 간신히 굴러가는 모습을 보면서, SSE와 WebSocket 두 친구와 제대로 대화해 보기로 한 밤이었다.

먼저 문을 두드린 건 SSE였다. `const evtSource = new EventSource('/events')`라는 짧은 한 줄이 브라우저에 상시 연결을 만들고, 서버는 표준 HTTP 연결을 ‘keep-alive’ 상태로 붙잡아 둔다. 내가 공부한 대로라면, 메시지는 `data:`로 시작해 `\n\n`으로 끝나는 단순한 텍스트였다. 그래서 Express로 작은 서버를 띄워 `res.writeHead(200, { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' });`라고 선언하고, 2초마다 `res.write("data: ${JSON.stringify({ message: 'Server time: ' + new Date() })}\n\n");`를 흘려보냈다. 브라우저 콘솔에서 “받은 데이터” 로그가 찍히는 순간, 마치 서버가 “먼저 연락할게”라고 손 흔드는 느낌이었다.

SSE의 장점은 명확했다. 서버에서 클라이언트 방향으로만 메시지를 던지면 되니 구조가 단순했고, 연결이 끊어지면 브라우저가 알아서 재연결을 시도했다. 텍스트만 전달하면 되니 JSON 문자열을 바로 보낼 수 있었고, Redis Pub/Sub과 결합하면 여러 서버 인스턴스가 한 채널을 보고 동시에 알림을 뿌릴 수 있었다. Nginx 설정도 비교적 단출했다. `proxy_set_header Connection '';`과 `proxy_buffering off;`, `proxy_read_timeout 1800s;` 정도만 챙기면 안정적으로 흘러갔다. 문제는 방향성. 클라이언트가 말을 붙이고 싶으면 결국 AJAX나 다른 채널을 열어야 했다.

그래서 WebSocket을 띄워 봤다. `const socket = new WebSocket('ws://localhost:3000');` 한 줄로 연결을 만들고, `socket.send(JSON.stringify({ type: 'greeting', message: 'Hello Server!' }));`로 말을 걸었다. 서버에서는 `ws` 라이브러리를 가져와 `const wss = new WebSocket.Server({ server });`로 시작해, `ws.on('message', (message) => { ... })`로 양방향 대화를 열어 두었다. 이 프로토콜은 HTTP로 시작해 “Upgrade: websocket”이라는 악수를 주고 받은 뒤, TCP 위에서 적은 헤더로 빠르게 이야기를 주고받는다. 텍스트뿐 아니라 바이너리 프레임도 후다닥 보낼 수 있고, 채팅이나 게임처럼 양쪽이 동시에 말해야 하는 상황에 제격이다.

하지만 자유에는 책임이 따랐다. WebSocket은 연결이 끊어지면 브라우저가 알아서 돌아오지 않는다. `socket.onclose`에서 직접 재연결 스케줄을 짜야 했고, 인증은 `Sec-WebSocket-Protocol` 헤더나 연결 이후의 첫 메시지로 별도로 처리해야 했다. 프록시도 더 예민했다. Nginx에게 `proxy_set_header Upgrade $http_upgrade;`, `proxy_set_header Connection "upgrade";`를 꼭 전달해야 했고, 타임아웃을 길게 잡지 않으면 예기치 않은 순간에 연결이 닫혔다.

둘을 비교하는 표를 손으로 그려 보니 성격 차이가 확실했다. SSE는 단방향, 텍스트 전용, 자동 재연결, HTTP 기반, 방화벽 친화적이었다. WebSocket은 양방향, 텍스트와 바이너리 지원, 수동 재연결, ws/wss 프로토콜, 낮은 헤더 오버헤드를 강점으로 내세웠다. “알림만 있으면 되는 페이지냐, 아니면 채팅과 협업 기능이 붙어야 하느냐”가 선택의 기준이라는 생각이 들었다.

실제로 우리 팀의 알림 시스템은 Redis Pub/Sub으로 여러 서버가 메시지를 공유한다. SSE와 묶으면 간단한 구조로 빠르게 결과를 얻을 수 있었지만, “혹시라도 메시지가 날아가면 어떡하지?”라는 걱정이 머리를 떠나지 않았다. Redis Pub/Sub은 구독 중인 클라이언트에게만 메시지를 던지고 바로 잊어버린다. 조금 늦게 붙은 클라이언트는 빈손이다. 그래서 Kafka를 꺼내 들었다. Kafka 토픽에 메시지를 영속적으로 남겨 두면, 소비자가 잠시 잠들었다가도 오프셋을 따라 읽어 나갈 수 있다. 기본 보존 기간이 168시간이지만 설정에 따라 더 길게, 혹은 로그 크기 기준으로 조절할 수 있다.

Kafka를 붙이기로 결심했을 때 가장 크게 바뀐 사고방식은 “토픽과 파티션”이었다. 하나의 토픽은 여러 파티션으로 나뉘고, 각 파티션은 순서가 있는 레코드 시퀀스다. 키가 없는 메시지는 라운드 로빈으로 흩어지지만, 키를 지정하면 동일한 키가 항상 같은 파티션으로 들어가 순서가 보장된다. 파티션마다 리더와 팔로워가 있어서 한 노드가 쓰러져도 다른 노드가 리더가 될 수 있다는 것도 안심이 됐다. Redis Pub/Sub이 즉발적인 대화라면, Kafka는 “일단 말을 남겨 두고 천천히 들어도 좋아”라고 말해주는 일기장 같았다.

이제 손에 쥔 도구는 세 가지였다. SSE는 단방향 알림과 로그성 이벤트에, WebSocket은 채팅과 양방향 제어에, Kafka는 놓쳐선 안 되는 메시지에. Redis는 여전히 실시간 브로드캐스트에 유용했지만, 데이터 손실 우려가 있는 경우에는 Kafka를 뒤에 붙여 든든한 안전망을 만들 생각이다. Redis에 메시지를 publish하면서 동시에 Kafka 토픽에도 남겨 두면, 나중에 지연된 소비자가 있어도 문제 없다. Kafka의 파티션 키를 세션 ID나 룸 ID로 잡아두면, 순서도 유지된다.

그렇게 밤을 지새우며 두 개의 다이어그램을 노트에 그렸다. 첫 번째는 SSE 흐름도였다. 클라이언트는 `/api/subscribe/{userId}`로 연결을 열고, Spring Boot는 `SseEmitter`를 만들어 맵에 저장한다. Redis에서 메시지를 받아오면 해당 사용자에게 `emitter.send(SseEmitter.event().name("notification").data(notification))`를 보냈다. 55초마다 하트비트를 보내는 스케줄러도 덧붙였다. 두 번째는 WebSocket 흐름도였다. `WebSocketHandler`가 세션을 관리하고, 메시지는 Redis로 퍼뜨린 뒤 다시 모든 세션으로 broadcast됐다. SockJS를 붙여 소켓이 막힌 환경에서 폴백도 준비했다.

문득 이런 생각이 들었다. “만약 방화벽이 WebSocket을 막아버린다면?” 그래서 WebSocket이 실패하면 SSE로 폴백하는 전략을 모색했다. 클라이언트에서 `new WebSocket(...)`이 실패하면 EventSource를 열어 두고, 서버에서는 동일한 메시지를 SSE 채널로 한 번 더 흘리는 구조다. 다만 프로토콜이 다른 만큼 인증과 세션 동기화를 맞추는 일이 쉽지 않았다. 쿠키 기반 인증을 쓰면 문제 없지만, 토큰을 헤더로 주고받아야 할 땐 EventSource가 커스텀 헤더를 붙이지 못해 URL 파라미터나 초기화 API 호출이 필요했다.

이 모든 실험이 끝난 뒤, 노트를 덮으며 다시 질문을 적었다. “Redis Pub/Sub 말고 Kafka를 쓰면 정보가 날아가지 않겠지?” 답은 분명했다. Kafka는 디스크에 메시지를 영속시키고, 소비자가 오프라인이어도 오프셋에서 다시 읽게 해준다. 반면 Redis Pub/Sub은 구독자가 없으면 메시지를 지워 버린다. Kafka의 토픽을 적절히 파티션 분할하고, replication factor를 3으로 잡으면 하나의 브로커가 쓰러져도 데이터는 그대로 살아 있다. 대신 운영 복잡도가 올라가니, 시스템의 중요도와 팀의 역량을 함께 고려해야 한다는 메모를 남겼다.

마지막으로, 두 기술을 언제 선택할지 스스로에게 요약해 봤다. “딱 서버에서 알림만 뿌리면 된다면 SSE, 사용자도 말을 걸어야 하면 WebSocket, 메시지를 절대 잃어서는 안 되면 Kafka.” 그래도 늘 그렇듯, 실제 서비스에서는 이 셋이 함께 춤을 춘다. 오늘 밤 내가 짠 코드는 단지 초안일 뿐이고, 내일 팀과 함께 더 나은 균형점을 찾아야 한다. 노트북을 닫으며 이렇게 적어 두었다. “혹시 WebSocket이 막히면 SSE로 낮춰서라도 메시지를 보내는, 그런 끈질긴 시스템을 만들자.” 내일의 내가 이 다짐을 기억해 주길 바라면서.
```

### tcpip-revolution-journal.md

**Path:** `frontend/public/posts/2025/tcpip-revolution-journal.md`

```markdown
---
title: "TCP/IP 깃발 아래, 내가 본 인터넷의 탄생"
date: "2025-10-19"
category: "Network"
tags: ['TCPIP', '인터넷역사', '플래그데이', '프로토콜디자인', '인터네트워킹']
excerpt: "NCP에서 TCP/IP로 전환하던 플래그 데이의 긴장과 감동을 되살린 개발자의 일기"
readTime: "11분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**
![early](../../images/2025/deadlock.png)

세상에 ‘인터넷’이라는 단어가 아직 생소하던 시절, 나는 두 개의 네트워크를 이어 붙이는 일에 몰두했다. SATNET과 패킷 무선망, 그리고 ARPANET이라는 서로 다른 언어를 쓰는 친구들을 한 책상 위에 놓고 바라보며, “이 녀석들이 과연 서로와 대화할 수 있을까?”라고 중얼거렸던 밤이 아직도 생생하다. NCP는 이미 익숙한 친구였고, 홀수 포트와 짝수 포트를 맞추던 그 단순함이 주는 안락함도 있었지만, 동시에 다른 네트워크와는 손을 잡을 수 없다는 답답함이 나를 괴롭혔다.

그때 내 앞에 나타난 이름이 로버트 칸과 빈트 서프였다. 두 사람이 들고 온 아이디어는 충격적이었다. “네트워크가 달라도 패킷은 자유롭게 다녀야 해요. 그래서 우리는 ‘인터네트워킹’을 가능하게 할 프로토콜이 필요합니다.” 그들은 TCP/IP라는 새로운 언어를 제안했고, 나는 그 언어를 배우느라 새벽을 수십 번 지새웠다. 전송 계층의 신뢰성을 TCP가, 라우팅과 주소 지정이라는 최소한의 역할을 IP가 맡는 분담. “종단은 똑똑하고, 네트워크는 단순해야 한다”는 철학은 거칠지만 이상하게 듬직했다. 나는 이 철학을 ‘엔드 투 엔드 원칙’이라고 노트에 적어 두었다. 언젠가 후배들이 물으면, 이게 인터넷이 끝없이 확장될 수 있었던 이유라고 말해주고 싶었다.

처음으로 TCP/IP 패킷이 게이트웨이를 타고 이종 네트워크로 이동했을 때, 나는 터미널 앞에서 소리 없이 박수를 쳤다. 아직 버그투성이였지만, 다른 네트워크를 거쳐 목적지에 도착한 그 작은 데이터그램은 나에게 미래를 보여 주었다. 게이트웨이(이후 라우터라 부를) 장비를 세팅하면서, IP 헤더에 출발지와 목적지를 붙여 보내는 일이 이렇게 크게 느껴질 줄 몰랐다. 연결형 TCP와 비연결형 IP가 서로 기대어 동작하는 구조를 이해하려고 나는 빈트 서프가 남긴 메모와 RFC를 수십 번 반복해 읽었다. 그 핵심은 결국, 네트워크 내부에 복잡한 지능을 넣지 않고, 끝단에서 책임과 유연성을 확보하겠다는 고집이었다.

하지만 아무리 설계가 아름다워도, 전환의 밤은 긴장으로 가득했다. 1983년 1월 1일, 우리가 “플래그 데이”라고 부른 그날을 앞두고 나는 일주일 내내 거의 잠을 못 잤다. ARPANET에 연결된 모든 호스트와 게이트웨이가 같은 날 같은 시간에 NCP를 끄고 TCP/IP를 켜야 했다. 한 시스템이라도 놓치면 그 호스트는 인터넷에서 고립될 테니까. DARPA가 보낸 체크리스트를 들고, UCLA와 SRI, BBN의 운영자들과 교대근무를 하며 케이블을 점검했다. “정말 이게 한 번에 될까?”라는 두려움이 목 뒤를 잡아당겼지만, 동시에 “이걸 성공시키면 진짜 인터넷이 태어난다”는 두근거림이 우리를 움직였다.

플래그 데이 새벽, 터미널 화면 속에서 마지막 NCP 프로세스를 끌 때 손이 잠시 떨렸다. “Bye, old friend.” 나도 모르게 혼잣말을 했다. 그리고 TCP/IP 데몬을 띄운 뒤 몇 초간 이어진 침묵은 내 인생에서 가장 길게 느껴진 순간이었다. 첫 번째 ping이 성공했을 때, 거대한 짐이 내려가는 느낌에 그대로 의자 등받이에 몸을 기댔다. 몇몇 호스트는 설정을 잘못 해서 잠깐 고립되기도 했지만, 우리는 침착하게 설정 파일을 고쳐 붙였다. 그날 이후, 우리는 단일 네트워크가 아니라 네트워크들의 네트워크 위에 서게 되었다.

플래그 데이의 여진은 오래갔다. TCP/IP의 보편성이 증명되자 NSFNET이 새 백본으로 떠오르고, DNS가 HOSTS.TXT의 한계를 해결하며 1980년대 인터넷의 지붕을 세우는 것을 나는 눈앞에서 지켜봤다. 이더넷 표준이 IEEE 802.3으로 정리되어 학교 연구실과 회사 사무실에 깔리기 시작할 때, “처음부터 이런 그림이 가능했을까?”라고 스스로에게 묻기도 했다. 하지만 결국 모든 것은 1974년 빈트 서프와 로버트 칸이 쓴 RFC와 1983년 새벽의 전환이 바탕이 되었다. 나는 아직도 그들이 회의실에서 TCP/IP 스키치를 설명하던 홀더보드 사진을 핸드폰 배경으로 써 둔다.

오늘도 나는 오래된 게이트웨이를 점검하면서 새로 추가된 IPv6 주소 목록을 본다. 플래그 데이 방식으로는 더 이상 불가능한 시대가 왔다는 사실을 인정하면서도, 그날의 단호함과 연대가 지금도 유효하다고 믿는다. 우리는 언제나 완전한 계획 없이 새로운 프로토콜을 배포해야 하고, 때로는 서로 다른 철학을 가진 팀들을 설득해야 한다. 그럴 때마다 나는 손가락 끝으로 1983년의 기억을 더듬는다. “네트워크를 심플하게, 끝단을 똑똑하게.” 이 원칙은 여전히 내 책상 위 노트의 첫 페이지를 차지하고 있다.

나는 TCP/IP가 완성된 날의 밤하늘을 잊지 못한다. UCLA의 컴퓨터실을 나서며 문득 뒤를 돌아봤는데, 창 너머 빛나는 터미널 화면이 마치 새로운 시대가 깜박이는 신호등 같았다. 그 빛이 내 눈앞에서, 머리 위로, 그리고 언젠가 전 세계를 가로질러 퍼져 나갈 거라는 것을 나는 어렴풋이 짐작했다. 이제 40년이 넘는 세월이 흘렀고, 인터넷은 우리 일상 속 공기처럼 스며들었다. 하지만 내가 그 공기를 처음 들이마시던 새벽의 떨림은 아직도 내 손목에 남아 있다. 플래그 데이, TCP/IP, 그리고 우리가 함께 붙잡았던 약속. 나는 앞으로도 그 약속을 기억하며 새로운 네트워크의 문을 열고 싶다.

```

### terraform-01-basic-setup.md

**Path:** `frontend/public/posts/2025/terraform-01-basic-setup.md`

```markdown
---
title: "Terraform 기본 설정과 첫 리소스"
date: "2025-01-09"
category: "DevOps"
tags: ["DevOps","Terraform","IaC","초급","실습"]
excerpt: "Terraform 설치부터 첫 local_file 리소스 생성까지 필수 워크플로우(init, plan, apply, destroy)를 단계별로 정리."
author: "Admin"
published: true
---

# Terraform 기본 설정

##  개요

Terraform은 HashiCorp Configuration Language(HCL)를 사용하여 인프라를 코드로 정의하는 IaC 도구입니다.

##  학습 목표
- Terraform 설치 및 기본 구조 이해
- 첫 번째 리소스 생성
- Terraform 워크플로우 (init, plan, apply, destroy) 실습

##  설치

### Linux/macOS
```bash
wget https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip
unzip terraform_1.6.0_linux_amd64.zip
sudo mv terraform /usr/local/bin/
terraform --version
```

### Windows (Chocolatey)
```powershell
choco install terraform
```

## ️ 기본 프로젝트 구조
```
project/
├── main.tf          # 주요 리소스 정의
├── variables.tf     # 변수 선언
├── outputs.tf       # 출력 값 정의
├── terraform.tfvars # 변수 값 설정
└── .terraform/      # 플러그인 & 상태 (자동 생성)
```

## ️ 첫 번째 예제: local_file 리소스 생성

`examples/01-local-file/main.tf`:
```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    local = {
      source  = "hashicorp/local"
      version = "~> 2.0"
    }
  }
}

resource "local_file" "hello" {
  filename = "${path.module}/hello.txt"
  content  = "Hello, Terraform!"
}

resource "local_file" "multiple" {
  count    = 3
  filename = "${path.module}/file-${count.index}.txt"
  content  = "This is file number ${count.index}"
}
```

### 초기화
```bash
cd examples/01-local-file
terraform init
```

### 실행 계획 확인
```bash
terraform plan
```

### 적용
```bash
terraform apply
```

### 상태 및 리소스 확인
```bash
terraform show
terraform state list
terraform state show local_file.hello
```

### 제거
```bash
terraform destroy
```

##  핵심 개념

### Provider (프로바이더)
Terraform이 인프라와 상호작용하도록 하는 플러그인.
```hcl
provider "aws" { region = "us-east-1" }
provider "azurerm" { features {} }
```

### Resource (리소스)
생성/관리할 인프라 구성 요소.
```hcl
resource "리소스타입" "이름" {
  argument1 = "value1"
}
```

### Data Source (데이터 소스)
기존 리소스 정보 조회.
```hcl
data "local_file" "existing" { filename = "/path/file.txt" }
output "file_content" { value = data.local_file.existing.content }
```

##  Terraform 워크플로우 요약
```
1. Write
2. terraform init
3. terraform plan
4. terraform apply
5. terraform destroy
```

| 명령어 | 설명 | 사용 시점 |
|--------|------|-----------|
| `terraform init` | 플러그인 다운로드, 백엔드 초기화 | 시작/프로바이더 추가 |
| `terraform plan` | 변경 사항 미리보기 | 적용 전 검증 |
| `terraform apply` | 실제 리소스 생성/변경/삭제 | 인프라 변경 시 |
| `terraform destroy` | 모든 리소스 삭제 | 테스트 환경 정리 |
| `terraform fmt` | 코드 포맷팅 | 정리 |
| `terraform validate` | 구문 검증 | 오류 체크 |

##  실습 과제

### 과제 1: 디렉토리 구조 생성
```
output/
├── logs/
│   ├── app.log
│   └── error.log
└── data/
    └── config.json
```

힌트:
```hcl
resource "local_file" "app_log" {
  filename = "${path.module}/output/logs/app.log"
  content  = "Application started at ${timestamp()}"
}
```

### 과제 2: 변수 활용
```hcl
variable "file_content" { type = string default = "Default content" }
resource "local_file" "dynamic" { filename = "${path.module}/dynamic.txt" content = var.file_content }
```
실행:
```bash
terraform apply -var="file_content=Custom message"
```

##  트러블슈팅
| 문제 | 원인 | 해결 |
|------|------|------|
| `terraform: command not found` | PATH 미설정 | PATH에 /usr/local/bin 추가 |
| Provider init failed | 네트워크 문제 | `.terraform` 삭제 후 재 init |
| State lock 에러 | 다른 프로세스 실행 중 | `terraform force-unlock <LOCK_ID>` |

##  참고 자료
- Terraform 공식 문서: https://developer.hashicorp.com/terraform/docs
- Registry: https://registry.terraform.io/
- HCL 문법: https://developer.hashicorp.com/terraform/language/syntax

## ▶ 다음 단계
- [AWS EC2 실습 예제](terraform-02-aws-ec2-example.md)
- 상태 관리와 모듈화 (예정)

```

### terraform-02-aws-ec2-example.md

**Path:** `frontend/public/posts/2025/terraform-02-aws-ec2-example.md`

```markdown
---
title: "Terraform로 AWS EC2 배포 실습"
date: "2025-01-10"
category: "DevOps"
tags: ["DevOps","Terraform","AWS","EC2","실습"]
excerpt: "VPC, Subnet, Security Group, EC2, User Data까지 포함한 AWS 웹 서버 인프라를 Terraform으로 단계별 구성."
author: "Admin"
published: true
---

# Terraform AWS EC2 실습

##  개요
실제 클라우드 리소스를 Terraform으로 프로비저닝하는 실습입니다. AWS EC2 인스턴스, VPC, Security Group을 생성합니다.

##  학습 목표
- AWS Provider 설정
- VPC 및 네트워크 리소스 생성
- EC2 인스턴스 배포 및 User Data 초기화
- SSH 접근 및 상태/비용 최적화

##  사전 준비: AWS CLI & 자격 증명
```bash
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
aws --version
aws configure
```
입력 예:
```
AWS Access Key ID: YOUR_ACCESS_KEY
AWS Secret Access Key: YOUR_SECRET_KEY
Default region name: ap-northeast-2
Default output format: json
```

##  프로젝트 구조
```
02-aws-ec2/
├── main.tf
├── variables.tf
├── outputs.tf
├── terraform.tfvars
└── userdata.sh
```

##  variables.tf
```hcl
variable "aws_region" { type = string default = "ap-northeast-2" }
variable "instance_type" { type = string default = "t2.micro" }
variable "instance_name" { type = string default = "terraform-web-server" }
variable "allowed_ssh_ips" { type = list(string) default = ["0.0.0.0/0"] }
variable "key_name" { type = string }
```

##  main.tf (요약)
```hcl
terraform {
  required_version = ">= 1.0"
  required_providers { aws = { source = "hashicorp/aws" version = "~> 5.0" } }
}
provider "aws" { region = var.aws_region }

# VPC
resource "aws_vpc" "main" { cidr_block = "10.0.0.0/16" enable_dns_hostnames = true enable_dns_support = true tags = { Name = "terraform-vpc" } }

# Internet Gateway
resource "aws_internet_gateway" "main" { vpc_id = aws_vpc.main.id tags = { Name = "terraform-igw" } }

# Subnet
resource "aws_subnet" "public" { vpc_id = aws_vpc.main.id cidr_block = "10.0.1.0/24" availability_zone = "${var.aws_region}a" map_public_ip_on_launch = true tags = { Name = "terraform-public-subnet" } }

# Route Table + Association
resource "aws_route_table" "public" { vpc_id = aws_vpc.main.id route { cidr_block = "0.0.0.0/0" gateway_id = aws_internet_gateway.main.id } tags = { Name = "terraform-public-rt" } }
resource "aws_route_table_association" "public" { subnet_id = aws_subnet.public.id route_table_id = aws_route_table.public.id }

# Security Group
resource "aws_security_group" "web" {
  name = "terraform-web-sg" vpc_id = aws_vpc.main.id
  ingress { description = "SSH" from_port = 22 to_port = 22 protocol = "tcp" cidr_blocks = var.allowed_ssh_ips }
  ingress { description = "HTTP" from_port = 80 to_port = 80 protocol = "tcp" cidr_blocks = ["0.0.0.0/0"] }
  egress  { description = "All outbound" from_port = 0 to_port = 0 protocol = "-1" cidr_blocks = ["0.0.0.0/0"] }
  tags = { Name = "terraform-web-sg" }
}

# 최신 Fedora Cloud AMI 조회 (data source)
data "aws_ami" "fedora" {
  most_recent = true
  owners      = ["125523088429"] # Fedora Cloud (공식)
  filter { name = "name" values = ["Fedora-Cloud-Base-*.x86_64-*-HVM-*"] }
  filter { name = "virtualization-type" values = ["hvm"] }
}

# EC2 Instance + User Data
resource "aws_instance" "web" {
  ami                         = data.aws_ami.fedora.id
  instance_type               = var.instance_type
  key_name                    = var.key_name
  subnet_id                   = aws_subnet.public.id
  vpc_security_group_ids      = [aws_security_group.web.id]
  user_data = <<-EOF
              #!/bin/bash
              set -euxo pipefail
              dnf -y update
              dnf -y install nginx
              echo "<h1>Hello from Terraform (Fedora)!</h1>" > /usr/share/nginx/html/index.html
              systemctl enable --now nginx
              EOF
  tags = { Name = var.instance_name }
}
```

##  outputs.tf
```hcl
output "instance_id" { value = aws_instance.web.id }
output "instance_public_ip" { value = aws_instance.web.public_ip }
output "web_url" { value = "http://${aws_instance.web.public_ip}" }
output "ssh_command" { value = "ssh -i ~/.ssh/${var.key_name}.pem fedora@${aws_instance.web.public_ip}" }
```

##  terraform.tfvars 예시
```hcl
aws_region     = "ap-northeast-2"
instance_type  = "t2.micro"
instance_name  = "my-web-server"
key_name       = "my-key-pair"
```

##  배포 실행
```bash
terraform init
terraform plan -var="key_name=my-key-pair"
terraform apply -var="key_name=my-key-pair"
terraform output
```
출력 예:
```
instance_public_ip = "3.35.123.45"
web_url = "http://3.35.123.45"
ssh_command = "ssh -i ~/.ssh/my-key-pair.pem fedora@3.35.123.45"
```

##  접근 테스트
```bash
curl http://$(terraform output -raw instance_public_ip)
ssh -i ~/.ssh/my-key-pair.pem fedora@$(terraform output -raw instance_public_ip)
```

##  리소스 간 종속성 시각화
```
VPC → Internet Gateway → Subnet
                     ↓
Security Group ← EC2 Instance → Route Table
```
명시적 depends_on 필요 시:
```hcl
resource "aws_instance" "web" {
  depends_on = [aws_internet_gateway.main]
}
```

##  고급 패턴
- 다중 인스턴스 생성: `count`
- 조건부 생성: `count = var.create_instance ? 1 : 0`
- 동적 블록: Security Group ingress 규칙 반복 생성

##  비용 최적화 팁
1. 프리티어 인스턴스(t2.micro) 활용
2. 사용 후 즉시 `terraform destroy`
3. AWS Budgets 알림 설정
4. 지역 선택 비용 비교 (서울 vs 도쿄)

##  트러블슈팅
| 에러 | 원인 | 해결 |
|------|------|------|
| InvalidKeyPair.NotFound | 키 페어 미존재 | 콘솔에서 생성 후 이름 확인 |
| VpcLimitExceeded | VPC 수량 제한 | 사용 안 하는 VPC 정리 |
| SSH Connection refused | SG 규칙 또는 IP 오류 | 실제 공인 IP 확인 후 허용 CIDR 수정 |
| UnauthorizedOperation | IAM 권한 부족 | EC2FullAccess 임시 부여 후 최소 권한 재설계 |

##  인프라 업데이트 예시
```hcl
# terraform.tfvars
instance_type = "t3.small"
```
```bash
terraform plan
terraform apply
```

##  리소스 정리
```bash
terraform destroy
terraform destroy -target=aws_instance.web   # 특정 리소스만
```

##  다음 단계
- 상태 관리와 모듈화 (예정)
- 변수와 출력 고급 패턴 (예정)

##  참고 자료
- AWS Provider: https://registry.terraform.io/providers/hashicorp/aws
- AWS Free Tier: https://aws.amazon.com/free/

```

### terraform-03-state-management.md

**Path:** `frontend/public/posts/2025/terraform-03-state-management.md`

```markdown
---
title: "Terraform 상태 관리와 모듈화"
date: "2025-02-03"
category: "DevOps"
tags: ["DevOps","Terraform","State","Module"]
excerpt: "Terraform state 원격 백엔드, 잠금(lock), drift 감지, 워크스페이스 전략과 모듈화 베스트 프랙티스를 손에 잡히게 정리합니다."
author: "Admin"
published: true
---

Terraform는 선언형 IaC 도구이지만, 실제 인프라의 현재 상태를 추적해야 원하는 변경만 안전하게 반영할 수 있습니다. 이 글은 Terraform의 상태(state) 관리와 모듈화 전략을 실무 관점에서 정리합니다.

## 왜 state가 필요한가
- 변경 최소화: 현재 상태를 알고 있어야 차이만 계획(plan)하고 적용(apply)합니다.
- 병렬 안전성: 여러 사람이 동시에 작업할 때 잠금(lock)으로 충돌을 방지합니다.
- drift 감지: 코드와 실제 인프라의 불일치를 탐지합니다.

## 로컬 vs 원격 state
- 로컬: 기본값. 팀 협업, 잠금, 백업에 취약합니다.
- 원격(권장): S3/DynamoDB, GCS, Azure Blob 등. 버전 관리와 잠금 제공.

예: AWS S3 + DynamoDB 백엔드 설정 (루트 모듈에서만 설정)

```hcl
terraform {
  backend "s3" {
    bucket         = "my-tf-state-bucket"
    key            = "prod/network/terraform.tfstate" # 워크스페이스/스택별로 키 분리
    region         = "ap-northeast-2"
    dynamodb_table = "my-tf-locks"
    encrypt        = true
  }
}
```

베스트 프랙티스
- 루트 모듈에서만 backend를 정의하고, 모듈 내부에서는 절대 정의하지 않습니다.
- 버킷 버저닝/암호화/KMS, 최소 권한 버킷 정책을 적용합니다.
- 키(key) 네이밍을 환경/스택/컴포넌트 단위로 일관되게 관리합니다.

## 상태 파일 보안과 민감정보
- state에는 리소스 속성(암호/시크릿 포함 가능)이 저장됩니다.
- 가능하면 시크릿은 외부 비밀관리(SSM Parameter Store, Secrets Manager 등)를 사용하고, 값은 data 소스로 참조합니다.
- `terraform state pull`/`show` 결과를 저장소에 커밋하지 않습니다.

## Drift 감지와 점검 루틴
- `terraform plan -refresh-only`: 실제와 상태를 동기화하는 변경만 제안합니다.
- `terraform validate` + `tflint` (선택)로 정적 점검을 선행합니다.
- `terraform state list`/`show`로 특정 리소스 추적이 가능합니다.

## 상태 이동/정리 명령어 핵심
- 리소스 주소 변경: 리팩터링 시
  ```bash
  terraform state mv aws_security_group.web module.vpc.aws_security_group.web
  ```
- 잘못 추적된 리소스 제거(실제 삭제 아님):
  ```bash
  terraform state rm aws_s3_bucket.temp
  ```
- 부분 교체 적용(taint 대체):
  ```bash
  terraform apply -replace=aws_instance.web
  ```

## 워크스페이스 전략
워크스페이스는 동일한 코드로 경량 환경 분기를 제공합니다.

```bash
terraform workspace new dev
terraform workspace select dev
terraform workspace list
```

언제 쓸까?
- 동일 스택을 소규모 환경(dev/stage)으로 빠르게 분기할 때 적합.
- 대규모/격리 요구가 크면 디렉터리 분리 또는 별도 스택(리포지토리)로 관리하는 것이 안전합니다.

## 모듈화의 목적
- 재사용/표준화: 보안/태깅/로깅 등 공통 정책을 캡슐화.
- 경계 명확화: 입력 변수, 출력 값으로 명세화.
- 변경 영향 축소: 모듈 버저닝으로 점진적 배포.

### 모듈 구조 예시
디렉터리 레이아웃(모듈 repo 또는 `modules/` 폴더):

```
modules/
  vpc/
    main.tf
    variables.tf
    outputs.tf
```

`modules/vpc/variables.tf`
```hcl
variable "name" { type = string }
variable "cidr_block" { type = string }
variable "tags" {
  type    = map(string)
  default = {}
}
```

`modules/vpc/main.tf`
```hcl
resource "aws_vpc" "this" {
  cidr_block           = var.cidr_block
  enable_dns_support   = true
  enable_dns_hostnames = true
  tags = merge({ Name = var.name }, var.tags)
}
```

`modules/vpc/outputs.tf`
```hcl
output "vpc_id" { value = aws_vpc.this.id }
```

루트 모듈 사용 예시
```hcl
module "vpc" {
  source     = "./modules/vpc"
  name       = "prod-main"
  cidr_block = "10.0.0.0/16"
  tags = {
    Project = "core"
    Env     = "prod"
  }
}
```

베스트 프랙티스
- 모듈 입력은 최소/명시적으로, 출력은 소비자가 필요한 것만 제공합니다.
- 기본값을 과도하게 넣지 말고, 필수 값은 명확하게 요구합니다.
- 레지스트리/깃 소스 사용 시 버전 pinning(`?ref=v1.2.3`)으로 재현성을 확보합니다.

## 폴더 전략과 상태 키 네이밍
- 예시 레이아웃
```
live/
  prod/
    network/
    compute/
  stage/
    network/
modules/
  vpc/
  ecs-service/
```
- 백엔드 키 예: `prod/network/terraform.tfstate`, `stage/network/terraform.tfstate`
- CI에서 워크스페이스/디렉터리/변수를 조합해 일관된 배포 파이프라인을 구성합니다.

## 로컬 → 원격 백엔드 마이그레이션
1) 루트 모듈에 backend 블록 추가
2) `terraform init -migrate-state` 실행하여 기존 상태를 이동
3) 원격 백엔드에서 잠금/버저닝이 동작하는지 확인

문제 해결 팁
- 잠금 충돌: `-lock-timeout=5m` 옵션 사용 또는 DynamoDB 항목 확인 후 해제
- 권한 오류: S3 PutObject/GetObject, DynamoDB GetItem/PutItem/UpdateItem 권한 점검

## 체크리스트
- [ ] 루트 모듈에서만 backend 정의했는가?
- [ ] 키 네이밍이 환경/스택별로 일관적인가?
- [ ] 시크릿은 외부에서 주입하고 state 노출을 최소화하는가?
- [ ] plan/validate/lint가 CI에 포함되어 있는가?
- [ ] 모듈 버전이 고정되어 있는가?

## 마무리
견고한 상태 관리와 모듈화는 팀 규모가 커질수록 가치가 커집니다. 백엔드/잠금/키 전략을 표준화하고, 모듈 경계를 명확히 하여 안전하고 예측 가능한 IaC 운영 기반을 마련하세요.

```

### terraform-04-variables-outputs.md

**Path:** `frontend/public/posts/2025/terraform-04-variables-outputs.md`

```markdown
---
title: "Terraform 변수와 출력 고급 패턴"
date: "2025-02-04"
category: "DevOps"
tags: ["DevOps","Terraform","Variables","Outputs"]
excerpt: "변수 타입/검증, locals, dynamic/for_each, map/object, 민감정보, 출력 패턴까지 실무형 레시피로 정리합니다."
author: "Admin"
published: true
---

Terraform 변수와 출력은 모듈 경계를 정의하고 재사용성을 높이는 핵심 요소입니다. 이 글은 실무에서 자주 쓰는 변수/locals/출력 패턴을 간단한 예제와 함께 소개합니다.

## 변수 타입과 검증
`variables.tf`
```hcl
variable "name" {
  type        = string
  description = "리소스 식별용 이름"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "공통 태그"
}

variable "subnets" {
  type        = list(object({
    name = string
    cidr = string
    az   = string
  }))
  description = "서브넷 목록"
}

variable "replicas" {
  type        = number
  default     = 2
  validation {
    condition     = var.replicas >= 1 && var.replicas <= 10
    error_message = "replicas must be between 1 and 10"
  }
}
```

- 타입을 명시하면 계획/검증 단계에서 오류를 빠르게 발견합니다.
- `validation` 블록으로 범위/형식 조건을 강제합니다.

## locals로 의도 드러내기
`locals`는 계산값/표준화를 캡슐화합니다.
```hcl
locals {
  base_tags = merge({
    ManagedBy = "terraform"
    Project   = "core"
  }, var.tags)

  subnet_tags = { for s in var.subnets : s.name => {
    Name = s.name
    AZ   = s.az
  }}
}
```
- `locals.base_tags`로 모든 리소스에 공통 태그 적용
- 파생 데이터(`subnet_tags`)를 맵으로 재구성해 참조를 단순화

## for_each와 dynamic 블록
반복 리소스 작성 시 핵심 도구입니다.

```hcl
resource "aws_subnet" "this" {
  for_each          = { for s in var.subnets : s.name => s }
  vpc_id            = aws_vpc.this.id
  cidr_block        = each.value.cidr
  availability_zone = each.value.az
  tags = merge(local.base_tags, {
    Name = each.value.name
  })
}
```

Security Group 예: 인바운드 규칙을 변수로 정의하고 동적으로 생성
```hcl
variable "ingress_rules" {
  type = list(object({
    port     = number
    protocol = string
    cidrs    = list(string)
  }))
  default = [
    { port = 22,  protocol = "tcp", cidrs = ["0.0.0.0/0"] },
    { port = 443, protocol = "tcp", cidrs = ["0.0.0.0/0"] },
  ]
}

resource "aws_security_group" "web" {
  name        = "web-sg"
  description = "Web SG"
  vpc_id      = aws_vpc.this.id

  dynamic "ingress" {
    for_each = var.ingress_rules
    content {
      from_port   = ingress.value.port
      to_port     = ingress.value.port
      protocol    = ingress.value.protocol
      cidr_blocks = ingress.value.cidrs
    }
  }
}
```

## 조건부/병합 패턴
- 삼항 연산식
  ```hcl
  count = var.enable_nat ? 1 : 0
  ```
- 맵 병합으로 선택적 값 적용
  ```hcl
  tags = merge(local.base_tags, (var.extra_tag != null ? { Extra = var.extra_tag } : {}))
  ```

## 민감정보 다루기
- 입력 변수: `sensitive = true`로 계획 출력에서 마스킹
  ```hcl
  variable "db_password" {
    type      = string
    sensitive = true
  }
  ```
- 출력 값: `sensitive = true`로 마스킹
  ```hcl
  output "db_password" {
    value     = var.db_password
    sensitive = true
  }
  ```
- 가능하면 외부 비밀관리(SSM/Secrets Manager/Key Vault)를 사용하고 `data` 소스 참조를 권장

## 출력(outputs) 패턴
`outputs.tf`
```hcl
output "vpc_id" {
  description = "생성된 VPC ID"
  value       = aws_vpc.this.id
}

output "subnet_ids" {
  description = "서브넷 ID 목록 (가용영역별)"
  value       = [for s in aws_subnet.this : s.id]
}

output "subnet_map" {
  description = "서브넷 이름→ID 매핑"
  value       = { for k, s in aws_subnet.this : k => s.id }
}

output "sg_rule_summary" {
  description = "보안그룹 규칙 요약"
  value       = join(", ", [for r in var.ingress_rules : "${r.protocol}:${r.port}"])
}
```
- 소비자 관점에서 바로 사용 가능한 형태로 가공합니다.
- 리스트/맵 변환으로 참조를 단순화합니다.

## 모듈 간 전달 베스트 프랙티스
- 입력은 필수/선택을 명확히, 기본값 남발 금지
- 출력은 실제로 필요한 최소 데이터만 노출
- 모듈 소스 버전 고정(`?ref=vX.Y.Z` 또는 레지스트리 `~> 1.2`)
- 크로스 모듈 의존은 출력→입력으로 느슨하게 연결

## 예시: 네트워크 모듈 출력 → 앱 모듈 입력
루트 모듈
```hcl
module "network" {
  source     = "./modules/network"
  name       = "prod"
  subnets    = [
    { name = "a", cidr = "10.0.1.0/24", az = "ap-northeast-2a" },
    { name = "c", cidr = "10.0.2.0/24", az = "ap-northeast-2c" },
  ]
}

module "app" {
  source      = "./modules/app"
  vpc_id      = module.network.vpc_id
  subnet_ids  = module.network.subnet_ids
  common_tags = module.network.common_tags
}
```

`modules/network/outputs.tf`
```hcl
output "common_tags" {
  value = local.base_tags
}
```

## 체크리스트
- [ ] 변수 타입/검증이 정의되어 있는가?
- [ ] locals로 파생 데이터를 캡슐화했는가?
- [ ] 반복은 for_each/dynamic으로 선언적으로 표현했는가?
- [ ] 민감정보는 sensitive/외부 비밀관리로 보호되는가?
- [ ] 출력은 소비자 친화적으로 가공되었는가?

## 마무리
명확한 변수/출력 계약과 locals 정리는 모듈 재사용성을 극대화합니다. 작은 규칙의 일관성이 대규모 IaC 코드베이스의 유지보수성을 좌우합니다.

```

### web-commercialization-journal.md

**Path:** `frontend/public/posts/2025/web-commercialization-journal.md`

```markdown
---
title: "모자이크를 띄운 날, 월드 와이드 웹이 손에 들어왔다"
date: "2025-10-20"
category: "Network"
tags: ['월드와이드웹', '모자이크', 'NSFNET', 'BGP', 'CIDR']
excerpt: "웹 브라우저와 DNS, BGP가 열어젖힌 1990년대 인터넷의 폭발을 현장에서 지켜본 나의 기록"
readTime: "12분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

1993년 겨울, 나는 CERN에서 방금 풀린 소프트웨어 뭉치를 받아들고 자리로 돌아왔다. 팀 버너스리가 남긴 문서를 읽으며 URL과 HTTP, HTML이라는 낯선 조합을 손끝으로 따라가던 그날, 나는 인터넷이 더 이상 학술 네트워크에 머물지 않을 거라는 이상한 직감을 느꼈다. 네비게이션 창에 `http://`를 적어 넣고 링크를 클릭하는 순간마다, 내가 알고 있던 FTP와 Gopher의 세계가 어색하게 뒤로 물러났다.

몇 달 뒤 NCSA 모자이크가 내 PC 화면을 채웠을 때, 나는 진짜 충격에 빠졌다. 텍스트 사이에 이미지가 인라인으로 뜨고, 마우스 클릭 하나로 다른 문서로 이동할 수 있다니. 브라우저 창 앞에 앉아 있던 동료가 “이제 인터넷은 글이 아니라 매거진이 될 거야”라고 말했을 때, 우리는 모두 웃었지만, 그 예감이 맞아떨어질 줄은 몰랐다. 우리는 모자이크를 회사 전체에 배포했고, 이튿날부터 연구원이 아니라 디자이너, 마케터, 학생까지 우리 서버에 접속하기 시작했다. 웹은 지극히 개인적인 호기심을 대중적 열풍으로 바꾸는 촉매였다.

하지만 화려한 브라우저 뒤에는 여전히 무거운 백본이 있었다. NSFNET의 라우터가 과부하로 비명을 지르던 시절, 나는 미시간 남쪽의 PoP에 붙어 매일 접속량을 모니터링했다. 정부가 네트워크를 상업 사업자에게 넘기기로 결정하자, 우리는 갑자기 수십 개의 독립 ISP를 상대해야 했다. EGP로는 이 복잡한 지형을 커버할 수 없었다. 그때 등장한 이름이 BGP였다. 경로 벡터라는 개념을 처음 들었을 때 나는 “이건 라우팅이 아니라 외교처럼 들리는데?”라고 농담했다. 하지만 실제 BGP 피어링 세션을 맺고 광고 정책을 조정하면서, 인터넷이 기술과 경제의 합작품이 되어 가는 걸 몸으로 느꼈다. 고객-피어-트랜싯이라는 단어는 그때 내 일기장에 처음 등장했다.

DNS가 없던 시절을 떠올리면 아직도 머리가 지끈거린다. HOSTS.TXT 파일을 매일 업데이트하고, 이름 충돌이 발생할 때마다 전화로 조율하던 일상을 생각하면, 폴 모카페트리스가 도메인 이름 시스템을 만들어 준 게 얼마나 큰 선물인지 새삼 느낀다. 루트 서버를 새벽에 재부팅하는 날이면 머리맡에 호출기가 놓여 있었고, 문제가 생기면 전 세계 운영자들이 전화 회의로 모였다. DNS가 길을 안내해 주기 시작하면서부터, 웹 브라우저는 진짜로 누구나 쓸 수 있는 도구가 되었다.

1994년 넷스케이프가 등장했을 때, 우리 팀은 그들의 IPO 소식을 보며 환호했다. 한편으로는 두려움도 있었다. “이제부터 진짜 상업의 시대가 오는 거야.” 우리는 ISP 간 트래픽 정산 문제를 두고 새벽까지 회의를 했다. BGP 광고가 잘못 흘러 들어와 몇 분간 인터넷이 갈라지는 사건이 일어나면, 곧장 언론에서 전화를 걸어 왔다. 나는 그때마다 콘솔에 앉아 `show ip bgp`를 두드리며, 테이블에 쌓이는 프리픽스 숫자를 보고 호흡을 가다듬었다.

CIDR을 처음 듣던 회의에서 한 운영자가 “클래스 A를 또 나눌 수 있다고요? 그럼 더 이상 주소가 공중으로 날아가지 않겠네요”라고 감탄했던 기억이 난다. 나는 1993년의 그 회의록을 아직도 보관하고 있다. 도트로 구분된 숫자 뒤에 `/20`, `/21` 같은 접미사가 붙기 시작한 순간, 라우팅 테이블의 기하급수적 증가가 멈칫했고, 우리는 IPv4가 아직 버틸 수 있겠다고 안도했다. ISP 고객들의 프리픽스를 하나로 묶어 광고할 수 있게 되자, BGP 테이블이 살짝 가벼워지는 게 눈에 보였다. CIDR이 없었다면, 우리는 1990년대 말에 이미 주소 바닥을 보지 않았을까.

나는 1995년 4월, NSFNET이 공식적으로 퇴역하는 날을 아직도 기억한다. 백본을 내려놓기 전에, 나와 몇몇 동료는 라우터에 붙어 있던 작은 플래그 스티커를 떼어 주머니에 넣었다. 공공에서 민간으로 넘어가는 그 순간의 공기에는 아쉬움과 설렘이 동시에 배어 있었다. 인터넷이 정부 프로젝트를 넘어 진짜 사회 인프라가 되는 문턱에 우리가 있었다는 사실이 자랑스러웠다.

웹의 대중화는 기술만으로 설명할 수 없는, 사람들의 욕망과 문화가 뒤엉킨 사건이었다. 새로 생긴 웹사이트들을 돌아다니며 즐겁게 시간을 보내는 한편, 우리는 뒤편에서 DNS 존 파일을 돌보고, BGP 세션을 재협상하고, CIDR 도입을 설득해야 했다. 모자이크를 띄운 첫날의 설렘과 NSFNET 마지막 날의 허전함이 같은 한 사람의 삶에 함께 들어온다는 사실이 놀랍다. 나는 오늘도 브라우저 북마크를 훑으며 스스로에게 말한다. “우리는 단지 URL을 클릭한 게 아니라, 전 세계가 공유할 플랫폼을 여는 문을 밀어젖혔어.” 이 말이 과장처럼 들릴지 몰라도, 1990년대의 나는 그걸 분명히 자신의 손으로 느꼈다.

```

### wine-clipboard-bridge-journal.md

**Path:** `frontend/public/posts/2025/wine-clipboard-bridge-journal.md`

```markdown
---
title: "Wayland 위에서 Wine 카카오톡이 복붙을 잃어버린 날"
date: "2025-10-31"
category: "Linux"
tags: ['Wine','Wayland','클립보드','Hyprland','wl-clipboard']
excerpt: "EndeavourOS에서 Wine 카카오톡과 호스트 사이 복붙이 끊겼던 사건을 기록하며, 왜 그런지 그리고 어떻게 우회했는지 정리했다."
readTime: "8분"
---
EndeavourOS를 설치한 뒤 메신저 세팅까지 마쳤을 때만 해도 마음이 한결 가벼웠다. 그런데 금요일 오전, 카카오톡 창에서 복사한 문장을 호스트 쪽 에디터로 붙여넣는 순간 텍스트가 사라져 버렸다. 반대로 리눅스에서 복사한 주소를 Wine 속 카카오톡 입력창에 붙여넣으면 텔레파시처럼 조용히 실패했다. “같은 창 안에서는 잘 되는데 왜 바깥으로 나오면 말을 안 듣지?” 이상하게도 Wine 안에서는 복붙이 멀쩡했기에 더 혼란스러웠다.

먼저 의심한 건 쓰고 있는 Hyprland와 Wayland 조합이었다. 예전에 Xorg를 쓸 때는 이런 문제가 없었는데, Wayland로 넘어오면서 클립보드 인프라가 확 달라졌다는 이야기를 들었기 때문이다. X11에는 PRIMARY, CLIPBOARD 같은 선택 버퍼가 따로 있고, 프로그램이 종료되면 클립보드 소유자가 사라지는 구조라 매니저가 없으면 내용이 비어버린다. Wayland에서는 이 역할을 컴포지터가 맡는데, XWayland 앱과 네이티브 Wayland 앱 사이에는 여전히 브리지 계층이 필요하다. Wine은 Windows의 클립보드를 Linux 선택 시스템에 매핑해야 하고, 이 과정에서 Wayland 지원은 비교적 최근 버전까지 계속 손봐 왔다.

Reddit을 조금 뒤져 보니 Hyprland에서 XWayland와 Wayland 사이 클립보드 동기화가 깨진다는 보고가 여럿 있었다. KDE Plasma 6.5에서도 Wine이나 Proton 앱에 붙여넣기가 안 된다는 사례가 눈에 띄었다. 결국 KakaoTalk의 문제가 아니라 내 컴포지터와 Wine Wayland 드라이버의 조합이 서로 말을 안 섞는 것이었다. 특히 Wine 10.3 즈음에서 Wayland 드라이버가 wl_data_device 경로를 통해 클립보드를 다루기 시작했다는 릴리스 노트가 있는데, 그 이전 버전이나 특정 Proton 빌드에서는 CLIPBOARD 전송이 아예 빠져 있을 수 있다는 얘기도 들려왔다.

가만히 있을 수 없으니 직접 확인해 보기로 했다. `wine --backtrace` 대신 클립보드 트레이스를 켜서 로그를 뜯어보면 어느 지점에서 형식이 끊어지는지 볼 수 있다기에, `WINEDEBUG=clipboard` 환경 변수를 걸고 KakaoTalk에서 복사를 해봤다. 로그에는 Windows API 단계에서 CLIPBOARD를 잡았다는 메시지가 보였지만, 호스트 쪽에는 전달되지 않았다. 이때 깨달았다. 브리지 계층을 중간에서 대신 동기화해 주면 어떨까?

마침 EndeavourOS 커뮤니티 글에서 Wayland↔X11 클립보드 브릿지를 띄우면 문제를 우회할 수 있다는 팁을 찾았다. `wl-clipboard`와 `xclip`을 설치한 다음 다음 명령을 백그라운드로 돌리는 방식이었다.

```bash
wl-paste -t text -w xclip -selection clipboard
```

이 명령은 Wayland에서 텍스트를 복사하면 그 내용을 X클립보드(CLIPBOARD)에 전달하고, Wine(XWayland) 쪽이 이를 읽어갈 수 있게 해 준다. 반대로 역방향 브리지를 위해서는 `xclip -selection clipboard -o | wl-copy` 같은 파이프를 만들어 두면 리눅스 → Wine 방향도 연결된다. 이 방식은 임시방편이지만, 그날 당장 메신저에서 주소를 복사해 브라우저에 붙여넣어야 했던 저는 큰 숨을 돌릴 수 있었다.

다만 처음에는 이 명령이 통하지 않았다. 터미널에 `XDG_RUNTIME_DIR is invalid or not set` 같은 메시지가 뜨고, `Failed to connect to a Wayland server`라는 경고가 연달아 나왔다. 원인은 간단했다. 아마 습관처럼 `sudo`를 붙여 실행했기에, 루트 환경에서는 Wayland 세션 정보(`XDG_RUNTIME_DIR`, `WAYLAND_DISPLAY`)가 비어 있기 때문이다. 결국 브리지는 루트 권한이 아니라, Wayland 세션을 열고 있는 사용자 계정으로 실행해야 한다. 다시 말해 데스크톱에서 바로 터미널을 켜고, `sudo` 없이 `wl-paste`를 띄우면 문제가 사라진다. 꼭 권한 상승이 필요하다면 `sudo -E`로 환경 변수를 넘기거나, 아예 `systemd --user` 서비스로 등록해 로그인할 때 자동 실행되도록 하는 편이 훨씬 안정적이다.

또 하나 배운 점은, TTY로 빠져나온 상태나 SSH 세션에서는 Wayland 소켓이 열려 있지 않기 때문에 브리지가 실패할 수 있다는 사실이다. 그런 환경에서는 우회 스크립트를 띄우기 전에 `echo $XDG_RUNTIME_DIR`, `echo $WAYLAND_DISPLAY`를 확인해 보고, 값이 비어 있다면 데스크톱 세션 안으로 들어가 다시 시도해야 한다. 작은 습관 하나만 바꿨을 뿐인데, 그 뒤로는 더 이상 같은 오류를 보지 않았다.

여기에 한 가지 함정이 더 있었다. `wl-paste`의 `-w/--watch` 모드는 `zwlr_data_control_manager_v1`이라는 wlroots 확장 프로토콜이 있어야 동작한다. 지원하지 않는 컴포지터에서는 “Watch mode requires a compositor that supports the wlroots data-control protocol”이라는 메시지만 남기고 즉시 종료된다. `wayland-info | grep data_control`로 해당 프로토콜이 노출되는지 확인해 보고, Hyprland·sway 같은 wlroots 계열이라면 최신 버전으로 업데이트하거나 설정 파일에서 data-control을 비활성화하지 않았는지 점검해야 한다. GNOME이나 KDE Plasma처럼 아직 data-control을 제공하지 않는 환경에서는 이 방식이 근본적으로 불가능하므로, 대신 `wl-paste --type text | xclip -selection clipboard`를 짧은 간격으로 반복 실행하는 간단한 스크립트나 `cliphist`, `wl-clipboard-rs` 같은 별도 브리지 도구를 사용하는 편이 낫다.

물론 임시 브리지를 계속 켜 두는 것이 불편하다면 환경 자체를 손보는 편이 낫다. 나는 먼저 Wine을 최신 버전으로 올려서 Wayland 드라이버 패치를 받은 다음, Hyprland의 최신 릴리스를 적용했다. 그래도 완벽하지 않을 때는 Xorg 세션으로 잠시 갈아타서 테스트해 보는 것도 좋은 진단법이다. Xorg에서는 기존처럼 X11 선택 기능이 그대로 동작하니 문제가 사라진다면 Wayland 계층의 책임이 확실해진다. 또 GNOME이나 Plasma에서 기본으로 제공하는 클립보드 매니저(예: Klipper, gnome-shell-extension clipboard indicator)를 켜두면 CLIPBOARD가 프로그램 종료 후에도 유지돼서 일부 문제를 완화하기도 했다.

재미있었던 점은, 동일한 Wine 환경 안에서 다른 Windows 프로그램끼리는 복붙이 잘 된다는 것이었다. KakaoTalk과 메모장 사이, 프로토콜 뷰어와 브라우저 사이에서는 아무 일 없다는 듯 데이터가 오갔다. 이것만으로도 “브리지 구간”에서 문제가 생겼다는 추정을 확신할 수 있었다. 실제로 Wine 개발자 포럼에서도 Wayland 드라이버가 호스트와 데이터를 주고받는 계층이 가장 민감하다고 언급하고 있었다.

몇 시간의 시행착오를 지나 작은 체크리스트를 갖게 되었다. 호스트 ↔ Wine 복붙이 안 될 때는 가장 먼저 Wine 버전을 확인하고, 컴포지터 업데이트 여부를 살핀다. 필요하다면 위 브리지 스크립트를 구동해 놓고, `wl-paste`, `wl-copy`, `xclip` 같은 도구가 있는지 점검한다. 그리고 여전히 문제가 계속되면 Xorg 세션으로 부팅해 보고, 거기서도 문제라면 Wine 로그를 추적한다. 이상하게 들릴지 몰라도, 이런 루틴을 갖춘 뒤로는 복붙이 끊겨도 당황하지 않게 되었다.

마지막으로, 이 글을 읽는 분들께도 조심스럽게 권하고 싶은 건 “당분간 X세상과 Wayland 사이를 이어주는 임시 다리”를 하나 정도는 준비해 두자는 것이다. 완벽한 해결은 언젠가 더 다듬어진 Wine Wayland 드라이버와 컴포지터 업데이트가 가져다주겠지만, 오늘도 KakaoTalk에서 복사한 메시지를 리눅스 메모 앱에 붙여넣어야 하는 우리는 현실적인 우회로가 필요하니까. 언젠가 이 글을 다시 읽으며 “그땐 이런 브리지가 필요했지” 하고 웃을 수 있기를 바라며, 오늘도 `wl-paste`와 `xclip`이 곁을 지켜 주길 기대해 본다.

```

---

## frontend/public/posts/en/2025

### future-tech-six-insights.md

**Path:** `frontend/public/posts/en/2025/future-tech-six-insights.md`

```markdown
---
title: "Six Future-Tech Insights That Reset My Brain"
date: "2025-11-04"
category: "Tech Essay"
tags: ["AI", "DevOps", "Future", "Infrastructure", "Self-Evolving Systems"]
excerpt: "Exploring six paradigm-shifting lessons from forward-looking technical documents about AI, DevOps, and self-evolving systems."
coverImage: "/images/2025/future-map.jpg"
slug: "future-tech-six-insights"
language: "en"
---

# Six Future-Tech Insights That Reset My Brain

## Prologue: Drawing Insight from a Flood of Ideas

Over the past few weeks I was immersed in a sea of product requirement documents, system architecture blueprints, and master plans. At first they seemed like unrelated fragments, but suddenly the dots connected into a constellation. It felt as if a secret map to the future had been hidden in plain sight. Patterns emerging from those documents pointed far beyond individual projects—they revealed the trajectory that technology itself is taking. The six insights below are the landmarks I traced from that map, the ones powerful enough to reboot my thinking.

## 1. AI Graduates from Tool to Architect

We used to treat AI like a bright assistant that suggests a few lines of code. The documents I read describe a radically different future. In "Project TONE", if a user simply asks for "a Python real-time chat app", an AI agent assembles the entire Kubernetes and Istio deployment stack automatically. "Meta-Platform" goes even further: want to run a storefront? The AI builds the full stack—from frontend to database to deployment—through conversation alone. "CodeHeal.ai" scans existing codebases, finds hardcoded IPs or misconfigurations, and self-heals by generating correct config files and patches.

The common theme is the shift from syntax to semantics. We are leaving the era of telling machines how to do something, and entering the era of just describing what we want. AI becomes a partner that translates intent into reality. Developers evolve from builders into directors and visionaries who choreograph systems with intent.

## 2. DevOps Ends When DevOps Disappears

The irony is clear: we invest in DevOps to make DevOps obsolete. "Project TONE" imagines a self-driving cloud platform. "Meta-Platform" targets a zero-ops pipeline. Their goal is for developers to stop thinking about servers, CI/CD, or networking. This is not DevOps failing—it is DevOps achieving its final form. Mature infrastructure becomes invisible, like the power grid when you flick a light switch. The pinnacle of DevOps is its own disappearance.

## 3. Systems That Breathe, Learn, and Evolve

Systems are no longer static deployments. They are living entities that optimize themselves and grow new capabilities. A JAMstack blog architecture outlined a "Living Archive" that regularly converts dynamic data into static assets and redeploys itself, making the site faster over time. "Auto-Doc AI" goes further: when a user requests a capability it lacks, the agent analyzes requirements, picks libraries, generates code, tests it in a sandbox, and fuses it into production. A network report for the AGI era paints the end-state: data flows like a living organism through a vast ecosystem, always seeking the optimal state.

## 4. Code and Documentation Finally Merge

"Is this doc up to date?" haunts every team. The "AI Pair Programmer" concept slays that demon. Whenever a function signature changes, an AI agent instantly updates the docstrings and Javadocs. The drudgery of documentation drift just disappears. Productivity, onboarding, and maintainability all skyrocket. In this future, documentation is not a chore; it is a synchronized extension of the code itself.

## 5. The Safest Wall Has No Door

Traditional security pokes inbound holes in firewalls so legitimate traffic can get in. The "Development Environment Sharing" report flips this model with outbound-only tunnels such as Cloudflare Tunnel. Picture keeping your door locked while your home links to the delivery locker outside through a secure chute. Couriers can drop off packages but never touch your door. Internal systems initiate the connection to a trusted relay, and every request flows through that pre-established tunnel. The firewall exposes no inbound ports. Security turns inside-out.

## 6. From Owning Data to Accessing Data Streams

The "Network in the AGI Era" report adds a philosophical twist. Centralized clouds run into a gravity problem: latency, cost, and inefficiency balloon as data piles up. The proposed future is a decentralized mesh where data flows intelligently, orchestrated by AGI. Data is no longer boxed up in a warehouse; it becomes a living current that we tap into on demand. We stop "owning" data and instead connect securely to the streams we need, when we need them.

## Closing: When Machines Handle Implementation, What Do We Do?

Across every document runs a single motif: technology evolves from obedient tool to autonomous collaborator. Implementation, maintenance, documentation, and infrastructure become machine territory. That forces us to ask: if machines shoulder execution, what uniquely human work remains? The future will be defined less by the capabilities we build, and more by the problems we choose to imagine and the impact we dare to design.

```

---

## frontend/public/posts/ko/2025

### future-tech-six-insights.md

**Path:** `frontend/public/posts/ko/2025/future-tech-six-insights.md`

```markdown
---
title: "제가 뇌를 리셋하게 만든 미래 기술 문서에서 발견한 6가지 깨달음"
date: "2025-11-04"
category: "Tech Essay"
tags: ["AI", "DevOps", "Future", "Infrastructure", "Self-Evolving Systems"]
excerpt: "미래 기술 문서들 속에서 발견한 6가지 통찰과 인간 역할의 재정의를 공유합니다."
coverImage: "/images/2025/future-map.jpg"
slug: "future-tech-six-insights"
language: "ko"
---

# 제가 뇌를 리셋하게 만든 미래 기술 문서에서 발견한 6가지 깨달음

## 서론: 아이디어의 홍수 속에서 길어 올린 통찰

최근 몇 주간, 저는 PRD, 시스템 아키텍처 설계도, 마스터 플랜과 같은 수많은 기술 문서를 탐독했습니다. 처음에는 서로 다른 조각처럼 보였지만, 어느 순간 퍼즐이 맞춰지듯 거대한 별자리가 나타났습니다. 마치 누군가 미래로 가는 비밀 지도를 문서 곳곳에 숨겨둔 듯했죠. 그 지도를 따라가며 얻은 여섯 가지 깨달음은 제 사고를 완전히 리셋했습니다.

## 1. AI는 도구가 아니라 시스템을 설계하는 건축가다

우리는 AI를 코드 몇 줄을 제안해주는 조수 정도로 생각해왔습니다. 하지만 문서 속의 AI는 인간의 의도를 듣고 전체 시스템을 설계하고 구축하는 건축가였습니다. "Project TONE"은 "파이썬으로 만든 실시간 채팅 앱"이라는 말 한마디로 쿠버네티스와 이스티오 설정을 자동으로 완성합니다. "Meta-Platform"은 대화를 통해 풀스택 쇼핑몰을 만들어냅니다. "CodeHeal.ai"는 기존 코드의 설정 오류를 찾아내고, 올바른 설정 파일과 수정 패치를 제안하는 자가 치유형 에이전트를 구상하고 있었습니다.

공통점은 인간-컴퓨터 상호작용의 중심이 구문(Syntax)에서 의미(Semantics)로 이동한다는 점입니다. 우리는 더 이상 기계에게 "어떻게" 구현할지를 지시하지 않고, "무엇을" 원하는지를 설명합니다. AI는 구현의 도구가 아니라, 인간의 의도를 현실로 번역하는 파트너가 됩니다. 개발자의 역할도 구현가에서 비전을 제시하는 감독, 설계자로 재정의됩니다.

## 2. 데브옵스의 최종 목표는 데브옵스의 소멸이다

우리가 데브옵스에 집착하는 이유는 언젠가 인프라를 신경 쓰지 않아도 되는 미래를 만들기 위함입니다. "Project TONE"이 꿈꾸는 자율 주행 클라우드, "Meta-Platform"이 지향하는 제로 옵스 파이프라인은 같은 목표를 가리킵니다. 개발자는 서버와 네트워크, CI/CD를 잊고 비즈니스 로직에 집중하게 됩니다. 이것은 실패가 아니라 궁극적인 성공입니다. 전력망처럼 하루 종일 생각하지 않아도 되는 인프라, 그것이 데브옵스의 완성입니다.

## 3. 미래의 시스템은 살아 숨 쉬며 진화한다

배포된 뒤 멈춰 있는 시스템은 사라지고 있습니다. JAMstack 블로그의 "살아있는 아카이브" 전략은 오래된 데이터를 정적으로 변환하며 점점 빨라지는 사이트를 만들었습니다. "Auto-Doc AI"는 없는 기능을 요청받으면 필요 분석부터 라이브러리 선정, 코드 생성, 샌드박스 테스트, 통합까지 스스로 수행합니다. AGI 시대 네트워크 보고서는 데이터가 생태계처럼 스스로 최적 상태를 찾아 흐르는 미래를 보여줍니다.

## 4. 코드와 문서는 결국 하나가 된다

"이 문서 최신 맞아요?"라는 질문은 곧 과거형이 될지도 모릅니다. "AI 페어 프로그래머" 개념은 함수 시그니처가 바뀌는 순간 관련 문서와 주석을 즉시 업데이트합니다. 문서 동기화라는 고질적인 부담이 사라집니다. 팀 생산성, 온보딩, 유지보수 모두가 비약적으로 향상됩니다.

## 5. 가장 안전한 벽에는 문이 없다

우리는 그동안 외부 접근을 허용하기 위해 방화벽에 문을 열어두었습니다. 하지만 "개발 환경 공유" 보고서는 Cloudflare Tunnel 같은 아웃바운드 전용 터널을 제시합니다. 내부 시스템이 먼저 신뢰할 수 있는 외부 지점으로 안전한 연결을 만들고, 모든 요청은 그 터널을 통해서만 들어옵니다. 방화벽에는 어떤 문도 열릴 필요가 없습니다. 보안 패러다임이 안에서 밖으로 뒤집힙니다.

## 6. 데이터는 소유에서 접속으로 이동한다

"AGI 시대의 네트워크" 보고서는 데이터를 창고에 쌓아두는 대신, 지능적인 메쉬 네트워크 속에서 흐르는 존재로 봅니다. 중앙 집중식 클라우드가 만들어낸 데이터의 중력 문제—지연, 비용, 에너지—를 해소하기 위해서입니다. 우리는 데이터를 "소유"하는 대신, 필요할 때 안전하게 "접속"하는 시대로 이동하게 됩니다.

## 결론: 기계가 구현을 맡을 때 인간은 무엇을 해야 하는가

문서들을 관통한 흐름은 뚜렷했습니다. 기술은 명령을 수행하는 도구에서 자율적 파트너로 진화합니다. 구현, 유지보수, 문서화, 인프라 설계의 짐이 기계로 넘어갈 때, 인간은 무엇을 해야 할까요? 미래는 우리가 구축하는 기술의 능력이 아니라, 우리가 상상하고자 선택한 문제의 깊이와 가치에 의해 결정될 것입니다.

```

---

## frontend/scripts

### generate-manifests.js

**Path:** `frontend/scripts/generate-manifests.js`

```javascript
#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

const postsDir = path.join(process.cwd(), 'public', 'posts');

function normalizeImagePath(rawPath, markdownAbsPath) {
  if (!rawPath) return undefined;
  if (/^https?:\/\//i.test(rawPath) || rawPath.startsWith('data:')) {
    return rawPath;
  }

  const markdownDir = path.dirname(markdownAbsPath);
  const absolutePath = path.resolve(markdownDir, rawPath);
  const publicDir = path.join(process.cwd(), 'public');
  const relativeToPublic = path.relative(publicDir, absolutePath);

  if (relativeToPublic && !relativeToPublic.startsWith('..')) {
    return `/${relativeToPublic.replace(/\\/g, '/')}`;
  }

  if (rawPath.startsWith('/')) {
    return rawPath;
  }

  const stripped = rawPath.replace(/^\.\/?/, '').replace(/^\.\./, '');
  return `/${stripped}`;
}

function extractCoverImage(frontmatter, body, markdownAbsPath) {
  const fmCover = frontmatter.coverImage || frontmatter.cover;
  if (fmCover) {
    return normalizeImagePath(fmCover, markdownAbsPath);
  }

  const markdownImageMatch = body.match(/!\[[^\]]*\]\(([^)]+)\)/);
  if (markdownImageMatch?.[1]) {
    return normalizeImagePath(markdownImageMatch[1], markdownAbsPath);
  }

  const htmlImageMatch = body.match(/<img[^>]+src=["']([^"']+)["']/i);
  if (htmlImageMatch?.[1]) {
    return normalizeImagePath(htmlImageMatch[1], markdownAbsPath);
  }

  return undefined;
}

function stripLeadingMedia(content) {
  if (!content) return content;
  let result = content.trimStart();

  const leadingBlockPatterns = [
    /^>\s*\*\*[^\n]*\*\*\s*\n?/,
    /^>\s*[^\n]*\n?/
  ];

  leadingBlockPatterns.forEach(pattern => {
    result = result.replace(pattern, '').trimStart();
  });

  result = result.replace(/^!\[[^\]]*\]\([^\)]+\)\s*/m, '');
  result = result.replace(/^<img[^>]*>\s*/im, '');

  return result.trimStart();
}

function validateMarkdownFile(filePath, filename) {
  // Check for invalid filenames
  if (filename === '.md' || filename.startsWith('.md')) {
    console.error(`❌ Invalid filename detected: "${filename}" in ${filePath}`);
    console.error(`   This file has an empty name before the .md extension`);
    return false;
  }

  // Check for files starting with dot (hidden files)
  if (filename.startsWith('.') && filename !== '.md') {
    console.warn(`⚠️  Hidden file detected: "${filename}" - skipping`);
    return false;
  }

  // Check for proper filename format (should have alphanumeric characters, hyphens, underscores)
  const validFilenamePattern = /^[a-zA-Z0-9][a-zA-Z0-9\-_]*\.md$/;
  if (!validFilenamePattern.test(filename)) {
    console.warn(
      `⚠️  Potentially problematic filename: "${filename}" - consider using alphanumeric characters, hyphens, and underscores only`
    );
  }

  // Validate file content
  try {
    const content = fs.readFileSync(filePath, 'utf8');

    // Check if file is empty
    if (content.trim().length === 0) {
      console.error(`❌ Empty file detected: "${filename}"`);
      return false;
    }

    // Check for frontmatter
    if (!content.startsWith('---')) {
      console.warn(
        `⚠️  No frontmatter detected in: "${filename}" - this may cause display issues`
      );
    }

    // Check for title in frontmatter
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (frontmatterMatch) {
      const frontmatter = frontmatterMatch[1];
      if (!frontmatter.includes('title:')) {
        console.warn(`⚠️  No title found in frontmatter for: "${filename}"`);
      }
    }
  } catch (error) {
    console.error(`❌ Error reading file "${filename}": ${error.message}`);
    return false;
  }

  return true;
}

function generateManifestForYear(year) {
  const yearDir = path.join(postsDir, year);

  if (!fs.existsSync(yearDir)) {
    console.log(`Directory ${yearDir} does not exist, skipping...`);
    return;
  }

  const allFiles = fs.readdirSync(yearDir).filter(file => file.endsWith('.md'));

  console.log(`\n📁 Processing ${year} directory...`);

  const validFiles = [];
  const invalidFiles = [];

  for (const file of allFiles) {
    const filePath = path.join(yearDir, file);
    console.log(`   Validating: ${file}`);

    if (validateMarkdownFile(filePath, file)) {
      validFiles.push(file);
      console.log(`   ✅ Valid: ${file}`);
    } else {
      invalidFiles.push(file);
      console.log(`   ❌ Invalid: ${file}`);
    }
  }

  if (invalidFiles.length > 0) {
    console.error(
      `\n🚨 Found ${invalidFiles.length} invalid file(s) in ${year}:`
    );
    invalidFiles.forEach(file => {
      console.error(`   - ${file}`);
    });
    console.error(`\n💡 Suggestions:`);
    console.error(`   - Rename files with proper names (e.g., "my-post.md")`);
    console.error(`   - Ensure files have valid frontmatter with title`);
    console.error(`   - Remove empty files`);
    console.error(`\n⚠️  Invalid files will be excluded from the manifest.`);
  }

  const sortedValidFiles = validFiles.sort();

  const manifest = {
    files: sortedValidFiles,
    generatedAt: new Date().toISOString(),
    totalFiles: sortedValidFiles.length,
    excludedFiles: invalidFiles.length,
  };

  const manifestPath = path.join(yearDir, 'manifest.json');
  fs.writeFileSync(manifestPath, `${JSON.stringify(manifest, null, 2)}\n`);

  console.log(`\n📄 Generated manifest for ${year}:`);
  console.log(`   ✅ Valid files: ${sortedValidFiles.length}`);
  console.log(`   ❌ Excluded files: ${invalidFiles.length}`);

  return { valid: sortedValidFiles.length, invalid: invalidFiles.length };
}

function generateUnifiedManifest(years) {
  console.log('\n📄 Generating unified posts manifest...');

  const items = [];

  for (const year of years) {
    const yearDir = path.join(postsDir, year);
    if (!fs.existsSync(yearDir)) continue;

    const files = fs.readdirSync(yearDir).filter(file => file.endsWith('.md'));

    for (const file of files) {
      const abs = path.join(yearDir, file);
      if (!validateMarkdownFile(abs, file)) continue;

      const raw = fs.readFileSync(abs, 'utf8');
      const { data: fm, content: body } = matter(raw);

      const filename = path.basename(file, '.md');
      const slug = fm.slug || filename;
      const date = fm.date || `${year}-01-01`;
      const tags = Array.isArray(fm.tags) ? fm.tags : [];
      const category = fm.category || 'General';
      const author = fm.author || 'Admin';
      const published = fm.published !== false;
      const coverImage = extractCoverImage(fm, body, abs);

      // Compute snippet and reading time
      const cleanedBody = stripLeadingMedia(body);
      const textOnly = cleanedBody
        // strip code fences
        .replace(/```[\s\S]*?```/g, '')
        // strip html tags if any
        .replace(/<[^>]+>/g, '')
        .trim();
      const baseSummary = fm.description || fm.excerpt || cleanedBody;
      const sanitizedSummary = stripLeadingMedia(baseSummary);
      const snippet = (sanitizedSummary || textOnly)
        .slice(0, 200)
        .trim();
      const words = textOnly.split(/\s+/).filter(Boolean).length;
      const minutes = Math.max(1, Math.ceil(words / 200));
      const readingTime = `${minutes} min read`;

      items.push({
        path: `/posts/${year}/${file}`,
        year,
        slug,
        title:
          fm.title ||
          slug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
        description: fm.description || snippet,
        snippet,
        date,
        tags,
        category,
        author,
        readingTime,
        published,
        coverImage,
        url: `/blog/${year}/${slug}`,
      });
    }
  }

  // Sort by date desc
  items.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

  const unifiedManifest = {
    total: items.length,
    items,
    generatedAt: new Date().toISOString(),
    years: years.sort().reverse(),
    format: 2, // version marker for clients
  };

  const publicDir = path.join(process.cwd(), 'public');
  const unifiedManifestPathRoot = path.join(publicDir, 'posts-manifest.json');
  const unifiedManifestPathNested = path.join(
    publicDir,
    'posts',
    'posts-manifest.json'
  );
  // ensure nested dir exists
  fs.mkdirSync(path.dirname(unifiedManifestPathNested), { recursive: true });

  const payload = `${JSON.stringify(unifiedManifest, null, 2)}\n`;
  fs.writeFileSync(unifiedManifestPathRoot, payload);
  fs.writeFileSync(unifiedManifestPathNested, payload);

  console.log(`✅ Generated unified manifest: ${items.length} posts`);
  console.log(`   Saved to: posts-manifest.json and posts/posts-manifest.json`);

  return items.length;
}

function generateAllManifests() {
  console.log('🚀 Starting manifest generation with validation...\n');

  if (!fs.existsSync(postsDir)) {
    console.error('❌ Posts directory does not exist');
    process.exit(1);
  }

  const years = fs
    .readdirSync(postsDir)
    .filter(item => fs.statSync(path.join(postsDir, item)).isDirectory())
    .filter(year => /^\d{4}$/.test(year)); // Only 4-digit year directories

  console.log(`📅 Found year directories: ${years.join(', ')}\n`);

  let totalValid = 0;
  let totalInvalid = 0;

  // Generate individual year manifests
  for (const year of years) {
    const result = generateManifestForYear(year);
    if (result) {
      totalValid += result.valid;
      totalInvalid += result.invalid;
    }
  }

  // Generate unified manifest for postService
  const unifiedPostCount = generateUnifiedManifest(years);

  console.log('\n🎉 Manifest generation completed!');
  console.log(`📊 Summary:`);
  console.log(`   ✅ Total valid files: ${totalValid}`);
  console.log(`   ❌ Total excluded files: ${totalInvalid}`);
  console.log(`   📄 Unified manifest: ${unifiedPostCount} posts`);

  if (totalInvalid > 0) {
    console.log(
      `\n⚠️  ${totalInvalid} file(s) were excluded due to validation errors.`
    );
    console.log(
      `   Please fix these issues for the files to appear on your blog.`
    );
    process.exit(1); // Exit with error code to fail CI/CD if there are invalid files
  }

  console.log('\n✨ All files are valid and ready for deployment!');
}

generateAllManifests();

```

### generate-seo.js

**Path:** `frontend/scripts/generate-seo.js`

```javascript
#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

const PROJECT_ROOT = process.cwd();
const PUBLIC_DIR = path.join(PROJECT_ROOT, 'public');
const MANIFEST_ROOT_PATH = path.join(PUBLIC_DIR, 'posts-manifest.json');
const MANIFEST_NESTED_PATH = path.join(
  PUBLIC_DIR,
  'posts',
  'posts-manifest.json'
);

import dotenv from 'dotenv';
// Load root .env if present, then frontend/.env override
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..', '..');
dotenv.config({ path: path.join(repoRoot, '.env') });
dotenv.config({ path: path.join(repoRoot, 'frontend', '.env'), override: true });
const BASE_URL =
  process.env.SITE_BASE_URL ||
  process.env.VITE_SITE_BASE_URL ||
  'http://localhost:3000';
const SITE_NAME = 'Nodove Blog';
const SITE_DESCRIPTION =
  'A blog about technology, programming, and web development';

function ensureDir(dir) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function loadManifest() {
  let manifestPath = MANIFEST_ROOT_PATH;
  if (!fs.existsSync(manifestPath) && fs.existsSync(MANIFEST_NESTED_PATH)) {
    manifestPath = MANIFEST_NESTED_PATH;
  }
  if (!fs.existsSync(manifestPath)) {
    throw new Error(
      `posts-manifest.json not found at ${MANIFEST_ROOT_PATH} or ${MANIFEST_NESTED_PATH}. Run npm run generate-manifests first.`
    );
  }
  const raw = fs.readFileSync(manifestPath, 'utf8');
  const parsed = JSON.parse(raw);
  return parsed;
}

function parsePost(filePath, manifestPath) {
  const content = fs.readFileSync(filePath, 'utf8');
  const { data: frontMatter, content: body } = matter(content);

  const rel = manifestPath.replace(/^\//, ''); // remove leading slash
  const parts = rel.split('/'); // [ 'posts', '2025', 'my-post.md' ]
  const year = parts[1] || String(new Date().getFullYear());
  const filename = parts[2] || path.basename(filePath);
  const slugFromFile = filename.replace(/\.md$/i, '');

  const slug = frontMatter.slug || slugFromFile;
  const title =
    frontMatter.title ||
    slug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  const description =
    frontMatter.description || `${body.trim().slice(0, 160)}...`;
  const date = frontMatter.date || `${year}-01-01`;
  const tags = Array.isArray(frontMatter.tags) ? frontMatter.tags : [];
  const category = frontMatter.category || 'General';
  const published = frontMatter.published !== false;

  return {
    title,
    description,
    date,
    tags,
    category,
    slug,
    year,
    published,
  };
}

function loadPosts() {
  const manifest = loadManifest();
  const posts = [];

  if (Array.isArray(manifest.items)) {
    for (const item of manifest.items) {
      // Skip unpublished
      if (item && item.published === false) continue;
      const rel = (item.path || '').replace(/^\//, '');
      const abs = path.join(PUBLIC_DIR, rel);
      if (!fs.existsSync(abs)) {
        console.warn(`Skipping missing post file: ${abs}`);
        continue;
      }
      // Prefer manifest metadata to preserve custom slug and fields
      const year = String(item.year || '');
      const slug = String(item.slug || '');
      const title =
        item.title ||
        slug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      const description = item.description || item.snippet || '';
      const date =
        item.date || (year ? `${year}-01-01` : new Date().toISOString());
      const tags = Array.isArray(item.tags) ? item.tags : [];
      const category = item.category || 'General';
      const published = item.published !== false;

      posts.push({
        title,
        description,
        date,
        tags,
        category,
        slug,
        year,
        published,
      });
    }
  } else if (Array.isArray(manifest.posts)) {
    for (const manifestPath of manifest.posts) {
      const rel = manifestPath.replace(/^\//, '');
      const abs = path.join(PUBLIC_DIR, rel);
      if (!fs.existsSync(abs)) {
        console.warn(`Skipping missing post file: ${abs}`);
        continue;
      }
      const post = parsePost(abs, manifestPath);
      if (post.published) posts.push(post);
    }
  } else {
    console.warn(
      "posts-manifest.json has an unknown structure. Expected 'items' (format:2) or 'posts' (legacy)."
    );
  }

  // sort by date desc
  posts.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  return posts;
}

function generateSitemap(posts) {
  const entries = [
    {
      url: BASE_URL,
      changefreq: 'weekly',
      priority: 1.0,
      lastmod: new Date().toISOString(),
    },
    {
      url: `${BASE_URL}/blog`,
      changefreq: 'daily',
      priority: 0.9,
      lastmod: new Date().toISOString(),
    },
    {
      url: `${BASE_URL}/about`,
      changefreq: 'monthly',
      priority: 0.7,
      lastmod: new Date().toISOString(),
    },
    {
      url: `${BASE_URL}/contact`,
      changefreq: 'monthly',
      priority: 0.6,
      lastmod: new Date().toISOString(),
    },
    ...posts.map(p => ({
      url: `${BASE_URL}/blog/${p.year}/${p.slug}`,
      changefreq: 'monthly',
      priority: 0.8,
      lastmod: new Date(p.date).toISOString(),
    })),
  ];

  const xml =
    `<?xml version="1.0" encoding="UTF-8"?>\n` +
    `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n${entries
      .map(
        e =>
          `  <url>\n    <loc>${e.url}</loc>\n    <lastmod>${e.lastmod}</lastmod>\n    <changefreq>${e.changefreq}</changefreq>\n    <priority>${e.priority}</priority>\n  </url>`
      )
      .join('\n')}\n</urlset>\n`;
  return xml;
}

function buildRobotsWithSitemap(existing = '') {
  const sitemapLine = `Sitemap: ${BASE_URL}/sitemap.xml`;
  if (existing.includes('Sitemap:')) {
    // If a Sitemap line exists but not our exact URL, append our URL too.
    if (!existing.includes(sitemapLine)) {
      const end = existing.endsWith('\n') ? '' : '\n';
      return `${existing + end + sitemapLine}\n`;
    }
    return existing;
  }
  if (existing.trim().length > 0) {
    const end = existing.endsWith('\n') ? '' : '\n';
    return `${existing + end + sitemapLine}\n`;
  }
  // Default robots if none exists
  return `User-agent: *\nAllow: /\n\n${sitemapLine}\n`;
}

function escapeXml(str = '') {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

function generateRSS(posts) {
  const items = posts
    .slice(0, 20)
    .map(
      p =>
        `    <item>\n` +
        `      <title>${escapeXml(p.title)}</title>\n` +
        `      <description>${escapeXml(p.description)}</description>\n` +
        `      <link>${BASE_URL}/blog/${p.year}/${p.slug}</link>\n` +
        `      <guid isPermaLink="true">${BASE_URL}/blog/${p.year}/${p.slug}</guid>\n` +
        `      <pubDate>${new Date(p.date).toUTCString()}</pubDate>\n` +
        `      <category>${escapeXml(p.category)}</category>\n${p.tags
          .map(t => `      <category>${escapeXml(t)}</category>`)
          .join('\n')}\n    </item>`
    )
    .join('\n');

  const rss =
    `<?xml version="1.0" encoding="UTF-8"?>\n` +
    `<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">\n` +
    `  <channel>\n` +
    `    <title>${escapeXml(SITE_NAME)}</title>\n` +
    `    <description>${escapeXml(SITE_DESCRIPTION)}</description>\n` +
    `    <link>${BASE_URL}</link>\n` +
    `    <atom:link href="${BASE_URL}/rss.xml" rel="self" type="application/rss+xml"/>\n` +
    `    <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>\n` +
    `    <language>en-US</language>\n${items}\n  </channel>\n` +
    `</rss>\n`;
  return rss;
}

function writeFileSafe(filePath, content) {
  ensureDir(path.dirname(filePath));
  fs.writeFileSync(filePath, content);
  console.log(
    `✔ Wrote ${path.relative(PROJECT_ROOT, filePath)} (${Buffer.byteLength(content)} bytes)`
  );
}

function main() {
  console.log('🧭 Generating SEO files (sitemap.xml, robots.txt, rss.xml)...');
  const posts = loadPosts();
  const sitemap = generateSitemap(posts);
  // Preserve existing robots.txt if present, ensure sitemap line exists
  const robotsPath = path.join(PUBLIC_DIR, 'robots.txt');
  const existingRobots = fs.existsSync(robotsPath)
    ? fs.readFileSync(robotsPath, 'utf8')
    : '';
  const robots = buildRobotsWithSitemap(existingRobots);
  const rss = generateRSS(posts);

  writeFileSafe(path.join(PUBLIC_DIR, 'sitemap.xml'), sitemap);
  writeFileSafe(robotsPath, robots);
  writeFileSafe(path.join(PUBLIC_DIR, 'rss.xml'), rss);

  console.log('✨ SEO files generated successfully');
}

try {
  main();
} catch (err) {
  console.error('Failed to generate SEO files:', err);
  process.exit(1);
}

```

### korean-normalize.js

**Path:** `frontend/scripts/korean-normalize.js`

```javascript
#!/usr/bin/env node

/**
 * Korean font fragment checker/fixer
 *
 * Detects decomposed Hangul (Jamo) and zero-width characters that can render as
 * fragmented Korean text, then optionally fixes by normalizing to NFC and
 * removing zero-widths.
 *
 * Usage:
 *   node scripts/korean-normalize.js [--fix] [--remove-zero-width] [--ci]
 *                                    [--ext md,mdx,txt] [paths...]
 *
 * Defaults:
 *   - Paths: public/posts
 *   - Extensions: md, mdx, txt
 *
 * Exit codes:
 *   - 0: no issues or issues fixed
 *   - 1: issues found (when not running with --fix) and --ci provided
 */

import { promises as fs } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const JamoRegex = /[\u1100-\u11FF\uA960-\uA97F\uD7B0-\uD7FF]/; // Hangul Jamo + Extended A/B
const ZeroWidthRegexGlobal = /[\u200B\u200C\u200D\uFEFF\u00AD]/g; // ZWSP, ZWNJ, ZWJ, BOM, soft hyphen
const ZeroWidthRegex = /[\u200B\u200C\u200D\uFEFF\u00AD]/; // non-global for testing

const DEFAULT_PATHS = ["public/posts"];
const DEFAULT_EXTS = [".md", ".mdx", ".txt"];
const IGNORED_DIRS = new Set([
  "node_modules",
  ".git",
  "dist",
  "build",
  ".next",
  ".vercel",
]);

function printHelp() {
  console.log(
    `Korean font fragment checker/fixer\n\n` +
      `Usage:\n` +
      `  node scripts/korean-normalize.js [options] [paths...]\n\n` +
      `Options:\n` +
      `  --fix                 Write fixes back to files (NFC normalize)\n` +
      `  --remove-zero-width   Also strip zero-width chars (ZWSP/ZWNJ/ZWJ/BOM/SHY)\n` +
      `  --ext <list>          Comma-separated extensions to include (default: md,mdx,txt)\n` +
      `  --ci                  Exit with code 1 if issues found (when not fixing)\n` +
      `  --silent              Reduce log output\n` +
      `  --help                Show this help\n` +
      `\nExamples:\n` +
      `  node scripts/korean-normalize.js\n` +
      `  node scripts/korean-normalize.js --fix\n` +
      `  node scripts/korean-normalize.js --ext md,txt docs public/posts\n`,
  );
}

function parseArgs(argv) {
  const options = {
    fix: false,
    removeZeroWidth: false,
    exts: [...DEFAULT_EXTS],
    ci: false,
    silent: false,
    paths: [],
  };

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];
    switch (arg) {
      case "--fix":
        options.fix = true;
        break;
      case "--remove-zero-width":
        options.removeZeroWidth = true;
        break;
      case "--ext":
      case "-e": {
        const val = argv[++i];
        if (!val) throw new Error("--ext requires a value");
        options.exts = val
          .split(",")
          .map((s) => s.trim().toLowerCase())
          .map((s) => (s.startsWith(".") ? s : `.${s}`));
        break;
      }
      case "--ci":
        options.ci = true;
        break;
      case "--silent":
        options.silent = true;
        break;
      case "--help":
      case "-h":
        printHelp();
        process.exit(0);
      default:
        // treat as path
        options.paths.push(arg);
        break;
    }
  }

  if (options.paths.length === 0) {
    options.paths = [...DEFAULT_PATHS];
  }

  return options;
}

async function pathExists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

async function* walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      if (IGNORED_DIRS.has(entry.name)) continue;
      yield* walk(full);
    } else if (entry.isFile()) {
      yield full;
    }
  }
}

function matchesExt(file, exts) {
  const ext = path.extname(file).toLowerCase();
  return exts.includes(ext);
}

function summarizeZeroWidth(text) {
  const matches = text.match(ZeroWidthRegexGlobal);
  if (!matches) return { count: 0, byChar: {} };
  return matches.reduce(
    (acc, ch) => {
      acc.count++;
      acc.byChar[ch] = (acc.byChar[ch] || 0) + 1;
      return acc;
    },
    { count: 0, byChar: {} },
  );
}

function hasDecomposedHangul(text) {
  if (!JamoRegex.test(text)) return false;
  return text !== text.normalize("NFC");
}

function findProblemLines(text) {
  const lines = text.split(/\r?\n/);
  const issues = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const needsNorm = JamoRegex.test(line) && line !== line.normalize("NFC");
    const zws = line.match(ZeroWidthRegexGlobal)?.length || 0;
    if (needsNorm || zws) {
      issues.push({
        line: i + 1,
        norm: needsNorm,
        zws,
        preview: line.length > 160 ? line.slice(0, 160) + "…" : line,
      });
    }
  }
  return issues;
}

async function processFile(file, options) {
  const content = await fs.readFile(file, "utf8");
  const needsNorm = hasDecomposedHangul(content);
  const { count: zwsCount } = summarizeZeroWidth(content);

  const hasIssues = needsNorm || zwsCount > 0;
  let fixed = content;
  if (options.fix && hasIssues) {
    fixed = fixed.normalize("NFC");
    if (options.removeZeroWidth)
      fixed = fixed.replace(ZeroWidthRegexGlobal, "");
    if (fixed !== content) await fs.writeFile(file, fixed, "utf8");
  }

  if (hasIssues) {
    const lines = findProblemLines(content);
    return {
      file,
      needsNorm,
      zwsCount,
      lines,
      changed: options.fix && fixed !== content,
    };
  }
  return null;
}

async function gatherTargets(pathsList, exts) {
  const targets = [];
  for (const p of pathsList) {
    const abs = path.isAbsolute(p) ? p : path.join(process.cwd(), p);
    if (!(await pathExists(abs))) continue;
    const stat = await fs.lstat(abs);
    if (stat.isDirectory()) {
      for await (const f of walk(abs)) {
        if (matchesExt(f, exts)) targets.push(f);
      }
    } else if (stat.isFile()) {
      if (matchesExt(abs, exts)) targets.push(abs);
    }
  }
  return targets;
}

function formatIssue(issue, rootDir) {
  const rel = path.relative(rootDir, issue.file) || issue.file;
  const head = `- ${rel} ${issue.changed ? "[fixed]" : ""}`.trim();
  const details = issue.lines.slice(0, 5).map((l) => {
    const markers = [l.norm ? "NFC" : null, l.zws ? `ZW:${l.zws}` : null]
      .filter(Boolean)
      .join(",");
    return `    L${l.line} (${markers}): ${l.preview}`;
  });
  const more =
    issue.lines.length > 5
      ? `    …and ${issue.lines.length - 5} more lines`
      : "";
  return [head, ...details, more].filter(Boolean).join("\n");
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  const rootDir = process.cwd();

  const targets = await gatherTargets(options.paths, options.exts);
  if (!options.silent) {
    console.log(
      `Scanning ${targets.length} file(s) in: ${options.paths.join(", ")} [exts: ${options.exts.join(", ")}]`,
    );
    if (targets.length === 0) console.log("No matching files found.");
  }

  const results = [];
  for (const file of targets) {
    try {
      const r = await processFile(file, options);
      if (r) results.push(r);
    } catch (err) {
      console.error(`Error processing ${file}:`, err.message || err);
    }
  }

  const issues = results.filter(Boolean);
  const filesWithIssues = issues.length;
  const filesChanged = issues.filter((i) => i.changed).length;
  const totalZws = issues.reduce((sum, i) => sum + i.zwsCount, 0);
  const filesNeedingNorm = issues.filter((i) => i.needsNorm).length;

  if (!options.silent) {
    if (filesWithIssues > 0) {
      console.log("\nIssues found:");
      for (const issue of issues) {
        console.log(formatIssue(issue, rootDir));
      }
    }

    console.log("\nSummary:");
    console.log(`  Files scanned        : ${targets.length}`);
    console.log(`  Files with issues    : ${filesWithIssues}`);
    console.log(`  Files needing NFC    : ${filesNeedingNorm}`);
    console.log(`  Zero-width chars     : ${totalZws}`);
    if (options.fix) console.log(`  Files changed        : ${filesChanged}`);
  }

  if (!options.fix && options.ci && filesWithIssues > 0) {
    process.exitCode = 1;
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

```

---

## frontend/src

### App.css

**Path:** `frontend/src/App.css`

```css

```

### App.tsx

**Path:** `frontend/src/App.tsx`

```tsx
import { useEffect, useState } from 'react';
import { HashRouter as Router, Routes, Route } from 'react-router-dom';
import { ThemeProvider } from './contexts/ThemeContext';
import { LanguageProvider } from './contexts/LanguageContext';
import { Header, Footer } from './components/organisms';
import { Toaster } from './components/ui/toaster';
import { TooltipProvider } from './components/ui/tooltip';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import Index from './pages/Index';
import Blog from './pages/Blog';
import BlogPost from './pages/BlogPost';
import About from './pages/About';
import Contact from './pages/Contact';
import NewPost from './pages/NewPost';
import NotFound from './pages/NotFound';
import Insight from './pages/Insight';
import AdminConfig from './pages/AdminConfig';
import './App.css';
import { VisitedPostsMinimap } from '@/components/features/navigation/VisitedPostsMinimap';
import FloatingActionBar from '@/components/features/memo/FloatingActionBar';

const queryClient = new QueryClient();

function App() {
  console.log('[App] component init');
  const [fabOn, setFabOn] = useState(false);
  useEffect(() => {
    console.log('[App] mounted');
    const getFabEnabled = () => {
      const envFlag = (import.meta as any).env?.VITE_FEATURE_FAB;
      const envOn = envFlag === true || envFlag === 'true' || envFlag === '1';
      try {
        const ls = localStorage.getItem('aiMemo.fab.enabled');
        if (ls != null) return !!JSON.parse(ls);
      } catch {}
      return !!envOn;
    };
    setFabOn(getFabEnabled());

    const onStorage = (e: StorageEvent) => {
      if (!e.key || e.key === 'aiMemo.fab.enabled') setFabOn(getFabEnabled());
    };
    window.addEventListener('storage', onStorage);
    return () => console.log('[App] unmounted');
  }, []);
  return (
    <QueryClientProvider client={queryClient}>
      <LanguageProvider>
        <ThemeProvider>
          <TooltipProvider>
            <Router>
              <div className='min-h-screen flex flex-col bg-background text-foreground'>
                <Header />
                <main className='flex-1 pb-[110px] lg:pb-[60px]'>
                  <Routes>
                    <Route path='/' element={<Index />} />
                    <Route path='/blog' element={<Blog />} />
                    <Route path='/blog/:year/:slug' element={<BlogPost />} />
                    <Route path='/post/:year/:slug' element={<BlogPost />} />
                    <Route path='/about' element={<About />} />
                    <Route path='/contact' element={<Contact />} />
                    <Route path='/insight' element={<Insight />} />
                    <Route path='/admin/new-post' element={<NewPost />} />
                    <Route path='/admin/config' element={<AdminConfig />} />
                    <Route path='*' element={<NotFound />} />
                  </Routes>
                </main>
                <Footer />
                {!fabOn && <VisitedPostsMinimap />}
                <FloatingActionBar />
                <Toaster />
              </div>
            </Router>
          </TooltipProvider>
        </ThemeProvider>
      </LanguageProvider>
    </QueryClientProvider>
  );
}

export default App;

```

### index.css

**Path:** `frontend/src/index.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 226 70% 55%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;

    /* Z-Index Layer System */
    --z-base: 0;
    --z-floating-content: 40;
    --z-fab-bar: 50;
    --z-memo-panel: 60;
    --z-modal-overlay: 100;
    --z-chat-widget: 110;
    --z-toast: 200;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 226 70% 60%;
    --primary-foreground: 210 40% 98%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }

  /* Terminal Theme - CRT / Green Monitor Aesthetic */
  /* Design Philosophy: "모든 UI는 터미널 명령어와 출력값처럼 보여야 한다" */
  /* Color Balance: Neon green limited to interactive elements only */
  .terminal {
    /* Deep charcoal with subtle green tint - easier on eyes than pure black */
    --background: 200 25% 5%;
    /* Light warm white for body text - better readability */
    --foreground: 60 10% 92%;
    /* Card backgrounds - slightly elevated from main bg */
    --card: 200 20% 7%;
    --card-foreground: 60 10% 92%;
    /* Popover uses card colors */
    --popover: 200 20% 7%;
    --popover-foreground: 60 10% 92%;
    /* Neon green primary accent - use sparingly */
    --primary: 150 100% 62%;
    --primary-foreground: 200 25% 5%;
    /* Muted secondary - softer contrast */
    --secondary: 200 20% 10%;
    --secondary-foreground: 60 10% 85%;
    /* Muted text colors - warm gray for better comfort */
    --muted: 200 15% 10%;
    --muted-foreground: 60 5% 55%;
    /* Accent matches primary for consistency */
    --accent: 150 100% 62%;
    --accent-foreground: 200 25% 5%;
    /* Destructive red */
    --destructive: 0 70% 50%;
    --destructive-foreground: 60 10% 92%;
    /* Borders - subtle, not competing with content */
    --border: 200 15% 15%;
    --input: 200 15% 15%;
    /* Ring for focus states */
    --ring: 150 100% 62%;
    
    /* Cyber-Minimalism Design Tokens */
    --radius: 4px; /* 날렵한 사각형 (Radius 2px~4px) */
    
    /* Terminal-specific custom properties */
    --terminal-glow: 150 100% 62%;
    --terminal-cyan: 190 100% 60%;
    --terminal-amber: 40 100% 55%;
    --terminal-code-bg: 200 25% 4%;
    --terminal-code-text: 60 20% 75%;
    --terminal-prompt: 150 100% 62%;
    --terminal-cursor: 150 100% 62%;
    --terminal-link: 150 100% 62%;
    --terminal-link-hover: 150 80% 75%;
    --terminal-titlebar: 200 25% 4%;
    --terminal-window-btn-close: 0 70% 55%;
    --terminal-window-btn-minimize: 40 90% 55%;
    --terminal-window-btn-maximize: 140 70% 45%;
    
    /* Cyber-Minimalism: Glow Effects - softer for less eye strain */
    --glow-shadow: 0 0 8px hsl(150 100% 62% / 0.3);
    --glow-shadow-strong: 0 0 12px hsl(150 100% 62% / 0.5);
    
    /* Dim states for inactive elements */
    --terminal-dim: 150 100% 62% / 0.08;
    --terminal-inactive-border: 200 15% 18%;
  }
}

@layer base {
  body {
    @apply bg-background text-foreground;
    font-family: 'Pretendard Variable', 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans KR', sans-serif;
    font-feature-settings:
      'rlig' 1,
      'calt' 1;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }
  
  /* Light/Dark 테마 가독성 향상 */
  :root {
    /* 본문 폰트 크기 및 행간 최적화 */
    --content-line-height: 1.8;
    --content-letter-spacing: -0.01em;
  }
  
  /* 본문 텍스트 가독성 향상 */
  .prose,
  article,
  .content,
  [role="article"] {
    line-height: var(--content-line-height);
    letter-spacing: var(--content-letter-spacing);
  }
  
  /* 한글 최적화 (Light/Dark 테마) */
  :not(.terminal) .prose p,
  :not(.terminal) article p,
  :not(.terminal) .content p {
    word-break: keep-all;
    overflow-wrap: break-word;
    text-align: justify;
    text-justify: inter-character;
  }
  
  /* Base heading styles to ensure consistent sizing and spacing (sectioned headings included) */
  h1,
  section h1,
  article h1,
  [role='article'] h1,
  .prose h1 {
    @apply text-3xl md:text-4xl font-extrabold leading-tight my-4;
  }
  h2,
  section h2,
  article h2,
  [role='article'] h2,
  .prose h2 {
    @apply text-2xl md:text-3xl font-semibold leading-snug my-3;
  }
  h3,
  section h3,
  article h3,
  [role='article'] h3,
  .prose h3 {
    @apply text-xl md:text-2xl font-medium leading-snug my-2;
  }
  code,
  pre,
  kbd,
  samp {
    @apply font-mono;
  }
}

@layer utilities {
  /* Responsive styles for markdown content */
  .content img {
    @apply max-w-full h-auto rounded-md;
  }
  .content pre {
    @apply overflow-x-auto;
  }
  .content table {
    @apply w-full overflow-x-auto block;
  }

  .animate-gradient {
    background-size: 400% 400%;
    animation: gradient 15s ease infinite;
  }

  @keyframes gradient {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }

  /* Accessibility and mobile improvements */
  .touch-target-44 {
    min-height: 44px;
    min-width: 44px;
  }

  .safe-area {
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    padding-bottom: env(safe-area-inset-bottom);
  }

  .safe-area-top {
    padding-top: env(safe-area-inset-top);
  }

  /* Mobile-friendly button sizes */
  .mobile-btn {
    @apply min-h-[44px] min-w-[44px];
  }

  /* Improved mobile spacing */
  @media (max-width: 767px) {
    .mobile-padding {
      @apply px-4 py-3;
    }
    
    .mobile-gap {
      @apply gap-3;
    }
  }

  /* Animation utilities */
  @keyframes slide-in {
    from {
      opacity: 0;
      transform: translateX(1rem);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  .animate-slide-in {
    animation: slide-in 0.3s ease-out forwards;
  }

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  .animate-fade-in {
    animation: fade-in 0.3s ease-out forwards;
  }

  /* Shimmer for skeletons */
  @keyframes shimmer {
    0% {
      background-position: -200% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }
  .shimmer {
    background: linear-gradient(
      90deg,
      rgba(0, 0, 0, 0) 0%,
      rgba(255, 255, 255, 0.2) 50%,
      rgba(0, 0, 0, 0) 100%
    );
    background-size: 200% 100%;
    animation: shimmer 1.6s infinite;
  }

  /* Focus improvements for keyboard navigation */
  .focus-ring {
    @apply focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:ring-offset-background focus:outline-none;
  }

  /* Skip link for accessibility */
  .skip-link {
    @apply absolute -top-10 left-6 z-[100] bg-background px-4 py-2 text-foreground focus:top-6;
  }
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}

::-webkit-scrollbar-track {
  @apply bg-muted;
}

::-webkit-scrollbar-thumb {
  @apply bg-muted-foreground/20 rounded-full;
}

::-webkit-scrollbar-thumb:hover {
  @apply bg-muted-foreground/30;
}

/* Better focus styles */

*:focus-visible {
  @apply ring-2 ring-ring ring-offset-2 ring-offset-background;
}

/* Line clamp utilities */
.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.line-clamp-3 {
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* Reduced motion preference */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* ============================================
   Terminal Theme Specific Styles
   ============================================ */

/* Terminal theme scrollbar */
.terminal ::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

.terminal ::-webkit-scrollbar-track {
  background: hsl(var(--terminal-code-bg));
}

.terminal ::-webkit-scrollbar-thumb {
  background: hsl(var(--terminal-glow) / 0.3);
  border-radius: 3px;
}

.terminal ::-webkit-scrollbar-thumb:hover {
  background: hsl(var(--terminal-glow) / 0.5);
}

/* Terminal cursor blink animation */
@keyframes terminal-cursor-blink {
  0%, 50% {
    opacity: 1;
  }
  51%, 100% {
    opacity: 0;
  }
}

.terminal-cursor {
  display: inline-block;
  width: 0.6em;
  height: 1.2em;
  background-color: hsl(var(--terminal-cursor));
  animation: terminal-cursor-blink 1s step-end infinite;
  vertical-align: text-bottom;
  margin-left: 2px;
}

/* Terminal scanline effect (optional, performance-friendly) */
.terminal-scanlines::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  z-index: var(--z-toast); /* Use layered z-index system */
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 0, 0, 0.03) 2px,
    rgba(0, 0, 0, 0.03) 4px
  );
}

/* Terminal CRT glow effect */
.terminal-glow {
  text-shadow: 0 0 5px hsl(var(--terminal-glow) / 0.5),
               0 0 10px hsl(var(--terminal-glow) / 0.3);
}

/* Terminal typography overrides */
.terminal h1,
.terminal h2,
.terminal h3,
.terminal h4,
.terminal h5,
.terminal h6 {
  font-family: 'JetBrains Mono', 'Fira Code', 'IBM Plex Mono', ui-monospace, 'SF Mono', monospace;
  letter-spacing: 0.04em;
}

.terminal .font-mono,
.terminal code,
.terminal pre,
.terminal kbd,
.terminal samp {
  font-family: 'JetBrains Mono', 'Fira Code', 'IBM Plex Mono', ui-monospace, 'SF Mono', monospace;
}

/* Terminal link styles */
.terminal a:not(.no-terminal-style) {
  color: hsl(var(--terminal-link));
  text-decoration: underline;
  text-decoration-style: dotted;
  text-underline-offset: 3px;
  transition: all 0.15s ease;
}

.terminal a:not(.no-terminal-style):hover {
  color: hsl(var(--terminal-link-hover));
  text-decoration-style: solid;
}

/* Terminal focus ring */
.terminal *:focus-visible {
  outline: 2px solid hsl(var(--terminal-glow));
  outline-offset: 2px;
  box-shadow: 0 0 8px hsl(var(--terminal-glow) / 0.4);
}

/* Terminal window title bar */
.terminal-titlebar {
  background: hsl(var(--terminal-titlebar));
  border-bottom: 1px solid hsl(var(--border));
  padding: 8px 12px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
}

.terminal-window-buttons {
  display: flex;
  gap: 6px;
}

.terminal-window-btn {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: none;
  cursor: default;
}

.terminal-window-btn-close {
  background: hsl(var(--terminal-window-btn-close));
}

.terminal-window-btn-minimize {
  background: hsl(var(--terminal-window-btn-minimize));
}

.terminal-window-btn-maximize {
  background: hsl(var(--terminal-window-btn-maximize));
}

/* Terminal prompt prefix */
.terminal-prompt::before {
  content: '> ';
  color: hsl(var(--terminal-prompt));
  font-weight: 600;
}

/* Terminal code block styles */
.terminal pre[class*="language-"],
.terminal .code-block {
  background: hsl(var(--terminal-code-bg)) !important;
  border: 1px solid hsl(var(--border));
  border-radius: 6px;
}

.terminal pre[class*="language-"] code,
.terminal .code-block code {
  color: hsl(var(--terminal-code-text)) !important;
}

/* Terminal card/container styles */
.terminal .terminal-card {
  background: hsl(var(--card));
  border: 1px solid hsl(var(--border));
  border-radius: 8px;
  box-shadow: inset 0 1px 0 hsl(var(--border)),
              0 4px 16px rgba(0, 0, 0, 0.4);
}

/* Terminal list styles (ASCII bullets) */
.terminal ul:not(.no-terminal-style) > li::marker {
  content: '- ';
  color: hsl(var(--terminal-prompt));
}

.terminal ol:not(.no-terminal-style) > li::marker {
  color: hsl(var(--terminal-prompt));
  font-family: 'JetBrains Mono', monospace;
}

/* Terminal blockquote */
.terminal blockquote {
  border-left: 3px solid hsl(var(--terminal-glow));
  background: hsl(var(--terminal-code-bg));
  padding: 12px 16px;
  font-style: normal;
}

/* Terminal table */
.terminal table {
  border: 1px solid hsl(var(--border));
}

.terminal th {
  background: hsl(var(--terminal-code-bg));
  color: hsl(var(--terminal-glow));
  font-family: 'JetBrains Mono', monospace;
  font-weight: 600;
  text-transform: uppercase;
  font-size: 0.85em;
  letter-spacing: 0.05em;
}

.terminal td {
  border: 1px solid hsl(var(--border));
}

/* Terminal selection highlight */
.terminal ::selection {
  background: hsl(var(--terminal-glow) / 0.3);
  color: hsl(var(--foreground));
}

/* Terminal toast notification */
.terminal [data-radix-toast-viewport] [data-state="open"] {
  background: hsl(var(--terminal-titlebar));
  border: 1px solid hsl(var(--terminal-glow) / 0.3);
  font-family: 'JetBrains Mono', monospace;
  box-shadow: 0 0 20px hsl(var(--terminal-glow) / 0.2);
}

.terminal [data-radix-toast-viewport] [data-state="open"] [class*="ToastTitle"],
.terminal [data-radix-toast-viewport] [data-state="open"] > div > div:first-child {
  color: hsl(var(--terminal-glow));
  font-weight: 600;
}

.terminal [data-radix-toast-viewport] [data-state="open"] [class*="ToastDescription"],
.terminal [data-radix-toast-viewport] [data-state="open"] > div > div:last-child {
  color: hsl(var(--terminal-secondary));
  font-size: 0.85em;
}

/* ============================================
   Cyber-Minimalism Utility Classes
   ============================================ */

/* Glassmorphism Card Style */
.glass-card {
  background: rgba(255, 255, 255, 0.03);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.05);
}

.terminal .glass-card {
  background: rgba(20, 25, 30, 0.6);
  border: 1px solid hsl(var(--border));
}

.terminal .glass-card:hover {
  background: rgba(20, 25, 30, 0.8);
  border-color: hsl(var(--primary) / 0.3);
  box-shadow: var(--glow-shadow);
}

/* Terminal Hover Glow Effect for Cards */
.terminal .glow-card {
  transition: all 0.3s ease;
}

.terminal .glow-card:hover {
  border-color: hsl(var(--primary) / 0.5);
  box-shadow: 
    0 0 20px hsl(var(--primary) / 0.15),
    inset 0 0 20px hsl(var(--primary) / 0.05);
}

/* Terminal Panel (Output Window) */
.terminal .terminal-panel,
.terminal-panel {
  background-color: hsl(var(--terminal-panel, var(--card)));
  border: 1px solid hsl(var(--terminal-inactive-border, var(--border)));
  border-left: 3px solid hsl(var(--primary));
  padding: 1.5rem;
  border-radius: 4px;
  position: relative;
}

/* Command Button (Keycap style) */
.terminal .cmd-btn,
.cmd-btn {
  background: transparent;
  border: 1px solid hsl(var(--terminal-inactive-border, var(--border)));
  color: hsl(var(--muted-foreground));
  padding: 0.5rem 1rem;
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  font-size: 0.75rem;
  font-weight: bold;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.terminal .cmd-btn:hover,
.cmd-btn:hover {
  border-color: hsl(var(--primary));
  color: hsl(var(--primary));
  box-shadow: var(--glow-shadow, 0 0 10px hsl(150 100% 62% / 0.4));
  text-shadow: 0 0 5px hsl(var(--primary));
}

.terminal .cmd-btn.active,
.cmd-btn.active {
  background: hsl(var(--primary));
  color: hsl(210 50% 2%); /* Dark text on neon green */
  border-color: hsl(var(--primary));
  box-shadow: var(--glow-shadow, 0 0 10px hsl(150 100% 62% / 0.4));
}

.terminal .cmd-btn.close,
.cmd-btn.close {
  border-color: hsl(var(--destructive) / 0.5);
  color: hsl(var(--destructive));
}

.terminal .cmd-btn.close:hover,
.cmd-btn.close:hover {
  background: hsl(var(--destructive));
  color: white; /* White text on red background */
  border-color: hsl(var(--destructive));
  box-shadow: 0 0 10px hsl(var(--destructive) / 0.5);
}

/* Terminal Prompt Style */
.terminal .prompt-prefix::before {
  content: '> ';
  color: hsl(var(--terminal-prompt, var(--primary)));
  font-weight: 600;
  font-family: 'JetBrains Mono', monospace;
}

/* Comment Style Title (// prefix) */
.terminal .section-comment {
  color: hsl(var(--muted-foreground));
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.95rem;
  font-weight: normal;
}

/* Neon Glow Text */
.terminal .neon-text {
  color: hsl(var(--primary));
  text-shadow: 0 0 5px hsl(var(--primary) / 0.5),
               0 0 10px hsl(var(--primary) / 0.3);
}

/* Terminal highlight text */
.terminal .highlight-text {
  color: hsl(var(--foreground));
  text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
}

/* ============================================
   Light/Dark Theme Enhanced Readability
   ============================================ */

/* 기본 테마 카드/컨테이너 스타일 */
:not(.terminal) .card,
:not(.terminal) [class*="Card"] {
  @apply transition-all duration-200;
}

:not(.terminal) .card:hover,
:not(.terminal) [class*="Card"]:hover {
  @apply shadow-lg;
}

/* 기본 테마 버튼 최소 터치 타겟 */
:not(.terminal) button,
:not(.terminal) [role="button"],
:not(.terminal) a[href] {
  min-height: 44px;
  min-width: 44px;
}

/* 예외: 인라인 링크와 작은 아이콘 버튼 */
:not(.terminal) a:not([class*="btn"]):not([class*="Button"]),
:not(.terminal) .inline-link,
:not(.terminal) [class*="icon-only"] {
  min-height: unset;
  min-width: unset;
}

/* 기본 테마 인풋 필드 스타일링 */
:not(.terminal) input[type="text"],
:not(.terminal) input[type="email"],
:not(.terminal) input[type="password"],
:not(.terminal) input[type="search"],
:not(.terminal) textarea,
:not(.terminal) select {
  @apply transition-all duration-200;
  font-size: 16px; /* iOS 줌 방지 */
}

/* 기본 테마 포커스 스타일 */
:not(.terminal) input:focus,
:not(.terminal) textarea:focus,
:not(.terminal) select:focus {
  @apply ring-2 ring-primary/30 border-primary;
}

/* Light 테마 세부 조정 */
.light {
  /* 더 나은 대비를 위한 텍스트 색상 */
  --foreground: 222.2 84% 6%;
  --muted-foreground: 215.4 16.3% 40%;
}

/* Dark 테마 세부 조정 */
.dark:not(.terminal) {
  /* 눈의 피로를 줄이기 위한 약간 따뜻한 배경 */
  --background: 224 71% 4%;
  --card: 224 71% 6%;
  /* 더 나은 가독성을 위한 텍스트 색상 */
  --foreground: 210 40% 96%;
  --muted-foreground: 215 20.2% 60%;
}

/* 기본 테마 prose 스타일 개선 */
:not(.terminal) .prose {
  --tw-prose-body: hsl(var(--foreground));
  --tw-prose-headings: hsl(var(--foreground));
  --tw-prose-lead: hsl(var(--muted-foreground));
  --tw-prose-links: hsl(var(--primary));
  --tw-prose-bold: hsl(var(--foreground));
  --tw-prose-counters: hsl(var(--muted-foreground));
  --tw-prose-bullets: hsl(var(--muted-foreground));
  --tw-prose-hr: hsl(var(--border));
  --tw-prose-quotes: hsl(var(--foreground));
  --tw-prose-quote-borders: hsl(var(--primary));
  --tw-prose-captions: hsl(var(--muted-foreground));
  --tw-prose-code: hsl(var(--primary));
  --tw-prose-pre-code: hsl(var(--foreground));
  --tw-prose-pre-bg: hsl(var(--muted));
  --tw-prose-th-borders: hsl(var(--border));
  --tw-prose-td-borders: hsl(var(--border));
}

:not(.terminal) .prose h1,
:not(.terminal) .prose h2,
:not(.terminal) .prose h3,
:not(.terminal) .prose h4 {
  @apply font-semibold tracking-tight;
  font-family: 'Pretendard Variable', 'Pretendard', -apple-system, BlinkMacSystemFont, sans-serif;
}

:not(.terminal) .prose p {
  @apply leading-relaxed;
  margin-bottom: 1.25em;
}

:not(.terminal) .prose a {
  @apply underline underline-offset-4 decoration-primary/40 hover:decoration-primary transition-colors;
}

:not(.terminal) .prose blockquote {
  @apply border-l-4 border-primary/30 bg-muted/30 py-2 px-4 my-4 italic;
}

:not(.terminal) .prose code:not(pre code) {
  @apply bg-muted px-1.5 py-0.5 rounded text-sm font-normal;
}

:not(.terminal) .prose pre {
  @apply rounded-xl border border-border/50 shadow-sm;
}

/* 기본 테마 목록 스타일 */
:not(.terminal) .prose ul,
:not(.terminal) .prose ol {
  @apply my-4 pl-5;
}

:not(.terminal) .prose li {
  @apply my-1;
}

:not(.terminal) .prose li::marker {
  color: hsl(var(--primary));
}

/* 기본 테마 테이블 스타일 */
:not(.terminal) .prose table {
  @apply w-full border-collapse;
}

:not(.terminal) .prose th {
  @apply bg-muted/50 font-semibold text-left px-4 py-3 border-b-2 border-border;
}

:not(.terminal) .prose td {
  @apply px-4 py-3 border-b border-border/50;
}

:not(.terminal) .prose tr:hover {
  @apply bg-muted/30;
}

/* 기본 테마 이미지 스타일 */
:not(.terminal) .prose img {
  @apply rounded-xl shadow-md my-6;
}

:not(.terminal) .prose figure {
  @apply my-6;
}

:not(.terminal) .prose figcaption {
  @apply text-center text-sm text-muted-foreground mt-3;
}

/* ============================================
   Compact TUI System
   ============================================ */

/* TUI Typography Scaling */
:root {
  font-size: clamp(14px, 1.5vw, 15px);
  line-height: 1.6;
}

/* TUI Button & Padding Refactoring */
.btn-tui {
  @apply border bg-transparent text-foreground hover:bg-primary/10 hover:text-primary;
  padding: 0.5rem 1rem;
  height: auto;
  min-height: 36px;
  font-family: 'JetBrains Mono', monospace;
}

.tui-card {
  @apply border bg-transparent p-4 shadow-none;
}

/* ============================================
   Button Contrast & Visibility Improvements
   ============================================ */

/* Primary button: ensure text is always readable */
.btn-primary,
button[class*="bg-primary"]:not([class*="bg-primary/"]) {
  color: hsl(var(--primary-foreground)) !important;
}

/* Terminal theme primary buttons - Dark text on bright neon green */
.terminal .btn-primary,
.terminal button[class*="bg-primary"]:not([class*="bg-primary/"]),
.terminal a[class*="bg-primary"]:not([class*="bg-primary/"]),
.terminal button[class*="terminal-active"],
.terminal [class*="terminal-active"] {
  background-color: hsl(var(--primary));
  color: hsl(210 50% 2%) !important; /* Force dark text on neon green */
  font-weight: 600;
}

/* Outline buttons in terminal theme */
.terminal .btn-outline {
  background: transparent;
  border: 1px solid hsl(var(--primary));
  color: hsl(var(--primary));
}

.terminal .btn-outline:hover {
  background: hsl(var(--primary) / 0.1);
}

/* FAB dock buttons - only apply to actual FAB elements, not all bg-primary/20 */
.terminal [role="toolbar"] [class*="bg-primary/20"],
.terminal .fab-button[class*="bg-primary/20"] {
  color: hsl(var(--primary));
}

/* Terminal active tabs - ensure contrast */
.terminal [data-state="active"][class*="bg-primary"],
.terminal button[data-state="active"][class*="terminal"] {
  color: hsl(210 50% 2%) !important; /* Dark text on neon green */
}

/* Destructive buttons - ensure red text is visible on dark backgrounds */
.terminal button[class*="destructive"],
.terminal [class*="destructive"] {
  --destructive-text: 0 70% 60%; /* Slightly brighter red for dark mode */
}

.terminal button[class*="bg-destructive"]:not([class*="bg-destructive/"]) {
  color: hsl(0 0% 100%) !important; /* White text on red background */
}

/* Secondary buttons in terminal theme */
.terminal button[class*="bg-secondary"]:not([class*="bg-secondary/"]) {
  color: hsl(var(--secondary-foreground));
}

/* Ghost and outline buttons should have visible text */
.terminal button[class*="ghost"],
.terminal button[class*="outline"] {
  color: hsl(var(--foreground));
}

.terminal button[class*="ghost"]:hover,
.terminal button[class*="outline"]:hover {
  color: hsl(var(--primary));
}

/* ============================================
   Mobile UX Improvements (All Themes)
   ============================================ */

@media (max-width: 767px) {
  /* 모바일 버튼 최소 크기 */
  button,
  [role="button"],
  .btn,
  [class*="Button"] {
    min-height: 40px;
  }
  
  /* 모바일 간격 */
  .container,
  .content-container {
    @apply px-4; /* 1rem for mobile */
  }
  
  /* 모바일 폰트 크기 */
  .prose,
  article,
  .content {
    font-size: 1rem;
    line-height: 1.7;
  }

  h1, .text-3xl { font-size: 1.75rem; }
  h2, .text-2xl { font-size: 1.5rem; }
  h3, .text-xl { font-size: 1.25rem; }

  /* Adjust meta data font size */
  .meta-text {
    font-size: clamp(11px, 2vw, 12px);
  }
  
  /* Mobile performance: reduce backdrop-filter intensity */
  .backdrop-blur,
  .backdrop-blur-sm,
  .backdrop-blur-md,
  .backdrop-blur-lg,
  .backdrop-blur-xl,
  [class*="backdrop-blur"] {
    --tw-backdrop-blur: blur(4px) !important;
  }
  
  /* Disable backdrop-filter on very low-end devices (prefers-reduced-motion as proxy) */
  @media (prefers-reduced-motion: reduce) {
    .backdrop-blur,
    .backdrop-blur-sm,
    .backdrop-blur-md,
    .backdrop-blur-lg,
    .backdrop-blur-xl,
    [class*="backdrop-blur"] {
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
      background-color: hsl(var(--background) / 0.95) !important;
    }
  }
  
  /* Glass card mobile optimization */
  .glass-card {
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
  }
}

/* ============================================
   Accessibility Improvements
   ============================================ */

/* Hide scrollbar for carousel */
.scrollbar-hide::-webkit-scrollbar {
  display: none;
}

.scrollbar-hide {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

/* 고대비 모드 지원 */
@media (prefers-contrast: high) {
  :root {
    --border: 214.3 31.8% 50%;
  }
  
  .dark {
    --border: 217.2 32.6% 50%;
  }
}

/* 스크린 리더 전용 텍스트 */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

```

### main.tsx

**Path:** `frontend/src/main.tsx`

```tsx
import './polyfills';
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import './index.css';

// Debug logs to diagnose blank screen
console.log('[main] script loaded');
const rootEl = document.getElementById('root');
console.log('[main] root element:', rootEl);
// Global error handlers
window.addEventListener('error', e => {
  console.error('[main] Global error:', e.message, e.error);
});
window.addEventListener('unhandledrejection', e => {
  console.error('[main] Unhandled rejection:', e.reason);
});
if (rootEl) {
  createRoot(rootEl).render(<App />);
  console.log('[main] React root mounted');
} else {
  console.error('[main] #root element not found');
}

```

### polyfills.ts

**Path:** `frontend/src/polyfills.ts`

```typescript
/* Polyfill Node.js Buffer for browser (needed by libraries like gray-matter) */
import { Buffer as BufferPolyfill } from 'buffer';

// Define Buffer globally if not present
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const g: any = (typeof globalThis !== 'undefined' ? globalThis : window) as any;
if (g && !g.Buffer) {
  g.Buffer = BufferPolyfill;
}

```

### vite-env.d.ts

**Path:** `frontend/src/vite-env.d.ts`

```typescript
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_SITE_BASE_URL?: string;
  readonly VITE_API_BASE_URL?: string;
  readonly VITE_DEV_HOST?: string;
  readonly VITE_DEV_PORT?: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}

```

---

## frontend/src/components

### index.ts

**Path:** `frontend/src/components/index.ts`

```typescript
// Re-export all components for cleaner imports
export * from './atoms';
export * from './molecules';
export * from './organisms';

// Feature-based exports
export * from './features/blog';
export * from './features/search';
export * from './features/navigation';
export * from './common';
export * from './ui';

```

---

## frontend/src/components/atoms

### DateDisplay.tsx

**Path:** `frontend/src/components/atoms/DateDisplay.tsx`

```tsx
import { Calendar, Clock } from 'lucide-react';

interface DateDisplayProps {
  date: string;
  showIcon?: boolean;
  className?: string;
}

export function DateDisplay({
  date,
  showIcon = true,
  className = '',
}: DateDisplayProps) {
  return (
    <div
      className={`flex items-center text-sm text-muted-foreground ${className}`}
    >
      {showIcon && <Calendar className='h-3 w-3 mr-1' />}
      {date}
    </div>
  );
}

interface ReadTimeProps {
  readTime: number;
  showIcon?: boolean;
  className?: string;
}

export function ReadTime({
  readTime,
  showIcon = true,
  className = '',
}: ReadTimeProps) {
  return (
    <div
      className={`flex items-center text-sm text-muted-foreground ${className}`}
    >
      {showIcon && <Clock className='h-3 w-3 mr-1' />}
      {readTime} min read
    </div>
  );
}

```

### TagList.tsx

**Path:** `frontend/src/components/atoms/TagList.tsx`

```tsx
import { Tag } from 'lucide-react';
import { Badge } from '@/components/ui/badge';

interface TagListProps {
  tags: string[];
  maxVisible?: number;
  showIcon?: boolean;
  variant?: 'default' | 'secondary' | 'destructive' | 'outline';
  className?: string;
  size?: 'sm' | 'default' | 'lg';
}

export function TagList({
  tags,
  maxVisible = 2,
  showIcon = true,
  variant = 'secondary',
  className = '',
  size = 'default',
}: TagListProps) {
  if (!tags || tags.length === 0) return null;

  const visibleTags = tags.slice(0, maxVisible);
  const remainingCount = tags.length - maxVisible;

  const sizeClasses = {
    sm: 'text-xs px-2 py-0.5 rounded-full',
    default: 'text-xs px-2.5 py-0.5 rounded-full',
    lg: 'text-sm px-3 py-1 rounded-full',
  };

  const iconSizes = {
    sm: 'h-2.5 w-2.5',
    default: 'h-3 w-3',
    lg: 'h-3.5 w-3.5',
  };

  return (
    <div className={`flex items-center gap-1 flex-wrap ${className}`}>
      {showIcon && <Tag className={iconSizes[size]} />}
      {visibleTags.map(tag => (
        <Badge
          key={tag}
          variant={variant}
          className={`${sizeClasses[size]} whitespace-nowrap bg-slate-200 text-slate-700 dark:bg-slate-700 dark:text-slate-200`}
        >
          {tag}
        </Badge>
      ))}
      {remainingCount > 0 && (
        <span className={`${sizeClasses[size]} text-muted-foreground`}>
          +{remainingCount}
        </span>
      )}
    </div>
  );
}

```

### index.ts

**Path:** `frontend/src/components/atoms/index.ts`

```typescript
export { DateDisplay, ReadTime } from './DateDisplay';
export { TagList } from './TagList';

```

---

## frontend/src/components/common

### LanguageToggle.tsx

**Path:** `frontend/src/components/common/LanguageToggle.tsx`

```tsx
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { useLanguage } from '@/contexts/LanguageContext';
import type { SupportedLanguage } from '@/types/blog';
import { Globe } from 'lucide-react';

const LABELS: Record<SupportedLanguage, string> = {
  ko: '한국어',
  en: 'EN',
};

export function LanguageToggle() {
  const { language, setLanguage } = useLanguage();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          type='button'
          variant='ghost'
          size='icon'
          aria-label={`언어 변경: 현재 ${LABELS[language]}`}
          className='h-9 w-9'
        >
          <Globe className='h-4 w-4' />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align='end' className='w-32 text-sm'>
        {(Object.keys(LABELS) as SupportedLanguage[]).map(lang => (
          <DropdownMenuItem
            key={lang}
            onSelect={() => setLanguage(lang)}
            aria-checked={language === lang}
            className='flex items-center justify-between'
          >
            <span>{LABELS[lang]}</span>
            {language === lang && <span className='text-primary text-xs'>•</span>}
          </DropdownMenuItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### OptimizedImage.tsx

**Path:** `frontend/src/components/common/OptimizedImage.tsx`

```tsx
import { useState, useEffect, useRef } from 'react';
import { cn } from '@/lib/utils';

interface OptimizedImageProps {
  src: string;
  alt: string;
  className?: string;
  width?: number;
  height?: number;
  placeholder?: string;
  loading?: 'lazy' | 'eager';
  onLoad?: () => void;
  onError?: () => void;
}

export const OptimizedImage = ({
  src,
  alt,
  className,
  width,
  height,
  placeholder = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIwIiBoZWlnaHQ9IjE4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PC9zdmc+',
  loading = 'lazy',
  onLoad,
  onError,
}: OptimizedImageProps) => {
  const [imageSrc, setImageSrc] = useState(placeholder);
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  // Intersection Observer for lazy loading
  useEffect(() => {
    if (loading === 'eager') {
      setIsInView(true);
      return;
    }

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      {
        rootMargin: '50px',
        threshold: 0.01,
      }
    );

    const currentImgRef = imgRef.current;
    if (currentImgRef) {
      observer.observe(currentImgRef);
    }

    return () => {
      if (currentImgRef) {
        observer.unobserve(currentImgRef);
      }
    };
  }, [loading]);

  // Load the actual image when in view
  useEffect(() => {
    if (!isInView) return;

    const img = new Image();

    img.onload = () => {
      setImageSrc(src);
      setIsLoading(false);
      setHasError(false);
      onLoad?.();
    };

    img.onerror = () => {
      setHasError(true);
      setIsLoading(false);
      onError?.();
    };

    img.src = src;

    return () => {
      img.onload = null;
      img.onerror = null;
    };
  }, [isInView, src, onLoad, onError]);

  if (hasError) {
    return (
      <div
        className={cn(
          'flex items-center justify-center bg-gray-200 dark:bg-gray-800 text-gray-500 dark:text-gray-400 text-sm rounded',
          className
        )}
        style={{ width, height }}
        role='img'
        aria-label={`이미지를 불러올 수 없습니다: ${alt}`}
      >
        <svg
          className='w-8 h-8'
          fill='none'
          stroke='currentColor'
          viewBox='0 0 24 24'
          aria-hidden='true'
        >
          <path
            strokeLinecap='round'
            strokeLinejoin='round'
            strokeWidth={2}
            d='M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z'
          />
        </svg>
      </div>
    );
  }

  return (
    <div className='relative overflow-hidden rounded'>
      <img
        ref={imgRef}
        src={imageSrc}
        alt={alt}
        width={width}
        height={height}
        className={cn(
          'transition-all duration-500 ease-in-out',
          isLoading ? 'opacity-0 scale-105 blur-sm' : 'opacity-100 scale-100 blur-0',
          className
        )}
        loading={loading}
        decoding='async'
      />

      {isLoading && (
        <div className='absolute inset-0 flex items-center justify-center bg-gray-50 dark:bg-gray-900'>
          <div className='relative'>
            <div className='animate-pulse bg-gray-200 dark:bg-gray-700 rounded-full w-12 h-12'></div>
            <div className='absolute inset-0 flex items-center justify-center'>
              <div className='animate-spin rounded-full h-6 w-6 border-2 border-primary border-t-transparent'></div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

```

### ReadingProgress.tsx

**Path:** `frontend/src/components/common/ReadingProgress.tsx`

```tsx
import { useEffect, useState } from 'react';
import { Progress } from '@/components/ui/progress';

export const ReadingProgress = () => {
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    const updateProgress = () => {
      const scrollTop = window.scrollY;
      const docHeight =
        document.documentElement.scrollHeight - window.innerHeight;
      const scrollPercent = (scrollTop / docHeight) * 100;
      setProgress(Math.min(100, Math.max(0, scrollPercent)));
    };

    window.addEventListener('scroll', updateProgress);
    updateProgress();

    return () => window.removeEventListener('scroll', updateProgress);
  }, []);

  return (
    <div className='fixed top-0 left-0 right-0 z-50 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b'>
      <Progress value={progress} className='h-1 rounded-none' />
    </div>
  );
};

```

### ScrollToTop.tsx

**Path:** `frontend/src/components/common/ScrollToTop.tsx`

```tsx
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { ArrowUp } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useIsMobile } from '@/hooks/use-mobile';
import { useTheme } from '@/contexts/ThemeContext';

export const ScrollToTop = () => {
  const [isVisible, setIsVisible] = useState(false);
  const isMobile = useIsMobile();
  const { isTerminal } = useTheme();

  // Hide on mobile terminal - shell bar has its own scroll-to-top button
  const shouldHide = isMobile && isTerminal;

  useEffect(() => {
    const toggleVisibility = () => {
      if (window.scrollY > 300) {
        setIsVisible(true);
      } else {
        setIsVisible(false);
      }
    };

    window.addEventListener('scroll', toggleVisibility);
    return () => window.removeEventListener('scroll', toggleVisibility);
  }, []);

  const scrollToTop = () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth',
    });
  };

  // Don't render on mobile terminal (shell bar has integrated scroll-to-top)
  if (shouldHide) {
    return null;
  }

  return (
    <Button
      onClick={scrollToTop}
      size='icon'
      variant='outline'
      className={cn(
        'fixed bottom-8 right-8 z-50 rounded-full shadow-lg transition-all duration-300',
        isVisible ? 'opacity-100 scale-100' : 'opacity-0 scale-0',
        // Muted styling to differentiate from AI feature buttons
        isTerminal
          ? 'border-[hsl(var(--terminal-inactive-border))] bg-background/80 text-[hsl(var(--terminal-glow)/0.6)] hover:text-[hsl(var(--terminal-glow))] hover:bg-background'
          : 'border-border/60 bg-muted/70 text-muted-foreground hover:bg-muted hover:text-foreground'
      )}
    >
      <ArrowUp className='h-4 w-4' />
    </Button>
  );
};

```

### SkipLink.tsx

**Path:** `frontend/src/components/common/SkipLink.tsx`

```tsx
import { cn } from '@/lib/utils';

interface SkipLinkProps {
  href: string;
  children: React.ReactNode;
  className?: string;
}

export const SkipLink = ({ href, children, className }: SkipLinkProps) => {
  return (
    <a
      href={href}
      className={cn(
        'skip-link',
        'absolute -top-10 left-6 z-[100] bg-background px-4 py-2 text-foreground',
        'focus:top-6 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
        'transition-all duration-200 font-medium rounded-md shadow-lg',
        className
      )}
    >
      {children}
    </a>
  );
};

```

### ThemeToggle.tsx

**Path:** `frontend/src/components/common/ThemeToggle.tsx`

```tsx
import { Moon, Sun, Monitor, Terminal } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { useTheme } from '@/contexts/ThemeContext';
import { cn } from '@/lib/utils';

interface ThemeToggleProps {
  className?: string;
}

export function ThemeToggle({ className }: ThemeToggleProps) {
  const { theme, setTheme, isTerminal } = useTheme();

  const handleThemeChange = (
    newTheme: 'light' | 'dark' | 'system' | 'terminal'
  ) => {
    setTheme(newTheme);
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant='ghost'
          size='icon'
          className={cn(
            'h-9 w-9',
            isTerminal && 'text-primary hover:text-primary hover:bg-primary/10',
            className
          )}
          aria-label='Toggle theme'
        >
          {/* Light mode icon */}
          <Sun
            className={cn(
              'h-[1.2rem] w-[1.2rem] transition-all',
              theme === 'terminal'
                ? 'rotate-90 scale-0'
                : 'rotate-0 scale-100 dark:-rotate-90 dark:scale-0'
            )}
          />
          {/* Dark mode icon */}
          <Moon
            className={cn(
              'absolute h-[1.2rem] w-[1.2rem] transition-all',
              theme === 'terminal'
                ? 'rotate-90 scale-0'
                : 'rotate-90 scale-0 dark:rotate-0 dark:scale-100'
            )}
          />
          {/* Terminal mode icon */}
          <Terminal
            className={cn(
              'absolute h-[1.2rem] w-[1.2rem] transition-all',
              theme === 'terminal'
                ? 'rotate-0 scale-100'
                : 'rotate-90 scale-0'
            )}
          />
          <span className='sr-only'>Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent 
        align='end'
        className={cn(
          isTerminal && 'border-primary/40 bg-background/95 backdrop-blur'
        )}
      >
        <DropdownMenuItem
          onClick={() => handleThemeChange('light')}
          className={cn(
            theme === 'light' && 'bg-accent',
            isTerminal && 'font-mono hover:bg-primary/10 hover:text-primary focus:bg-primary/10 focus:text-primary'
          )}
        >
          <Sun className='mr-2 h-4 w-4' />
          <span>Light</span>
          {theme === 'light' && <span className={cn('ml-auto', isTerminal && 'text-primary')}>✓</span>}
        </DropdownMenuItem>
        <DropdownMenuItem
          onClick={() => handleThemeChange('dark')}
          className={cn(
            theme === 'dark' && 'bg-accent',
            isTerminal && 'font-mono hover:bg-primary/10 hover:text-primary focus:bg-primary/10 focus:text-primary'
          )}
        >
          <Moon className='mr-2 h-4 w-4' />
          <span>Dark</span>
          {theme === 'dark' && <span className={cn('ml-auto', isTerminal && 'text-primary')}>✓</span>}
        </DropdownMenuItem>
        <DropdownMenuItem
          onClick={() => handleThemeChange('system')}
          className={cn(
            theme === 'system' && 'bg-accent',
            isTerminal && 'font-mono hover:bg-primary/10 hover:text-primary focus:bg-primary/10 focus:text-primary'
          )}
        >
          <Monitor className='mr-2 h-4 w-4' />
          <span>System</span>
          {theme === 'system' && <span className={cn('ml-auto', isTerminal && 'text-primary')}>✓</span>}
        </DropdownMenuItem>
        <DropdownMenuItem
          onClick={() => handleThemeChange('terminal')}
          className={cn(
            theme === 'terminal' && 'bg-primary/15',
            'font-mono',
            isTerminal && 'hover:bg-primary/10 hover:text-primary focus:bg-primary/10 focus:text-primary'
          )}
        >
          <Terminal
            className={cn(
              'mr-2 h-4 w-4',
              theme === 'terminal' && 'text-primary'
            )}
          />
          <span className={cn(theme === 'terminal' && 'text-primary')}>
            Terminal
          </span>
          {theme === 'terminal' && (
            <span className='ml-auto text-primary'>✓</span>
          )}
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

export default ThemeToggle;

```

### index.ts

**Path:** `frontend/src/components/common/index.ts`

```typescript
export { default as ThemeToggle } from './ThemeToggle';
export { ScrollToTop } from './ScrollToTop';
export { ReadingProgress } from './ReadingProgress';
export { OptimizedImage } from './OptimizedImage';
export { SkipLink } from './SkipLink';
export { LanguageToggle } from './LanguageToggle';

```

---

## frontend/src/components/features/admin

### ConfigManager.tsx

**Path:** `frontend/src/components/features/admin/ConfigManager.tsx`

```tsx
import { useState, useEffect, useCallback } from 'react';
import { useQuery, useMutation } from '@tanstack/react-query';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/components/ui/use-toast';
import { Eye, EyeOff, Download, Save, RefreshCw, Copy, CheckCircle2, AlertCircle } from 'lucide-react';

interface ConfigVariable {
  key: string;
  type: 'text' | 'number' | 'boolean' | 'select' | 'password' | 'url' | 'textarea';
  options?: string[];
  default?: string;
  isSecret?: boolean;
  description?: string;
  delimiter?: string;
}

interface ConfigCategory {
  id: string;
  name: string;
  description: string;
  variables: ConfigVariable[];
}

interface ConfigValue {
  value: string;
  isSecret: boolean;
  isSet: boolean;
  default: string;
}

const API_BASE = import.meta.env.VITE_API_BASE_URL || '';

async function fetchWithAuth(url: string, options: RequestInit = {}) {
  const token = localStorage.getItem('adminToken') || '';
  return fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
      ...options.headers,
    },
  });
}

export function ConfigManager() {
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState('app');
  const [editedValues, setEditedValues] = useState<Record<string, string>>({});
  const [visibleSecrets, setVisibleSecrets] = useState<Set<string>>(new Set());
  const [hasChanges, setHasChanges] = useState(false);

  const { data: categoriesData, isLoading: categoriesLoading } = useQuery({
    queryKey: ['config-categories'],
    queryFn: async () => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/config/categories`);
      if (!res.ok) throw new Error('Failed to fetch categories');
      const json = await res.json();
      return json.data.categories as ConfigCategory[];
    },
  });

  const { data: configData, isLoading: configLoading, refetch: refetchConfig } = useQuery({
    queryKey: ['config-current'],
    queryFn: async () => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/config/current`);
      if (!res.ok) throw new Error('Failed to fetch config');
      const json = await res.json();
      return json.data.config as Record<string, ConfigValue>;
    },
  });

  const exportMutation = useMutation({
    mutationFn: async (format: string) => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/config/export`, {
        method: 'POST',
        body: JSON.stringify({ format, includeSecrets: false }),
      });
      if (!res.ok) throw new Error('Export failed');
      return res.json();
    },
    onSuccess: (data, format) => {
      const content = data.data.content;
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = format === 'env' ? '.env.example' : format === 'docker-compose' ? 'docker-env.yml' : 'wrangler-vars.toml';
      a.click();
      URL.revokeObjectURL(url);
      toast({ title: 'Export complete', description: `Downloaded ${format} file` });
    },
    onError: () => {
      toast({ title: 'Export failed', variant: 'destructive' });
    },
  });

  const saveMutation = useMutation({
    mutationFn: async (variables: Record<string, string>) => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/config/save-env`, {
        method: 'POST',
        body: JSON.stringify({ variables, target: 'backend' }),
      });
      if (!res.ok) throw new Error('Save failed');
      return res.json();
    },
    onSuccess: () => {
      toast({ title: 'Saved', description: 'Environment file updated. Restart server to apply changes.' });
      setHasChanges(false);
      refetchConfig();
    },
    onError: () => {
      toast({ title: 'Save failed', variant: 'destructive' });
    },
  });

  const updateValue = useCallback((key: string, value: string) => {
    setEditedValues((prev) => ({ ...prev, [key]: value }));
    setHasChanges(true);
  }, []);

  const toggleSecretVisibility = useCallback((key: string) => {
    setVisibleSecrets((prev) => {
      const next = new Set(prev);
      if (next.has(key)) {
        next.delete(key);
      } else {
        next.add(key);
      }
      return next;
    });
  }, []);

  const copyToClipboard = useCallback(async (text: string) => {
    await navigator.clipboard.writeText(text);
    toast({ title: 'Copied to clipboard' });
  }, [toast]);

  const getValue = useCallback(
    (key: string): string => {
      if (key in editedValues) return editedValues[key];
      return configData?.[key]?.value || '';
    },
    [editedValues, configData]
  );

  const handleSave = () => {
    saveMutation.mutate(editedValues);
  };

  const renderField = (variable: ConfigVariable) => {
    const value = getValue(variable.key);
    const configValue = configData?.[variable.key];
    const isSecret = variable.isSecret;
    const isVisible = visibleSecrets.has(variable.key);

    switch (variable.type) {
      case 'select':
        return (
          <Select value={value} onValueChange={(v) => updateValue(variable.key, v)}>
            <SelectTrigger className="w-full">
              <SelectValue placeholder={variable.default || 'Select...'} />
            </SelectTrigger>
            <SelectContent>
              {variable.options?.map((opt) => (
                <SelectItem key={opt} value={opt}>
                  {opt}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );

      case 'password':
        return (
          <div className="flex gap-2">
            <Input
              type={isVisible ? 'text' : 'password'}
              value={value}
              onChange={(e) => updateValue(variable.key, e.target.value)}
              placeholder={configValue?.isSet ? '••••••••' : 'Not set'}
              className="flex-1"
            />
            <Button variant="outline" size="icon" onClick={() => toggleSecretVisibility(variable.key)}>
              {isVisible ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
            </Button>
          </div>
        );

      case 'textarea':
        return (
          <Textarea
            value={value}
            onChange={(e) => updateValue(variable.key, e.target.value)}
            placeholder={variable.default || ''}
            rows={3}
          />
        );

      case 'url':
        return (
          <div className="flex gap-2">
            <Input
              type="url"
              value={value}
              onChange={(e) => updateValue(variable.key, e.target.value)}
              placeholder={variable.default || 'https://...'}
              className="flex-1"
            />
            {value && (
              <Button variant="outline" size="icon" onClick={() => copyToClipboard(value)}>
                <Copy className="h-4 w-4" />
              </Button>
            )}
          </div>
        );

      case 'number':
        return (
          <Input
            type="number"
            value={value}
            onChange={(e) => updateValue(variable.key, e.target.value)}
            placeholder={variable.default || '0'}
          />
        );

      default:
        return (
          <Input
            type="text"
            value={value}
            onChange={(e) => updateValue(variable.key, e.target.value)}
            placeholder={variable.default || ''}
          />
        );
    }
  };

  if (categoriesLoading || configLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <RefreshCw className="h-6 w-6 animate-spin" />
        <span className="ml-2">Loading configuration...</span>
      </div>
    );
  }

  const categories = categoriesData || [];

  return (
    <div className="max-w-4xl mx-auto p-4 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold">환경변수 설정</h1>
          <p className="text-muted-foreground">서버 환경 설정을 관리합니다</p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={() => exportMutation.mutate('env')}>
            <Download className="h-4 w-4 mr-2" />
            Export .env
          </Button>
          <Button variant="outline" onClick={() => exportMutation.mutate('docker-compose')}>
            <Download className="h-4 w-4 mr-2" />
            Docker
          </Button>
          <Button onClick={handleSave} disabled={!hasChanges || saveMutation.isPending}>
            <Save className="h-4 w-4 mr-2" />
            {saveMutation.isPending ? 'Saving...' : 'Save'}
          </Button>
        </div>
      </div>

      {hasChanges && (
        <div className="flex items-center gap-2 p-3 bg-yellow-500/10 border border-yellow-500/30 rounded-lg">
          <AlertCircle className="h-4 w-4 text-yellow-500" />
          <span className="text-sm">You have unsaved changes</span>
        </div>
      )}

      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <TabsList className="flex flex-wrap gap-1">
          {categories.map((cat) => (
            <TabsTrigger key={cat.id} value={cat.id}>
              {cat.name}
            </TabsTrigger>
          ))}
        </TabsList>

        {categories.map((category) => (
          <TabsContent key={category.id} value={category.id}>
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  {category.name}
                  <Badge variant="outline" className="ml-2">
                    {category.variables.length} variables
                  </Badge>
                </CardTitle>
                <CardDescription>{category.description}</CardDescription>
              </CardHeader>
              <CardContent className="space-y-6">
                {category.variables.map((variable) => {
                  const configValue = configData?.[variable.key];
                  return (
                    <div key={variable.key} className="space-y-2">
                      <div className="flex items-center gap-2">
                        <Label htmlFor={variable.key} className="font-mono text-sm">
                          {variable.key}
                        </Label>
                        {variable.isSecret && (
                          <Badge variant="secondary" className="text-xs">
                            Secret
                          </Badge>
                        )}
                        {configValue?.isSet && (
                          <CheckCircle2 className="h-3 w-3 text-green-500" />
                        )}
                      </div>
                      {variable.description && (
                        <p className="text-xs text-muted-foreground">{variable.description}</p>
                      )}
                      {renderField(variable)}
                      {variable.default && !variable.isSecret && (
                        <p className="text-xs text-muted-foreground">
                          Default: <code className="bg-muted px-1 rounded">{variable.default}</code>
                        </p>
                      )}
                    </div>
                  );
                })}
              </CardContent>
            </Card>
          </TabsContent>
        ))}
      </Tabs>
    </div>
  );
}

export default ConfigManager;

```

### WorkersManager.tsx

**Path:** `frontend/src/components/features/admin/WorkersManager.tsx`

```tsx
import { useState, useCallback } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@/components/ui/accordion';
import { useToast } from '@/components/ui/use-toast';
import {
  Cloud,
  Database,
  HardDrive,
  Key,
  Rocket,
  RefreshCw,
  Settings,
  Terminal,
  CheckCircle2,
  AlertCircle,
  Copy,
  Eye,
  EyeOff,
} from 'lucide-react';

interface WorkerConfig {
  id: string;
  name: string;
  description: string;
  path: string;
  wranglerPath: string;
  hasProduction: boolean;
  exists: boolean;
  config: {
    name: string;
    main: string;
    compatibility_date: string;
    account_id: string;
    vars: Record<string, string>;
    production: {
      name: string;
      vars: Record<string, string>;
    };
    d1_databases: Array<{ binding: string; database_name: string; database_id: string }>;
    r2_buckets: Array<{ binding: string; bucket_name: string }>;
    kv_namespaces: Array<{ binding: string; id: string }>;
  } | null;
}

interface SecretInfo {
  key: string;
  description: string;
  workers: string[];
}

const API_BASE = import.meta.env.VITE_API_BASE_URL || '';

async function fetchWithAuth(url: string, options: RequestInit = {}) {
  const token = localStorage.getItem('adminToken') || '';
  return fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
      ...options.headers,
    },
  });
}

export function WorkersManager() {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [selectedWorker, setSelectedWorker] = useState<string | null>(null);
  const [deployEnv, setDeployEnv] = useState<'development' | 'production'>('production');
  const [secretInputs, setSecretInputs] = useState<Record<string, string>>({});
  const [visibleSecrets, setVisibleSecrets] = useState<Set<string>>(new Set());

  const { data: workersData, isLoading: workersLoading } = useQuery({
    queryKey: ['workers-list'],
    queryFn: async () => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/workers/list`);
      if (!res.ok) throw new Error('Failed to fetch workers');
      const json = await res.json();
      return json.data.workers as WorkerConfig[];
    },
  });

  const { data: secretsData } = useQuery({
    queryKey: ['workers-secrets'],
    queryFn: async () => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/workers/secrets`);
      if (!res.ok) throw new Error('Failed to fetch secrets');
      const json = await res.json();
      return json.data.secrets as SecretInfo[];
    },
  });

  const { data: d1Data } = useQuery({
    queryKey: ['workers-d1'],
    queryFn: async () => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/workers/d1/databases`);
      const json = await res.json();
      return json.data.databases || [];
    },
  });

  const { data: kvData } = useQuery({
    queryKey: ['workers-kv'],
    queryFn: async () => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/workers/kv/namespaces`);
      const json = await res.json();
      return json.data.namespaces || [];
    },
  });

  const { data: r2Data } = useQuery({
    queryKey: ['workers-r2'],
    queryFn: async () => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/workers/r2/buckets`);
      const json = await res.json();
      return json.data.buckets || [];
    },
  });

  const deployMutation = useMutation({
    mutationFn: async ({ workerId, env, dryRun }: { workerId: string; env: string; dryRun: boolean }) => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/workers/${workerId}/deploy`, {
        method: 'POST',
        body: JSON.stringify({ env, dryRun }),
      });
      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || 'Deploy failed');
      }
      return res.json();
    },
    onSuccess: (data) => {
      toast({
        title: 'Deployment',
        description: data.data.message,
      });
    },
    onError: (err: Error) => {
      toast({
        title: 'Deployment failed',
        description: err.message,
        variant: 'destructive',
      });
    },
  });

  const secretMutation = useMutation({
    mutationFn: async ({ workerId, key, value, env }: { workerId: string; key: string; value: string; env: string }) => {
      const res = await fetchWithAuth(`${API_BASE}/api/v1/admin/workers/${workerId}/secret`, {
        method: 'POST',
        body: JSON.stringify({ key, value, env }),
      });
      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || 'Failed to set secret');
      }
      return res.json();
    },
    onSuccess: (data) => {
      toast({ title: 'Secret Updated', description: data.data.message });
      setSecretInputs({});
    },
    onError: (err: Error) => {
      toast({ title: 'Failed to set secret', description: err.message, variant: 'destructive' });
    },
  });

  const copyToClipboard = useCallback(
    async (text: string) => {
      await navigator.clipboard.writeText(text);
      toast({ title: 'Copied to clipboard' });
    },
    [toast]
  );

  const toggleSecretVisibility = useCallback((key: string) => {
    setVisibleSecrets((prev) => {
      const next = new Set(prev);
      if (next.has(key)) next.delete(key);
      else next.add(key);
      return next;
    });
  }, []);

  if (workersLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <RefreshCw className="h-6 w-6 animate-spin" />
        <span className="ml-2">Loading workers...</span>
      </div>
    );
  }

  const workers = workersData || [];
  const secrets = secretsData || [];

  return (
    <div className="space-y-6">
      <Tabs defaultValue="workers">
        <TabsList>
          <TabsTrigger value="workers">
            <Cloud className="h-4 w-4 mr-2" />
            Workers
          </TabsTrigger>
          <TabsTrigger value="secrets">
            <Key className="h-4 w-4 mr-2" />
            Secrets
          </TabsTrigger>
          <TabsTrigger value="resources">
            <Database className="h-4 w-4 mr-2" />
            Resources
          </TabsTrigger>
        </TabsList>

        <TabsContent value="workers" className="space-y-4">
          <div className="grid gap-4">
            {workers.map((worker) => (
              <Card key={worker.id} className={!worker.exists ? 'opacity-60' : ''}>
                <CardHeader className="pb-3">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <Cloud className="h-5 w-5 text-primary" />
                      <div>
                        <CardTitle className="text-lg">{worker.name}</CardTitle>
                        <CardDescription>{worker.description}</CardDescription>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      {worker.exists ? (
                        <Badge variant="outline" className="text-green-600 border-green-600">
                          <CheckCircle2 className="h-3 w-3 mr-1" />
                          Configured
                        </Badge>
                      ) : (
                        <Badge variant="outline" className="text-yellow-600 border-yellow-600">
                          <AlertCircle className="h-3 w-3 mr-1" />
                          Missing
                        </Badge>
                      )}
                      {worker.hasProduction && (
                        <Badge variant="secondary">Production</Badge>
                      )}
                    </div>
                  </div>
                </CardHeader>
                {worker.exists && worker.config && (
                  <CardContent className="space-y-4">
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                      <div>
                        <span className="text-muted-foreground">Name:</span>
                        <code className="ml-2 bg-muted px-1 rounded">{worker.config.name}</code>
                      </div>
                      <div>
                        <span className="text-muted-foreground">Entry:</span>
                        <code className="ml-2 bg-muted px-1 rounded">{worker.config.main}</code>
                      </div>
                      <div>
                        <span className="text-muted-foreground">Compat:</span>
                        <code className="ml-2 bg-muted px-1 rounded">{worker.config.compatibility_date}</code>
                      </div>
                      <div className="flex items-center gap-1">
                        <span className="text-muted-foreground">Account:</span>
                        <code className="bg-muted px-1 rounded text-xs truncate max-w-[100px]">
                          {worker.config.account_id.slice(0, 8)}...
                        </code>
                        <Button
                          variant="ghost"
                          size="icon"
                          className="h-6 w-6"
                          onClick={() => copyToClipboard(worker.config!.account_id)}
                        >
                          <Copy className="h-3 w-3" />
                        </Button>
                      </div>
                    </div>

                    <Accordion type="single" collapsible>
                      <AccordionItem value="vars">
                        <AccordionTrigger className="text-sm">
                          <Settings className="h-4 w-4 mr-2" />
                          Environment Variables
                        </AccordionTrigger>
                        <AccordionContent>
                          <div className="space-y-4">
                            <div>
                              <h4 className="font-medium text-sm mb-2">Development</h4>
                              <div className="grid gap-2">
                                {Object.entries(worker.config.vars).map(([key, value]) => (
                                  <div key={key} className="flex items-center gap-2 text-sm">
                                    <code className="bg-muted px-2 py-1 rounded min-w-[180px]">{key}</code>
                                    <code className="bg-muted/50 px-2 py-1 rounded flex-1 truncate">{value}</code>
                                  </div>
                                ))}
                                {Object.keys(worker.config.vars).length === 0 && (
                                  <p className="text-muted-foreground text-sm">No variables configured</p>
                                )}
                              </div>
                            </div>
                            {worker.hasProduction && Object.keys(worker.config.production.vars).length > 0 && (
                              <div>
                                <h4 className="font-medium text-sm mb-2">Production</h4>
                                <div className="grid gap-2">
                                  {Object.entries(worker.config.production.vars).map(([key, value]) => (
                                    <div key={key} className="flex items-center gap-2 text-sm">
                                      <code className="bg-muted px-2 py-1 rounded min-w-[180px]">{key}</code>
                                      <code className="bg-muted/50 px-2 py-1 rounded flex-1 truncate">{value}</code>
                                    </div>
                                  ))}
                                </div>
                              </div>
                            )}
                          </div>
                        </AccordionContent>
                      </AccordionItem>

                      <AccordionItem value="bindings">
                        <AccordionTrigger className="text-sm">
                          <Database className="h-4 w-4 mr-2" />
                          Resource Bindings
                        </AccordionTrigger>
                        <AccordionContent>
                          <div className="space-y-3">
                            {worker.config.d1_databases.length > 0 && (
                              <div>
                                <h4 className="text-sm font-medium mb-1">D1 Databases</h4>
                                {worker.config.d1_databases.map((db, i) => (
                                  <div key={i} className="text-sm flex items-center gap-2">
                                    <Badge variant="outline">D1</Badge>
                                    <code>{db.binding}</code>
                                    <span className="text-muted-foreground">→</span>
                                    <code>{db.database_name}</code>
                                  </div>
                                ))}
                              </div>
                            )}
                            {worker.config.r2_buckets.length > 0 && (
                              <div>
                                <h4 className="text-sm font-medium mb-1">R2 Buckets</h4>
                                {worker.config.r2_buckets.map((bucket, i) => (
                                  <div key={i} className="text-sm flex items-center gap-2">
                                    <Badge variant="outline">R2</Badge>
                                    <code>{bucket.binding}</code>
                                    <span className="text-muted-foreground">→</span>
                                    <code>{bucket.bucket_name}</code>
                                  </div>
                                ))}
                              </div>
                            )}
                            {worker.config.kv_namespaces.length > 0 && (
                              <div>
                                <h4 className="text-sm font-medium mb-1">KV Namespaces</h4>
                                {worker.config.kv_namespaces.map((kv, i) => (
                                  <div key={i} className="text-sm flex items-center gap-2">
                                    <Badge variant="outline">KV</Badge>
                                    <code>{kv.binding}</code>
                                    <span className="text-muted-foreground">→</span>
                                    <code className="text-xs">{kv.id.slice(0, 16)}...</code>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        </AccordionContent>
                      </AccordionItem>
                    </Accordion>

                    <div className="flex items-center gap-2 pt-2 border-t">
                      <Select
                        value={deployEnv}
                        onValueChange={(v) => setDeployEnv(v as 'development' | 'production')}
                      >
                        <SelectTrigger className="w-[140px]">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="development">Development</SelectItem>
                          {worker.hasProduction && (
                            <SelectItem value="production">Production</SelectItem>
                          )}
                        </SelectContent>
                      </Select>
                      <Button
                        variant="outline"
                        onClick={() =>
                          deployMutation.mutate({ workerId: worker.id, env: deployEnv, dryRun: true })
                        }
                        disabled={deployMutation.isPending}
                      >
                        <Terminal className="h-4 w-4 mr-2" />
                        Dry Run
                      </Button>
                      <Button
                        onClick={() =>
                          deployMutation.mutate({ workerId: worker.id, env: deployEnv, dryRun: false })
                        }
                        disabled={deployMutation.isPending}
                      >
                        <Rocket className="h-4 w-4 mr-2" />
                        {deployMutation.isPending ? 'Deploying...' : 'Deploy'}
                      </Button>
                    </div>
                  </CardContent>
                )}
              </Card>
            ))}
          </div>
        </TabsContent>

        <TabsContent value="secrets" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Key className="h-5 w-5" />
                Worker Secrets
              </CardTitle>
              <CardDescription>
                Secrets are encrypted and stored securely by Cloudflare. Set secrets for each worker.
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              {secrets.map((secret) => (
                <div key={secret.key} className="border rounded-lg p-4 space-y-3">
                  <div className="flex items-center justify-between">
                    <div>
                      <code className="font-mono font-bold">{secret.key}</code>
                      <p className="text-sm text-muted-foreground">{secret.description}</p>
                    </div>
                    <div className="flex gap-1">
                      {secret.workers.map((w) => (
                        <Badge key={w} variant="secondary" className="text-xs">
                          {w}
                        </Badge>
                      ))}
                    </div>
                  </div>
                  <div className="flex gap-2">
                    <div className="flex-1 flex gap-2">
                      <Input
                        type={visibleSecrets.has(secret.key) ? 'text' : 'password'}
                        placeholder="Enter new secret value..."
                        value={secretInputs[secret.key] || ''}
                        onChange={(e) =>
                          setSecretInputs((prev) => ({ ...prev, [secret.key]: e.target.value }))
                        }
                      />
                      <Button
                        variant="outline"
                        size="icon"
                        onClick={() => toggleSecretVisibility(secret.key)}
                      >
                        {visibleSecrets.has(secret.key) ? (
                          <EyeOff className="h-4 w-4" />
                        ) : (
                          <Eye className="h-4 w-4" />
                        )}
                      </Button>
                    </div>
                    <Select defaultValue={secret.workers[0]}>
                      <SelectTrigger className="w-[160px]">
                        <SelectValue placeholder="Select worker" />
                      </SelectTrigger>
                      <SelectContent>
                        {secret.workers.map((w) => (
                          <SelectItem key={w} value={w}>
                            {w}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <Button
                      onClick={() => {
                        const value = secretInputs[secret.key];
                        if (value) {
                          secretMutation.mutate({
                            workerId: secret.workers[0],
                            key: secret.key,
                            value,
                            env: 'production',
                          });
                        }
                      }}
                      disabled={!secretInputs[secret.key] || secretMutation.isPending}
                    >
                      Set Secret
                    </Button>
                  </div>
                </div>
              ))}
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="resources" className="space-y-4">
          <div className="grid gap-4 md:grid-cols-3">
            <Card>
              <CardHeader className="pb-3">
                <CardTitle className="flex items-center gap-2 text-base">
                  <Database className="h-4 w-4" />
                  D1 Databases
                </CardTitle>
              </CardHeader>
              <CardContent>
                {Array.isArray(d1Data) && d1Data.length > 0 ? (
                  <div className="space-y-2">
                    {d1Data.map((db: any) => (
                      <div key={db.uuid} className="text-sm border rounded p-2">
                        <div className="font-medium">{db.name}</div>
                        <code className="text-xs text-muted-foreground">{db.uuid}</code>
                      </div>
                    ))}
                  </div>
                ) : (
                  <p className="text-sm text-muted-foreground">No databases found or wrangler not authenticated</p>
                )}
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-3">
                <CardTitle className="flex items-center gap-2 text-base">
                  <HardDrive className="h-4 w-4" />
                  KV Namespaces
                </CardTitle>
              </CardHeader>
              <CardContent>
                {Array.isArray(kvData) && kvData.length > 0 ? (
                  <div className="space-y-2">
                    {kvData.map((kv: any) => (
                      <div key={kv.id} className="text-sm border rounded p-2">
                        <div className="font-medium">{kv.title}</div>
                        <code className="text-xs text-muted-foreground">{kv.id}</code>
                      </div>
                    ))}
                  </div>
                ) : (
                  <p className="text-sm text-muted-foreground">No KV namespaces found</p>
                )}
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-3">
                <CardTitle className="flex items-center gap-2 text-base">
                  <HardDrive className="h-4 w-4" />
                  R2 Buckets
                </CardTitle>
              </CardHeader>
              <CardContent>
                {Array.isArray(r2Data) && r2Data.length > 0 ? (
                  <div className="space-y-2">
                    {r2Data.map((bucket: any) => (
                      <div key={bucket.name} className="text-sm border rounded p-2">
                        <div className="font-medium">{bucket.name}</div>
                        <span className="text-xs text-muted-foreground">
                          Created: {new Date(bucket.creation_date).toLocaleDateString()}
                        </span>
                      </div>
                    ))}
                  </div>
                ) : (
                  <p className="text-sm text-muted-foreground">No R2 buckets found</p>
                )}
              </CardContent>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
}

export default WorkersManager;

```

### index.ts

**Path:** `frontend/src/components/features/admin/index.ts`

```typescript
export { ConfigManager } from './ConfigManager';
export { WorkersManager } from './WorkersManager';

```

---

## frontend/src/components/features/admin/ai

### AIManager.tsx

**Path:** `frontend/src/components/features/admin/ai/AIManager.tsx`

```tsx
/**
 * AI Model Management Dashboard
 */

import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Bot, Cpu, GitBranch, BarChart3 } from 'lucide-react';
import { ProvidersManager } from './ProvidersManager';
import { ModelsManager } from './ModelsManager';
import { RoutesManager } from './RoutesManager';
import { UsageMonitor } from './UsageMonitor';

export function AIManager() {
  return (
    <Tabs defaultValue="models" className="space-y-6">
      <TabsList className="grid w-full max-w-2xl grid-cols-4">
        <TabsTrigger value="models" className="flex items-center gap-2">
          <Bot className="h-4 w-4" />
          Models
        </TabsTrigger>
        <TabsTrigger value="providers" className="flex items-center gap-2">
          <Cpu className="h-4 w-4" />
          Providers
        </TabsTrigger>
        <TabsTrigger value="routes" className="flex items-center gap-2">
          <GitBranch className="h-4 w-4" />
          Routes
        </TabsTrigger>
        <TabsTrigger value="monitoring" className="flex items-center gap-2">
          <BarChart3 className="h-4 w-4" />
          Monitoring
        </TabsTrigger>
      </TabsList>

      <TabsContent value="models">
        <ModelsManager />
      </TabsContent>

      <TabsContent value="providers">
        <ProvidersManager />
      </TabsContent>

      <TabsContent value="routes">
        <RoutesManager />
      </TabsContent>

      <TabsContent value="monitoring">
        <UsageMonitor />
      </TabsContent>
    </Tabs>
  );
}

```

### ModelsManager.tsx

**Path:** `frontend/src/components/features/admin/ai/ModelsManager.tsx`

```tsx
/**
 * AI Models Manager Component
 */

import { useState, useEffect } from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { Badge } from '@/components/ui/badge';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  Plus,
  MoreHorizontal,
  Play,
  Pencil,
  Trash2,
  Eye,
  Zap,
  MessageSquare,
  Loader2,
  CheckCircle,
  XCircle,
  AlertCircle,
} from 'lucide-react';
import { useModels, useProviders } from './hooks';
import type { AIModel, ModelFormData, AIProvider } from './types';

interface ModelFormProps {
  model?: AIModel;
  providers: AIProvider[];
  onSubmit: (data: ModelFormData) => Promise<void>;
  onCancel: () => void;
}

function ModelForm({ model, providers, onSubmit, onCancel }: ModelFormProps) {
  const [formData, setFormData] = useState<ModelFormData>({
    modelName: model?.modelName || '',
    displayName: model?.displayName || '',
    providerId: model?.provider?.id || '',
    litellmModel: model?.litellmModel || '',
    description: model?.description || '',
    contextWindow: model?.contextWindow || undefined,
    maxTokens: model?.maxTokens || undefined,
    inputCostPer1k: model?.cost?.inputPer1k || undefined,
    outputCostPer1k: model?.cost?.outputPer1k || undefined,
    supportsVision: model?.capabilities?.vision || false,
    supportsStreaming: model?.capabilities?.streaming ?? true,
    supportsFunctionCalling: model?.capabilities?.functionCalling || false,
    priority: model?.priority || 0,
  });
  const [submitting, setSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSubmitting(true);
    try {
      await onSubmit(formData);
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="grid grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="modelName">Model Name *</Label>
          <Input
            id="modelName"
            value={formData.modelName}
            onChange={(e) => setFormData({ ...formData, modelName: e.target.value })}
            placeholder="gpt-4o"
            disabled={!!model}
            required
          />
          <p className="text-xs text-muted-foreground">Used in API calls</p>
        </div>
        <div className="space-y-2">
          <Label htmlFor="displayName">Display Name *</Label>
          <Input
            id="displayName"
            value={formData.displayName}
            onChange={(e) => setFormData({ ...formData, displayName: e.target.value })}
            placeholder="GPT-4o"
            required
          />
        </div>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="providerId">Provider *</Label>
          <Select
            value={formData.providerId}
            onValueChange={(v) => setFormData({ ...formData, providerId: v })}
            disabled={!!model}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select provider" />
            </SelectTrigger>
            <SelectContent>
              {providers.map((p) => (
                <SelectItem key={p.id} value={p.id}>
                  {p.displayName}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        <div className="space-y-2">
          <Label htmlFor="litellmModel">LiteLLM Model *</Label>
          <Input
            id="litellmModel"
            value={formData.litellmModel}
            onChange={(e) => setFormData({ ...formData, litellmModel: e.target.value })}
            placeholder="openai/gpt-4o"
            required
          />
          <p className="text-xs text-muted-foreground">Actual model identifier</p>
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="description">Description</Label>
        <Input
          id="description"
          value={formData.description || ''}
          onChange={(e) => setFormData({ ...formData, description: e.target.value })}
          placeholder="Model description"
        />
      </div>

      <div className="grid grid-cols-3 gap-4">
        <div className="space-y-2">
          <Label htmlFor="contextWindow">Context Window</Label>
          <Input
            id="contextWindow"
            type="number"
            value={formData.contextWindow || ''}
            onChange={(e) =>
              setFormData({ ...formData, contextWindow: e.target.value ? parseInt(e.target.value) : undefined })
            }
            placeholder="128000"
          />
        </div>
        <div className="space-y-2">
          <Label htmlFor="maxTokens">Max Tokens</Label>
          <Input
            id="maxTokens"
            type="number"
            value={formData.maxTokens || ''}
            onChange={(e) =>
              setFormData({ ...formData, maxTokens: e.target.value ? parseInt(e.target.value) : undefined })
            }
            placeholder="4096"
          />
        </div>
        <div className="space-y-2">
          <Label htmlFor="priority">Priority</Label>
          <Input
            id="priority"
            type="number"
            value={formData.priority || ''}
            onChange={(e) =>
              setFormData({ ...formData, priority: e.target.value ? parseInt(e.target.value) : 0 })
            }
            placeholder="0"
          />
        </div>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="inputCost">Input Cost ($/1K tokens)</Label>
          <Input
            id="inputCost"
            type="number"
            step="0.0001"
            value={formData.inputCostPer1k || ''}
            onChange={(e) =>
              setFormData({ ...formData, inputCostPer1k: e.target.value ? parseFloat(e.target.value) : undefined })
            }
            placeholder="0.01"
          />
        </div>
        <div className="space-y-2">
          <Label htmlFor="outputCost">Output Cost ($/1K tokens)</Label>
          <Input
            id="outputCost"
            type="number"
            step="0.0001"
            value={formData.outputCostPer1k || ''}
            onChange={(e) =>
              setFormData({ ...formData, outputCostPer1k: e.target.value ? parseFloat(e.target.value) : undefined })
            }
            placeholder="0.03"
          />
        </div>
      </div>

      <div className="flex gap-6 py-2">
        <div className="flex items-center gap-2">
          <Switch
            id="vision"
            checked={formData.supportsVision}
            onCheckedChange={(v) => setFormData({ ...formData, supportsVision: v })}
          />
          <Label htmlFor="vision" className="flex items-center gap-1">
            <Eye className="h-4 w-4" /> Vision
          </Label>
        </div>
        <div className="flex items-center gap-2">
          <Switch
            id="streaming"
            checked={formData.supportsStreaming}
            onCheckedChange={(v) => setFormData({ ...formData, supportsStreaming: v })}
          />
          <Label htmlFor="streaming" className="flex items-center gap-1">
            <Zap className="h-4 w-4" /> Streaming
          </Label>
        </div>
        <div className="flex items-center gap-2">
          <Switch
            id="functions"
            checked={formData.supportsFunctionCalling}
            onCheckedChange={(v) => setFormData({ ...formData, supportsFunctionCalling: v })}
          />
          <Label htmlFor="functions" className="flex items-center gap-1">
            <MessageSquare className="h-4 w-4" /> Functions
          </Label>
        </div>
      </div>

      <DialogFooter>
        <Button type="button" variant="outline" onClick={onCancel}>
          Cancel
        </Button>
        <Button type="submit" disabled={submitting}>
          {submitting && <Loader2 className="h-4 w-4 mr-2 animate-spin" />}
          {model ? 'Update' : 'Create'} Model
        </Button>
      </DialogFooter>
    </form>
  );
}

interface TestResultProps {
  result: {
    success: boolean;
    modelName: string;
    latencyMs?: number;
    response?: string;
    error?: string;
  };
}

function TestResult({ result }: TestResultProps) {
  return (
    <div className="space-y-2">
      <div className="flex items-center gap-2">
        {result.success ? (
          <CheckCircle className="h-5 w-5 text-green-500" />
        ) : (
          <XCircle className="h-5 w-5 text-red-500" />
        )}
        <span className="font-medium">
          {result.success ? 'Test Passed' : 'Test Failed'}
        </span>
        {result.latencyMs && (
          <Badge variant="secondary">{result.latencyMs}ms</Badge>
        )}
      </div>
      {result.response && (
        <div className="p-3 bg-muted rounded-md">
          <p className="text-sm font-mono">{result.response}</p>
        </div>
      )}
      {result.error && (
        <div className="p-3 bg-red-50 dark:bg-red-950 rounded-md">
          <p className="text-sm text-red-600 dark:text-red-400">{result.error}</p>
        </div>
      )}
    </div>
  );
}

export function ModelsManager() {
  const { models, loading, error, fetchModels, createModel, updateModel, deleteModel, testModel } =
    useModels();
  const { providers, fetchProviders } = useProviders();
  const [showForm, setShowForm] = useState(false);
  const [editingModel, setEditingModel] = useState<AIModel | null>(null);
  const [testingModel, setTestingModel] = useState<string | null>(null);
  const [testResult, setTestResult] = useState<TestResultProps['result'] | null>(null);
  const [showTestDialog, setShowTestDialog] = useState(false);
  const [filterProvider, setFilterProvider] = useState<string>('');
  const [filterEnabled, setFilterEnabled] = useState<string>('');
  const [searchQuery, setSearchQuery] = useState('');

  useEffect(() => {
    fetchModels();
    fetchProviders();
  }, [fetchModels, fetchProviders]);

  const handleCreate = async (data: ModelFormData) => {
    const result = await createModel(data);
    if (result.ok) {
      setShowForm(false);
    }
  };

  const handleUpdate = async (data: ModelFormData) => {
    if (!editingModel) return;
    const result = await updateModel(editingModel.id, data);
    if (result.ok) {
      setEditingModel(null);
    }
  };

  const handleToggleEnabled = async (model: AIModel) => {
    await updateModel(model.id, { isEnabled: !model.isEnabled });
  };

  const handleDelete = async (model: AIModel) => {
    if (!confirm(`Delete model "${model.displayName}"?`)) return;
    await deleteModel(model.id);
  };

  const handleTest = async (model: AIModel) => {
    setTestingModel(model.id);
    setTestResult(null);
    setShowTestDialog(true);
    const result = await testModel(model.id);
    setTestingModel(null);
    if (result.ok && result.data) {
      setTestResult(result.data);
    } else {
      setTestResult({
        success: false,
        modelName: model.modelName,
        error: result.error,
      });
    }
  };

  const filteredModels = models.filter((m) => {
    if (filterProvider && m.provider.id !== filterProvider) return false;
    if (filterEnabled === 'true' && !m.isEnabled) return false;
    if (filterEnabled === 'false' && m.isEnabled) return false;
    if (searchQuery) {
      const q = searchQuery.toLowerCase();
      return (
        m.modelName.toLowerCase().includes(q) ||
        m.displayName.toLowerCase().includes(q) ||
        m.provider.displayName.toLowerCase().includes(q)
      );
    }
    return true;
  });

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>AI Models</CardTitle>
            <CardDescription>Manage available AI models and their configurations</CardDescription>
          </div>
          <Button onClick={() => setShowForm(true)}>
            <Plus className="h-4 w-4 mr-2" />
            Add Model
          </Button>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Filters */}
        <div className="flex gap-4 flex-wrap">
          <Input
            placeholder="Search models..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="max-w-xs"
          />
          <Select value={filterProvider} onValueChange={setFilterProvider}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="All Providers" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="">All Providers</SelectItem>
              {providers.map((p) => (
                <SelectItem key={p.id} value={p.id}>
                  {p.displayName}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          <Select value={filterEnabled} onValueChange={setFilterEnabled}>
            <SelectTrigger className="w-[150px]">
              <SelectValue placeholder="All Status" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="">All Status</SelectItem>
              <SelectItem value="true">Enabled Only</SelectItem>
              <SelectItem value="false">Disabled Only</SelectItem>
            </SelectContent>
          </Select>
        </div>

        {error && (
          <div className="p-3 bg-red-50 dark:bg-red-950 text-red-600 dark:text-red-400 rounded-md flex items-center gap-2">
            <AlertCircle className="h-4 w-4" />
            {error}
          </div>
        )}

        {loading ? (
          <div className="flex justify-center py-8">
            <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
          </div>
        ) : (
          <div className="space-y-3">
            {filteredModels.map((model) => (
              <div
                key={model.id}
                className={`p-4 border rounded-lg ${
                  model.isEnabled
                    ? 'border-border'
                    : 'border-dashed border-muted-foreground/30 opacity-60'
                }`}
              >
                <div className="flex items-start justify-between">
                  <div className="space-y-1">
                    <div className="flex items-center gap-2">
                      <span className="font-medium">{model.displayName}</span>
                      <Badge variant="outline" className="font-mono text-xs">
                        {model.modelName}
                      </Badge>
                      <Badge variant="secondary">{model.provider.displayName}</Badge>
                      {!model.isEnabled && <Badge variant="destructive">Disabled</Badge>}
                    </div>
                    <p className="text-sm text-muted-foreground">
                      {model.description || model.litellmModel}
                    </p>
                    <div className="flex items-center gap-4 text-xs text-muted-foreground">
                      {model.contextWindow && <span>Context: {(model.contextWindow / 1000).toFixed(0)}K</span>}
                      {model.cost.inputPer1k !== null && (
                        <span>
                          Cost: ${model.cost.inputPer1k}/${model.cost.outputPer1k} per 1K
                        </span>
                      )}
                      <span className="flex items-center gap-1">
                        {model.capabilities.vision && (
                          <span title="Vision">
                            <Eye className="h-3 w-3" />
                          </span>
                        )}
                        {model.capabilities.streaming && (
                          <span title="Streaming">
                            <Zap className="h-3 w-3" />
                          </span>
                        )}
                        {model.capabilities.functionCalling && (
                          <span title="Function Calling">
                            <MessageSquare className="h-3 w-3" />
                          </span>
                        )}
                      </span>
                      <span>Priority: {model.priority}</span>
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => handleTest(model)}
                      disabled={testingModel === model.id}
                    >
                      {testingModel === model.id ? (
                        <Loader2 className="h-4 w-4 animate-spin" />
                      ) : (
                        <Play className="h-4 w-4" />
                      )}
                      <span className="ml-1">Test</span>
                    </Button>
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon">
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => setEditingModel(model)}>
                          <Pencil className="h-4 w-4 mr-2" />
                          Edit
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => handleToggleEnabled(model)}>
                          {model.isEnabled ? 'Disable' : 'Enable'}
                        </DropdownMenuItem>
                        <DropdownMenuSeparator />
                        <DropdownMenuItem
                          onClick={() => handleDelete(model)}
                          className="text-red-600"
                        >
                          <Trash2 className="h-4 w-4 mr-2" />
                          Delete
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </div>
                </div>
              </div>
            ))}
            {filteredModels.length === 0 && (
              <p className="text-center text-muted-foreground py-8">
                No models found. Add your first model to get started.
              </p>
            )}
          </div>
        )}
      </CardContent>

      {/* Create Dialog */}
      <Dialog open={showForm} onOpenChange={setShowForm}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Add New Model</DialogTitle>
            <DialogDescription>Configure a new AI model for use in the system</DialogDescription>
          </DialogHeader>
          <ModelForm
            providers={providers}
            onSubmit={handleCreate}
            onCancel={() => setShowForm(false)}
          />
        </DialogContent>
      </Dialog>

      {/* Edit Dialog */}
      <Dialog open={!!editingModel} onOpenChange={() => setEditingModel(null)}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Edit Model</DialogTitle>
            <DialogDescription>Update model configuration</DialogDescription>
          </DialogHeader>
          {editingModel && (
            <ModelForm
              model={editingModel}
              providers={providers}
              onSubmit={handleUpdate}
              onCancel={() => setEditingModel(null)}
            />
          )}
        </DialogContent>
      </Dialog>

      {/* Test Dialog */}
      <Dialog open={showTestDialog} onOpenChange={setShowTestDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Model Test</DialogTitle>
            <DialogDescription>Testing model connectivity and response</DialogDescription>
          </DialogHeader>
          {testingModel && (
            <div className="flex items-center justify-center py-8">
              <Loader2 className="h-8 w-8 animate-spin" />
            </div>
          )}
          {testResult && <TestResult result={testResult} />}
        </DialogContent>
      </Dialog>
    </Card>
  );
}

```

### ProvidersManager.tsx

**Path:** `frontend/src/components/features/admin/ai/ProvidersManager.tsx`

```tsx
/**
 * AI Providers Manager Component
 */

import { useState, useEffect } from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  Plus,
  MoreHorizontal,
  RefreshCw,
  Pencil,
  Trash2,
  Loader2,
  CheckCircle,
  XCircle,
  AlertCircle,
  Circle,
} from 'lucide-react';
import { useProviders } from './hooks';
import type { AIProvider, ProviderFormData } from './types';

interface ProviderFormProps {
  provider?: AIProvider;
  onSubmit: (data: ProviderFormData) => Promise<void>;
  onCancel: () => void;
}

function ProviderForm({ provider, onSubmit, onCancel }: ProviderFormProps) {
  const [formData, setFormData] = useState<ProviderFormData>({
    name: provider?.name || '',
    displayName: provider?.displayName || '',
    apiBaseUrl: provider?.apiBaseUrl || '',
    apiKeyEnv: provider?.apiKeyEnv || '',
  });
  const [submitting, setSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSubmitting(true);
    try {
      await onSubmit(formData);
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="grid grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="name">Name *</Label>
          <Input
            id="name"
            value={formData.name}
            onChange={(e) => setFormData({ ...formData, name: e.target.value })}
            placeholder="openai"
            disabled={!!provider}
            required
          />
          <p className="text-xs text-muted-foreground">Identifier (lowercase, no spaces)</p>
        </div>
        <div className="space-y-2">
          <Label htmlFor="displayName">Display Name *</Label>
          <Input
            id="displayName"
            value={formData.displayName}
            onChange={(e) => setFormData({ ...formData, displayName: e.target.value })}
            placeholder="OpenAI"
            required
          />
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="apiBaseUrl">API Base URL</Label>
        <Input
          id="apiBaseUrl"
          value={formData.apiBaseUrl || ''}
          onChange={(e) => setFormData({ ...formData, apiBaseUrl: e.target.value })}
          placeholder="https://api.openai.com/v1"
        />
        <p className="text-xs text-muted-foreground">Leave empty for default provider URL</p>
      </div>

      <div className="space-y-2">
        <Label htmlFor="apiKeyEnv">API Key Environment Variable</Label>
        <Input
          id="apiKeyEnv"
          value={formData.apiKeyEnv || ''}
          onChange={(e) => setFormData({ ...formData, apiKeyEnv: e.target.value })}
          placeholder="OPENAI_API_KEY"
        />
        <p className="text-xs text-muted-foreground">
          Environment variable name containing the API key (for security, we don't store actual keys)
        </p>
      </div>

      <DialogFooter>
        <Button type="button" variant="outline" onClick={onCancel}>
          Cancel
        </Button>
        <Button type="submit" disabled={submitting}>
          {submitting && <Loader2 className="h-4 w-4 mr-2 animate-spin" />}
          {provider ? 'Update' : 'Create'} Provider
        </Button>
      </DialogFooter>
    </form>
  );
}

function HealthStatusBadge({ status }: { status: AIProvider['healthStatus'] }) {
  switch (status) {
    case 'healthy':
      return (
        <Badge variant="default" className="bg-green-500">
          <CheckCircle className="h-3 w-3 mr-1" />
          Healthy
        </Badge>
      );
    case 'degraded':
      return (
        <Badge variant="secondary" className="bg-yellow-500 text-white">
          <AlertCircle className="h-3 w-3 mr-1" />
          Degraded
        </Badge>
      );
    case 'down':
      return (
        <Badge variant="destructive">
          <XCircle className="h-3 w-3 mr-1" />
          Down
        </Badge>
      );
    default:
      return (
        <Badge variant="outline">
          <Circle className="h-3 w-3 mr-1" />
          Unknown
        </Badge>
      );
  }
}

export function ProvidersManager() {
  const {
    providers,
    loading,
    error,
    fetchProviders,
    createProvider,
    updateProvider,
    deleteProvider,
    checkHealth,
  } = useProviders();
  const [showForm, setShowForm] = useState(false);
  const [editingProvider, setEditingProvider] = useState<AIProvider | null>(null);
  const [checkingHealth, setCheckingHealth] = useState<string | null>(null);

  useEffect(() => {
    fetchProviders();
  }, [fetchProviders]);

  const handleCreate = async (data: ProviderFormData) => {
    const result = await createProvider(data);
    if (result.ok) {
      setShowForm(false);
    }
  };

  const handleUpdate = async (data: ProviderFormData) => {
    if (!editingProvider) return;
    const result = await updateProvider(editingProvider.id, data);
    if (result.ok) {
      setEditingProvider(null);
    }
  };

  const handleToggleEnabled = async (provider: AIProvider) => {
    await updateProvider(provider.id, { isEnabled: !provider.isEnabled });
  };

  const handleDelete = async (provider: AIProvider) => {
    if (!confirm(`Delete provider "${provider.displayName}"? This cannot be undone.`)) return;
    await deleteProvider(provider.id);
  };

  const handleCheckHealth = async (provider: AIProvider) => {
    setCheckingHealth(provider.id);
    await checkHealth(provider.id);
    setCheckingHealth(null);
  };

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>AI Providers</CardTitle>
            <CardDescription>Manage AI service providers and their API configurations</CardDescription>
          </div>
          <Button onClick={() => setShowForm(true)}>
            <Plus className="h-4 w-4 mr-2" />
            Add Provider
          </Button>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        {error && (
          <div className="p-3 bg-red-50 dark:bg-red-950 text-red-600 dark:text-red-400 rounded-md flex items-center gap-2">
            <AlertCircle className="h-4 w-4" />
            {error}
          </div>
        )}

        {loading ? (
          <div className="flex justify-center py-8">
            <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
          </div>
        ) : (
          <div className="space-y-3">
            {providers.map((provider) => (
              <div
                key={provider.id}
                className={`p-4 border rounded-lg ${
                  provider.isEnabled
                    ? 'border-border'
                    : 'border-dashed border-muted-foreground/30 opacity-60'
                }`}
              >
                <div className="flex items-start justify-between">
                  <div className="space-y-1">
                    <div className="flex items-center gap-2">
                      <span className="font-medium">{provider.displayName}</span>
                      <Badge variant="outline" className="font-mono text-xs">
                        {provider.name}
                      </Badge>
                      <HealthStatusBadge status={provider.healthStatus} />
                      {!provider.isEnabled && <Badge variant="destructive">Disabled</Badge>}
                    </div>
                    <div className="text-sm text-muted-foreground">
                      {provider.apiBaseUrl && <p>URL: {provider.apiBaseUrl}</p>}
                      {provider.apiKeyEnv && <p>API Key: ${provider.apiKeyEnv}</p>}
                    </div>
                    <div className="flex items-center gap-4 text-xs text-muted-foreground">
                      <span>{provider.enabledModelCount}/{provider.modelCount} models enabled</span>
                      {provider.lastHealthCheck && (
                        <span>Last check: {new Date(provider.lastHealthCheck).toLocaleString()}</span>
                      )}
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => handleCheckHealth(provider)}
                      disabled={checkingHealth === provider.id}
                    >
                      {checkingHealth === provider.id ? (
                        <Loader2 className="h-4 w-4 animate-spin" />
                      ) : (
                        <RefreshCw className="h-4 w-4" />
                      )}
                      <span className="ml-1">Health</span>
                    </Button>
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon">
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => setEditingProvider(provider)}>
                          <Pencil className="h-4 w-4 mr-2" />
                          Edit
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => handleToggleEnabled(provider)}>
                          {provider.isEnabled ? 'Disable' : 'Enable'}
                        </DropdownMenuItem>
                        <DropdownMenuSeparator />
                        <DropdownMenuItem
                          onClick={() => handleDelete(provider)}
                          className="text-red-600"
                          disabled={provider.modelCount > 0}
                        >
                          <Trash2 className="h-4 w-4 mr-2" />
                          Delete
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </div>
                </div>
              </div>
            ))}
            {providers.length === 0 && (
              <p className="text-center text-muted-foreground py-8">
                No providers configured. Add your first provider to get started.
              </p>
            )}
          </div>
        )}
      </CardContent>

      {/* Create Dialog */}
      <Dialog open={showForm} onOpenChange={setShowForm}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Provider</DialogTitle>
            <DialogDescription>Configure a new AI service provider</DialogDescription>
          </DialogHeader>
          <ProviderForm onSubmit={handleCreate} onCancel={() => setShowForm(false)} />
        </DialogContent>
      </Dialog>

      {/* Edit Dialog */}
      <Dialog open={!!editingProvider} onOpenChange={() => setEditingProvider(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Edit Provider</DialogTitle>
            <DialogDescription>Update provider configuration</DialogDescription>
          </DialogHeader>
          {editingProvider && (
            <ProviderForm
              provider={editingProvider}
              onSubmit={handleUpdate}
              onCancel={() => setEditingProvider(null)}
            />
          )}
        </DialogContent>
      </Dialog>
    </Card>
  );
}

```

### RoutesManager.tsx

**Path:** `frontend/src/components/features/admin/ai/RoutesManager.tsx`

```tsx
/**
 * AI Routes Manager Component
 */

import { useState, useEffect } from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  Plus,
  MoreHorizontal,
  Pencil,
  Trash2,
  Loader2,
  AlertCircle,
  Star,
  ArrowDown,
  Copy,
} from 'lucide-react';
import { useRoutes, useModels } from './hooks';
import type { AIRoute, RouteFormData, AIModel } from './types';

interface RouteFormProps {
  route?: AIRoute;
  models: AIModel[];
  onSubmit: (data: RouteFormData) => Promise<void>;
  onCancel: () => void;
}

function RouteForm({ route, models, onSubmit, onCancel }: RouteFormProps) {
  const [formData, setFormData] = useState<RouteFormData>({
    name: route?.name || '',
    description: route?.description || '',
    routingStrategy: route?.routingStrategy || 'latency-based-routing',
    primaryModelId: route?.primaryModel?.id || '',
    fallbackModelIds: route?.fallbackModelIds || [],
    contextWindowFallbackIds: route?.contextWindowFallbackIds || [],
    numRetries: route?.numRetries || 3,
    timeoutSeconds: route?.timeoutSeconds || 120,
    isDefault: route?.isDefault || false,
  });
  const [submitting, setSubmitting] = useState(false);

  const enabledModels = models.filter((m) => m.isEnabled);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSubmitting(true);
    try {
      await onSubmit(formData);
    } finally {
      setSubmitting(false);
    }
  };

  const toggleFallback = (modelId: string) => {
    const current = formData.fallbackModelIds || [];
    if (current.includes(modelId)) {
      setFormData({
        ...formData,
        fallbackModelIds: current.filter((id) => id !== modelId),
      });
    } else {
      setFormData({
        ...formData,
        fallbackModelIds: [...current, modelId],
      });
    }
  };

  const toggleContextFallback = (modelId: string) => {
    const current = formData.contextWindowFallbackIds || [];
    if (current.includes(modelId)) {
      setFormData({
        ...formData,
        contextWindowFallbackIds: current.filter((id) => id !== modelId),
      });
    } else {
      setFormData({
        ...formData,
        contextWindowFallbackIds: [...current, modelId],
      });
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="grid grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="name">Route Name *</Label>
          <Input
            id="name"
            value={formData.name}
            onChange={(e) => setFormData({ ...formData, name: e.target.value })}
            placeholder="default"
            disabled={!!route}
            required
          />
        </div>
        <div className="space-y-2">
          <Label htmlFor="strategy">Routing Strategy</Label>
          <Select
            value={formData.routingStrategy}
            onValueChange={(v) =>
              setFormData({
                ...formData,
                routingStrategy: v as RouteFormData['routingStrategy'],
              })
            }
          >
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="simple">Simple</SelectItem>
              <SelectItem value="latency-based-routing">Latency Based</SelectItem>
              <SelectItem value="cost-based-routing">Cost Based</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="description">Description</Label>
        <Input
          id="description"
          value={formData.description || ''}
          onChange={(e) => setFormData({ ...formData, description: e.target.value })}
          placeholder="Route description"
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="primaryModel">Primary Model</Label>
        <Select
          value={formData.primaryModelId || ''}
          onValueChange={(v) => setFormData({ ...formData, primaryModelId: v })}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select primary model" />
          </SelectTrigger>
          <SelectContent>
            {enabledModels.map((m) => (
              <SelectItem key={m.id} value={m.id}>
                {m.displayName} ({m.provider.displayName})
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-2">
        <Label>Fallback Models</Label>
        <p className="text-xs text-muted-foreground mb-2">
          Select models to use when the primary model fails
        </p>
        <div className="flex flex-wrap gap-2">
          {enabledModels
            .filter((m) => m.id !== formData.primaryModelId)
            .map((m) => (
              <Badge
                key={m.id}
                variant={formData.fallbackModelIds?.includes(m.id) ? 'default' : 'outline'}
                className="cursor-pointer"
                onClick={() => toggleFallback(m.id)}
              >
                {m.displayName}
              </Badge>
            ))}
        </div>
      </div>

      <div className="space-y-2">
        <Label>Context Window Fallbacks</Label>
        <p className="text-xs text-muted-foreground mb-2">
          Select models for long context scenarios
        </p>
        <div className="flex flex-wrap gap-2">
          {enabledModels
            .filter((m) => (m.contextWindow || 0) > 100000)
            .map((m) => (
              <Badge
                key={m.id}
                variant={
                  formData.contextWindowFallbackIds?.includes(m.id) ? 'default' : 'outline'
                }
                className="cursor-pointer"
                onClick={() => toggleContextFallback(m.id)}
              >
                {m.displayName} ({((m.contextWindow || 0) / 1000).toFixed(0)}K)
              </Badge>
            ))}
        </div>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="retries">Retries</Label>
          <Input
            id="retries"
            type="number"
            value={formData.numRetries}
            onChange={(e) =>
              setFormData({ ...formData, numRetries: parseInt(e.target.value) || 3 })
            }
            min={0}
            max={10}
          />
        </div>
        <div className="space-y-2">
          <Label htmlFor="timeout">Timeout (seconds)</Label>
          <Input
            id="timeout"
            type="number"
            value={formData.timeoutSeconds}
            onChange={(e) =>
              setFormData({ ...formData, timeoutSeconds: parseInt(e.target.value) || 120 })
            }
            min={10}
            max={600}
          />
        </div>
      </div>

      <div className="flex items-center gap-2">
        <input
          type="checkbox"
          id="isDefault"
          checked={formData.isDefault}
          onChange={(e) => setFormData({ ...formData, isDefault: e.target.checked })}
          className="h-4 w-4"
        />
        <Label htmlFor="isDefault">Set as default route</Label>
      </div>

      <DialogFooter>
        <Button type="button" variant="outline" onClick={onCancel}>
          Cancel
        </Button>
        <Button type="submit" disabled={submitting}>
          {submitting && <Loader2 className="h-4 w-4 mr-2 animate-spin" />}
          {route ? 'Update' : 'Create'} Route
        </Button>
      </DialogFooter>
    </form>
  );
}

export function RoutesManager() {
  const { routes, loading, error, fetchRoutes, createRoute, updateRoute, deleteRoute } =
    useRoutes();
  const { models, fetchModels } = useModels();
  const [showForm, setShowForm] = useState(false);
  const [editingRoute, setEditingRoute] = useState<AIRoute | null>(null);

  useEffect(() => {
    fetchRoutes();
    fetchModels();
  }, [fetchRoutes, fetchModels]);

  const handleCreate = async (data: RouteFormData) => {
    const result = await createRoute(data);
    if (result.ok) {
      setShowForm(false);
    }
  };

  const handleUpdate = async (data: RouteFormData) => {
    if (!editingRoute) return;
    const result = await updateRoute(editingRoute.id, data);
    if (result.ok) {
      setEditingRoute(null);
    }
  };

  const handleSetDefault = async (route: AIRoute) => {
    await updateRoute(route.id, { isDefault: true });
  };

  const handleToggleEnabled = async (route: AIRoute) => {
    await updateRoute(route.id, { isEnabled: !route.isEnabled });
  };

  const handleDelete = async (route: AIRoute) => {
    if (route.isDefault) {
      alert('Cannot delete the default route. Set another route as default first.');
      return;
    }
    if (!confirm(`Delete route "${route.name}"?`)) return;
    await deleteRoute(route.id);
  };

  const handleClone = (route: AIRoute) => {
    setEditingRoute({
      ...route,
      id: '',
      name: `${route.name}-copy`,
      isDefault: false,
    } as AIRoute);
    setShowForm(true);
  };

  const getModelName = (modelId: string) => {
    const model = models.find((m) => m.id === modelId);
    return model?.displayName || modelId;
  };

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Routing Rules</CardTitle>
            <CardDescription>Configure model routing and fallback strategies</CardDescription>
          </div>
          <Button onClick={() => setShowForm(true)}>
            <Plus className="h-4 w-4 mr-2" />
            Add Route
          </Button>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        {error && (
          <div className="p-3 bg-red-50 dark:bg-red-950 text-red-600 dark:text-red-400 rounded-md flex items-center gap-2">
            <AlertCircle className="h-4 w-4" />
            {error}
          </div>
        )}

        {loading ? (
          <div className="flex justify-center py-8">
            <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
          </div>
        ) : (
          <div className="space-y-3">
            {routes.map((route) => (
              <div
                key={route.id}
                className={`p-4 border rounded-lg ${
                  route.isDefault
                    ? 'border-primary bg-primary/5'
                    : route.isEnabled
                    ? 'border-border'
                    : 'border-dashed border-muted-foreground/30 opacity-60'
                }`}
              >
                <div className="flex items-start justify-between">
                  <div className="space-y-2">
                    <div className="flex items-center gap-2">
                      {route.isDefault && <Star className="h-4 w-4 text-yellow-500 fill-yellow-500" />}
                      <span className="font-medium">{route.name}</span>
                      <Badge variant="outline">{route.routingStrategy}</Badge>
                      {!route.isEnabled && <Badge variant="destructive">Disabled</Badge>}
                    </div>
                    {route.description && (
                      <p className="text-sm text-muted-foreground">{route.description}</p>
                    )}

                    {/* Route Flow Visualization */}
                    <div className="flex flex-wrap items-center gap-2 text-sm">
                      <span className="font-medium text-muted-foreground">Flow:</span>
                      {route.primaryModel && (
                        <Badge variant="secondary">{route.primaryModel.displayName}</Badge>
                      )}
                      {route.fallbackModelIds.length > 0 && (
                        <>
                          <ArrowDown className="h-4 w-4 text-muted-foreground" />
                          {route.fallbackModelIds.map((id, idx) => (
                            <span key={id} className="flex items-center gap-1">
                              <Badge variant="outline">{getModelName(id)}</Badge>
                              {idx < route.fallbackModelIds.length - 1 && (
                                <ArrowDown className="h-3 w-3 text-muted-foreground" />
                              )}
                            </span>
                          ))}
                        </>
                      )}
                    </div>

                    <div className="flex items-center gap-4 text-xs text-muted-foreground">
                      <span>Retries: {route.numRetries}</span>
                      <span>Timeout: {route.timeoutSeconds}s</span>
                      {route.contextWindowFallbackIds.length > 0 && (
                        <span>
                          Long context: {route.contextWindowFallbackIds.map(getModelName).join(', ')}
                        </span>
                      )}
                    </div>
                  </div>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="icon">
                        <MoreHorizontal className="h-4 w-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem onClick={() => setEditingRoute(route)}>
                        <Pencil className="h-4 w-4 mr-2" />
                        Edit
                      </DropdownMenuItem>
                      <DropdownMenuItem onClick={() => handleClone(route)}>
                        <Copy className="h-4 w-4 mr-2" />
                        Clone
                      </DropdownMenuItem>
                      {!route.isDefault && (
                        <DropdownMenuItem onClick={() => handleSetDefault(route)}>
                          <Star className="h-4 w-4 mr-2" />
                          Set as Default
                        </DropdownMenuItem>
                      )}
                      <DropdownMenuItem onClick={() => handleToggleEnabled(route)}>
                        {route.isEnabled ? 'Disable' : 'Enable'}
                      </DropdownMenuItem>
                      <DropdownMenuSeparator />
                      <DropdownMenuItem
                        onClick={() => handleDelete(route)}
                        className="text-red-600"
                        disabled={route.isDefault}
                      >
                        <Trash2 className="h-4 w-4 mr-2" />
                        Delete
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              </div>
            ))}
            {routes.length === 0 && (
              <p className="text-center text-muted-foreground py-8">
                No routes configured. Add your first routing rule to get started.
              </p>
            )}
          </div>
        )}
      </CardContent>

      {/* Create Dialog */}
      <Dialog open={showForm} onOpenChange={setShowForm}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Add New Route</DialogTitle>
            <DialogDescription>Configure a new routing rule</DialogDescription>
          </DialogHeader>
          <RouteForm
            models={models}
            onSubmit={handleCreate}
            onCancel={() => setShowForm(false)}
          />
        </DialogContent>
      </Dialog>

      {/* Edit Dialog */}
      <Dialog open={!!editingRoute} onOpenChange={() => setEditingRoute(null)}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Edit Route</DialogTitle>
            <DialogDescription>Update routing configuration</DialogDescription>
          </DialogHeader>
          {editingRoute && (
            <RouteForm
              route={editingRoute}
              models={models}
              onSubmit={handleUpdate}
              onCancel={() => setEditingRoute(null)}
            />
          )}
        </DialogContent>
      </Dialog>
    </Card>
  );
}

```

### UsageMonitor.tsx

**Path:** `frontend/src/components/features/admin/ai/UsageMonitor.tsx`

```tsx
/**
 * AI Usage Monitoring Component
 */

import { useState, useEffect, useMemo } from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Loader2,
  AlertCircle,
  TrendingUp,
  Zap,
  DollarSign,
  Clock,
  CheckCircle,
  XCircle,
  RefreshCw,
  Download,
} from 'lucide-react';
import { useUsage, useAIConfig } from './hooks';

function formatNumber(num: number): string {
  if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
  if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
  return num.toString();
}

function StatCard({
  title,
  value,
  subtitle,
  icon: Icon,
  trend,
}: {
  title: string;
  value: string | number;
  subtitle?: string;
  icon: React.ElementType;
  trend?: 'up' | 'down' | 'neutral';
}) {
  return (
    <Card>
      <CardContent className="p-4">
        <div className="flex items-center justify-between">
          <div>
            <p className="text-sm text-muted-foreground">{title}</p>
            <p className="text-2xl font-bold">{value}</p>
            {subtitle && <p className="text-xs text-muted-foreground">{subtitle}</p>}
          </div>
          <div
            className={`h-10 w-10 rounded-full flex items-center justify-center ${
              trend === 'up'
                ? 'bg-green-100 text-green-600 dark:bg-green-950 dark:text-green-400'
                : trend === 'down'
                ? 'bg-red-100 text-red-600 dark:bg-red-950 dark:text-red-400'
                : 'bg-muted text-muted-foreground'
            }`}
          >
            <Icon className="h-5 w-5" />
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

function UsageBar({
  label,
  value,
  maxValue,
  color,
}: {
  label: string;
  value: number;
  maxValue: number;
  color?: string;
}) {
  const percentage = maxValue > 0 ? (value / maxValue) * 100 : 0;
  return (
    <div className="space-y-1">
      <div className="flex justify-between text-sm">
        <span>{label}</span>
        <span className="text-muted-foreground">{percentage.toFixed(1)}%</span>
      </div>
      <div className="h-2 bg-muted rounded-full overflow-hidden">
        <div
          className={`h-full rounded-full transition-all ${color || 'bg-primary'}`}
          style={{ width: `${Math.min(percentage, 100)}%` }}
        />
      </div>
    </div>
  );
}

export function UsageMonitor() {
  const { usage, loading, error, fetchUsage } = useUsage();
  const { reloadConfig, exportConfig, loading: configLoading } = useAIConfig();
  const [period, setPeriod] = useState('7d');
  const [groupBy, setGroupBy] = useState<'day' | 'model'>('day');

  useEffect(() => {
    const days = period === '7d' ? 7 : period === '30d' ? 30 : 1;
    const endDate = new Date().toISOString().split('T')[0];
    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)
      .toISOString()
      .split('T')[0];
    fetchUsage({ startDate, endDate, groupBy });
  }, [fetchUsage, period, groupBy]);

  const chartData = useMemo(() => {
    if (!usage?.breakdown) return [];
    return usage.breakdown;
  }, [usage]);

  const maxRequests = useMemo(() => {
    if (groupBy === 'model' && chartData.length > 0) {
      return Math.max(...chartData.map((d) => d.requests));
    }
    return 0;
  }, [chartData, groupBy]);

  const handleReload = async () => {
    const result = await reloadConfig();
    if (result.ok) {
      alert(`Config generated with ${result.data?.modelCount} models. ${result.data?.message}`);
    } else {
      alert(`Error: ${result.error}`);
    }
  };

  const handleExport = async () => {
    const result = await exportConfig();
    if (result.ok && result.data) {
      const blob = new Blob([JSON.stringify(result.data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `ai-config-export-${result.data.exportedAt.split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
    } else {
      alert(`Export failed: ${result.error}`);
    }
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle>Usage & Monitoring</CardTitle>
              <CardDescription>Track AI usage, costs, and performance</CardDescription>
            </div>
            <div className="flex items-center gap-2">
              <Select value={period} onValueChange={setPeriod}>
                <SelectTrigger className="w-[130px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="1d">Last 24h</SelectItem>
                  <SelectItem value="7d">Last 7 days</SelectItem>
                  <SelectItem value="30d">Last 30 days</SelectItem>
                </SelectContent>
              </Select>
              <Select value={groupBy} onValueChange={(v) => setGroupBy(v as 'day' | 'model')}>
                <SelectTrigger className="w-[130px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="day">By Day</SelectItem>
                  <SelectItem value="model">By Model</SelectItem>
                </SelectContent>
              </Select>
              <Button variant="outline" size="icon" onClick={() => fetchUsage()}>
                <RefreshCw className="h-4 w-4" />
              </Button>
            </div>
          </div>
        </CardHeader>
      </Card>

      {error && (
        <div className="p-3 bg-red-50 dark:bg-red-950 text-red-600 dark:text-red-400 rounded-md flex items-center gap-2">
          <AlertCircle className="h-4 w-4" />
          {error}
        </div>
      )}

      {loading ? (
        <div className="flex justify-center py-8">
          <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        </div>
      ) : usage ? (
        <>
          {/* Summary Stats */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <StatCard
              title="Total Requests"
              value={formatNumber(usage.summary.totalRequests)}
              icon={TrendingUp}
              trend="neutral"
            />
            <StatCard
              title="Total Tokens"
              value={formatNumber(usage.summary.totalTokens)}
              icon={Zap}
              trend="neutral"
            />
            <StatCard
              title="Total Cost"
              value={`$${usage.summary.totalCost.toFixed(2)}`}
              icon={DollarSign}
              trend={usage.summary.totalCost > 10 ? 'up' : 'neutral'}
            />
            <StatCard
              title="Avg Latency"
              value={`${usage.summary.avgLatencyMs}ms`}
              icon={Clock}
              trend={usage.summary.avgLatencyMs > 2000 ? 'down' : 'neutral'}
            />
          </div>

          {/* Success/Error Stats */}
          <div className="grid grid-cols-2 gap-4">
            <Card>
              <CardContent className="p-4 flex items-center gap-4">
                <CheckCircle className="h-8 w-8 text-green-500" />
                <div>
                  <p className="text-2xl font-bold">{usage.summary.successCount}</p>
                  <p className="text-sm text-muted-foreground">Successful Requests</p>
                </div>
              </CardContent>
            </Card>
            <Card>
              <CardContent className="p-4 flex items-center gap-4">
                <XCircle className="h-8 w-8 text-red-500" />
                <div>
                  <p className="text-2xl font-bold">{usage.summary.errorCount}</p>
                  <p className="text-sm text-muted-foreground">Failed Requests</p>
                </div>
              </CardContent>
            </Card>
          </div>

          {/* Breakdown */}
          <Card>
            <CardHeader>
              <CardTitle className="text-lg">
                {groupBy === 'day' ? 'Daily Usage' : 'Usage by Model'}
              </CardTitle>
            </CardHeader>
            <CardContent>
              {chartData.length > 0 ? (
                groupBy === 'model' ? (
                  <div className="space-y-4">
                    {chartData.map((item, idx) => (
                      <UsageBar
                        key={item.model?.id || idx}
                        label={item.model?.displayName || 'Unknown'}
                        value={item.requests}
                        maxValue={maxRequests}
                        color={
                          idx === 0
                            ? 'bg-blue-500'
                            : idx === 1
                            ? 'bg-green-500'
                            : idx === 2
                            ? 'bg-yellow-500'
                            : 'bg-gray-400'
                        }
                      />
                    ))}
                  </div>
                ) : (
                  <div className="overflow-x-auto">
                    <table className="w-full text-sm">
                      <thead>
                        <tr className="border-b">
                          <th className="text-left p-2">Date</th>
                          <th className="text-right p-2">Requests</th>
                          <th className="text-right p-2">Tokens</th>
                          <th className="text-right p-2">Cost</th>
                          <th className="text-right p-2">Avg Latency</th>
                        </tr>
                      </thead>
                      <tbody>
                        {chartData.map((item, idx) => (
                          <tr key={item.date || idx} className="border-b">
                            <td className="p-2">{item.date}</td>
                            <td className="text-right p-2">{formatNumber(item.requests)}</td>
                            <td className="text-right p-2">{formatNumber(item.tokens)}</td>
                            <td className="text-right p-2">${item.cost.toFixed(4)}</td>
                            <td className="text-right p-2">{item.avgLatencyMs}ms</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )
              ) : (
                <p className="text-center text-muted-foreground py-8">
                  No usage data available for this period.
                </p>
              )}
            </CardContent>
          </Card>

          {/* Config Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="text-lg">Configuration Actions</CardTitle>
              <CardDescription>Manage LiteLLM configuration sync</CardDescription>
            </CardHeader>
            <CardContent className="flex gap-4">
              <Button onClick={handleReload} disabled={configLoading}>
                {configLoading ? (
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                ) : (
                  <RefreshCw className="h-4 w-4 mr-2" />
                )}
                Generate LiteLLM Config
              </Button>
              <Button variant="outline" onClick={handleExport}>
                <Download className="h-4 w-4 mr-2" />
                Export Config
              </Button>
            </CardContent>
          </Card>
        </>
      ) : null}
    </div>
  );
}

```

### hooks.ts

**Path:** `frontend/src/components/features/admin/ai/hooks.ts`

```typescript
/**
 * AI Admin API Hooks
 */

import { useState, useCallback } from 'react';
import type {
  AIProvider,
  AIModel,
  AIRoute,
  AIUsageData,
  ProviderFormData,
  ModelFormData,
  RouteFormData,
} from './types';

const API_BASE = import.meta.env.VITE_API_BASE_URL || '';

const getAuthHeaders = () => {
  const token = localStorage.getItem('adminToken');
  return {
    'Content-Type': 'application/json',
    Authorization: token ? `Bearer ${token}` : '',
  };
};

// Generic fetch wrapper
async function apiFetch<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<{ ok: boolean; data?: T; error?: string }> {
  try {
    const res = await fetch(`${API_BASE}/api/v1/admin/ai${endpoint}`, {
      ...options,
      headers: {
        ...getAuthHeaders(),
        ...(options.headers || {}),
      },
    });

    const json = await res.json();

    if (!res.ok || !json.ok) {
      return { ok: false, error: json.error || `HTTP ${res.status}` };
    }

    return { ok: true, data: json.data };
  } catch (err) {
    return { ok: false, error: err instanceof Error ? err.message : 'Unknown error' };
  }
}

// ============================================================================
// Providers
// ============================================================================

export function useProviders() {
  const [providers, setProviders] = useState<AIProvider[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchProviders = useCallback(async () => {
    setLoading(true);
    setError(null);
    const result = await apiFetch<{ providers: AIProvider[] }>('/providers');
    if (result.ok && result.data) {
      setProviders(result.data.providers);
    } else {
      setError(result.error || 'Failed to fetch providers');
    }
    setLoading(false);
  }, []);

  const createProvider = useCallback(async (data: ProviderFormData) => {
    const result = await apiFetch<AIProvider>('/providers', {
      method: 'POST',
      body: JSON.stringify(data),
    });
    if (result.ok) {
      await fetchProviders();
    }
    return result;
  }, [fetchProviders]);

  const updateProvider = useCallback(
    async (id: string, data: Partial<ProviderFormData & { isEnabled: boolean }>) => {
      const result = await apiFetch<AIProvider>(`/providers/${id}`, {
        method: 'PUT',
        body: JSON.stringify(data),
      });
      if (result.ok) {
        await fetchProviders();
      }
      return result;
    },
    [fetchProviders]
  );

  const deleteProvider = useCallback(
    async (id: string) => {
      const result = await apiFetch<{ deleted: string }>(`/providers/${id}`, {
        method: 'DELETE',
      });
      if (result.ok) {
        await fetchProviders();
      }
      return result;
    },
    [fetchProviders]
  );

  const checkHealth = useCallback(async (id: string) => {
    const result = await apiFetch<{
      providerId: string;
      status: string;
      latencyMs: number | null;
      error: string | null;
    }>(`/providers/${id}/health`, { method: 'POST' });
    if (result.ok) {
      await fetchProviders();
    }
    return result;
  }, [fetchProviders]);

  return {
    providers,
    loading,
    error,
    fetchProviders,
    createProvider,
    updateProvider,
    deleteProvider,
    checkHealth,
  };
}

// ============================================================================
// Models
// ============================================================================

export function useModels() {
  const [models, setModels] = useState<AIModel[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchModels = useCallback(async (providerId?: string, enabled?: boolean) => {
    setLoading(true);
    setError(null);
    const params = new URLSearchParams();
    if (providerId) params.set('providerId', providerId);
    if (enabled !== undefined) params.set('enabled', String(enabled));
    const query = params.toString() ? `?${params}` : '';
    
    const result = await apiFetch<{ models: AIModel[] }>(`/models${query}`);
    if (result.ok && result.data) {
      setModels(result.data.models);
    } else {
      setError(result.error || 'Failed to fetch models');
    }
    setLoading(false);
  }, []);

  const createModel = useCallback(async (data: ModelFormData) => {
    const result = await apiFetch<AIModel>('/models', {
      method: 'POST',
      body: JSON.stringify(data),
    });
    if (result.ok) {
      await fetchModels();
    }
    return result;
  }, [fetchModels]);

  const updateModel = useCallback(
    async (id: string, data: Partial<ModelFormData & { isEnabled: boolean }>) => {
      const result = await apiFetch<AIModel>(`/models/${id}`, {
        method: 'PUT',
        body: JSON.stringify(data),
      });
      if (result.ok) {
        await fetchModels();
      }
      return result;
    },
    [fetchModels]
  );

  const deleteModel = useCallback(
    async (id: string) => {
      const result = await apiFetch<{ deleted: string }>(`/models/${id}`, {
        method: 'DELETE',
      });
      if (result.ok) {
        await fetchModels();
      }
      return result;
    },
    [fetchModels]
  );

  const testModel = useCallback(async (id: string, prompt?: string) => {
    const result = await apiFetch<{
      success: boolean;
      modelId: string;
      modelName: string;
      latencyMs?: number;
      response?: string;
      error?: string;
    }>(`/models/${id}/test`, {
      method: 'POST',
      body: JSON.stringify({ prompt }),
    });
    return result;
  }, []);

  return {
    models,
    loading,
    error,
    fetchModels,
    createModel,
    updateModel,
    deleteModel,
    testModel,
  };
}

// ============================================================================
// Routes
// ============================================================================

export function useRoutes() {
  const [routes, setRoutes] = useState<AIRoute[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchRoutes = useCallback(async () => {
    setLoading(true);
    setError(null);
    const result = await apiFetch<{ routes: AIRoute[] }>('/routes');
    if (result.ok && result.data) {
      setRoutes(result.data.routes);
    } else {
      setError(result.error || 'Failed to fetch routes');
    }
    setLoading(false);
  }, []);

  const createRoute = useCallback(async (data: RouteFormData) => {
    const result = await apiFetch<AIRoute>('/routes', {
      method: 'POST',
      body: JSON.stringify(data),
    });
    if (result.ok) {
      await fetchRoutes();
    }
    return result;
  }, [fetchRoutes]);

  const updateRoute = useCallback(
    async (id: string, data: Partial<RouteFormData & { isEnabled: boolean }>) => {
      const result = await apiFetch<AIRoute>(`/routes/${id}`, {
        method: 'PUT',
        body: JSON.stringify(data),
      });
      if (result.ok) {
        await fetchRoutes();
      }
      return result;
    },
    [fetchRoutes]
  );

  const deleteRoute = useCallback(
    async (id: string) => {
      const result = await apiFetch<{ deleted: string }>(`/routes/${id}`, {
        method: 'DELETE',
      });
      if (result.ok) {
        await fetchRoutes();
      }
      return result;
    },
    [fetchRoutes]
  );

  return {
    routes,
    loading,
    error,
    fetchRoutes,
    createRoute,
    updateRoute,
    deleteRoute,
  };
}

// ============================================================================
// Usage
// ============================================================================

export function useUsage() {
  const [usage, setUsage] = useState<AIUsageData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchUsage = useCallback(
    async (options?: {
      startDate?: string;
      endDate?: string;
      modelId?: string;
      groupBy?: 'day' | 'model';
    }) => {
      setLoading(true);
      setError(null);
      const params = new URLSearchParams();
      if (options?.startDate) params.set('startDate', options.startDate);
      if (options?.endDate) params.set('endDate', options.endDate);
      if (options?.modelId) params.set('modelId', options.modelId);
      if (options?.groupBy) params.set('groupBy', options.groupBy);
      const query = params.toString() ? `?${params}` : '';

      const result = await apiFetch<AIUsageData>(`/usage${query}`);
      if (result.ok && result.data) {
        setUsage(result.data);
      } else {
        setError(result.error || 'Failed to fetch usage');
      }
      setLoading(false);
    },
    []
  );

  return {
    usage,
    loading,
    error,
    fetchUsage,
  };
}

// ============================================================================
// Config
// ============================================================================

export function useAIConfig() {
  const [loading, setLoading] = useState(false);

  const reloadConfig = useCallback(async () => {
    setLoading(true);
    const result = await apiFetch<{
      config: unknown;
      modelCount: number;
      message: string;
    }>('/reload', { method: 'POST' });
    setLoading(false);
    return result;
  }, []);

  const exportConfig = useCallback(async () => {
    const result = await apiFetch<{
      exportedAt: string;
      providers: AIProvider[];
      models: AIModel[];
      routes: AIRoute[];
    }>('/config/export');
    return result;
  }, []);

  return {
    loading,
    reloadConfig,
    exportConfig,
  };
}

```

### index.ts

**Path:** `frontend/src/components/features/admin/ai/index.ts`

```typescript
export { AIManager } from './AIManager';
export { ProvidersManager } from './ProvidersManager';
export { ModelsManager } from './ModelsManager';
export { RoutesManager } from './RoutesManager';
export { UsageMonitor } from './UsageMonitor';
export * from './hooks';
export * from './types';

```

### types.ts

**Path:** `frontend/src/components/features/admin/ai/types.ts`

```typescript
/**
 * AI Model Management Types
 */

export interface AIProvider {
  id: string;
  name: string;
  displayName: string;
  apiBaseUrl: string | null;
  apiKeyEnv: string | null;
  isEnabled: boolean;
  healthStatus: 'healthy' | 'degraded' | 'down' | 'unknown';
  lastHealthCheck: string | null;
  modelCount: number;
  enabledModelCount: number;
  createdAt: string;
  updatedAt: string;
}

export interface AIModel {
  id: string;
  modelName: string;
  displayName: string;
  litellmModel: string;
  description: string | null;
  provider: {
    id: string;
    name: string;
    displayName: string;
    isEnabled?: boolean;
  };
  contextWindow: number | null;
  maxTokens: number | null;
  cost: {
    inputPer1k: number | null;
    outputPer1k: number | null;
  };
  capabilities: {
    vision: boolean;
    streaming: boolean;
    functionCalling: boolean;
  };
  isEnabled: boolean;
  priority: number;
  createdAt: string;
  updatedAt: string;
}

export interface AIRoute {
  id: string;
  name: string;
  description: string | null;
  routingStrategy: 'simple' | 'latency-based-routing' | 'cost-based-routing';
  primaryModel: {
    id: string;
    modelName: string;
    displayName: string;
  } | null;
  fallbackModelIds: string[];
  contextWindowFallbackIds: string[];
  numRetries: number;
  timeoutSeconds: number;
  isDefault: boolean;
  isEnabled: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface AIUsageSummary {
  totalRequests: number;
  totalTokens: number;
  totalCost: number;
  avgLatencyMs: number;
  successCount: number;
  errorCount: number;
}

export interface AIUsageBreakdown {
  date?: string;
  model?: {
    id: string;
    modelName: string;
    displayName: string;
  };
  requests: number;
  tokens: number;
  cost: number;
  avgLatencyMs: number;
}

export interface AIUsageData {
  period: {
    start: string;
    end: string;
  };
  summary: AIUsageSummary;
  breakdown: AIUsageBreakdown[];
}

// Form types
export interface ProviderFormData {
  name: string;
  displayName: string;
  apiBaseUrl?: string;
  apiKeyEnv?: string;
}

export interface ModelFormData {
  modelName: string;
  displayName: string;
  providerId: string;
  litellmModel: string;
  description?: string;
  contextWindow?: number;
  maxTokens?: number;
  inputCostPer1k?: number;
  outputCostPer1k?: number;
  supportsVision?: boolean;
  supportsStreaming?: boolean;
  supportsFunctionCalling?: boolean;
  priority?: number;
}

export interface RouteFormData {
  name: string;
  description?: string;
  routingStrategy?: 'simple' | 'latency-based-routing' | 'cost-based-routing';
  primaryModelId?: string;
  fallbackModelIds?: string[];
  contextWindowFallbackIds?: string[];
  numRetries?: number;
  timeoutSeconds?: number;
  isDefault?: boolean;
}

```

---

## frontend/src/components/features/blog

### ActiveFilters.tsx

**Path:** `frontend/src/components/features/blog/ActiveFilters.tsx`

```tsx
import { X } from 'lucide-react';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';

export type ActiveFiltersProps = {
  tags: string[];
  onRemove: (tag: string) => void;
  onClearAll: () => void;
};

export function ActiveFilters({ tags, onRemove, onClearAll }: ActiveFiltersProps) {
  if (!tags.length) return null;

  return (
    <div className='bg-card/50 backdrop-blur-sm border rounded-xl p-4 md:p-6 shadow-sm'>
      <div className='flex flex-col gap-3'>
        <div className='flex flex-wrap items-center gap-2'>
          <span className='text-sm font-medium text-muted-foreground mr-1'>
            Active filters
          </span>
          {tags.map(tag => (
            <Badge
              key={tag}
              variant='secondary'
              className='flex items-center gap-1 rounded-full bg-primary/10 text-primary dark:bg-primary/20 dark:text-primary-foreground'
            >
              #{tag}
              <button
                type='button'
                onClick={() => onRemove(tag)}
                className='inline-flex h-4 w-4 items-center justify-center rounded-full hover:bg-primary/20 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary'
                aria-label={`Remove filter ${tag}`}
              >
                <X className='h-3 w-3' aria-hidden='true' />
              </button>
            </Badge>
          ))}
        </div>
        <div>
          <Button
            variant='ghost'
            size='sm'
            onClick={onClearAll}
            className='w-fit'
          >
            <X className='h-4 w-4 mr-2' aria-hidden='true' />
            Clear all filters
          </Button>
        </div>
      </div>
    </div>
  );
}

```

### BlogCard.tsx

**Path:** `frontend/src/components/features/blog/BlogCard.tsx`

```tsx
import { memo, useMemo } from 'react';
import { Link, useLocation } from 'react-router-dom';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { BlogPost } from '@/types/blog';
import { formatDate, resolveLocalizedPost } from '@/utils/blog';
import { stripMarkdown } from '@/utils/common';
import { ArrowRight, Clock, User } from 'lucide-react';
import { DateDisplay, TagList } from '@/components/atoms';
import { prefetchPost } from '@/data/posts';
import { OptimizedImage } from '@/components/common/OptimizedImage';
import useLanguage from '@/hooks/useLanguage';

interface BlogCardProps {
  post: BlogPost;
}

const BlogCard = memo(({ post }: BlogCardProps) => {
  const location = useLocation();
  const { language } = useLanguage();
  const localized = useMemo(
    () => resolveLocalizedPost(post, language),
    [language, post]
  );

  const search = location.search;
  const fromState = {
    pathname: location.pathname,
    search,
  } as const;

  // Create the proper blog post URL using year and slug
  const postUrl = `/blog/${post.year}/${post.slug}`;

  // Display excerpt or description with markdown stripped
  const displayText = useMemo(() => {
    const raw = localized.excerpt || localized.description || '';
    return stripMarkdown(raw, 150);
  }, [localized.excerpt, localized.description]);

  const readingTimeLabel = useMemo(() => {
    const raw = post.readingTime || (post.readTime ? `${post.readTime} min read` : '');
    if (!raw) return '';
    const match = raw.match(/(\d+)/);
    if (language === 'ko') {
      const minutes = match ? match[1] : '';
      if (minutes) return `${minutes}분 읽기`;
      return raw.includes('분') ? raw : raw.replace('min read', '분 읽기');
    }
    // English fallback
    if (raw.includes('분')) {
      const minutes = match ? match[1] : '';
      if (minutes) return `${minutes} min read`;
    }
    return raw;
  }, [language, post.readTime, post.readingTime]);

  const readMoreLabel = language === 'ko' ? '더 읽기' : 'Read more';

  const formattedDate = formatDate(post.date, language);

  return (
    <Card className='h-full flex flex-col hover:shadow-lg transition-all duration-300 group border-border/50 hover:border-border'>
      {/* Cover image or placeholder */}
      <div className='aspect-video overflow-hidden bg-muted/40'>
        {post.coverImage ? (
          <OptimizedImage
            src={post.coverImage}
            alt={localized.title}
            className='w-full h-full object-cover group-hover:scale-105 transition-transform duration-300'
          />
        ) : (
          <div className='w-full h-full flex items-center justify-center bg-gradient-to-br from-slate-200 to-slate-100 dark:from-slate-800 dark:to-slate-900'>
            <svg
              className='w-10 h-10 text-slate-400 dark:text-slate-500'
              viewBox='0 0 24 24'
              fill='none'
              stroke='currentColor'
              aria-hidden='true'
            >
              <path
                strokeLinecap='round'
                strokeLinejoin='round'
                strokeWidth='2'
                d='M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z'
              />
            </svg>
          </div>
        )}
      </div>

      <CardHeader className='pb-0 px-6 pt-6 md:px-8 md:pt-8'>
        <div className='flex justify-between items-start gap-2 mb-3'>
          <Badge variant='secondary' className='text-xs'>
            {post.category}
          </Badge>
          <DateDisplay date={formattedDate} />
        </div>
        <CardTitle className='line-clamp-2 group-hover:text-primary transition-colors leading-tight font-extrabold'>
          <Link
            to={{ pathname: postUrl, search: search || undefined }}
            state={{ from: fromState }}
            className='hover:underline'
            onMouseEnter={() => prefetchPost(post.year, post.slug)}
            onFocus={() => prefetchPost(post.year, post.slug)}
          >
            {localized.title}
          </Link>
        </CardTitle>
      </CardHeader>

      <CardContent className='flex-1 pt-3 px-6 md:px-8'>
        <CardDescription className='line-clamp-3 text-sm leading-relaxed text-slate-600 dark:text-slate-400'>
          {displayText}
        </CardDescription>
      </CardContent>

      <CardFooter className='flex flex-col gap-3 pt-3 px-6 pb-6 md:px-8'>
        {/* Metadata row */}
        <div className='flex items-center justify-between w-full text-xs text-muted-foreground'>
          <div className='flex items-center gap-4'>
            {/* Reading time */}
            {(post.readingTime || post.readTime) && readingTimeLabel && (
              <div className='flex items-center gap-1'>
                <Clock className='h-3 w-3' />
                <span>{readingTimeLabel}</span>
              </div>
            )}

            {/* Author */}
            {post.author && (
              <div className='flex items-center gap-1'>
                <User className='h-3 w-3' />
                <span>{post.author}</span>
              </div>
            )}
          </div>
        </div>

        {/* Tags */}
        {post.tags && post.tags.length > 0 && (
          <div className='w-full'>
            <TagList
              tags={post.tags}
              maxVisible={3}
              size='sm'
              showIcon={false}
              variant='secondary'
            />
          </div>
        )}

        {/* Read more button */}
        <Button asChild variant='ghost' className='w-full group/button mt-2'>
          <Link
            to={{ pathname: postUrl, search: search || undefined }}
            state={{ from: fromState }}
            onMouseEnter={() => prefetchPost(post.year, post.slug)}
            onFocus={() => prefetchPost(post.year, post.slug)}
          >
            {readMoreLabel}
            <ArrowRight className='ml-2 h-4 w-4 transition-transform group-hover/button:translate-x-1' />
          </Link>
        </Button>
      </CardFooter>
    </Card>
  );
});

BlogCard.displayName = 'BlogCard';

export default BlogCard;

```

### BlogCardSkeleton.tsx

**Path:** `frontend/src/components/features/blog/BlogCardSkeleton.tsx`

```tsx
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';

const BlogCardSkeleton = () => {
  return (
    <Card className='h-full transition-all duration-300 hover:shadow-lg border-l-4 border-l-primary/20'>
      <CardHeader className='space-y-3'>
        <div className='flex items-center justify-between'>
          <Skeleton className='h-4 w-16 shimmer' />
          <Skeleton className='h-4 w-20 shimmer' />
        </div>
        <Skeleton className='h-6 w-full shimmer' />
        <Skeleton className='h-6 w-3/4 shimmer' />
      </CardHeader>
      <CardContent className='space-y-4'>
        <div className='space-y-2'>
          <Skeleton className='h-4 w-full shimmer' />
          <Skeleton className='h-4 w-full shimmer' />
          <Skeleton className='h-4 w-2/3 shimmer' />
        </div>
        <div className='flex flex-wrap gap-2'>
          <Skeleton className='h-6 w-16 shimmer' />
          <Skeleton className='h-6 w-20 shimmer' />
          <Skeleton className='h-6 w-14 shimmer' />
        </div>
        <div className='flex items-center justify-between pt-4'>
          <Skeleton className='h-4 w-24 shimmer' />
          <Skeleton className='h-9 w-20 shimmer' />
        </div>
      </CardContent>
    </Card>
  );
};

export default BlogCardSkeleton;

```

### CommentInputModal.tsx

**Path:** `frontend/src/components/features/blog/CommentInputModal.tsx`

```tsx
import * as React from 'react';
import { useEffect, useRef, useState, useCallback } from 'react';
import { Globe2, Loader2, Send, X } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useIsMobile } from '@/hooks/use-mobile';

interface CommentInputModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: {
    author: string;
    content: string;
    website: string;
  }) => Promise<void>;
  isTerminal: boolean;
  initialAuthor?: string;
}

export default function CommentInputModal({
  isOpen,
  onClose,
  onSubmit,
  isTerminal,
  initialAuthor = '',
}: CommentInputModalProps) {
  const [author, setAuthor] = useState(initialAuthor);
  const [content, setContent] = useState('');
  const [website, setWebsite] = useState('');
  const [showWebsiteField, setShowWebsiteField] = useState(false);
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const isMobile = useIsMobile();
  const modalRef = useRef<HTMLDivElement>(null);
  const contentRef = useRef<HTMLTextAreaElement>(null);
  const authorRef = useRef<HTMLInputElement>(null);

  // Focus management - only run when modal opens, not on every author change
  useEffect(() => {
    if (isOpen) {
      // Small delay to ensure modal is rendered
      const timer = setTimeout(() => {
        // Use initialAuthor to determine focus, not the live author state
        if (initialAuthor?.trim()) {
          contentRef.current?.focus();
        } else {
          authorRef.current?.focus();
        }
      }, 100);
      return () => clearTimeout(timer);
    }
  }, [isOpen, initialAuthor]);

  // Handle ESC key to close
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        e.preventDefault();
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown);
      // Prevent body scroll when modal is open
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.body.style.overflow = '';
    };
  }, [isOpen, onClose]);

  // Handle viewport resize (for mobile keyboard)
  useEffect(() => {
    if (!isOpen || !isMobile) return;

    const handleResize = () => {
      if (modalRef.current) {
        // Use visualViewport if available for accurate mobile keyboard handling
        const vh = window.visualViewport?.height || window.innerHeight;
        modalRef.current.style.height = `${vh}px`;
        
        // Scroll the focused element into view when keyboard opens
        const activeEl = document.activeElement;
        if (activeEl && (activeEl === authorRef.current || activeEl === contentRef.current)) {
          setTimeout(() => {
            activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 100);
        }
      }
    };

    // Initial setup
    handleResize();

    // Listen to both resize and visualViewport changes
    window.addEventListener('resize', handleResize);
    window.visualViewport?.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      window.visualViewport?.removeEventListener('resize', handleResize);
    };
  }, [isOpen, isMobile]);

  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    if (!author.trim() || !content.trim()) return;

    try {
      setSubmitting(true);
      setError(null);
      await onSubmit({
        author: author.trim(),
        content: content.trim(),
        website: website.trim(),
      });
      // Clear form on success
      setContent('');
      setWebsite('');
      setShowWebsiteField(false);
      onClose();
    } catch (err: any) {
      setError(err?.message || 'Failed to submit comment');
    } finally {
      setSubmitting(false);
    }
  }, [author, content, website, onSubmit, onClose]);

  // Handle Ctrl/Cmd + Enter to submit
  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
      if (author.trim() && content.trim() && !submitting) {
        handleSubmit(e as any);
      }
    }
  }, [author, content, submitting, handleSubmit]);

  if (!isOpen) return null;

  // PC: Center popup with dimmed background
  // Mobile: Full screen modal
  return (
    <div
      className={cn(
        "fixed inset-0 z-[var(--z-modal-overlay)] flex",
        // PC: center alignment with dimmed overlay
        !isMobile && "items-center justify-center bg-black/50 backdrop-blur-sm",
        // Mobile: full screen with background (prevents black screen issue)
        isMobile && "flex-col bg-background"
      )}
      role="dialog"
      aria-modal="true"
      aria-labelledby="comment-modal-title"
      onClick={!isMobile ? (e) => { if (e.target === e.currentTarget) onClose(); } : undefined}
    >
      <div
        ref={modalRef}
        className={cn(
          "flex flex-col overflow-hidden",
          // PC styles: centered dialog
          !isMobile && [
            "w-full max-w-xl rounded-2xl shadow-2xl",
            isTerminal
              ? "border border-primary/30 bg-[hsl(var(--background))]"
              : "border border-border bg-background"
          ],
          // Mobile styles: full screen
          isMobile && [
            "w-full",
            isTerminal
              ? "bg-[hsl(var(--background))]"
              : "bg-background"
          ]
        )}
        style={isMobile ? { height: '100dvh' } : { maxHeight: '85vh' }}
      >
        {/* Header - Vim/Nano style */}
        <header
          className={cn(
            "flex items-center justify-between px-4 py-3 shrink-0",
            isTerminal
              ? "bg-primary/20 border-b border-primary/30"
              : "bg-card border-b border-border",
            // PC: rounded top corners
            !isMobile && "rounded-t-2xl"
          )}
        >
          <span
            id="comment-modal-title"
            className={cn(
              "text-sm font-bold tracking-wide",
              isTerminal
                ? "font-mono text-primary terminal-glow"
                : "text-foreground"
            )}
          >
            {isTerminal ? "-- INSERT --" : "New Comment"}
          </span>

          {/* Action Buttons */}
          <div className="flex items-center gap-2">
            <button
              type="button"
              onClick={onClose}
              disabled={submitting}
              className={cn(
                "px-3 py-1.5 text-xs font-medium rounded-md transition-colors",
                isTerminal
                  ? "font-mono border border-border text-muted-foreground hover:border-primary hover:text-primary disabled:opacity-50"
                  : "border border-border text-muted-foreground hover:bg-muted disabled:opacity-50"
              )}
            >
              {isTerminal ? ":q!" : "Cancel"}
            </button>
            <button
              type="submit"
              form="comment-form"
              disabled={submitting || !author.trim() || !content.trim()}
              className={cn(
                "inline-flex items-center gap-1.5 px-3 py-1.5 text-xs font-semibold rounded-md transition-all disabled:opacity-50",
                isTerminal
                  ? "font-mono border border-primary bg-primary/20 text-primary hover:bg-primary/30 disabled:hover:bg-primary/20"
                  : "bg-primary text-primary-foreground hover:bg-primary/90"
              )}
            >
              {submitting ? (
                <Loader2 className="h-3.5 w-3.5 animate-spin" />
              ) : (
                <Send className="h-3.5 w-3.5" />
              )}
              {isTerminal ? ":wq" : "Submit"}
            </button>
          </div>
        </header>

        {/* Form Content */}
        <form
          id="comment-form"
          onSubmit={handleSubmit}
          onKeyDown={handleKeyDown}
          className="flex-1 flex flex-col overflow-hidden"
        >
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {/* Error display */}
          {error && (
            <div
              className={cn(
                "px-3 py-2 rounded-lg text-sm",
                isTerminal
                  ? "bg-destructive/20 text-destructive border border-destructive/30 font-mono"
                  : "bg-destructive/10 text-destructive"
              )}
            >
              {isTerminal ? `// Error: ${error}` : error}
            </div>
          )}

          {/* Author field */}
          <div className="space-y-2">
            <label
              htmlFor="modal-author"
              className={cn(
                "block text-sm font-medium",
                isTerminal
                  ? "font-mono text-primary"
                  : "text-foreground"
              )}
            >
              {isTerminal ? "$ name:" : "Name"}
            </label>
            <input
              ref={authorRef}
              id="modal-author"
              type="text"
              value={author}
              onChange={(e) => setAuthor(e.target.value)}
              placeholder={isTerminal ? "your_username" : "Your name"}
              required
              className={cn(
                "w-full px-4 py-3 text-base outline-none transition-all",
                isTerminal
                  ? "rounded-lg border border-border bg-[hsl(var(--terminal-code-bg))] font-mono text-foreground placeholder:text-muted-foreground focus:border-primary focus:ring-1 focus:ring-primary/50"
                  : "rounded-xl border border-border bg-background text-foreground placeholder:text-muted-foreground focus:border-primary focus:ring-2 focus:ring-primary/20"
              )}
            />
          </div>

          {/* Website toggle & field */}
          <div className="space-y-2">
            <button
              type="button"
              onClick={() => setShowWebsiteField(!showWebsiteField)}
              className={cn(
                "inline-flex items-center gap-2 text-sm transition-colors",
                isTerminal
                  ? "font-mono text-muted-foreground hover:text-primary"
                  : "text-muted-foreground hover:text-primary"
              )}
            >
              <Globe2 className="h-4 w-4" />
              {showWebsiteField
                ? isTerminal ? "// hide website" : "Hide website"
                : isTerminal ? "// add website (optional)" : "Add website (optional)"
              }
            </button>
            
            {showWebsiteField && (
              <input
                id="modal-website"
                type="url"
                value={website}
                onChange={(e) => setWebsite(e.target.value)}
                placeholder="https://example.com"
                className={cn(
                  "w-full px-4 py-3 text-base outline-none transition-all animate-in slide-in-from-top-2 duration-200",
                  isTerminal
                    ? "rounded-lg border border-border bg-[hsl(var(--terminal-code-bg))] font-mono text-foreground placeholder:text-muted-foreground focus:border-primary focus:ring-1 focus:ring-primary/50"
                    : "rounded-xl border border-border bg-background text-foreground placeholder:text-muted-foreground focus:border-primary focus:ring-2 focus:ring-primary/20"
                )}
              />
            )}
          </div>

          {/* Comment content */}
          <div className="space-y-2 flex-1">
            <label
              htmlFor="modal-content"
              className={cn(
                "block text-sm font-medium",
                isTerminal
                  ? "font-mono text-primary"
                  : "text-foreground"
              )}
            >
              {isTerminal ? "$ comment:" : "Comment"}
            </label>
            <div className="relative">
              <textarea
                ref={contentRef}
                id="modal-content"
                value={content}
                onChange={(e) => setContent(e.target.value)}
                placeholder={isTerminal
                  ? "// write your thoughts here...\n// markdown supported"
                  : "Share your thoughts...\nMarkdown is supported"
                }
                required
                rows={6}
                className={cn(
                  "w-full px-4 py-3 text-base leading-relaxed outline-none transition-all resize-none",
                  isTerminal
                    ? "rounded-lg border border-border bg-[hsl(var(--terminal-code-bg))] font-mono text-foreground placeholder:text-muted-foreground focus:border-primary focus:ring-1 focus:ring-primary/50"
                    : "rounded-xl border border-border bg-background text-foreground placeholder:text-muted-foreground focus:border-primary focus:ring-2 focus:ring-primary/20"
                )}
              />
              {/* Blinking cursor effect for terminal mode */}
              {isTerminal && !content && (
                <span className="absolute left-4 top-3 font-mono text-primary animate-pulse pointer-events-none">
                  _
                </span>
              )}
            </div>
          </div>
        </div>

        {/* Footer - explanatory text */}
        <footer
          className={cn(
            "shrink-0 px-4 py-2 border-t",
            isTerminal
              ? "bg-[hsl(var(--terminal-code-bg))] border-border"
              : "bg-muted/30 border-border",
            // PC: rounded bottom corners
            !isMobile && "rounded-b-2xl",
            // Mobile: safe area padding
            isMobile && "pb-[calc(0.5rem+env(safe-area-inset-bottom,0px))]"
          )}
        >
          <span
            className={cn(
              "text-xs text-center block",
              isTerminal
                ? "font-mono text-muted-foreground"
                : "text-muted-foreground"
            )}
          >
            {isTerminal
              ? "[ESC to cancel, Ctrl+Enter to submit]"
              : "Styling with Markdown is supported."
            }
          </span>
        </footer>
      </form>
      </div>
    </div>
  );
}

```

### CommentReactions.tsx

**Path:** `frontend/src/components/features/blog/CommentReactions.tsx`

```tsx
import * as React from 'react';
import { useCallback, useEffect, useState } from 'react';
import { cn } from '@/lib/utils';
import {
  ALLOWED_EMOJIS,
  ReactionCount,
  ReactionEmoji,
  addReaction,
  removeReaction,
  getUserReactions,
  setUserReactions,
} from '@/services/reactions';

interface CommentReactionsProps {
  commentId: string;
  initialReactions?: ReactionCount[];
  isTerminal?: boolean;
  compact?: boolean;
}

export default function CommentReactions({
  commentId,
  initialReactions = [],
  isTerminal = false,
  compact = false,
}: CommentReactionsProps) {
  const [reactions, setReactions] = useState<ReactionCount[]>(initialReactions);
  const [userReactions, setUserReactionsState] = useState<Set<ReactionEmoji>>(() => 
    getUserReactions(commentId)
  );
  const [isPickerOpen, setIsPickerOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  // Update reactions when initialReactions changes
  useEffect(() => {
    setReactions(initialReactions);
  }, [initialReactions]);

  const handleReaction = useCallback(async (emoji: ReactionEmoji) => {
    if (isLoading) return;
    
    const hasReacted = userReactions.has(emoji);
    setIsLoading(true);

    try {
      if (hasReacted) {
        // Remove reaction
        await removeReaction(commentId, emoji);
        
        // Update local state
        setReactions(prev => {
          const updated = prev.map(r => 
            r.emoji === emoji ? { ...r, count: Math.max(0, r.count - 1) } : r
          ).filter(r => r.count > 0);
          return updated;
        });
        
        const newUserReactions = new Set(userReactions);
        newUserReactions.delete(emoji);
        setUserReactionsState(newUserReactions);
        setUserReactions(commentId, newUserReactions);
      } else {
        // Add reaction
        await addReaction(commentId, emoji);
        
        // Update local state
        setReactions(prev => {
          const existing = prev.find(r => r.emoji === emoji);
          if (existing) {
            return prev.map(r => 
              r.emoji === emoji ? { ...r, count: r.count + 1 } : r
            );
          }
          return [...prev, { emoji, count: 1 }];
        });
        
        const newUserReactions = new Set(userReactions);
        newUserReactions.add(emoji);
        setUserReactionsState(newUserReactions);
        setUserReactions(commentId, newUserReactions);
      }
    } catch (err) {
      console.error('Failed to toggle reaction:', err);
    } finally {
      setIsLoading(false);
      setIsPickerOpen(false);
    }
  }, [commentId, userReactions, isLoading]);

  // Sort reactions by count
  const sortedReactions = [...reactions].sort((a, b) => b.count - a.count);

  return (
    <div 
      className={cn(
        "flex flex-wrap items-center gap-1.5",
        compact ? "mt-1.5" : "mt-2.5"
      )}
    >
      {/* Existing reactions */}
      {sortedReactions.map(({ emoji, count }) => (
        <button
          key={emoji}
          type="button"
          onClick={() => handleReaction(emoji as ReactionEmoji)}
          disabled={isLoading}
          className={cn(
            "inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs transition-all",
            isTerminal
              ? cn(
                  "border font-mono",
                  userReactions.has(emoji as ReactionEmoji)
                    ? "bg-primary/20 border-primary/40 text-primary"
                    : "bg-background/50 border-border hover:border-primary/30 hover:bg-primary/10 text-muted-foreground"
                )
              : cn(
                  "border",
                  userReactions.has(emoji as ReactionEmoji)
                    ? "bg-primary/10 border-primary/30 text-primary shadow-sm"
                    : "bg-background/50 border-border/50 hover:border-primary/30 hover:bg-primary/5 text-muted-foreground"
                ),
            isLoading && "opacity-50 cursor-not-allowed"
          )}
        >
          <span className="text-sm">{emoji}</span>
          <span>{count}</span>
        </button>
      ))}

      {/* Add reaction button */}
      <div className="relative">
        <button
          type="button"
          onClick={() => setIsPickerOpen(!isPickerOpen)}
          disabled={isLoading}
          className={cn(
            "inline-flex items-center justify-center w-6 h-6 rounded-full transition-all text-xs",
            isTerminal
              ? "bg-background/50 border border-border text-muted-foreground hover:border-primary/30 hover:text-primary font-mono"
              : "bg-background/50 border border-border/50 text-muted-foreground hover:border-primary/30 hover:bg-primary/5 hover:text-primary",
            isLoading && "opacity-50 cursor-not-allowed"
          )}
          title="Add reaction"
        >
          +
        </button>

        {/* Emoji picker dropdown */}
        {isPickerOpen && (
          <>
            {/* Backdrop */}
            <div 
              className="fixed inset-0 z-40"
              onClick={() => setIsPickerOpen(false)}
            />
            {/* Picker */}
            <div 
              className={cn(
                "absolute left-0 bottom-full mb-1 z-50 p-1.5 rounded-lg shadow-lg animate-in fade-in-0 zoom-in-95 duration-100",
                isTerminal
                  ? "bg-[hsl(var(--terminal-code-bg))] border border-primary/30"
                  : "bg-card border border-border"
              )}
            >
              <div className="flex gap-1">
                {ALLOWED_EMOJIS.map(emoji => (
                  <button
                    key={emoji}
                    type="button"
                    onClick={() => handleReaction(emoji)}
                    className={cn(
                      "w-8 h-8 rounded-md flex items-center justify-center text-lg transition-transform hover:scale-110",
                      isTerminal
                        ? "hover:bg-primary/20"
                        : "hover:bg-primary/10",
                      userReactions.has(emoji) && (
                        isTerminal
                          ? "bg-primary/30 ring-1 ring-primary/50"
                          : "bg-primary/20 ring-1 ring-primary/30"
                      )
                    )}
                    title={userReactions.has(emoji) ? "Remove reaction" : "Add reaction"}
                  >
                    {emoji}
                  </button>
                ))}
              </div>
            </div>
          </>
        )}
      </div>
    </div>
  );
}

```

### CommentSection.tsx

**Path:** `frontend/src/components/features/blog/CommentSection.tsx`

```tsx
import * as React from 'react';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Bot, Globe2, Loader2, MessageCircle, PenLine, Send, Sparkles, User } from 'lucide-react';
import { getApiBaseUrl } from '@/utils/apiBase';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { useTheme } from '@/contexts/ThemeContext';
import { cn } from '@/lib/utils';
import CommentInputModal from './CommentInputModal';
import CommentReactions from './CommentReactions';
import { streamChatEvents } from '@/services/chat';
import { fetchReactionsBatch, ReactionCount } from '@/services/reactions';

// Load any archived comments bundled at build-time
// Using a relative glob; keys may vary (relative vs absolute) depending on bundler.
const archivedModules = (import.meta as any).glob(
  '../../../data/comments/**/*.json',
  { eager: true }
);

type CommentItem = {
  id?: string;
  postId: string;
  author: string;
  content: string;
  website?: string | null;
  parentId?: string | null;
  createdAt?: string | null;
};

type ArchivedPayload = { comments: CommentItem[] };

function getArchivedFor(postId: string): ArchivedPayload | null {
  const entries = Object.entries(archivedModules as Record<string, any>);
  // Match any key that ends with `/${postId}.json`
  const found = entries.find(([k]) => k.endsWith(`/${postId}.json`));
  if (!found) return null;
  const mod = found[1];
  const data = mod?.default ?? mod;
  if (data && Array.isArray(data.comments)) return data as ArchivedPayload;
  return null;
}

export default function CommentSection({ postId }: { postId: string }) {
  const { isTerminal } = useTheme();
  const archived = useMemo(() => getArchivedFor(postId), [postId]);
  const [comments, setComments] = useState<CommentItem[] | null>(
    archived?.comments ?? null
  );
  const [loading, setLoading] = useState<boolean>(!archived);
  const [error, setError] = useState<string | null>(null);

  // Reactions state: map of commentId -> reactions
  const [reactionsMap, setReactionsMap] = useState<Record<string, ReactionCount[]>>({});

  // Modal state
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [savedAuthor, setSavedAuthor] = useState('');
  const formShownAt = useRef<number>(Date.now());

  // AI Discussion mode state
  const [aiDiscussionEnabled, setAiDiscussionEnabled] = useState(() => {
    if (typeof window === 'undefined') return false;
    try {
      return localStorage.getItem('comment.aiDiscussion') === 'true';
    } catch {
      return false;
    }
  });
  const [aiResponding, setAiResponding] = useState(false);
  const [aiStreamingText, setAiStreamingText] = useState('');

  // Fetch reactions when comments change
  useEffect(() => {
    if (!comments || comments.length === 0) return;
    
    const commentIds = comments
      .map(c => c.id)
      .filter((id): id is string => !!id);
    
    if (commentIds.length === 0) return;

    fetchReactionsBatch(commentIds)
      .then(reactions => setReactionsMap(reactions))
      .catch(err => console.warn('Failed to fetch reactions:', err));
  }, [comments]);

  useEffect(() => {
    let cancelled = false;
    let es: EventSource | null = null;
    if (archived) {
      setLoading(false);
      setComments(archived.comments);
      return () => void 0;
    }

    async function load() {
      try {
        setLoading(true);
        setError(null);
        const base = getApiBaseUrl().replace(/\/$/, '');
        const url = `${base}/api/v1/comments?postId=${encodeURIComponent(
          postId
        )}`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = (await resp.json()) as any;
        const list = Array.isArray(data?.comments)
          ? data.comments
          : data?.data?.comments || [];
        if (!cancelled) setComments(list || []);

        // Try to open SSE stream for live updates (best-effort)
        const sseUrl = `${base}/api/v1/comments/stream?postId=${encodeURIComponent(
          postId
        )}`;
        es = new EventSource(sseUrl, { withCredentials: true } as any);
        es.onmessage = ev => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg && msg.type === 'append' && Array.isArray(msg.items)) {
              setComments(prev => {
                const before = (prev || []).filter(Boolean) as any[];
                const keyOf = (it: any) =>
                  String(
                    it.id ||
                      `${it.createdAt || ''}|${it.author || ''}|${(it.content || '').slice(0, 24)}`
                  );
                const seen = new Set(before.map(keyOf));
                const merged = [...before];
                for (const it of msg.items) {
                  const k = keyOf(it);
                  if (!seen.has(k)) {
                    seen.add(k);
                    merged.push(it);
                  }
                }
                // keep chronological order by createdAt
                merged.sort((a, b) => {
                  const ta = a.createdAt ? Date.parse(a.createdAt) : 0;
                  const tb = b.createdAt ? Date.parse(b.createdAt) : 0;
                  return ta - tb;
                });
                return merged;
              });
            }
          } catch {}
        };
        es.onerror = () => {
          es?.close();
          es = null;
        };
      } catch (e: any) {
        if (!cancelled) setError(e?.message || 'Failed to load comments');
      } finally {
        if (!cancelled) setLoading(false);
      }
    }

    void load();
    return () => {
      cancelled = true;
      if (es) {
        es.close();
        es = null;
      }
    };
  }, [postId, archived]);

  // Toggle AI discussion mode
  const handleToggleAiDiscussion = useCallback(() => {
    setAiDiscussionEnabled(prev => {
      const next = !prev;
      try {
        localStorage.setItem('comment.aiDiscussion', String(next));
      } catch {}
      return next;
    });
  }, []);

  // AI response error state
  const [aiError, setAiError] = useState<string | null>(null);

  // Generate AI response to a user comment
  const generateAiResponse = useCallback(async (userComment: string, userName: string) => {
    if (!aiDiscussionEnabled) return;
    
    setAiResponding(true);
    setAiStreamingText('');
    setAiError(null);
    
    const pageTitle = typeof document !== 'undefined' ? document.title : '';
    const pageUrl = typeof window !== 'undefined' ? window.location.href : '';
    
    // Build context from recent comments
    const recentComments = (comments || []).slice(-5).map(c => 
      `${c.author}: ${c.content}`
    ).join('\n');
    
    const prompt = `당신은 블로그 글에서 독자들과 토론하는 친근한 AI 어시스턴트예요. 
현재 페이지: ${pageTitle}
URL: ${pageUrl}

최근 댓글들:
${recentComments}

방금 ${userName}님이 남긴 댓글:
"${userComment}"

${userName}님의 댓글에 대해 짧고 통찰력 있게 응답해주세요. 
- 2-3문장으로 간결하게
- 글의 내용과 연결지어 생각을 확장하거나 흥미로운 질문을 던져주세요
- 존댓말을 사용하고 친근하게 대해주세요`;

    // Create abort controller with 45-second timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 45000);

    try {
      let fullText = '';
      for await (const ev of streamChatEvents({ 
        text: prompt,
        useArticleContext: true,
        signal: controller.signal,
      })) {
        if (ev.type === 'text') {
          fullText += ev.text;
          setAiStreamingText(fullText);
        }
      }
      
      // Add AI comment to the list
      if (fullText.trim()) {
        const now = new Date().toISOString();
        const tempId = `ai-${Date.now()}`;
        
        // Optimistically add to local state first
        const aiComment: CommentItem = {
          id: tempId,
          postId,
          author: 'AI Assistant',
          content: fullText.trim(),
          website: null,
          createdAt: now,
        };
        setComments(prev => [...(prev || []), aiComment]);
        
        // Persist to D1 database
        try {
          const base = getApiBaseUrl().replace(/\/$/, '');
          const url = `${base}/api/v1/comments`;
          const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              postId,
              author: 'AI Assistant',
              content: fullText.trim(),
            }),
          });
          
          if (resp.ok) {
            const respData = (await resp.json()) as any;
            const persistedId = respData?.id ?? respData?.data?.id;
            // Update local state with persisted ID
            if (persistedId) {
              setComments(prev => 
                (prev || []).map(c => 
                  c.id === tempId ? { ...c, id: persistedId } : c
                )
              );
            }
          } else {
            console.warn('Failed to persist AI comment:', resp.status);
          }
        } catch (persistErr) {
          console.warn('Failed to persist AI comment:', persistErr);
          // Comment still exists in local state - graceful degradation
        }
      }
    } catch (err) {
      const error = err as Error;
      console.error('AI response error:', error);
      
      // Set user-facing error message
      if (error.name === 'AbortError') {
        setAiError('AI 응답 시간이 초과되었습니다. 잠시 후 다시 시도해주세요.');
      } else {
        setAiError('AI 응답을 생성하지 못했습니다.');
      }
    } finally {
      clearTimeout(timeoutId);
      setAiResponding(false);
      setAiStreamingText('');
    }
  }, [aiDiscussionEnabled, comments, postId]);

  // Comment submission handler for the modal
  const handleCommentSubmit = useCallback(async (data: {
    author: string;
    content: string;
    website: string;
  }) => {
    const now = Date.now();
    // Spam defense: minimum time before submission
    if (now - formShownAt.current < 3000) {
      throw new Error('Please take a moment before submitting.');
    }

    const base = getApiBaseUrl().replace(/\/$/, '');
    const url = `${base}/api/v1/comments`;
    const resp = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        postId,
        author: data.author,
        content: data.content,
        website: data.website || undefined,
        meta: { shownAt: formShownAt.current, submittedAt: now },
      }),
    });

    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const respData = (await resp.json()) as any;
    const id = (respData?.id ?? respData?.data?.id) as string | undefined;

    // Optimistic append with deduplication
    setComments(prev => {
      const existing = prev || [];
      // Check if comment with this ID already exists (from SSE race condition)
      if (id && existing.some(c => c.id === id)) {
        return existing;
      }
      return [
        ...existing,
        {
          id,
          postId,
          author: data.author,
          content: data.content,
          website: data.website || null,
          createdAt: new Date().toISOString(),
        },
      ];
    });

    // Save author name for next comment
    setSavedAuthor(data.author);
    // Reset form shown time for next submission
    formShownAt.current = Date.now();

    // Trigger AI response if enabled
    if (aiDiscussionEnabled) {
      // Small delay to ensure user comment is visible first
      setTimeout(() => {
        generateAiResponse(data.content, data.author);
      }, 500);
    }
  }, [postId, aiDiscussionEnabled, generateAiResponse]);

  return (
    <section aria-label='Comments' className='space-y-6'>
      <div className={cn(
        "p-5 sm:p-6 shadow-sm backdrop-blur-sm transition-colors",
        isTerminal
          ? "rounded-lg border border-border bg-[hsl(var(--terminal-code-bg))]"
          : "rounded-[28px] border border-border/40 bg-card/80 dark:border-white/10 dark:bg-[#111725]/80"
      )}>
        {/* Header */}
        <div className={cn(
          "flex flex-wrap items-start justify-between gap-3 pb-4",
          isTerminal
            ? "border-b border-border"
            : "border-b border-border/40 dark:border-white/10"
        )}>
          <div className='flex items-start gap-3'>
            <span className={cn(
              "p-2.5 rounded-xl",
              isTerminal
                ? "bg-primary/20 text-primary"
                : "bg-gradient-to-br from-primary/15 to-primary/5 text-primary dark:from-primary/20 dark:to-primary/10"
            )}>
              <MessageCircle className={cn(
                "h-5 w-5",
                isTerminal && "terminal-glow"
              )} />
            </span>
            <div>
              <h2 className={cn(
                "text-lg font-semibold",
                isTerminal
                  ? "font-mono text-primary terminal-glow"
                  : "text-foreground dark:text-white"
              )}>
                {isTerminal ? ">_ Comments" : "Comments"}
              </h2>
              <p className={cn(
                "text-sm",
                isTerminal
                  ? "font-mono text-muted-foreground"
                  : "text-muted-foreground dark:text-white/60"
              )}>
                {isTerminal 
                  ? "// Leave a short reflection or follow-up question"
                  : "Leave a short reflection or follow-up question"}
              </p>
            </div>
          </div>
          <div className="flex items-center gap-2">
            {/* AI Discussion Toggle */}
            <button
              type="button"
              onClick={handleToggleAiDiscussion}
              className={cn(
                "inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium transition-all",
                isTerminal
                  ? aiDiscussionEnabled
                    ? "bg-primary/20 text-primary border border-primary/30 font-mono"
                    : "bg-muted/50 text-muted-foreground border border-border font-mono hover:border-primary/50"
                  : aiDiscussionEnabled
                    ? "bg-gradient-to-r from-violet-500/20 to-purple-500/20 text-violet-600 dark:text-violet-400 border border-violet-500/30"
                    : "bg-muted/50 text-muted-foreground border border-border/50 hover:border-violet-500/30 hover:text-violet-600 dark:hover:text-violet-400"
              )}
              title={aiDiscussionEnabled ? "AI 토론 모드 끄기" : "AI 토론 모드 켜기"}
            >
              <Bot className={cn(
                "h-3.5 w-3.5",
                aiDiscussionEnabled && "animate-pulse"
              )} />
              {isTerminal 
                ? aiDiscussionEnabled ? "AI:ON" : "AI:OFF"
                : aiDiscussionEnabled ? "AI 토론" : "AI 토론"
              }
              {aiDiscussionEnabled && (
                <Sparkles className="h-3 w-3" />
              )}
            </button>
            {error && (
              <span className={cn(
                "rounded-full px-3 py-1 text-xs font-medium",
                isTerminal
                  ? "bg-destructive/20 text-destructive border border-destructive/30"
                  : "bg-red-50 text-red-600 dark:bg-red-500/10 dark:text-red-200"
              )}>
                {error}
              </span>
            )}
          </div>
        </div>

        {/* Comments List */}
        <div className='space-y-4 py-5'>
          {loading && (
            <div className={cn(
              "flex items-center gap-2 py-4",
              isTerminal && "font-mono"
            )}>
              <Loader2 className={cn(
                "h-4 w-4 animate-spin",
                isTerminal && "text-primary"
              )} />
              <span className="text-sm text-muted-foreground">
                {isTerminal ? "$ loading comments..." : "Loading comments..."}
              </span>
            </div>
          )}

          {comments && comments.length > 0 && (
            <ul className={cn(
              "space-y-0",
              isTerminal && "border-l-2 border-primary/30 ml-2"
            )}>
              {comments.map((c, idx) => {
                const isAiComment = c.author === 'AI Assistant' || c.id?.startsWith('ai-');
                return (
                <li
                  key={c.id || idx}
                  className={cn(
                    "text-sm leading-relaxed transition-colors",
                    isTerminal
                      ? cn(
                          "pl-4 py-3 hover:bg-primary/5 relative before:absolute before:left-[-9px] before:top-[18px] before:w-2 before:h-2 before:rounded-full before:border-2 before:border-background",
                          isAiComment 
                            ? "before:bg-violet-500 bg-violet-500/5" 
                            : "before:bg-primary/50"
                        )
                      : cn(
                          "p-4 rounded-2xl border shadow-sm mb-3",
                          isAiComment
                            ? "border-violet-500/30 bg-gradient-to-br from-violet-500/5 to-purple-500/5 dark:from-violet-500/10 dark:to-purple-500/10"
                            : "border-border/30 bg-background/60 hover:bg-background/80 dark:border-white/5 dark:bg-white/5 dark:hover:bg-white/8"
                        )
                  )}
                >
                  {/* Terminal mode: Git log style */}
                  {isTerminal ? (
                    <div className="space-y-1">
                      <div className="flex flex-wrap items-center gap-x-2 gap-y-1 font-mono text-xs">
                        <span className="text-muted-foreground">
                          [{c.createdAt 
                            ? new Date(c.createdAt).toLocaleString('ko-KR', {
                                year: 'numeric',
                                month: '2-digit',
                                day: '2-digit',
                                hour: '2-digit',
                                minute: '2-digit'
                              })
                            : 'unknown'}]
                        </span>
                        <span className={cn(
                          "font-semibold",
                          isAiComment ? "text-violet-500" : "text-primary"
                        )}>
                          {isAiComment ? (
                            <span className="inline-flex items-center gap-1">
                              <Bot className="h-3 w-3" />
                              AI@assistant
                            </span>
                          ) : (
                            `${c.author}@visitor`
                          )}
                        </span>
                        <span className="text-muted-foreground">:~$</span>
                      </div>
                      <div className="font-mono text-foreground pl-0 sm:pl-4">
                        <ReactMarkdown 
                          remarkPlugins={[remarkGfm]}
                          components={{
                            p: ({ children }) => <span className="inline">{children}</span>,
                          }}
                        >
                          {c.content}
                        </ReactMarkdown>
                      </div>
                      {c.website && (
                        <a
                          href={c.website}
                          target='_blank'
                          rel='noreferrer'
                          className="inline-flex items-center gap-1 text-xs font-mono text-primary/70 hover:text-primary hover:underline pl-0 sm:pl-4"
                        >
                          <Globe2 className="h-3 w-3" />
                          {c.website}
                        </a>
                      )}
                      {/* Comment Reactions */}
                      {c.id && (
                        <div className="pl-0 sm:pl-4">
                          <CommentReactions
                            commentId={c.id}
                            initialReactions={reactionsMap[c.id] || []}
                            isTerminal={isTerminal}
                            compact
                          />
                        </div>
                      )}
                    </div>
                  ) : (
                    /* Standard mode: Card style */
                    <>
                      <div className='mb-2.5 flex items-center justify-between'>
                        <div className='flex items-center gap-2'>
                          <span className={cn(
                            "flex items-center justify-center rounded-full w-7 h-7",
                            isAiComment
                              ? "bg-gradient-to-br from-violet-500/20 to-purple-500/20"
                              : "bg-gradient-to-br from-primary/20 to-primary/10"
                          )}>
                            {isAiComment ? (
                              <Bot className="h-3.5 w-3.5 text-violet-500" />
                            ) : (
                              <User className="h-3.5 w-3.5 text-primary" />
                            )}
                          </span>
                          <span className={cn(
                            "font-semibold text-[13px]",
                            isAiComment
                              ? "text-violet-600 dark:text-violet-400"
                              : "text-foreground dark:text-white"
                          )}>
                            {c.author}
                            {isAiComment && (
                              <Sparkles className="inline h-3 w-3 ml-1 text-violet-500" />
                            )}
                          </span>
                        </div>
                        {c.createdAt && (
                          <span className="text-xs font-normal text-muted-foreground/70 dark:text-white/50">
                            {new Date(c.createdAt).toLocaleDateString()}
                          </span>
                        )}
                      </div>
                      <div className="prose prose-sm max-w-none leading-relaxed dark:prose-invert prose-p:text-foreground/90 dark:prose-p:text-white/85">
                        <ReactMarkdown remarkPlugins={[remarkGfm]}>
                          {c.content}
                        </ReactMarkdown>
                      </div>
                      {c.website && (
                        <a
                          href={c.website}
                          target='_blank'
                          rel='noreferrer'
                          className="mt-2.5 inline-flex items-center gap-1 text-xs text-primary/80 hover:text-primary hover:underline"
                        >
                          <Globe2 className="h-3 w-3" />
                          {c.website}
                        </a>
                      )}
                      {/* Comment Reactions */}
                      {c.id && (
                        <CommentReactions
                          commentId={c.id}
                          initialReactions={reactionsMap[c.id] || []}
                          isTerminal={isTerminal}
                        />
                      )}
                    </>
                  )}
                </li>
              );})}
            </ul>
          )}

          {/* AI Streaming Response */}
          {aiResponding && aiStreamingText && (
            <div
              className={cn(
                "text-sm leading-relaxed animate-in fade-in-0 slide-in-from-bottom-2 duration-300",
                isTerminal
                  ? "pl-4 py-3 ml-2 border-l-2 border-violet-500/50 bg-violet-500/5"
                  : "p-4 rounded-2xl border border-violet-500/30 bg-gradient-to-br from-violet-500/5 to-purple-500/5 dark:from-violet-500/10 dark:to-purple-500/10"
              )}
            >
              {isTerminal ? (
                <div className="space-y-1">
                  <div className="flex flex-wrap items-center gap-x-2 gap-y-1 font-mono text-xs">
                    <span className="text-muted-foreground">[typing...]</span>
                    <span className="text-violet-500 font-semibold inline-flex items-center gap-1">
                      <Bot className="h-3 w-3 animate-pulse" />
                      AI@assistant
                    </span>
                    <span className="text-muted-foreground">:~$</span>
                  </div>
                  <div className="font-mono text-foreground pl-0 sm:pl-4">
                    <ReactMarkdown 
                      remarkPlugins={[remarkGfm]}
                      components={{
                        p: ({ children }) => <span className="inline">{children}</span>,
                      }}
                    >
                      {aiStreamingText}
                    </ReactMarkdown>
                    <span className="inline-block w-2 h-4 bg-violet-500 animate-pulse ml-0.5" />
                  </div>
                </div>
              ) : (
                <>
                  <div className='mb-2.5 flex items-center gap-2'>
                    <span className="flex items-center justify-center rounded-full w-7 h-7 bg-gradient-to-br from-violet-500/20 to-purple-500/20">
                      <Bot className="h-3.5 w-3.5 text-violet-500 animate-pulse" />
                    </span>
                    <span className="font-semibold text-[13px] text-violet-600 dark:text-violet-400">
                      AI Assistant
                      <Sparkles className="inline h-3 w-3 ml-1 text-violet-500 animate-pulse" />
                    </span>
                    <Loader2 className="h-3 w-3 animate-spin text-violet-500 ml-auto" />
                  </div>
                  <div className="prose prose-sm max-w-none leading-relaxed dark:prose-invert prose-p:text-foreground/90 dark:prose-p:text-white/85">
                    <ReactMarkdown remarkPlugins={[remarkGfm]}>
                      {aiStreamingText}
                    </ReactMarkdown>
                    <span className="inline-block w-2 h-4 bg-violet-500 animate-pulse ml-0.5 align-middle" />
                  </div>
                </>
              )}
            </div>
          )}

          {/* AI Responding Indicator (before text starts) */}
          {aiResponding && !aiStreamingText && (
            <div
              className={cn(
                "flex items-center gap-2 py-3",
                isTerminal
                  ? "pl-4 ml-2 border-l-2 border-violet-500/50 font-mono"
                  : "px-4"
              )}
            >
              <Bot className="h-4 w-4 text-violet-500 animate-pulse" />
              <span className="text-sm text-violet-600 dark:text-violet-400">
                {isTerminal ? "$ AI thinking..." : "AI가 생각하는 중..."}
              </span>
              <Loader2 className="h-3 w-3 animate-spin text-violet-500" />
            </div>
          )}

          {/* AI Error Message */}
          {aiError && !aiResponding && (
            <div
              className={cn(
                "flex items-center gap-2 py-3 px-4 rounded-lg text-sm",
                isTerminal
                  ? "bg-destructive/10 border border-destructive/30 text-destructive font-mono"
                  : "bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-400"
              )}
            >
              <Bot className="h-4 w-4 shrink-0" />
              <span className="flex-1">{aiError}</span>
              <button
                type="button"
                onClick={() => setAiError(null)}
                className="text-xs underline hover:no-underline opacity-70 hover:opacity-100"
              >
                {isTerminal ? "dismiss" : "닫기"}
              </button>
            </div>
          )}

          {/* Comment Form Trigger */}
          <div
            className={cn(
              "p-4 sm:p-5",
              isTerminal
                ? "rounded-lg border border-border bg-background/30"
                : "rounded-2xl border border-border/40 bg-gradient-to-br from-background/60 to-background/40 shadow-inner dark:border-white/10 dark:from-white/5 dark:to-transparent"
            )}
          >
            <button
              type="button"
              onClick={() => setIsModalOpen(true)}
              className={cn(
                "w-full flex items-center gap-3 px-4 py-3 text-left transition-all",
                isTerminal
                  ? "rounded-lg border border-dashed border-border bg-[hsl(var(--terminal-code-bg))] font-mono text-muted-foreground hover:border-primary hover:text-primary group"
                  : "rounded-xl border border-dashed border-border/50 bg-background/50 text-muted-foreground hover:border-primary/50 hover:bg-primary/5 hover:text-foreground group"
              )}
            >
              <PenLine className={cn(
                "h-5 w-5 shrink-0 transition-colors",
                isTerminal
                  ? "group-hover:text-primary"
                  : "group-hover:text-primary"
              )} />
              <span className="flex-1">
                {isTerminal 
                  ? ">_ Write a comment..." 
                  : "Write a comment..."}
              </span>
              <span className={cn(
                "text-xs px-2 py-1 rounded transition-colors hidden sm:inline-block",
                isTerminal
                  ? "bg-primary/10 text-primary/70 group-hover:bg-primary/20"
                  : "bg-muted text-muted-foreground group-hover:bg-primary/10 group-hover:text-primary"
              )}>
                {isTerminal ? "INSERT" : "Click to write"}
              </span>
            </button>

            {archived && (
              <p className={cn(
                "mt-3 text-xs text-center",
                isTerminal
                  ? "font-mono text-muted-foreground"
                  : "text-muted-foreground dark:text-white/50"
              )}>
                {isTerminal 
                  ? "// archived comments shown; new ones appear live"
                  : "Archived comments are shown above; new ones will appear live."}
              </p>
            )}
          </div>
        </div>
      </div>

      {/* Comment Input Modal */}
      <CommentInputModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onSubmit={handleCommentSubmit}
        isTerminal={isTerminal}
        initialAuthor={savedAuthor}
      />
    </section>
  );
}

```

### CoverImage.tsx

**Path:** `frontend/src/components/features/blog/CoverImage.tsx`

```tsx
import { useState } from 'react';
import { cn } from '@/lib/utils';

interface CoverImageProps {
  src?: string | null;
  alt: string;
  className?: string;
  fallbackText?: string;
}

export const CoverImage = ({
  src,
  alt,
  className,
  fallbackText = 'No image',
}: CoverImageProps) => {
  const [errored, setErrored] = useState(false);

  if (!src || errored) {
    return (
      <div
        className={cn(
          'flex h-full w-full items-center justify-center bg-muted text-xs font-medium text-muted-foreground dark:bg-white/10 dark:text-white/70',
          className
        )}
        role='img'
        aria-label={`${alt} placeholder`}
      >
        {fallbackText}
      </div>
    );
  }

  return (
    <img
      src={src}
      alt={alt}
      className={className}
      onError={() => setErrored(true)}
    />
  );
};

```

### MarkdownRenderer.tsx

**Path:** `frontend/src/components/features/blog/MarkdownRenderer.tsx`

```tsx
import ReactMarkdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw';
import { Copy, Check } from 'lucide-react';
import { Children, Fragment, isValidElement, useMemo, useState } from 'react';
import { Button } from '@/components/ui/button';
import SparkInline from '@/components/features/sentio/SparkInline';
import { useTheme } from '@/contexts/ThemeContext';
import { cn } from '@/lib/utils';

// Terminal-style syntax highlighting theme
const terminalTheme: { [key: string]: React.CSSProperties } = {
  ...oneDark,
  'code[class*="language-"]': {
    ...oneDark['code[class*="language-"]'],
    color: '#c6f7d4',
    background: 'transparent',
    fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
  },
  'pre[class*="language-"]': {
    ...oneDark['pre[class*="language-"]'],
    background: 'hsl(200 50% 3%)',
    border: '1px solid hsl(200 30% 12%)',
  },
  comment: { color: '#4e5953' },
  keyword: { color: '#3cff96' },
  string: { color: '#3cb8ff' },
  function: { color: '#3cff96' },
  number: { color: '#ffb02e' },
  operator: { color: '#3cff96' },
  punctuation: { color: '#7f8f87' },
  variable: { color: '#e4f4e8' },
  'class-name': { color: '#3cb8ff' },
  constant: { color: '#ffb02e' },
  boolean: { color: '#ffb02e' },
};

interface MarkdownRendererProps {
  content: string;
  className?: string;
  inlineEnabled?: boolean;
  postTitle?: string;
}

export const MarkdownRenderer = ({
  content,
  className = '',
  inlineEnabled = false,
  postTitle = '',
}: MarkdownRendererProps) => {
  const [copiedCode, setCopiedCode] = useState<string | null>(null);
  const { isTerminal } = useTheme();

  const sanitizedContent = useMemo(() => {
    if (!postTitle) return content;
    const normalizedTitle = postTitle.trim().toLowerCase();
    const lines = content.split(/\r?\n/);
    while (lines.length) {
      const first = lines[0].trim();
      const plain = first.replace(/^#+\s*/, '').trim().toLowerCase();
      if (plain && plain === normalizedTitle) {
        lines.shift();
        continue;
      }
      break;
    }
    return lines.join('\n');
  }, [content, postTitle]);

  const copyToClipboard = (code: string) => {
    navigator.clipboard.writeText(code);
    setCopiedCode(code);
    setTimeout(() => setCopiedCode(null), 2000);
  };

  return (
    <div
      className={cn(
        'prose prose-neutral dark:prose-invert max-w-none prose-lg content',
        isTerminal && 'prose-headings:font-mono prose-headings:tracking-wide',
        className
      )}
    >
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[rehypeRaw]}
        components={{
          h1: ({ children }) => {
            const text = String(children);
            const id = text
              .toLowerCase()
              .replace(/[^\w\s-]/g, '')
              .replace(/\s+/g, '-');
            return (
              <h1
                id={id}
                className={cn(
                  'text-4xl font-bold mt-12 mb-6 scroll-mt-24 text-center max-w-4xl mx-auto',
                  isTerminal && 'terminal-glow'
                )}
              >
                {isTerminal && <span className='text-primary mr-2'>#</span>}
                {children}
              </h1>
            );
          },
          h2: ({ children }) => {
            const text = String(children);
            const id = text
              .toLowerCase()
              .replace(/[^\w\s-]/g, '')
              .replace(/\s+/g, '-');
            return (
              <h2
                id={id}
                className={cn(
                  'text-3xl font-semibold mt-10 mb-5 scroll-mt-24 text-center max-w-4xl mx-auto',
                  isTerminal && 'terminal-glow'
                )}
              >
                {isTerminal && <span className='text-primary mr-2'>##</span>}
                {children}
              </h2>
            );
          },
          h3: ({ children }) => {
            const text = String(children);
            const id = text
              .toLowerCase()
              .replace(/[^\w\s-]/g, '')
              .replace(/\s+/g, '-');
            return (
              <h3
                id={id}
                className={cn(
                  'text-2xl font-semibold mt-8 mb-4 scroll-mt-24 text-center max-w-4xl mx-auto',
                  isTerminal && 'terminal-glow'
                )}
              >
                {isTerminal && <span className='text-primary mr-2'>###</span>}
                {children}
              </h3>
            );
          },
          h4: ({ children }) => {
            const text = String(children);
            const id = text
              .toLowerCase()
              .replace(/[^\w\s-]/g, '')
              .replace(/\s+/g, '-');
            return (
              <h4
                id={id}
                className='text-xl font-semibold mt-4 mb-2 scroll-mt-24'
              >
                {children}
              </h4>
            );
          },
          h5: ({ children }) => {
            const text = String(children);
            const id = text
              .toLowerCase()
              .replace(/[^\w\s-]/g, '')
              .replace(/\s+/g, '-');
            return (
              <h5
                id={id}
                className='text-lg font-semibold mt-4 mb-2 scroll-mt-24'
              >
                {children}
              </h5>
            );
          },
          h6: ({ children }) => {
            const text = String(children);
            const id = text
              .toLowerCase()
              .replace(/[^\w\s-]/g, '')
              .replace(/\s+/g, '-');
            return (
              <h6
                id={id}
                className='text-base font-semibold mt-4 mb-2 scroll-mt-24'
              >
                {children}
              </h6>
            );
          },
          p: ({ children }) => {
            if (inlineEnabled) {
              return <SparkInline postTitle={postTitle}>{children}</SparkInline>;
            }

            const childArray = Children.toArray(children);
            const containsMedia = childArray.some(
              child =>
                isValidElement(child) &&
                typeof (child as any).props?.src === 'string'
            );

            if (containsMedia) {
              return (
                <div className='space-y-4 max-w-4xl mx-auto'>
                  {childArray.map((child, idx) => (
                    <Fragment key={idx}>{child}</Fragment>
                  ))}
                </div>
              );
            }

            return (
              <p
                className={cn(
                  'mb-6 leading-8 text-justify max-w-4xl mx-auto',
                  isTerminal && 'border-l border-border/50 pl-4'
                )}
              >
                {children}
              </p>
            );
          },
          ul: ({ children }) => (
            <ul
              className={cn(
                'list-disc pl-6 mb-6 space-y-3 max-w-4xl mx-auto',
                isTerminal && 'list-none'
              )}
            >
              {children}
            </ul>
          ),
          ol: ({ children }) => (
            <ol className='list-decimal pl-6 mb-6 space-y-3 max-w-4xl mx-auto'>
              {children}
            </ol>
          ),
          li: ({ children }) => (
            <li className={cn('leading-8 text-justify', isTerminal && 'before:content-["-_"] before:text-primary')}>
              {children}
            </li>
          ),
          blockquote: ({ children }) => (
            <blockquote
              className={cn(
                'border-l-4 border-primary pl-6 my-8 italic bg-muted/30 py-4 rounded-r-lg max-w-4xl mx-auto',
                isTerminal && 'bg-[hsl(var(--terminal-code-bg))] border-primary/60 not-italic font-mono'
              )}
            >
              {children}
            </blockquote>
          ),
          code({
            inline,
            className,
            children,
            ...props
          }: React.ComponentProps<'code'> & { inline?: boolean }) {
            const match = /language-(\w+)/.exec(className || '');
            const codeString = String(children).replace(/\n$/, '');
            const language = match ? match[1] : '';

            return !inline && match ? (
              <div className='relative group my-8 max-w-4xl mx-auto overflow-x-auto'>
                {/* Terminal-style header for code blocks */}
                {isTerminal && (
                  <div className='flex items-center gap-2 bg-[hsl(var(--terminal-titlebar))] px-4 py-2 rounded-t-xl border border-b-0 border-border font-mono text-xs text-muted-foreground'>
                    <span className='w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-close))]' />
                    <span className='w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-minimize))]' />
                    <span className='w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-maximize))]' />
                    <span className='ml-2 text-primary'>{language}</span>
                  </div>
                )}
                <Button
                  size='icon'
                  variant='ghost'
                  className={cn(
                    'absolute right-2 h-8 w-8 opacity-0 group-hover:opacity-100 transition-opacity z-10',
                    isTerminal ? 'top-12 text-primary hover:text-primary hover:bg-primary/10' : 'top-2'
                  )}
                  onClick={() => copyToClipboard(codeString)}
                >
                  {copiedCode === codeString ? (
                    <Check className='h-4 w-4' />
                  ) : (
                    <Copy className='h-4 w-4' />
                  )}
                </Button>
                <SyntaxHighlighter
                  style={isTerminal ? terminalTheme : oneDark}
                  language={language}
                  PreTag='div'
                  className={cn(
                    'rounded-xl shadow-lg !overflow-x-auto',
                    isTerminal && 'rounded-t-none !rounded-b-xl'
                  )}
                  wrapLongLines={false}
                >
                  {codeString}
                </SyntaxHighlighter>
              </div>
            ) : (
              <code
                className={cn(
                  'bg-muted px-1.5 py-0.5 rounded text-sm',
                  isTerminal && 'bg-[hsl(var(--terminal-code-bg))] text-primary font-mono'
                )}
                {...props}
              >
                {children}
              </code>
            );
          },
          a: ({ href, children }) => (
            <a
              href={href}
              target='_blank'
              rel='noopener noreferrer'
              className={cn(
                'text-primary hover:underline',
                isTerminal && 'underline decoration-dotted underline-offset-4 hover:decoration-solid'
              )}
            >
              {children}
            </a>
          ),
          img: ({ src, alt }) => {
            // 상대 경로를 절대 경로로 변환
            let resolvedSrc = src;
            if (src) {
              if (src.startsWith('../../images/')) {
                resolvedSrc = src.replace('../../images/', '/images/');
              } else if (src.startsWith('../images/')) {
                resolvedSrc = src.replace('../images/', '/images/');
              } else if (src.startsWith('./images/')) {
                resolvedSrc = src.replace('./images/', '/images/');
              }
            }

            return (
              <figure className='my-8 text-center'>
                <img
                  src={resolvedSrc}
                  alt={alt}
                  className={cn(
                    'rounded-xl shadow-lg mx-auto max-w-full h-auto',
                    isTerminal && 'rounded-lg border border-border'
                  )}
                />
                {alt && (
                  <figcaption
                    className={cn(
                      'text-sm text-muted-foreground mt-2 italic',
                      isTerminal && 'font-mono not-italic'
                    )}
                  >
                    {isTerminal ? `// ${alt}` : alt}
                  </figcaption>
                )}
              </figure>
            );
          },
          table: ({ children }) => (
            <div className='overflow-x-auto my-8 max-w-4xl mx-auto'>
              <table
                className={cn(
                  'min-w-full divide-y divide-border rounded-lg shadow-sm',
                  isTerminal && 'font-mono text-sm'
                )}
              >
                {children}
              </table>
            </div>
          ),
          th: ({ children }) => (
            <th
              className={cn(
                'px-4 py-2 text-left font-semibold bg-muted',
                isTerminal && 'bg-[hsl(var(--terminal-code-bg))] text-primary uppercase text-xs tracking-wider'
              )}
            >
              {children}
            </th>
          ),
          td: ({ children }) => (
            <td className='px-4 py-2 border-t'>{children}</td>
          ),
        }}
      >
        {sanitizedContent}
      </ReactMarkdown>
    </div>
  );
};

export default MarkdownRenderer;

```

### TableOfContents.tsx

**Path:** `frontend/src/components/features/blog/TableOfContents.tsx`

```tsx
import { useEffect, useState, useRef, useCallback } from 'react';
import { cn } from '@/lib/utils';
import { ScrollArea } from '@/components/ui/scroll-area';
import { useTheme } from '@/contexts/ThemeContext';
import { useIsMobile } from '@/hooks/use-mobile';

interface TocItem {
  id: string;
  title: string;
  level: number;
}

interface TableOfContentsProps {
  content: string;
}

export const TableOfContents = ({ content }: TableOfContentsProps) => {
  const [toc, setToc] = useState<TocItem[]>([]);
  const [activeId, setActiveId] = useState<string>('');
  const { isTerminal } = useTheme();
  const isMobile = useIsMobile();
  
  // Refs for scroll optimization
  const rafRef = useRef<number | null>(null);
  const lastScrollTime = useRef<number>(0);
  const THROTTLE_MS = 100; // Throttle scroll events to 100ms

  useEffect(() => {
    // Extract headings from markdown content
    const headingRegex = /^(#{1,6})\s+(.+)$/gm;
    const headings: TocItem[] = [];
    const usedIds = new Set<string>();
    let match: RegExpExecArray | null;

    while ((match = headingRegex.exec(content)) !== null) {
      const level = match[1].length;
      const title = match[2].trim();
      const id = title
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-');

      // Ensure unique IDs
      let uniqueId = id;
      let suffix = 1;
      while (usedIds.has(uniqueId)) {
        uniqueId = `${id}-${suffix}`;
        suffix++;
      }
      usedIds.add(uniqueId);

      headings.push({ id: uniqueId, title, level });
    }

    setToc(headings);
  }, [content]);

  useEffect(() => {
    // Skip scroll tracking on mobile for performance
    if (isMobile) return;
    
    const updateActiveHeading = () => {
      const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
      const scrollPosition = window.scrollY + 100;

      for (let i = headings.length - 1; i >= 0; i--) {
        const heading = headings[i] as HTMLElement;
        if (heading.offsetTop <= scrollPosition) {
          setActiveId(heading.id);
          break;
        }
      }
    };
    
    const handleScroll = () => {
      const now = Date.now();
      
      // Throttle: skip if called too frequently
      if (now - lastScrollTime.current < THROTTLE_MS) {
        return;
      }
      lastScrollTime.current = now;
      
      // Cancel any pending RAF
      if (rafRef.current) {
        cancelAnimationFrame(rafRef.current);
      }
      
      // Schedule update in next animation frame
      rafRef.current = requestAnimationFrame(updateActiveHeading);
    };

    window.addEventListener('scroll', handleScroll, { passive: true });
    updateActiveHeading(); // Initial check

    return () => {
      window.removeEventListener('scroll', handleScroll);
      if (rafRef.current) {
        cancelAnimationFrame(rafRef.current);
      }
    };
  }, [isMobile]);

  const scrollToHeading = (id: string) => {
    const element = document.getElementById(id);
    if (element) {
      element.scrollIntoView({ behavior: 'smooth' });
    }
  };

  if (toc.length === 0) return null;

  return (
    <div className='sticky top-8 w-72 hidden xl:block'>
      <div
        className={cn(
          'bg-card/50 backdrop-blur-sm border rounded-2xl p-6 shadow-lg',
          isTerminal && 'bg-[hsl(var(--terminal-code-bg))] border-border rounded-lg'
        )}
      >
        {/* Terminal-style header */}
        {isTerminal && (
          <div className='flex items-center gap-1.5 mb-4 pb-3 border-b border-border'>
            <span className='w-2.5 h-2.5 rounded-full bg-[hsl(var(--terminal-window-btn-close))]' />
            <span className='w-2.5 h-2.5 rounded-full bg-[hsl(var(--terminal-window-btn-minimize))]' />
            <span className='w-2.5 h-2.5 rounded-full bg-[hsl(var(--terminal-window-btn-maximize))]' />
          </div>
        )}

        <h3
          className={cn(
            'font-bold mb-4 text-base flex items-center',
            isTerminal && 'font-mono text-primary text-sm'
          )}
        >
          {isTerminal ? (
            <>
              <span className='text-muted-foreground mr-2'>$</span>
              cat TOC
            </>
          ) : (
            <>
              <svg
                className='w-5 h-5 mr-2'
                fill='none'
                stroke='currentColor'
                viewBox='0 0 24 24'
              >
                <path
                  strokeLinecap='round'
                  strokeLinejoin='round'
                  strokeWidth={2}
                  d='M4 6h16M4 10h16M4 14h16M4 18h16'
                />
              </svg>
              목차
            </>
          )}
        </h3>
        <ScrollArea className='h-[500px]'>
          <nav className='space-y-2'>
            {toc.map((item, index) => (
              <button
                key={`${item.id}-${index}`}
                onClick={() => scrollToHeading(item.id)}
                className={cn(
                  'block w-full text-left text-sm py-2 px-3 rounded-lg hover:bg-primary/10 transition-all duration-200',
                  'text-muted-foreground hover:text-foreground',
                  activeId === item.id &&
                    'bg-primary/15 text-primary font-semibold border-l-2 border-primary',
                  item.level === 1 && 'ml-0 font-medium',
                  item.level === 2 && 'ml-4',
                  item.level === 3 && 'ml-8',
                  item.level === 4 && 'ml-12',
                  item.level === 5 && 'ml-16',
                  item.level === 6 && 'ml-20',
                  isTerminal && 'font-mono text-xs rounded hover:bg-primary/20',
                  isTerminal && activeId === item.id && 'bg-primary/20 border-l-2 border-primary'
                )}
              >
                <span className='block truncate'>
                  {isTerminal && (
                    <span className='text-muted-foreground mr-2'>
                      {String(index + 1).padStart(2, '0')}
                    </span>
                  )}
                  {item.title}
                </span>
              </button>
            ))}
          </nav>
        </ScrollArea>
      </div>
    </div>
  );
};

export default TableOfContents;

```

### index.ts

**Path:** `frontend/src/components/features/blog/index.ts`

```typescript
export { default as BlogCard } from './BlogCard';
export { default as BlogCardSkeleton } from './BlogCardSkeleton';
export { default as MarkdownRenderer } from './MarkdownRenderer';
export { default as TableOfContents } from './TableOfContents';
export { default as CommentSection } from './CommentSection';
export { default as CommentInputModal } from './CommentInputModal';

```

---

## frontend/src/components/features/chat

### ChatMarkdown.tsx

**Path:** `frontend/src/components/features/chat/ChatMarkdown.tsx`

```tsx
import React, { useCallback, useMemo, useState, useRef, useEffect, memo } from 'react';
import ReactMarkdown from 'react-markdown';
import type { Components } from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import { useTheme } from '@/contexts/ThemeContext';
import { cn } from '@/lib/utils';
import { Copy, Check, Table2 } from 'lucide-react';

// Terminal-style syntax highlighting theme for chat
const terminalChatTheme: { [key: string]: React.CSSProperties } = {
  ...oneDark,
  'code[class*="language-"]': {
    ...oneDark['code[class*="language-"]'],
    color: '#c6f7d4',
    background: 'transparent',
    fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
  },
  'pre[class*="language-"]': {
    ...oneDark['pre[class*="language-"]'],
    background: 'hsl(200 50% 3%)',
  },
  comment: { color: '#4e5953' },
  keyword: { color: '#3cff96' },
  string: { color: '#3cb8ff' },
  function: { color: '#3cff96' },
  number: { color: '#ffb02e' },
};

interface ChatMarkdownProps {
  content: string;
  /** Enable streaming mode for better partial markdown handling */
  isStreaming?: boolean;
}

type CodeComponentProps = React.ComponentPropsWithoutRef<'code'> & {
  inline?: boolean;
  className?: string;
};

/**
 * Sanitize incomplete markdown during streaming to prevent parse errors
 * This helps avoid flickering and layout shifts when markdown is incomplete
 */
function sanitizeStreamingMarkdown(content: string): string {
  let result = content;
  
  // Count unclosed code fences
  const codeFenceMatches = result.match(/```/g);
  if (codeFenceMatches && codeFenceMatches.length % 2 === 1) {
    // Odd number of fences - close the last one
    result = result + '\n```';
  }
  
  // Handle incomplete inline code
  const inlineCodeMatches = result.match(/(?<!`)`(?!`)/g);
  if (inlineCodeMatches && inlineCodeMatches.length % 2 === 1) {
    result = result + '`';
  }
  
  // Handle incomplete bold/italic markers at the end
  // Only if the marker appears at the very end without closing
  if (/\*\*[^*]+$/.test(result) && !/\*\*[^*]+\*\*/.test(result.slice(-50))) {
    result = result + '**';
  }
  if (/(?<!\*)\*[^*]+$/.test(result) && !/(?<!\*)\*[^*]+\*(?!\*)/.test(result.slice(-30))) {
    result = result + '*';
  }
  
  return result;
}

const ChatMarkdown: React.FC<ChatMarkdownProps> = memo(({ content, isStreaming }) => {
  const [copiedCode, setCopiedCode] = useState<string | null>(null);
  const { isTerminal } = useTheme();
  const lastContentRef = useRef(content);
  const [displayContent, setDisplayContent] = useState(content);
  
  // Throttle content updates during streaming to reduce re-renders
  useEffect(() => {
    if (isStreaming) {
      // During streaming, update less frequently to avoid jank
      const timerId = setTimeout(() => {
        const sanitized = sanitizeStreamingMarkdown(content);
        setDisplayContent(sanitized);
        lastContentRef.current = content;
      }, 50); // 50ms throttle
      
      return () => clearTimeout(timerId);
    } else {
      // Not streaming - update immediately
      setDisplayContent(content);
      lastContentRef.current = content;
    }
  }, [content, isStreaming]);

  const handleCopy = useCallback((code: string) => {
    if (!navigator?.clipboard) return;
    void navigator.clipboard
      .writeText(code)
      .then(() => {
        setCopiedCode(code);
        window.setTimeout(() => setCopiedCode(null), 2000);
      })
      .catch(() => {});
  }, []);

  const components = useMemo<Components>(() => ({
    h1: ({ children }) => (
      <h3 className={cn('mt-4 mb-2 text-base font-semibold', isTerminal && 'font-mono text-primary')}>{children}</h3>
    ),
    h2: ({ children }) => (
      <h4 className={cn('mt-3 mb-1.5 text-sm font-semibold', isTerminal && 'font-mono text-primary')}>{children}</h4>
    ),
    h3: ({ children }) => (
      <h5 className={cn('mt-2 mb-1 text-sm font-semibold', isTerminal && 'font-mono')}>{children}</h5>
    ),
    h4: ({ children }) => (
      <h6 className={cn('mt-2 mb-1 text-[13px] font-semibold', isTerminal && 'font-mono')}>{children}</h6>
    ),
    h5: ({ children }) => (
      <h6 className={cn('mt-2 mb-1 text-[13px] font-medium', isTerminal && 'font-mono')}>{children}</h6>
    ),
    h6: ({ children }) => (
      <strong className={cn('text-[13px] font-semibold', isTerminal && 'font-mono')}>{children}</strong>
    ),
    p: ({ children }) => (
      <p className='text-[13px] leading-relaxed'>{children}</p>
    ),
    ul: ({ children }) => (
      <ul className={cn('pl-4 text-[13px] leading-relaxed list-disc space-y-1', isTerminal && 'list-none')}>
        {children}
      </ul>
    ),
    ol: ({ children }) => (
      <ol className={cn('pl-4 text-[13px] leading-relaxed list-decimal space-y-1', isTerminal && 'font-mono')}>
        {children}
      </ol>
    ),
    li: ({ children }) => (
      <li className={cn('leading-relaxed', isTerminal && 'before:content-["-_"] before:text-primary')}>{children}</li>
    ),
    blockquote: ({ children }) => (
      <blockquote className={cn(
        'rounded-md border-l-4 border-primary/40 bg-muted/40 pl-3 py-1 text-[13px] italic',
        isTerminal && 'bg-[hsl(var(--terminal-code-bg))] border-primary/60 not-italic font-mono'
      )}>
        {children}
      </blockquote>
    ),
    code({ inline, className, children, ...props }: CodeComponentProps) {
      const match = /language-(\w+)/.exec(className || '');
      const codeString = String(children).replace(/\n$/, '');
      const isCopied = copiedCode === codeString;

      if (!inline && match) {
        return (
          <div className={cn(
            'relative my-3 overflow-hidden rounded-lg bg-[#0b1020] dark:bg-[#050a1a] group',
            isTerminal && 'bg-[hsl(var(--terminal-code-bg))] border border-border'
          )}>
            <div className={cn(
              'flex items-center justify-between px-3 py-1.5 border-b text-xs',
              isTerminal 
                ? 'border-border bg-[hsl(var(--terminal-code-bg))]' 
                : 'border-white/10 bg-white/5'
            )}>
              <span className={cn(
                'font-mono uppercase tracking-wide',
                isTerminal ? 'text-primary/70' : 'text-white/60'
              )}>
                {match[1]}
              </span>
              <button
                type='button'
                className={cn(
                  'inline-flex items-center gap-1.5 rounded-md px-2 py-1 text-[11px] font-medium transition',
                  'opacity-0 group-hover:opacity-100 focus:opacity-100',
                  'sm:opacity-100', // Always visible on mobile
                  isTerminal 
                    ? 'bg-primary/20 text-primary hover:bg-primary/30 font-mono' 
                    : 'bg-white/10 text-white hover:bg-white/20 backdrop-blur'
                )}
                onClick={() => handleCopy(codeString)}
              >
                {isCopied ? (
                  <>
                    <Check className='h-3 w-3' />
                    <span>Copied</span>
                  </>
                ) : (
                  <>
                    <Copy className='h-3 w-3' />
                    <span>Copy</span>
                  </>
                )}
              </button>
            </div>
            <SyntaxHighlighter
              style={isTerminal ? terminalChatTheme : oneDark}
              language={match[1]}
              PreTag='div'
              className='!bg-transparent !p-4 text-[12px] !m-0 overflow-auto max-h-[400px]'
              wrapLongLines={false}
            >
              {codeString}
            </SyntaxHighlighter>
          </div>
        );
      }

      // Code block without language specified
      if (!inline && !match && codeString.includes('\n')) {
        return (
          <div className={cn(
            'relative my-3 overflow-hidden rounded-lg bg-[#0b1020] dark:bg-[#050a1a] group',
            isTerminal && 'bg-[hsl(var(--terminal-code-bg))] border border-border'
          )}>
            <button
              type='button'
              className={cn(
                'absolute right-2 top-2 inline-flex items-center gap-1.5 rounded-md px-2 py-1 text-[11px] font-medium transition z-10',
                'opacity-0 group-hover:opacity-100 focus:opacity-100 sm:opacity-100',
                isTerminal 
                  ? 'bg-primary/20 text-primary hover:bg-primary/30 font-mono' 
                  : 'bg-white/10 text-white hover:bg-white/20 backdrop-blur'
              )}
              onClick={() => handleCopy(codeString)}
            >
              {isCopied ? <Check className='h-3 w-3' /> : <Copy className='h-3 w-3' />}
            </button>
            <pre className={cn(
              'p-4 text-[12px] overflow-auto max-h-[400px]',
              isTerminal ? 'text-primary/90 font-mono' : 'text-white/90'
            )}>
              {codeString}
            </pre>
          </div>
        );
      }

      return (
        <code
          className={cn(
            'rounded bg-muted px-1.5 py-0.5 text-[12px] font-mono',
            isTerminal && 'bg-[hsl(var(--terminal-code-bg))] text-primary'
          )}
          {...props}
        >
          {children}
        </code>
      );
    },
    a: ({ children, href }) => (
      <a
        href={href}
        target='_blank'
        rel='noopener noreferrer'
        className={cn(
          'text-primary underline decoration-dotted underline-offset-2 hover:text-primary/80',
          isTerminal && 'hover:decoration-solid'
        )}
      >
        {children}
      </a>
    ),
    // Enhanced table rendering
    table: ({ children }) => (
      <div className={cn(
        'my-4 overflow-hidden rounded-lg border',
        isTerminal ? 'border-border bg-[hsl(var(--terminal-code-bg))]' : 'border-border/60 bg-muted/20'
      )}>
        <div className={cn(
          'flex items-center gap-2 px-3 py-2 border-b text-xs font-medium',
          isTerminal ? 'border-border text-primary/70' : 'border-border/60 text-muted-foreground'
        )}>
          <Table2 className='h-3.5 w-3.5' />
          <span className={isTerminal ? 'font-mono uppercase tracking-wide' : ''}>Table</span>
        </div>
        <div className='overflow-x-auto'>
          <table className={cn(
            'w-full text-left text-sm min-w-max',
            isTerminal && 'font-mono text-xs'
          )}>
            {children}
          </table>
        </div>
      </div>
    ),
    thead: ({ children }) => (
      <thead className={cn(
        isTerminal ? 'bg-[hsl(var(--terminal-code-bg))]' : 'bg-muted/50'
      )}>
        {children}
      </thead>
    ),
    tbody: ({ children }) => (
      <tbody className='divide-y divide-border/50'>
        {children}
      </tbody>
    ),
    tr: ({ children }) => (
      <tr className={cn(
        'transition-colors',
        isTerminal ? 'hover:bg-primary/5' : 'hover:bg-muted/30'
      )}>
        {children}
      </tr>
    ),
    th: ({ children }) => (
      <th className={cn(
        'px-4 py-2.5 text-xs font-semibold uppercase tracking-wide whitespace-nowrap',
        isTerminal ? 'text-primary border-b border-border' : 'text-foreground border-b border-border/60'
      )}>
        {children}
      </th>
    ),
    td: ({ children }) => (
      <td className={cn(
        'px-4 py-2.5 text-[13px] align-top',
        isTerminal && 'text-foreground/90'
      )}>
        {children}
      </td>
    ),
    // Horizontal rule
    hr: () => (
      <hr className={cn(
        'my-4 border-t',
        isTerminal ? 'border-primary/20' : 'border-border'
      )} />
    ),
  }), [copiedCode, handleCopy, isTerminal]);

  if (!displayContent.trim()) return null;

  return (
    <div className={cn(
      'chat-markdown prose prose-sm prose-neutral max-w-none dark:prose-invert',
      '[&>p]:mb-3 [&>p:last-child]:mb-0',
      '[&>ul]:my-2 [&>ol]:my-2',
      '[&_pre]:!overflow-auto',
      isTerminal && 'prose-headings:font-mono'
    )}>
      <ReactMarkdown remarkPlugins={[remarkGfm]} components={components}>
        {displayContent}
      </ReactMarkdown>
    </div>
  );
});

ChatMarkdown.displayName = 'ChatMarkdown';

export default ChatMarkdown;

```

### ChatWidget.tsx

**Path:** `frontend/src/components/features/chat/ChatWidget.tsx`

```tsx
/**
 * ChatWidget - AI Chat Widget Component
 *
 * This file re-exports from the modularized ./widget directory.
 * The original 1645-line monolithic component has been split into:
 *
 * - types.ts: Type definitions (SourceLink, ChatMessage, UploadedChatImage, etc.)
 * - constants.ts: Storage keys, quick prompts, helper functions
 * - hooks/: State management hooks
 *   - useChatState.ts: Main chat state (messages, input, sessions, refs)
 *   - useChatSession.ts: Session management (load, toggle, aggregate)
 *   - useChatActions.ts: Chat actions (send, stop, clearAll)
 *   - useChatKeyboard.ts: Keyboard handling hooks
 * - components/: UI components
 *   - ChatHeader.tsx: Header with controls
 *   - ChatSessionPanel.tsx: Session list, ModeSelector
 *   - ChatMessages.tsx: Message rendering (terminal + default styles)
 *   - ChatInput.tsx: Input area (terminal + default styles)
 *   - ChatDialogs.tsx: ImageDrawer, MobileActionSheet
 * - index.tsx: Main component (~240 lines)
 */

export { default } from "./widget";
export type { SourceLink, ChatMessage, QuestionMode } from "./widget/types";

```

---

## frontend/src/components/features/chat/widget

### constants.ts

**Path:** `frontend/src/components/features/chat/widget/constants.ts`

```typescript
export const CHAT_SESSIONS_INDEX_KEY = "ai_chat_sessions_index";
export const CHAT_SESSION_STORAGE_PREFIX = "ai_chat_history_v2_";
export const CURRENT_SESSION_KEY = "ai_chat_current_session_key";
export const PERSIST_OPTIN_KEY = "ai_chat_persist_optin";

export const QUICK_PROMPTS = [
  "이 글을 3줄로 요약해줘.",
  "SEO 키워드 5개 추천해줘.",
  "블로그 글 제목 3개를 제안해줘.",
];

// Helper function to extract image URL from message text
export function extractImageFromMessage(text: string): {
  imageUrl: string | null;
  cleanText: string;
} {
  const imageUrlMatch = text.match(
    /\[첨부 이미지\]\nURL: (https?:\/\/[^\s\n]+)/,
  );
  if (imageUrlMatch) {
    const imageUrl = imageUrlMatch[1];
    // Remove the image metadata section from the text
    const cleanText = text
      .replace(
        /\n\n\[첨부 이미지\]\nURL: [^\n]+\n파일명: [^\n]+\n크기: [^\n]+/,
        "",
      )
      .trim();
    return { imageUrl, cleanText };
  }
  return { imageUrl: null, cleanText: text };
}

// Generate a unique session key
export function generateSessionKey(): string {
  return `sess_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}

```

### index.tsx

**Path:** `frontend/src/components/features/chat/widget/index.tsx`

```tsx
import React, { useCallback, useState, useEffect } from "react";
import { cn } from "@/lib/utils";
import { useIsMobile } from "@/hooks/use-mobile";
import { useTheme } from "@/contexts/ThemeContext";

import {
  useChatState,
  useChatSession,
  useChatActions,
  useKeyboardHeight,
  useInputKeyDown,
  useModels,
} from "./hooks";
import {
  ChatHeader,
  ChatSessionPanel,
  ModeSelector,
  ChatMessages,
  ChatInput,
  ImageDrawer,
  MobileActionSheet,
} from "./components";

export default function ChatWidget(props: {
  onClose?: () => void;
  initialMessage?: string;
}) {
  const isMobile = useIsMobile();
  const { isTerminal } = useTheme();
  const keyboardHeight = useKeyboardHeight(isMobile);

  // Dynamic max height calculation for PC
  const [pcMaxHeight, setPcMaxHeight] = useState("80vh");

  useEffect(() => {
    if (isMobile) return;

    const calculateHeight = () => {
      const vh = window.innerHeight;
      // Reserve space for FAB (80px) + some padding, max 85% of viewport
      const safeMax = Math.min(vh * 0.85, vh - 100);
      setPcMaxHeight(`${Math.round(safeMax)}px`);
    };

    calculateHeight();
    window.addEventListener("resize", calculateHeight);
    return () => window.removeEventListener("resize", calculateHeight);
  }, [isMobile]);

  // Main state hook
  const state = useChatState({ initialMessage: props.initialMessage });

  // Model selection
  const modelState = useModels();

  // Session management
  const session = useChatSession({
    sessionKey: state.sessionKey,
    setSessionKey: state.setSessionKey,
    sessions: state.sessions,
    setSessions: state.setSessions,
    messages: state.messages,
    setMessages: state.setMessages,
    persistOptIn: state.persistOptIn,
    questionMode: state.questionMode,
    summary: state.summary,
    pageTitle: state.pageTitle,
    setFirstTokenMs: state.setFirstTokenMs,
    setAttachedImage: state.setAttachedImage,
    setIsAggregatePrompt: state.setIsAggregatePrompt,
    setShowSessions: state.setShowSessions,
    selectedSessionIds: state.selectedSessionIds,
    setSelectedSessionIds: state.setSelectedSessionIds,
    setInput: state.setInput,
  });

  // Chat actions
  const actions = useChatActions({
    canSend: state.canSend,
    input: state.input,
    setInput: state.setInput,
    attachedImage: state.attachedImage,
    setAttachedImage: state.setAttachedImage,
    setAttachedPreviewUrl: state.setAttachedPreviewUrl,
    busy: state.busy,
    setBusy: state.setBusy,
    setFirstTokenMs: state.setFirstTokenMs,
    abortRef: state.abortRef,
    push: state.push,
    setMessages: state.setMessages,
    isAggregatePrompt: state.isAggregatePrompt,
    setIsAggregatePrompt: state.setIsAggregatePrompt,
    questionMode: state.questionMode,
    lastPromptRef: state.lastPromptRef,
    uploadedImages: state.uploadedImages,
    setUploadedImages: state.setUploadedImages,
    messages: state.messages,
    setSessionKey: state.setSessionKey,
    selectedModel: modelState.selectedModel,
  });

  // Keyboard handler
  const onKeyDown = useInputKeyDown({
    canSend: state.canSend,
    send: actions.send,
  });

  const handlePromptClick = useCallback(
    (prompt: string) => {
      state.setInput(prompt);
      state.focusInput();
    },
    [state],
  );

  const handleRetry = useCallback(
    (lastPrompt: string) => {
      state.setInput(lastPrompt);
      state.focusInput();
    },
    [state],
  );

  return (
    <>
      <div
        className={cn(
          "fixed z-[var(--z-chat-widget)] flex flex-col overflow-hidden border bg-background shadow-2xl transition-all",
          // Mobile: always fullscreen (adjusted for keyboard)
          isMobile
            ? "inset-0 rounded-none"
            : "bottom-20 left-1/2 w-[min(100%-24px,42rem)] -translate-x-1/2 rounded-2xl",
          // Terminal theme: PC rounded, mobile fullscreen
          isTerminal &&
            !isMobile &&
            "border-border bg-[hsl(var(--terminal-code-bg))] rounded-lg",
          isTerminal &&
            isMobile &&
            "border-0 bg-[hsl(var(--terminal-code-bg))]",
        )}
        style={
          isMobile && keyboardHeight > 0
            ? { height: `calc(100dvh - ${keyboardHeight}px)` }
            : isMobile
              ? { height: "100dvh" }
              : { maxHeight: pcMaxHeight }
        }
      >
        {/* Header */}
        <ChatHeader
          isMobile={isMobile}
          isTerminal={isTerminal}
          busy={state.busy}
          persistOptIn={state.persistOptIn}
          sessions={state.sessions}
          uploadedImages={state.uploadedImages}
          onShowSessions={() => state.setShowSessions((v) => !v)}
          onShowActionSheet={() => state.setShowActionSheet(true)}
          onShowImageDrawer={() => state.setShowImageDrawer(true)}
          onTogglePersist={state.togglePersistStorage}
          onClearAll={actions.clearAll}
          onClose={props.onClose}
          // Model selection props
          models={modelState.models}
          modelsByProvider={modelState.modelsByProvider}
          selectedModel={modelState.selectedModel}
          currentModel={modelState.currentModel}
          modelsLoading={modelState.loading}
          modelsError={modelState.error}
          onModelSelect={modelState.setSelectedModel}
          onModelsRefresh={modelState.refresh}
        />

        {/* Session panel */}
        {state.showSessions && (
          <ChatSessionPanel
            sessions={state.sessions}
            selectedSessionIds={state.selectedSessionIds}
            onToggleSession={session.toggleSessionSelected}
            onLoadSession={session.loadSession}
            onClose={() => state.setShowSessions(false)}
            onAggregateSelected={session.handleAggregateFromSelected}
            isTerminal={isTerminal}
            isMobile={isMobile}
          />
        )}

        {/* Mode selector */}
        <ModeSelector
          questionMode={state.questionMode}
          onModeChange={state.setQuestionMode}
          isTerminal={isTerminal}
          isMobile={isMobile}
        />

        {/* Messages area */}
        <div
          ref={state.scrollRef}
          className={cn(
            "flex-1 overflow-auto px-4 py-4 space-y-4",
            isMobile && "px-4",
            isTerminal && "space-y-3 font-mono text-sm",
          )}
        >
          <ChatMessages
            messages={state.messages}
            isTerminal={isTerminal}
            isMobile={isMobile}
            onPromptClick={handlePromptClick}
            onRetry={handleRetry}
            lastPrompt={state.lastPromptRef.current}
            onNavigate={props.onClose}
          />
        </div>

        {/* Summary bar */}
        {state.persistOptIn && state.summary && (
          <div
            className={cn(
              "px-4 py-2 border-t text-xs text-muted-foreground truncate shrink-0",
              isTerminal &&
                "font-mono border-border bg-[hsl(var(--terminal-code-bg))]",
            )}
          >
            {isTerminal ? (
              <span>
                <span className="text-primary/60"># Last:</span> {state.summary}
              </span>
            ) : (
              <>요약: {state.summary}</>
            )}
          </div>
        )}

        {/* Input area */}
        <ChatInput
          input={state.input}
          onInputChange={state.setInput}
          onKeyDown={onKeyDown}
          onSend={actions.send}
          onStop={actions.stop}
          onClearAll={actions.clearAll}
          onFileSelect={state.setAttachedImage}
          attachedImage={state.attachedImage}
          attachedPreviewUrl={state.attachedPreviewUrl}
          busy={state.busy}
          canSend={state.canSend}
          firstTokenMs={state.firstTokenMs}
          questionMode={state.questionMode}
          isTerminal={isTerminal}
          isMobile={isMobile}
          textareaRef={state.textareaRef}
          fileInputRef={state.fileInputRef}
        />
      </div>

      {/* Image drawer dialog */}
      <ImageDrawer
        open={state.showImageDrawer}
        onOpenChange={state.setShowImageDrawer}
        uploadedImages={state.uploadedImages}
      />

      {/* Mobile action sheet */}
      <MobileActionSheet
        open={state.showActionSheet}
        onOpenChange={state.setShowActionSheet}
        sessions={state.sessions}
        uploadedImages={state.uploadedImages}
        persistOptIn={state.persistOptIn}
        onShowSessions={() => {
          state.setShowActionSheet(false);
          state.setShowSessions((v) => !v);
        }}
        onShowImageDrawer={() => {
          state.setShowActionSheet(false);
          state.setShowImageDrawer(true);
        }}
        onTogglePersist={state.togglePersistStorage}
        onClearAll={actions.clearAll}
        isTerminal={isTerminal}
      />
    </>
  );
}

```

### types.ts

**Path:** `frontend/src/components/features/chat/widget/types.ts`

```typescript
export type SourceLink = {
  title?: string;
  url?: string;
  score?: number;
  snippet?: string;
};

export type ChatMessage = {
  id: string;
  role: "user" | "assistant" | "system";
  text: string;
  sources?: SourceLink[];
  followups?: string[];
};

export type UploadedChatImage = {
  id: string;
  url: string;
  name: string;
  size: number;
};

export type ChatSessionMeta = {
  id: string;
  title: string;
  summary: string;
  createdAt: string;
  updatedAt: string;
  messageCount: number;
  mode: "article" | "general";
  articleUrl?: string;
  articleTitle?: string;
};

export type QuestionMode = "article" | "general";

```

---

## frontend/src/components/features/chat/widget/components

### ChatDialogs.tsx

**Path:** `frontend/src/components/features/chat/widget/components/ChatDialogs.tsx`

```tsx
import React from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
} from "@/components/ui/sheet";
import { cn } from "@/lib/utils";
import type { ChatSessionMeta, UploadedChatImage } from "../types";

type ImageDrawerProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  uploadedImages: UploadedChatImage[];
};

export function ImageDrawer({
  open,
  onOpenChange,
  uploadedImages,
}: ImageDrawerProps) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>이미지 메모</DialogTitle>
          <DialogDescription>
            최근 대화에서 첨부한 이미지들을 다시 확인할 수 있어요.
          </DialogDescription>
        </DialogHeader>
        <div className="max-h-[60vh] overflow-y-auto space-y-2 text-sm">
          {uploadedImages.length === 0 && (
            <p className="text-muted-foreground text-sm">
              저장된 이미지가 없습니다.
            </p>
          )}
          {uploadedImages.map((img) => (
            <button
              key={img.id}
              type="button"
              className="flex w-full items-center gap-3 rounded-lg border px-2 py-1 text-left hover:bg-muted"
              onClick={() => {
                try {
                  window.open(img.url, "_blank", "noopener,noreferrer");
                } catch {}
              }}
            >
              <div className="h-12 w-12 overflow-hidden rounded bg-muted">
                <img
                  src={img.url}
                  alt={img.name}
                  className="h-full w-full object-cover"
                />
              </div>
              <div className="flex-1 truncate">
                <div className="font-medium truncate">{img.name}</div>
                <div className="text-xs text-muted-foreground">
                  {Math.max(1, Math.round(img.size / 1024))}KB
                </div>
              </div>
            </button>
          ))}
        </div>
      </DialogContent>
    </Dialog>
  );
}

type MobileActionSheetProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  sessions: ChatSessionMeta[];
  uploadedImages: UploadedChatImage[];
  persistOptIn: boolean;
  onShowSessions: () => void;
  onShowImageDrawer: () => void;
  onTogglePersist: () => void;
  onClearAll: () => void;
  isTerminal: boolean;
};

export function MobileActionSheet({
  open,
  onOpenChange,
  sessions,
  uploadedImages,
  persistOptIn,
  onShowSessions,
  onShowImageDrawer,
  onTogglePersist,
  onClearAll,
  isTerminal,
}: MobileActionSheetProps) {
  const runAction = (fn: () => void) => {
    fn();
    onOpenChange(false);
  };

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent
        side="bottom"
        className={cn(
          "h-auto max-h-[85vh] rounded-t-3xl px-6 pb-8 pt-4",
          isTerminal &&
            "rounded-t-xl bg-[hsl(var(--terminal-code-bg))] border-primary/30",
        )}
        aria-describedby={undefined}
      >
        <SheetHeader className="text-left pb-4">
          <SheetTitle
            className={cn("text-lg", isTerminal && "font-mono text-primary")}
          >
            {isTerminal ? ">_ 대화 옵션" : "대화 옵션"}
          </SheetTitle>
          <SheetDescription className={isTerminal ? "font-mono" : ""}>
            대화 관리 및 설정
          </SheetDescription>
        </SheetHeader>
        <div className="space-y-3">
          <ActionButton
            label="최근 대화 보기"
            value={`${sessions.length}개`}
            disabled={!sessions.length}
            onClick={() => runAction(onShowSessions)}
            isTerminal={isTerminal}
          />
          <ActionButton
            label="이미지 메모 보기"
            value={`${uploadedImages.length}개`}
            disabled={!uploadedImages.length}
            onClick={() => runAction(onShowImageDrawer)}
            isTerminal={isTerminal}
          />
          <ActionButton
            label={persistOptIn ? "기록 저장 끄기" : "기록 저장 켜기"}
            value={persistOptIn ? "ON" : "OFF"}
            valueBadge
            valuePrimary={persistOptIn}
            onClick={() => runAction(onTogglePersist)}
            isTerminal={isTerminal}
          />
          <ActionButton
            label="대화 초기화"
            destructive
            onClick={() => runAction(onClearAll)}
            isTerminal={isTerminal}
          />
        </div>
      </SheetContent>
    </Sheet>
  );
}

function ActionButton({
  label,
  value,
  valueBadge,
  valuePrimary,
  disabled,
  destructive,
  onClick,
  isTerminal,
}: {
  label: string;
  value?: string;
  valueBadge?: boolean;
  valuePrimary?: boolean;
  disabled?: boolean;
  destructive?: boolean;
  onClick: () => void;
  isTerminal: boolean;
}) {
  return (
    <button
      type="button"
      className={cn(
        "flex w-full items-center justify-between rounded-2xl border px-5 py-4 text-left transition-colors",
        isTerminal
          ? "rounded-lg border-primary/30 hover:bg-primary/10 font-mono"
          : "hover:bg-muted",
        disabled && "opacity-50 cursor-not-allowed",
        destructive &&
          (isTerminal
            ? "border-destructive/40 text-destructive hover:bg-destructive/10"
            : "border-destructive/40 text-destructive hover:bg-destructive/5"),
      )}
      disabled={disabled}
      onClick={onClick}
    >
      <span className="text-base">{label}</span>
      {value && (
        <span
          className={cn(
            "text-sm",
            valueBadge && "px-2 py-0.5 rounded-full",
            valueBadge && valuePrimary
              ? isTerminal
                ? "bg-primary/20 text-primary"
                : "bg-primary/10 text-primary"
              : valueBadge
                ? "bg-muted text-muted-foreground"
                : isTerminal
                  ? "text-primary/60"
                  : "text-muted-foreground",
          )}
        >
          {value}
        </span>
      )}
    </button>
  );
}

```

### ChatHeader.tsx

**Path:** `frontend/src/components/features/chat/widget/components/ChatHeader.tsx`

```tsx
import React from "react";
import {
  Sparkles,
  MoreVertical,
  X,
  Loader2,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";
import type { ChatSessionMeta, UploadedChatImage } from "../types";
import type { AIModel } from "../hooks/useModels";
import { ModelSelector } from "./ModelSelector";

type ChatHeaderProps = {
  isMobile: boolean;
  isTerminal: boolean;
  busy: boolean;
  persistOptIn: boolean;
  sessions: ChatSessionMeta[];
  uploadedImages: UploadedChatImage[];
  onShowSessions: () => void;
  onShowActionSheet: () => void;
  onShowImageDrawer: () => void;
  onTogglePersist: () => void;
  onClearAll: () => void;
  onClose?: () => void;
  // Model selection props
  models?: AIModel[];
  modelsByProvider?: Record<string, AIModel[]>;
  selectedModel?: string;
  currentModel?: AIModel;
  modelsLoading?: boolean;
  modelsError?: string | null;
  onModelSelect?: (modelId: string) => void;
  onModelsRefresh?: () => void;
};

export function ChatHeader({
  isMobile,
  isTerminal,
  busy,
  persistOptIn,
  sessions,
  uploadedImages,
  onShowSessions,
  onShowActionSheet,
  onShowImageDrawer,
  onTogglePersist,
  onClearAll,
  onClose,
  // Model selection props
  models = [],
  modelsByProvider = {},
  selectedModel = '',
  currentModel,
  modelsLoading = false,
  modelsError = null,
  onModelSelect,
  onModelsRefresh,
}: ChatHeaderProps) {
  return (
    <div
      className={cn(
        "flex items-center justify-between border-b px-4 py-3 shrink-0",
        isMobile && "px-4 py-3 safe-area-top",
        isTerminal
          ? "bg-[hsl(var(--terminal-titlebar))] border-border"
          : "bg-background/95 backdrop-blur-sm",
      )}
    >
      {/* Left: Icon + Title */}
      <div className="flex items-center gap-3 min-w-0 flex-1">
        {/* Terminal window controls (PC only) */}
        {isTerminal && !isMobile && (
          <div className="flex items-center gap-1.5 mr-2">
            <span className="w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-close))]" />
            <span className="w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-minimize))]" />
            <span className="w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-maximize))]" />
          </div>
        )}
        <div
          className={cn(
            "flex items-center justify-center rounded-full bg-primary/10 shrink-0",
            isMobile ? "h-9 w-9" : "h-10 w-10",
            isTerminal && "bg-primary/20 rounded-lg",
          )}
        >
          <Sparkles
            className={cn(
              "text-primary",
              isMobile ? "h-4 w-4" : "h-5 w-5",
              isTerminal && "terminal-glow",
            )}
          />
        </div>
        <div className="min-w-0">
          <p
            className={cn(
              "font-semibold truncate",
              isMobile ? "text-sm" : "text-sm",
              isTerminal && "font-mono text-primary",
            )}
          >
            {isTerminal ? ">_ AI Chat" : "AI Chat"}
          </p>
          <p
            className={cn(
              "text-xs text-muted-foreground truncate",
              isTerminal && "font-mono",
            )}
          >
            {busy ? (
              <span className="inline-flex items-center gap-1">
                <Loader2 className="h-3 w-3 animate-spin" /> 생성 중…
              </span>
            ) : persistOptIn ? (
              "기록 저장 ON"
            ) : (
              "기록 저장 OFF"
            )}
          </p>
        </div>
      </div>

      {/* Right: Actions */}
      <div className="flex items-center gap-1 shrink-0">
        {/* Model Selector */}
        {onModelSelect && onModelsRefresh && (
          <ModelSelector
            models={models}
            modelsByProvider={modelsByProvider}
            selectedModel={selectedModel}
            currentModel={currentModel}
            loading={modelsLoading}
            error={modelsError}
            onSelect={onModelSelect}
            onRefresh={onModelsRefresh}
            isMobile={isMobile}
            isTerminal={isTerminal}
            disabled={busy}
          />
        )}

        {/* Options menu */}
        {isMobile ? (
          <Button
            type="button"
            size="icon"
            variant="ghost"
            aria-label="대화 옵션"
            className={cn(
              "h-10 w-10",
              isTerminal && "text-primary hover:bg-primary/10",
            )}
            onClick={onShowActionSheet}
          >
            <MoreVertical className="h-5 w-5" />
          </Button>
        ) : (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                type="button"
                size="icon"
                variant="ghost"
                aria-label="대화 옵션"
                className={cn(
                  "h-9 w-9",
                  isTerminal && "text-primary hover:bg-primary/10",
                )}
              >
                <MoreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-48 text-sm z-[9999]">
              <DropdownMenuItem
                disabled={!sessions.length}
                onSelect={onShowSessions}
              >
                최근 대화 보기
              </DropdownMenuItem>
              <DropdownMenuItem
                disabled={!uploadedImages.length}
                onSelect={onShowImageDrawer}
              >
                이미지 메모 보기
              </DropdownMenuItem>
              <DropdownMenuItem onSelect={onTogglePersist}>
                {persistOptIn ? "기록 저장 끄기" : "기록 저장 켜기"}
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem onSelect={onClearAll}>
                대화 초기화
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        )}

        {/* Close button */}
        {onClose && (
          <Button
            type="button"
            size="icon"
            variant="ghost"
            className={cn(
              isMobile ? "h-10 w-10" : "h-9 w-9",
              isTerminal && "text-primary hover:bg-primary/10",
            )}
            aria-label="창 닫기"
            onClick={onClose}
          >
            <X className={isMobile ? "h-5 w-5" : "h-4 w-4"} />
          </Button>
        )}
      </div>
    </div>
  );
}

```

### ChatInput.tsx

**Path:** `frontend/src/components/features/chat/widget/components/ChatInput.tsx`

```tsx
import React from "react";
import {
  Send,
  Loader2,
  Square,
  Image as ImageIcon,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";
import type { QuestionMode } from "../types";

type ChatInputProps = {
  input: string;
  onInputChange: (value: string) => void;
  onKeyDown: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void;
  onSend: () => void;
  onStop: () => void;
  onClearAll: () => void;
  onFileSelect: (file: File | null) => void;
  attachedImage: File | null;
  attachedPreviewUrl: string | null;
  busy: boolean;
  canSend: boolean;
  firstTokenMs: number | null;
  questionMode: QuestionMode;
  isTerminal: boolean;
  isMobile: boolean;
  textareaRef: React.RefObject<HTMLTextAreaElement>;
  fileInputRef: React.RefObject<HTMLInputElement>;
};

export function ChatInput({
  input,
  onInputChange,
  onKeyDown,
  onSend,
  onStop,
  onClearAll,
  onFileSelect,
  attachedImage,
  attachedPreviewUrl,
  busy,
  canSend,
  firstTokenMs,
  questionMode,
  isTerminal,
  isMobile,
  textareaRef,
  fileInputRef,
}: ChatInputProps) {
  const placeholder =
    questionMode === "article"
      ? "현재 글 내용에 대해 물어보고 싶은 것을 입력하세요..."
      : "자유롭게 궁금한 내용을 입력하세요...";

  return (
    <div
      className={cn(
        "border-t px-4 py-4 shrink-0",
        isMobile && "pb-[calc(1rem+env(safe-area-inset-bottom))]",
        isTerminal
          ? "bg-[hsl(var(--terminal-code-bg))] border-border"
          : "bg-background",
      )}
    >
      {/* New conversation button */}
      <div
        className={cn(
          "flex items-center justify-between mb-3",
          isTerminal && "font-mono",
        )}
      >
        <span
          className={cn(
            "text-xs text-muted-foreground",
            isTerminal && "text-primary/60",
          )}
        >
          {isTerminal ? "# 새 주제 시작" : "새 주제를 시작할 땐"}
        </span>
        <Button
          onClick={onClearAll}
          variant="ghost"
          size="sm"
          className={cn(
            "h-8 px-3 text-xs",
            isTerminal &&
              "font-mono text-primary/80 hover:text-primary hover:bg-primary/10 border border-primary/30",
          )}
        >
          {isTerminal ? "$ clear" : "새 대화"}
        </Button>
      </div>

      {/* Attached image preview */}
      {attachedImage && (
        <AttachedImagePreview
          image={attachedImage}
          previewUrl={attachedPreviewUrl}
          onRemove={() => onFileSelect(null)}
          isTerminal={isTerminal}
        />
      )}

      {/* Input field */}
      {isTerminal ? (
        <TerminalInput
          input={input}
          onInputChange={onInputChange}
          onKeyDown={onKeyDown}
          onSend={onSend}
          onStop={onStop}
          onFileClick={() => fileInputRef.current?.click()}
          busy={busy}
          canSend={canSend}
          firstTokenMs={firstTokenMs}
          questionMode={questionMode}
          isMobile={isMobile}
          textareaRef={textareaRef}
          fileInputRef={fileInputRef}
          onFileSelect={onFileSelect}
        />
      ) : (
        <DefaultInput
          input={input}
          onInputChange={onInputChange}
          onKeyDown={onKeyDown}
          onSend={onSend}
          onStop={onStop}
          onFileClick={() => fileInputRef.current?.click()}
          busy={busy}
          canSend={canSend}
          placeholder={placeholder}
          isMobile={isMobile}
          textareaRef={textareaRef}
          fileInputRef={fileInputRef}
          onFileSelect={onFileSelect}
        />
      )}
    </div>
  );
}

// Attached image preview
function AttachedImagePreview({
  image,
  previewUrl,
  onRemove,
  isTerminal,
}: {
  image: File;
  previewUrl: string | null;
  onRemove: () => void;
  isTerminal: boolean;
}) {
  return (
    <div
      className={cn(
        "flex items-center justify-between gap-3 rounded-xl border px-3 py-2.5 mb-3",
        isTerminal
          ? "rounded-lg border-primary/30 bg-[hsl(var(--terminal-code-bg))] font-mono"
          : "bg-muted/30",
      )}
    >
      <span className="inline-flex items-center gap-3 truncate min-w-0">
        <div
          className={cn(
            "h-10 w-10 flex-shrink-0 overflow-hidden rounded-lg bg-muted",
            isTerminal && "rounded border border-primary/20",
          )}
        >
          {previewUrl ? (
            <img
              src={previewUrl}
              alt={image.name}
              className="h-full w-full object-cover"
            />
          ) : (
            <ImageIcon className="h-5 w-5 mx-auto my-auto text-muted-foreground" />
          )}
        </div>
        <span className="inline-flex min-w-0 flex-col">
          <span className="inline-flex items-center gap-1 truncate text-sm">
            {isTerminal && <span className="text-primary/60">[img]</span>}
            <span className="truncate">{image.name}</span>
          </span>
          <span className="text-xs text-muted-foreground">
            {Math.max(1, Math.round(image.size / 1024))}KB
          </span>
        </span>
      </span>
      <Button
        type="button"
        size="sm"
        variant="ghost"
        className={cn(
          "h-8 px-2 text-xs shrink-0",
          isTerminal && "text-destructive hover:bg-destructive/10",
        )}
        onClick={onRemove}
      >
        {isTerminal ? "[x]" : "제거"}
      </Button>
    </div>
  );
}

// Terminal-style input
function TerminalInput({
  input,
  onInputChange,
  onKeyDown,
  onSend,
  onStop,
  onFileClick,
  busy,
  canSend,
  firstTokenMs,
  questionMode,
  isMobile,
  textareaRef,
  fileInputRef,
  onFileSelect,
}: {
  input: string;
  onInputChange: (value: string) => void;
  onKeyDown: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void;
  onSend: () => void;
  onStop: () => void;
  onFileClick: () => void;
  busy: boolean;
  canSend: boolean;
  firstTokenMs: number | null;
  questionMode: QuestionMode;
  isMobile: boolean;
  textareaRef: React.RefObject<HTMLTextAreaElement>;
  fileInputRef: React.RefObject<HTMLInputElement>;
  onFileSelect: (file: File | null) => void;
}) {
  return (
    <div className="bg-[hsl(var(--terminal-code-bg))] border border-border rounded-lg px-3 py-3">
      <div className="flex items-end gap-2">
        {!isMobile && (
          <span className="text-primary font-mono font-bold select-none shrink-0 py-2 text-sm">
            $
          </span>
        )}
        <Textarea
          value={input}
          onChange={(e) => onInputChange(e.target.value)}
          onKeyDown={onKeyDown}
          rows={isMobile ? 2 : 1}
          placeholder={
            questionMode === "article"
              ? "현재 글에 대해 질문하세요..."
              : "무엇이든 물어보세요..."
          }
          ref={textareaRef}
          className={cn(
            "flex-1 resize-none border-0 bg-transparent px-0 py-2 font-mono text-foreground focus-visible:ring-0 focus-visible:ring-offset-0 placeholder:text-muted-foreground/50 overflow-y-auto",
            isMobile
              ? "text-base min-h-[56px] max-h-[96px]"
              : "text-sm min-h-[40px] max-h-[72px]",
          )}
        />
        <div className="flex items-center gap-2">
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            className="hidden"
            onChange={(e) => {
              const file = e.target.files?.[0] ?? null;
              onFileSelect(file);
            }}
          />
          <Button
            type="button"
            size="icon"
            variant="ghost"
            className={cn(
              "rounded-lg border border-primary/30 text-primary/70 hover:text-primary hover:bg-primary/10 hover:border-primary/50",
              isMobile ? "h-11 w-11" : "h-10 w-10",
            )}
            onClick={onFileClick}
            aria-label="이미지 첨부"
          >
            <ImageIcon className={isMobile ? "h-5 w-5" : "h-4 w-4"} />
          </Button>
          {busy ? (
            <Button
              onClick={onStop}
              size="icon"
              variant="ghost"
              className={cn(
                "rounded-lg border border-destructive/50 text-destructive hover:bg-destructive/10",
                isMobile ? "h-11 w-11" : "h-10 w-10",
              )}
            >
              <Square className={isMobile ? "h-5 w-5" : "h-4 w-4"} />
            </Button>
          ) : (
            <Button
              onClick={onSend}
              disabled={!canSend}
              size="icon"
              className={cn(
                "rounded-lg border border-primary bg-primary/20 text-primary hover:bg-primary/30 disabled:opacity-30",
                isMobile ? "h-11 w-11" : "h-10 w-10",
              )}
            >
              <Send className={isMobile ? "h-5 w-5" : "h-4 w-4"} />
            </Button>
          )}
        </div>
      </div>
      {busy && firstTokenMs != null && (
        <div className="flex items-center gap-2 mt-2 text-xs font-mono text-primary/70">
          <Loader2 className="h-3 w-3 animate-spin" />
          <span>응답 중... (첫 토큰: {firstTokenMs}ms)</span>
        </div>
      )}
    </div>
  );
}

// Default style input
function DefaultInput({
  input,
  onInputChange,
  onKeyDown,
  onSend,
  onStop,
  onFileClick,
  busy,
  canSend,
  placeholder,
  isMobile,
  textareaRef,
  fileInputRef,
  onFileSelect,
}: {
  input: string;
  onInputChange: (value: string) => void;
  onKeyDown: (e: React.KeyboardEvent<HTMLTextAreaElement>) => void;
  onSend: () => void;
  onStop: () => void;
  onFileClick: () => void;
  busy: boolean;
  canSend: boolean;
  placeholder: string;
  isMobile: boolean;
  textareaRef: React.RefObject<HTMLTextAreaElement>;
  fileInputRef: React.RefObject<HTMLInputElement>;
  onFileSelect: (file: File | null) => void;
}) {
  return (
    <div
      className={cn(
        "rounded-2xl border border-border bg-muted/40 px-4 py-3 shadow-sm",
        isMobile && "rounded-xl",
      )}
    >
      <div className="flex items-end gap-3">
        <Textarea
          value={input}
          onChange={(e) => onInputChange(e.target.value)}
          onKeyDown={onKeyDown}
          rows={isMobile ? 2 : 2}
          placeholder={placeholder}
          ref={textareaRef}
          className={cn(
            "flex-1 resize-none border-0 bg-transparent px-0 py-2 focus-visible:ring-0 focus-visible:ring-offset-0 overflow-y-auto",
            isMobile
              ? "text-base min-h-[56px] max-h-[96px]"
              : "text-sm min-h-[52px] max-h-[72px]",
          )}
        />
        <div className="flex items-center gap-2">
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            className="hidden"
            onChange={(e) => {
              const file = e.target.files?.[0] ?? null;
              onFileSelect(file);
            }}
          />
          <Button
            type="button"
            size="icon"
            variant="ghost"
            className={cn(
              "rounded-xl border border-dashed border-muted-foreground/40 text-muted-foreground hover:border-muted-foreground hover:text-foreground",
              isMobile ? "h-12 w-12" : "h-11 w-11",
            )}
            onClick={onFileClick}
            aria-label="이미지 첨부"
          >
            <ImageIcon className={isMobile ? "h-5 w-5" : "h-4 w-4"} />
          </Button>
          {busy ? (
            <Button
              onClick={onStop}
              size="icon"
              variant="secondary"
              className={cn("rounded-xl", isMobile ? "h-12 w-12" : "h-11 w-11")}
            >
              <Square className={isMobile ? "h-5 w-5" : "h-4 w-4"} />
            </Button>
          ) : (
            <Button
              onClick={onSend}
              disabled={!canSend}
              size="icon"
              className={cn(
                "rounded-xl shadow-lg",
                isMobile ? "h-12 w-12" : "h-11 w-11",
              )}
            >
              <Send className={isMobile ? "h-5 w-5" : "h-4 w-4"} />
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}

```

### ChatMessages.tsx

**Path:** `frontend/src/components/features/chat/widget/components/ChatMessages.tsx`

```tsx
import React from "react";
import { Loader2, Terminal, ChevronRight } from "lucide-react";
import { useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import ChatMarkdown from "../../ChatMarkdown";
import { cn } from "@/lib/utils";
import type { ChatMessage, SourceLink } from "../types";
import { extractImageFromMessage, QUICK_PROMPTS } from "../constants";

type ChatMessagesProps = {
  messages: ChatMessage[];
  isTerminal: boolean;
  isMobile: boolean;
  onPromptClick: (prompt: string) => void;
  onRetry: (lastPrompt: string) => void;
  lastPrompt: string;
  onNavigate?: (path: string) => void;
};

export function ChatMessages({
  messages,
  isTerminal,
  isMobile,
  onPromptClick,
  onRetry,
  lastPrompt,
  onNavigate,
}: ChatMessagesProps) {
  const navigate = useNavigate();

  // Handle navigation to internal blog links
  const handleSourceClick = (url: string, e: React.MouseEvent) => {
    // Check if it's an internal blog link
    const currentHost = window.location.host;
    let isInternal = false;
    let internalPath = "";

    try {
      const urlObj = new URL(url, window.location.origin);
      if (urlObj.host === currentHost || url.startsWith("/")) {
        isInternal = true;
        internalPath = urlObj.pathname;
      }
    } catch {
      // If URL parsing fails, check if it's a relative path
      if (url.startsWith("/")) {
        isInternal = true;
        internalPath = url;
      }
    }

    if (isInternal && internalPath) {
      e.preventDefault();
      navigate(internalPath);
      onNavigate?.(internalPath);
    }
  };

  return (
    <>
      {messages.length === 0 && (
        <EmptyState
          isTerminal={isTerminal}
          isMobile={isMobile}
          onPromptClick={onPromptClick}
        />
      )}

      {messages.map((m) => {
        const isUser = m.role === "user";
        const isAssistant = m.role === "assistant";
        const isSystem = m.role === "system";

        // Extract image from user message
        const { imageUrl, cleanText } = isUser
          ? extractImageFromMessage(m.text)
          : { imageUrl: null, cleanText: m.text };

        if (isTerminal) {
          return (
            <TerminalMessage
              key={m.id}
              message={m}
              imageUrl={imageUrl}
              cleanText={cleanText}
              isUser={isUser}
              isAssistant={isAssistant}
              isSystem={isSystem}
              isMobile={isMobile}
              onPromptClick={onPromptClick}
              onRetry={() => onRetry(lastPrompt)}
              lastPrompt={lastPrompt}
              onSourceClick={handleSourceClick}
            />
          );
        }

        return (
          <DefaultMessage
            key={m.id}
            message={m}
            imageUrl={imageUrl}
            cleanText={cleanText}
            isUser={isUser}
            isAssistant={isAssistant}
            isSystem={isSystem}
            isMobile={isMobile}
            onPromptClick={onPromptClick}
            onRetry={() => onRetry(lastPrompt)}
            lastPrompt={lastPrompt}
            onSourceClick={handleSourceClick}
          />
        );
      })}
    </>
  );
}

// Empty state component
function EmptyState({
  isTerminal,
  isMobile,
  onPromptClick,
}: {
  isTerminal: boolean;
  isMobile: boolean;
  onPromptClick: (prompt: string) => void;
}) {
  return (
    <div
      className={cn(
        "space-y-4 rounded-2xl border border-dashed px-4 py-6 text-sm text-muted-foreground",
        isTerminal &&
          "rounded-lg border-primary/30 bg-[hsl(var(--terminal-code-bg))]",
      )}
    >
      {isTerminal ? (
        <>
          <p className="font-mono text-primary/80">
            <span className="text-primary">$</span> ./ai-chat --help
          </p>
          <p className="font-mono text-muted-foreground text-xs leading-relaxed">
            질문을 입력하고 Enter를 눌러 실행하세요.
          </p>
        </>
      ) : (
        <p className="text-center">빠르게 시작하려면 아래 프롬프트를 눌러보세요.</p>
      )}
      <div className={cn("flex flex-wrap gap-2", isMobile && "flex-col")}>
        {QUICK_PROMPTS.map((prompt) => (
          <Button
            key={prompt}
            size="sm"
            variant="secondary"
            className={cn(
              "text-xs justify-start",
              isMobile ? "h-12 px-4 w-full text-sm" : "h-10 px-4",
              isTerminal &&
                "rounded-none border border-primary/40 bg-transparent text-primary hover:bg-primary/20 hover:text-primary font-mono",
            )}
            onClick={() => onPromptClick(prompt)}
          >
            {isTerminal ? `> ${prompt}` : prompt}
          </Button>
        ))}
      </div>
    </div>
  );
}

// Terminal-style message
function TerminalMessage({
  message: m,
  imageUrl,
  cleanText,
  isUser,
  isAssistant,
  isSystem,
  isMobile,
  onPromptClick,
  onRetry,
  lastPrompt,
  onSourceClick,
}: {
  message: ChatMessage;
  imageUrl: string | null;
  cleanText: string;
  isUser: boolean;
  isAssistant: boolean;
  isSystem: boolean;
  isMobile: boolean;
  onPromptClick: (prompt: string) => void;
  onRetry: () => void;
  lastPrompt: string;
  onSourceClick: (url: string, e: React.MouseEvent) => void;
}) {
  return (
    <div className="space-y-2">
      {isUser && (
        <div className="space-y-2">
          <div className="flex items-start gap-2">
            <span className="text-primary font-bold select-none shrink-0 text-sm">
              user@blog:~$
            </span>
            <span className="whitespace-pre-wrap text-foreground break-words text-sm">
              {cleanText ||
                (imageUrl ? "첨부한 이미지에 대해 설명해줘." : m.text)}
            </span>
          </div>
          {imageUrl && <UserImage imageUrl={imageUrl} isTerminal />}
        </div>
      )}
      {isAssistant && (
        <div className="pl-0 border-l-2 border-primary/30 ml-0">
          <div className="flex items-center gap-2 text-xs text-primary/70 mb-2 pl-3">
            <Terminal className="h-3.5 w-3.5" />
            <span>AI Response</span>
            {!m.text.trim() && (
              <span className="inline-flex items-center gap-1 text-muted-foreground">
                <Loader2 className="h-3 w-3 animate-spin" />
                processing...
              </span>
            )}
          </div>
          <div className="pl-3 text-foreground/90 text-sm">
            {m.text.trim() ? (
              <ChatMarkdown content={m.text} />
            ) : (
              <span className="terminal-cursor" />
            )}
          </div>
          <Sources sources={m.sources} isTerminal onSourceClick={onSourceClick} />
          <Followups
            followups={m.followups}
            isTerminal
            isMobile={isMobile}
            onPromptClick={onPromptClick}
          />
        </div>
      )}
      {isSystem && (
        <SystemError
          text={m.text}
          isTerminal
          lastPrompt={lastPrompt}
          onRetry={onRetry}
        />
      )}
    </div>
  );
}

// Default style message
function DefaultMessage({
  message: m,
  imageUrl,
  cleanText,
  isUser,
  isAssistant,
  isSystem,
  isMobile,
  onPromptClick,
  onRetry,
  lastPrompt,
  onSourceClick,
}: {
  message: ChatMessage;
  imageUrl: string | null;
  cleanText: string;
  isUser: boolean;
  isAssistant: boolean;
  isSystem: boolean;
  isMobile: boolean;
  onPromptClick: (prompt: string) => void;
  onRetry: () => void;
  lastPrompt: string;
  onSourceClick: (url: string, e: React.MouseEvent) => void;
}) {
  return (
    <div className={cn("flex", isUser ? "justify-end" : "justify-start")}>
      <div
        className={cn(
          "max-w-full text-sm leading-relaxed px-4 py-3",
          isMobile ? "max-w-[90%] rounded-2xl" : "max-w-[85%] rounded-2xl",
          isUser && "bg-primary text-primary-foreground rounded-br-md",
          isAssistant && "bg-secondary text-secondary-foreground rounded-bl-md",
          isSystem && "bg-destructive/10 text-destructive",
        )}
      >
        {isAssistant ? (
          m.text.trim() ? (
            <ChatMarkdown content={m.text} />
          ) : (
            <div className="flex items-center gap-2 text-sm text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              답변을 준비하고 있어요…
            </div>
          )
        ) : isUser ? (
          <div className="space-y-2">
            <span className="whitespace-pre-wrap">
              {cleanText ||
                (imageUrl ? "첨부한 이미지에 대해 설명해줘." : m.text)}
            </span>
            {imageUrl && <UserImage imageUrl={imageUrl} isTerminal={false} />}
          </div>
        ) : (
          <span className="whitespace-pre-wrap">{m.text}</span>
        )}

        {isAssistant && <Sources sources={m.sources} isTerminal={false} onSourceClick={onSourceClick} />}
        {isAssistant && (
          <Followups
            followups={m.followups}
            isTerminal={false}
            isMobile={isMobile}
            onPromptClick={onPromptClick}
          />
        )}

        {isSystem && lastPrompt && (
          <div className="mt-3">
            <Button
              size="sm"
              variant="ghost"
              className="h-9 text-sm px-3"
              onClick={onRetry}
            >
              다시 시도하기
            </Button>
          </div>
        )}
      </div>
    </div>
  );
}

// User image attachment
function UserImage({
  imageUrl,
  isTerminal,
}: {
  imageUrl: string;
  isTerminal: boolean;
}) {
  if (isTerminal) {
    return (
      <div className="ml-0 mt-2">
        <div className="inline-block rounded border border-primary/30 overflow-hidden max-w-[200px] sm:max-w-[280px]">
          <img
            src={imageUrl}
            alt="첨부 이미지"
            className="w-full h-auto object-contain max-h-[200px]"
            onClick={() => window.open(imageUrl, "_blank")}
            style={{ cursor: "pointer" }}
          />
        </div>
        <div className="text-xs text-primary/60 mt-1 font-mono">
          [img] 클릭하여 원본 보기
        </div>
      </div>
    );
  }

  return (
    <div className="mt-2">
      <div className="inline-block rounded-lg overflow-hidden max-w-[200px] sm:max-w-[240px] border border-primary-foreground/20">
        <img
          src={imageUrl}
          alt="첨부 이미지"
          className="w-full h-auto object-contain max-h-[180px]"
          onClick={() => window.open(imageUrl, "_blank")}
          style={{ cursor: "pointer" }}
        />
      </div>
    </div>
  );
}

// Sources component
function Sources({
  sources,
  isTerminal,
  onSourceClick,
}: {
  sources?: SourceLink[];
  isTerminal: boolean;
  onSourceClick: (url: string, e: React.MouseEvent) => void;
}) {
  if (!Array.isArray(sources) || sources.length === 0) return null;

  if (isTerminal) {
    return (
      <div className="mt-3 pl-3 text-xs">
        <span className="text-primary/60"># Sources:</span>
        <ul className="mt-1 space-y-1">
          {sources.map((s, i) => (
            <li key={i} className="text-muted-foreground">
              <span className="text-primary/50">[{i + 1}]</span>{" "}
              {s.url ? (
                <a
                  className="underline decoration-dotted hover:text-primary cursor-pointer"
                  href={s.url}
                  onClick={(e) => onSourceClick(s.url!, e)}
                >
                  {s.title || s.url}
                </a>
              ) : (
                <span>{s.title || "출처"}</span>
              )}
            </li>
          ))}
        </ul>
      </div>
    );
  }

  return (
    <div className="mt-3 space-y-1.5">
      <div className="text-xs text-muted-foreground font-medium">참고한 출처</div>
      <ul className="text-sm list-disc pl-4 space-y-1">
        {sources.map((s, i) => (
          <li key={i}>
            {s.url ? (
              <a
                className="underline text-primary cursor-pointer"
                href={s.url}
                onClick={(e) => onSourceClick(s.url!, e)}
              >
                {s.title || s.url}
              </a>
            ) : (
              <span>{s.title || "출처"}</span>
            )}
          </li>
        ))}
      </ul>
    </div>
  );
}

// Followups component
function Followups({
  followups,
  isTerminal,
  isMobile,
  onPromptClick,
}: {
  followups?: string[];
  isTerminal: boolean;
  isMobile: boolean;
  onPromptClick: (prompt: string) => void;
}) {
  if (!Array.isArray(followups) || followups.length === 0) return null;

  if (isTerminal) {
    return (
      <div className="mt-3 pl-3">
        <span className="text-xs text-primary/60"># 연관 질문:</span>
        <div className={cn("flex gap-2 mt-2", isMobile ? "flex-col" : "flex-wrap")}>
          {followups.map((q, i) => (
            <button
              key={i}
              className={cn(
                "text-xs text-primary/80 hover:text-primary border border-primary/30 hover:bg-primary/10 transition-colors text-left",
                isMobile ? "px-4 py-3" : "px-3 py-2",
              )}
              onClick={() => onPromptClick(q)}
            >
              <ChevronRight className="inline h-3 w-3 -ml-0.5 mr-1" />
              {q}
            </button>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="mt-3">
      <div className="text-xs text-muted-foreground font-medium mb-2">
        연관 질문
      </div>
      <div className={cn("flex gap-2", isMobile ? "flex-col" : "flex-wrap")}>
        {followups.map((q, i) => (
          <Button
            key={i}
            size="sm"
            variant="secondary"
            className={cn(
              "text-xs justify-start",
              isMobile ? "h-12 px-4 w-full text-sm" : "h-10 px-4",
            )}
            onClick={() => onPromptClick(q)}
          >
            {q}
          </Button>
        ))}
      </div>
    </div>
  );
}

// System error component
function SystemError({
  text,
  isTerminal,
  lastPrompt,
  onRetry,
}: {
  text: string;
  isTerminal: boolean;
  lastPrompt: string;
  onRetry: () => void;
}) {
  if (isTerminal) {
    return (
      <div className="flex items-start gap-2 text-destructive">
        <span className="font-bold select-none shrink-0">[ERROR]</span>
        <span className="whitespace-pre-wrap break-words text-sm">{text}</span>
        {lastPrompt && (
          <button
            className="text-xs underline ml-2 hover:text-destructive/80"
            onClick={onRetry}
          >
            retry
          </button>
        )}
      </div>
    );
  }

  return null; // Default style handles this inline
}

```

### ChatSessionPanel.tsx

**Path:** `frontend/src/components/features/chat/widget/components/ChatSessionPanel.tsx`

```tsx
import React from "react";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import type { ChatSessionMeta, QuestionMode } from "../types";

type ChatSessionPanelProps = {
  sessions: ChatSessionMeta[];
  selectedSessionIds: string[];
  onToggleSession: (id: string) => void;
  onLoadSession: (id: string) => void;
  onClose: () => void;
  onAggregateSelected: () => void;
  isTerminal: boolean;
  isMobile: boolean;
};

export function ChatSessionPanel({
  sessions,
  selectedSessionIds,
  onToggleSession,
  onLoadSession,
  onClose,
  onAggregateSelected,
  isTerminal,
  isMobile,
}: ChatSessionPanelProps) {
  if (sessions.length === 0) return null;

  return (
    <div
      className={cn(
        "border-b shrink-0",
        isTerminal
          ? "bg-[hsl(var(--terminal-code-bg))] border-border"
          : "bg-muted/40",
      )}
    >
      <div
        className={cn(
          "px-4 pt-3 max-h-48 overflow-y-auto space-y-2",
          isMobile && "px-4",
        )}
      >
        {sessions.map((s) => {
          const checked = selectedSessionIds.includes(s.id);
          return (
            <div
              key={s.id}
              className={cn(
                "flex items-center gap-3 px-3 py-2.5 rounded-lg transition-colors",
                isTerminal
                  ? "border border-primary/20 hover:border-primary/40 hover:bg-primary/5"
                  : "border hover:bg-muted",
              )}
            >
              <input
                type="checkbox"
                className={cn("h-4 w-4 rounded", isTerminal && "accent-primary")}
                checked={checked}
                onChange={() => onToggleSession(s.id)}
              />
              <button
                type="button"
                className="flex-1 text-left min-w-0"
                onClick={() => {
                  onLoadSession(s.id);
                  onClose();
                }}
              >
                <div
                  className={cn(
                    "truncate font-medium text-sm",
                    isTerminal && "font-mono text-foreground",
                  )}
                >
                  {s.title || "제목 없음"}
                </div>
                <div className="flex items-center gap-2 text-xs text-muted-foreground truncate mt-0.5">
                  {s.articleTitle && (
                    <span className="truncate max-w-[120px]">
                      {s.articleTitle}
                    </span>
                  )}
                  <span className="shrink-0">
                    {new Date(s.updatedAt).toLocaleDateString()}
                  </span>
                </div>
              </button>
            </div>
          );
        })}
      </div>
      <div
        className={cn(
          "px-4 py-3 border-t flex items-center justify-between",
          isTerminal && "border-border",
        )}
      >
        <span
          className={cn("text-xs text-muted-foreground", isTerminal && "font-mono")}
        >
          선택: {selectedSessionIds.length}개
        </span>
        <Button
          type="button"
          size="sm"
          className={cn(
            "h-8 px-3 text-xs",
            isTerminal &&
              "bg-primary/20 text-primary border border-primary/40 hover:bg-primary/30",
          )}
          disabled={!selectedSessionIds.length}
          onClick={onAggregateSelected}
        >
          통합 질문하기
        </Button>
      </div>
    </div>
  );
}

type ModeSelectorProps = {
  questionMode: QuestionMode;
  onModeChange: (mode: QuestionMode) => void;
  isTerminal: boolean;
  isMobile: boolean;
};

export function ModeSelector({
  questionMode,
  onModeChange,
  isTerminal,
  isMobile,
}: ModeSelectorProps) {
  return (
    <div
      className={cn(
        "flex items-center justify-between border-b px-4 py-2 shrink-0",
        isTerminal
          ? "border-border font-mono bg-[hsl(var(--terminal-code-bg))]"
          : "bg-background/50",
      )}
    >
      <span
        className={cn(
          "text-xs text-muted-foreground truncate max-w-[50%]",
          isTerminal && "font-mono",
        )}
      >
        {isTerminal ? (
          questionMode === "article" ? (
            <>
              <span className="text-primary/60">mode:</span>{" "}
              <span className="text-primary">article</span>
            </>
          ) : (
            <>
              <span className="text-primary/60">mode:</span>{" "}
              <span className="text-primary">general</span>
            </>
          )
        ) : questionMode === "article" ? (
          `현재 글 기반`
        ) : (
          "일반 대화"
        )}
      </span>
      <div
        className={cn(
          "inline-flex rounded-full border bg-muted/60 p-0.5",
          isTerminal && "rounded-none bg-transparent border-primary/30",
        )}
      >
        <Button
          size="sm"
          type="button"
          variant={questionMode === "article" ? "secondary" : "ghost"}
          className={cn(
            "h-7 px-3 text-xs",
            isMobile && "h-8 px-4",
            isTerminal && "rounded-none font-mono",
            isTerminal &&
              questionMode === "article" &&
              "bg-primary/20 text-primary",
            isTerminal &&
              questionMode !== "article" &&
              "text-muted-foreground hover:text-primary hover:bg-primary/10",
          )}
          onClick={() => onModeChange("article")}
        >
          {isTerminal ? "--article" : "현재 글"}
        </Button>
        <Button
          size="sm"
          type="button"
          variant={questionMode === "general" ? "secondary" : "ghost"}
          className={cn(
            "h-7 px-3 text-xs",
            isMobile && "h-8 px-4",
            isTerminal && "rounded-none font-mono",
            isTerminal &&
              questionMode === "general" &&
              "bg-primary/20 text-primary",
            isTerminal &&
              questionMode !== "general" &&
              "text-muted-foreground hover:text-primary hover:bg-primary/10",
          )}
          onClick={() => onModeChange("general")}
        >
          {isTerminal ? "--general" : "일반"}
        </Button>
      </div>
    </div>
  );
}

```

### ModelSelector.tsx

**Path:** `frontend/src/components/features/chat/widget/components/ModelSelector.tsx`

```tsx
import React from 'react';
import { ChevronDown, Cpu, Loader2, RefreshCw } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { cn } from '@/lib/utils';
import type { AIModel } from '../hooks/useModels';

type ModelSelectorProps = {
  models: AIModel[];
  modelsByProvider: Record<string, AIModel[]>;
  selectedModel: string;
  currentModel?: AIModel;
  loading: boolean;
  error: string | null;
  onSelect: (modelId: string) => void;
  onRefresh: () => void;
  isMobile?: boolean;
  isTerminal?: boolean;
  disabled?: boolean;
};

// Provider icons/colors
const providerStyles: Record<string, { color: string; bgColor: string }> = {
  Google: { color: 'text-blue-600', bgColor: 'bg-blue-100 dark:bg-blue-900/30' },
  OpenAI: { color: 'text-green-600', bgColor: 'bg-green-100 dark:bg-green-900/30' },
  Anthropic: { color: 'text-orange-600', bgColor: 'bg-orange-100 dark:bg-orange-900/30' },
  Local: { color: 'text-purple-600', bgColor: 'bg-purple-100 dark:bg-purple-900/30' },
  Alias: { color: 'text-gray-500', bgColor: 'bg-gray-100 dark:bg-gray-800/50' },
};

function getProviderStyle(provider: string) {
  return providerStyles[provider] || { color: 'text-gray-600', bgColor: 'bg-gray-100' };
}

export function ModelSelector({
  models,
  modelsByProvider,
  selectedModel,
  currentModel,
  loading,
  error,
  onSelect,
  onRefresh,
  isMobile = false,
  isTerminal = false,
  disabled = false,
}: ModelSelectorProps) {
  const providerOrder = ['Google', 'OpenAI', 'Anthropic', 'Local', 'Alias'];
  const sortedProviders = Object.keys(modelsByProvider).sort((a, b) => {
    const aIndex = providerOrder.indexOf(a);
    const bIndex = providerOrder.indexOf(b);
    if (aIndex === -1 && bIndex === -1) return a.localeCompare(b);
    if (aIndex === -1) return 1;
    if (bIndex === -1) return -1;
    return aIndex - bIndex;
  });

  const displayName = currentModel?.name || selectedModel || 'Select Model';
  const displayProvider = currentModel?.provider;

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="ghost"
          size="sm"
          disabled={disabled || loading}
          className={cn(
            'h-7 px-2 gap-1.5 text-xs font-normal',
            isTerminal && 'font-mono text-primary hover:bg-primary/10',
            isMobile && 'h-8 px-3'
          )}
        >
          {loading ? (
            <Loader2 className="h-3 w-3 animate-spin" />
          ) : (
            <Cpu className="h-3 w-3" />
          )}
          <span className="max-w-[100px] truncate">
            {displayName}
          </span>
          <ChevronDown className="h-3 w-3 opacity-50" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent
        align="start"
        className={cn(
          'w-56 max-h-80 overflow-y-auto z-[9999]',
          isTerminal && 'font-mono'
        )}
      >
        {/* Error state */}
        {error && (
          <>
            <div className="px-2 py-1.5 text-xs text-destructive">
              {error}
            </div>
            <DropdownMenuSeparator />
          </>
        )}

        {/* Grouped models by provider */}
        {sortedProviders.map((provider, idx) => {
          const providerModels = modelsByProvider[provider];
          if (!providerModels?.length) return null;

          const style = getProviderStyle(provider);

          return (
            <React.Fragment key={provider}>
              {idx > 0 && <DropdownMenuSeparator />}
              <DropdownMenuLabel className="text-xs font-normal text-muted-foreground">
                {provider}
              </DropdownMenuLabel>
              {providerModels.map((model) => (
                <DropdownMenuItem
                  key={model.id}
                  onSelect={() => onSelect(model.id)}
                  className={cn(
                    'flex items-center gap-2 cursor-pointer',
                    selectedModel === model.id && 'bg-accent'
                  )}
                >
                  <div
                    className={cn(
                      'w-2 h-2 rounded-full shrink-0',
                      style.bgColor
                    )}
                  />
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-1.5">
                      <span className="truncate text-sm">{model.name}</span>
                      {model.isDefault && (
                        <span className="text-[10px] px-1 py-0.5 rounded bg-primary/10 text-primary shrink-0">
                          default
                        </span>
                      )}
                    </div>
                    {model.description && (
                      <p className="text-xs text-muted-foreground truncate">
                        {model.description}
                      </p>
                    )}
                  </div>
                </DropdownMenuItem>
              ))}
            </React.Fragment>
          );
        })}

        {/* Refresh button */}
        <DropdownMenuSeparator />
        <DropdownMenuItem
          onSelect={(e) => {
            e.preventDefault();
            onRefresh();
          }}
          className="flex items-center gap-2 text-muted-foreground"
        >
          <RefreshCw className={cn('h-3 w-3', loading && 'animate-spin')} />
          <span className="text-xs">Refresh models</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

### index.ts

**Path:** `frontend/src/components/features/chat/widget/components/index.ts`

```typescript
export { ChatHeader } from "./ChatHeader";
export { ChatSessionPanel, ModeSelector } from "./ChatSessionPanel";
export { ChatMessages } from "./ChatMessages";
export { ChatInput } from "./ChatInput";
export { ImageDrawer, MobileActionSheet } from "./ChatDialogs";
export { ModelSelector } from "./ModelSelector";

```

---

## frontend/src/components/features/chat/widget/hooks

### index.ts

**Path:** `frontend/src/components/features/chat/widget/hooks/index.ts`

```typescript
export { useChatState } from "./useChatState";
export { useChatSession } from "./useChatSession";
export { useChatActions } from "./useChatActions";
export { useKeyboardHeight, useInputKeyDown } from "./useChatKeyboard";
export { useModels } from "./useModels";
export type { AIModel, ModelsResponse } from "./useModels";

```

### useChatActions.ts

**Path:** `frontend/src/components/features/chat/widget/hooks/useChatActions.ts`

```typescript
import { useCallback, useRef } from "react";
import type { ChatMessage, UploadedChatImage } from "../types";
import {
  streamChatEvents,
  uploadChatImage,
  invokeChatAggregate,
} from "@/services/chat";
import { getRAGContextForChat } from "@/services/rag";
import { getMemoryContextForChat, extractAndSaveMemories } from "@/services/memory";
import { CURRENT_SESSION_KEY, generateSessionKey } from "../constants";

type UseChatActionsProps = {
  canSend: boolean;
  input: string;
  setInput: (input: string) => void;
  attachedImage: File | null;
  setAttachedImage: (file: File | null) => void;
  setAttachedPreviewUrl: (url: string | null) => void;
  busy: boolean;
  setBusy: (busy: boolean) => void;
  setFirstTokenMs: (ms: number | null) => void;
  abortRef: React.MutableRefObject<AbortController | null>;
  push: (msg: ChatMessage) => void;
  setMessages: React.Dispatch<React.SetStateAction<ChatMessage[]>>;
  isAggregatePrompt: boolean;
  setIsAggregatePrompt: (value: boolean) => void;
  questionMode: "article" | "general";
  lastPromptRef: React.MutableRefObject<string>;
  uploadedImages: UploadedChatImage[];
  setUploadedImages: React.Dispatch<React.SetStateAction<UploadedChatImage[]>>;
  messages: ChatMessage[];
  setSessionKey: (key: string) => void;
  selectedModel?: string;
};

export function useChatActions({
  canSend,
  input,
  setInput,
  attachedImage,
  setAttachedImage,
  setAttachedPreviewUrl,
  busy,
  setBusy,
  setFirstTokenMs,
  abortRef,
  push,
  setMessages,
  isAggregatePrompt,
  setIsAggregatePrompt,
  questionMode,
  lastPromptRef,
  uploadedImages,
  setUploadedImages,
  messages,
  setSessionKey,
  selectedModel,
}: UseChatActionsProps) {
  const send = useCallback(async () => {
    if (!canSend) return;
    const trimmed = input.trim();
    const imageToUpload = attachedImage;

    setBusy(true);
    setFirstTokenMs(null);
    abortRef.current?.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    let aiId: string | null = null;

    try {
      let uploaded: {
        url: string;
        key: string;
        size: number;
        contentType: string;
        imageAnalysis?: string | null;
      } | null = null;

      if (imageToUpload) {
        uploaded = await uploadChatImage(imageToUpload, controller.signal);
      }

      const baseText =
        trimmed || (imageToUpload ? "첨부한 이미지에 대해 설명해줘." : "");

      const lines: string[] = [baseText];

      if (uploaded && imageToUpload) {
        const sizeKb = Math.max(1, Math.round(uploaded.size / 1024));
        lines.push(
          "",
          "[첨부 이미지]",
          `URL: ${uploaded.url}`,
          `파일명: ${imageToUpload.name}`,
          `크기: ${sizeKb}KB`,
        );

        // Show AI image analysis result if available
        if (uploaded.imageAnalysis) {
          lines.push(
            "",
            "📷 **AI 이미지 분석:**",
            uploaded.imageAnalysis,
          );
        }

        const entry: UploadedChatImage = {
          id: `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
          url: uploaded.url,
          name: imageToUpload.name,
          size: uploaded.size,
        };
        setUploadedImages((prev) => [entry, ...prev].slice(0, 12));
      }

      const text = lines.join("\n");
      lastPromptRef.current = text;
      const id = `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      setInput("");
      setAttachedImage(null);
      setAttachedPreviewUrl(null);
      push({ id, role: "user", text });
      aiId = `${id}_ai`;

      if (isAggregatePrompt) {
        setIsAggregatePrompt(false);
        const aggregated = await invokeChatAggregate({
          prompt: text,
          signal: controller.signal,
        });
        push({ id: aiId, role: "assistant", text: aggregated });
      } else {
        // Fetch RAG context and memory context in parallel
        let ragContext: string | null = null;
        let memoryContext: string | null = null;

        const contextPromises: Promise<void>[] = [];

        // RAG context for general (blog-wide) questions
        if (questionMode === "general") {
          contextPromises.push(
            getRAGContextForChat(baseText, 2000)
              .then((ctx) => {
                ragContext = ctx;
              })
              .catch(() => {
                // RAG search failed, continue without context
              }),
          );
        }

        // User memory context (always fetch when available)
        contextPromises.push(
          getMemoryContextForChat(baseText, 5)
            .then((ctx) => {
              memoryContext = ctx;
            })
            .catch(() => {
              // Memory search failed, continue without context
            }),
        );

        // Wait for all context fetches
        await Promise.all(contextPromises);

        let acc = "";
        push({ id: aiId, role: "assistant", text: "" });
        for await (const ev of streamChatEvents({
          text: baseText,
          signal: controller.signal,
          onFirstToken: (ms) => setFirstTokenMs(ms),
          useArticleContext: questionMode === "article",
          imageUrl: uploaded?.url,
          imageAnalysis: uploaded?.imageAnalysis,
          ragContext,
          memoryContext,
          model: selectedModel,
        })) {
          if (ev.type === "text") {
            acc += ev.text;
            setMessages((prev) =>
              prev.map((m) => (m.id === aiId ? { ...m, text: acc } : m)),
            );
          } else if (ev.type === "sources") {
            setMessages((prev) =>
              prev.map((m) =>
                m.id === aiId ? { ...m, sources: ev.sources } : m,
              ),
            );
          } else if (ev.type === "followups") {
            setMessages((prev) =>
              prev.map((m) =>
                m.id === aiId ? { ...m, followups: ev.questions } : m,
              ),
            );
          }
        }

        // Extract and save memories from conversation (fire and forget)
        if (acc) {
          extractAndSaveMemories(baseText, acc).catch(() => {
            // Silent fail - memory extraction is optional
          });
        }
      }
    } catch (e: any) {
      const msg = e?.message || "Chat failed";
      const errId =
        aiId != null
          ? `${aiId}_err`
          : `${Date.now()}_${Math.random().toString(36).slice(2, 8)}_err`;
      push({ id: errId, role: "system", text: msg });
    } finally {
      setBusy(false);
    }
  }, [
    canSend,
    input,
    attachedImage,
    setBusy,
    setFirstTokenMs,
    abortRef,
    push,
    setInput,
    setAttachedImage,
    setAttachedPreviewUrl,
    isAggregatePrompt,
    setIsAggregatePrompt,
    questionMode,
    lastPromptRef,
    setUploadedImages,
    setMessages,
    selectedModel,
  ]);

  const stop = useCallback(() => {
    abortRef.current?.abort();
  }, [abortRef]);

  const clearAll = useCallback(() => {
    if (messages.length > 0) {
      if (!window.confirm("대화를 삭제할까요?")) return;
    }
    setMessages([]);
    setFirstTokenMs(null);
    setAttachedImage(null);
    setAttachedPreviewUrl(null);
    setUploadedImages([]);
    setIsAggregatePrompt(false);
    const nextKey = generateSessionKey();
    setSessionKey(nextKey);
    try {
      localStorage.setItem(CURRENT_SESSION_KEY, nextKey);
    } catch {}
  }, [
    messages.length,
    setMessages,
    setFirstTokenMs,
    setAttachedImage,
    setAttachedPreviewUrl,
    setUploadedImages,
    setIsAggregatePrompt,
    setSessionKey,
  ]);

  return { send, stop, clearAll };
}

```

### useChatKeyboard.ts

**Path:** `frontend/src/components/features/chat/widget/hooks/useChatKeyboard.ts`

```typescript
import { useCallback, useEffect, useState } from "react";

export function useKeyboardHeight(isMobile: boolean) {
  const [keyboardHeight, setKeyboardHeight] = useState(0);

  useEffect(() => {
    if (!isMobile || typeof window === "undefined") return;

    const vv = window.visualViewport;
    if (!vv) return;

    const handleResize = () => {
      // When keyboard is up, visualViewport.height decreases
      const heightDiff = window.innerHeight - vv.height;
      setKeyboardHeight(heightDiff > 100 ? heightDiff : 0);
    };

    vv.addEventListener("resize", handleResize);
    vv.addEventListener("scroll", handleResize);

    return () => {
      vv.removeEventListener("resize", handleResize);
      vv.removeEventListener("scroll", handleResize);
    };
  }, [isMobile]);

  return keyboardHeight;
}

type UseInputKeyDownProps = {
  canSend: boolean;
  send: () => void;
};

export function useInputKeyDown({ canSend, send }: UseInputKeyDownProps) {
  const onKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        if (canSend) void send();
      }
    },
    [canSend, send],
  );

  return onKeyDown;
}

```

### useChatSession.ts

**Path:** `frontend/src/components/features/chat/widget/hooks/useChatSession.ts`

```typescript
import { useCallback, useEffect } from "react";
import type { ChatMessage, ChatSessionMeta, QuestionMode } from "../types";
import {
  CHAT_SESSIONS_INDEX_KEY,
  CHAT_SESSION_STORAGE_PREFIX,
  CURRENT_SESSION_KEY,
  generateSessionKey,
} from "../constants";

type UseChatSessionProps = {
  sessionKey: string;
  setSessionKey: (key: string) => void;
  sessions: ChatSessionMeta[];
  setSessions: React.Dispatch<React.SetStateAction<ChatSessionMeta[]>>;
  messages: ChatMessage[];
  setMessages: React.Dispatch<React.SetStateAction<ChatMessage[]>>;
  persistOptIn: boolean;
  questionMode: QuestionMode;
  summary: string;
  pageTitle: string;
  setFirstTokenMs: (ms: number | null) => void;
  setAttachedImage: (file: File | null) => void;
  setIsAggregatePrompt: (value: boolean) => void;
  setShowSessions: (value: boolean) => void;
  selectedSessionIds: string[];
  setSelectedSessionIds: React.Dispatch<React.SetStateAction<string[]>>;
  setInput: (input: string) => void;
};

export function useChatSession({
  sessionKey,
  setSessionKey,
  sessions,
  setSessions,
  messages,
  setMessages,
  persistOptIn,
  questionMode,
  summary,
  pageTitle,
  setFirstTokenMs,
  setAttachedImage,
  setIsAggregatePrompt,
  setShowSessions,
  selectedSessionIds,
  setSelectedSessionIds,
  setInput,
}: UseChatSessionProps) {
  const loadSession = useCallback(
    (id: string) => {
      try {
        const raw = localStorage.getItem(`${CHAT_SESSION_STORAGE_PREFIX}${id}`);
        if (raw) {
          const parsed = JSON.parse(raw) as ChatMessage[];
          if (Array.isArray(parsed)) {
            setMessages(parsed);
          } else {
            setMessages([]);
          }
        } else {
          setMessages([]);
        }
        setFirstTokenMs(null);
        setAttachedImage(null);
        setSessionKey(id);
        try {
          localStorage.setItem(CURRENT_SESSION_KEY, id);
        } catch {}
      } catch {
        setMessages([]);
      }
    },
    [setMessages, setFirstTokenMs, setAttachedImage, setSessionKey],
  );

  const toggleSessionSelected = useCallback(
    (id: string) => {
      setSelectedSessionIds((prev) =>
        prev.includes(id) ? prev.filter((x) => x !== id) : [...prev, id],
      );
    },
    [setSelectedSessionIds],
  );

  const aggregateFromSessionIds = useCallback(
    (ids: string[]) => {
      const uniqueIds = Array.from(new Set(ids));
      if (!uniqueIds.length) return;
      const lines: string[] = ["[참조 세션 요약]"];

      uniqueIds.forEach((id, idx) => {
        const s = sessions.find((x) => x.id === id);
        if (!s) return;
        const title = s.title || s.articleTitle || `세션 ${idx + 1}`;
        const summaryText = s.summary || "(요약 없음)";
        lines.push(`${idx + 1}) ${title}`, summaryText, "");
      });

      lines.push(
        "---",
        "위 세션들을 모두 고려해서 다음 질문에 답해줘.",
        "",
        "(여기에 이어서 궁금한 점을 적어 주세요...)",
      );

      setInput(lines.join("\n"));
      setShowSessions(false);
      setSelectedSessionIds([]);
      setIsAggregatePrompt(true);
    },
    [
      sessions,
      setInput,
      setShowSessions,
      setSelectedSessionIds,
      setIsAggregatePrompt,
    ],
  );

  const handleAggregateFromSelected = useCallback(() => {
    if (!selectedSessionIds.length) return;
    aggregateFromSessionIds(selectedSessionIds);
  }, [aggregateFromSessionIds, selectedSessionIds]);

  // Listen for external aggregate events
  useEffect(() => {
    const handler = (ev: Event) => {
      const detail = (ev as CustomEvent<{ sessionIds?: string[] }>).detail;
      const ids = detail?.sessionIds;
      if (!Array.isArray(ids) || !ids.length) return;
      const filtered = ids.filter((id) => typeof id === "string");
      if (!filtered.length) return;
      aggregateFromSessionIds(filtered);
    };
    window.addEventListener(
      "aiChat:aggregateFromGraph",
      handler as EventListener,
    );
    return () => {
      window.removeEventListener(
        "aiChat:aggregateFromGraph",
        handler as EventListener,
      );
    };
  }, [aggregateFromSessionIds]);

  // Update session index when messages change
  useEffect(() => {
    if (!persistOptIn || !sessionKey) return;
    if (messages.length === 0) return;

    const nowIso = new Date().toISOString();
    const firstUser = messages.find((m) => m.role === "user" && m.text.trim());
    const baseTitle = (firstUser?.text || pageTitle || "새 대화")
      .split("\n")[0]
      .trim();
    const title =
      baseTitle.length > 60 ? `${baseTitle.slice(0, 60)}…` : baseTitle;
    const articleUrl =
      typeof window !== "undefined" ? window.location.href : undefined;

    setSessions((prev) => {
      const existing = prev.find((s) => s.id === sessionKey);
      const createdAt = existing?.createdAt || nowIso;
      const next: ChatSessionMeta = {
        id: sessionKey,
        title: existing?.title || title,
        summary,
        createdAt,
        updatedAt: nowIso,
        messageCount: messages.length,
        mode: questionMode,
        articleUrl: articleUrl || existing?.articleUrl,
        articleTitle: pageTitle || existing?.articleTitle,
      };
      const others = prev.filter((s) => s.id !== sessionKey);
      const updated = [next, ...others];
      try {
        localStorage.setItem(CHAT_SESSIONS_INDEX_KEY, JSON.stringify(updated));
        if (typeof window !== "undefined") {
          try {
            window.dispatchEvent(new CustomEvent("aiChat:sessionsUpdated"));
          } catch {}
        }
      } catch {}
      return updated;
    });
  }, [messages, summary, questionMode, pageTitle, persistOptIn, sessionKey, setSessions]);

  return {
    loadSession,
    toggleSessionSelected,
    aggregateFromSessionIds,
    handleAggregateFromSelected,
  };
}

```

### useChatState.ts

**Path:** `frontend/src/components/features/chat/widget/hooks/useChatState.ts`

```typescript
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import type {
  ChatMessage,
  ChatSessionMeta,
  UploadedChatImage,
  QuestionMode,
} from "../types";
import {
  CHAT_SESSIONS_INDEX_KEY,
  CHAT_SESSION_STORAGE_PREFIX,
  CURRENT_SESSION_KEY,
  PERSIST_OPTIN_KEY,
  generateSessionKey,
} from "../constants";
import {
  streamChatEvents,
  ensureSession,
  uploadChatImage,
  invokeChatAggregate,
} from "@/services/chat";

export function useChatState(options?: { initialMessage?: string }) {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState(options?.initialMessage || "");
  const [busy, setBusy] = useState(false);
  const [persistOptIn, setPersistOptIn] = useState<boolean>(true);
  const [sessionId, setSessionId] = useState<string>("");
  const [sessionKey, setSessionKey] = useState<string>(() => {
    if (typeof window === "undefined") return "";
    try {
      const existing = window.localStorage.getItem(CURRENT_SESSION_KEY);
      if (existing && existing.trim()) return existing;
    } catch {}
    const fresh = generateSessionKey();
    try {
      window.localStorage.setItem(CURRENT_SESSION_KEY, fresh);
    } catch {}
    return fresh;
  });
  const [sessions, setSessions] = useState<ChatSessionMeta[]>([]);
  const [showSessions, setShowSessions] = useState(false);
  const [showImageDrawer, setShowImageDrawer] = useState(false);
  const [showActionSheet, setShowActionSheet] = useState(false);
  const [selectedSessionIds, setSelectedSessionIds] = useState<string[]>([]);
  const [isAggregatePrompt, setIsAggregatePrompt] = useState(false);
  const [firstTokenMs, setFirstTokenMs] = useState<number | null>(null);
  const [questionMode, setQuestionMode] = useState<QuestionMode>("article");
  const [attachedImage, setAttachedImage] = useState<File | null>(null);
  const [attachedPreviewUrl, setAttachedPreviewUrl] = useState<string | null>(
    null,
  );
  const [uploadedImages, setUploadedImages] = useState<UploadedChatImage[]>([]);

  const scrollRef = useRef<HTMLDivElement | null>(null);
  const abortRef = useRef<AbortController | null>(null);
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement | null>(null);
  const lastPromptRef = useRef<string>("");

  const canSend =
    (input.trim().length > 0 || attachedImage !== null) && !busy;

  // Auto-scroll on new messages
  useEffect(() => {
    const sc = scrollRef.current;
    if (!sc) return;
    sc.scrollTop = sc.scrollHeight + 1000;
  }, [messages, busy]);

  // Load persist opt-in preference
  useEffect(() => {
    const v =
      typeof window !== "undefined"
        ? window.localStorage.getItem(PERSIST_OPTIN_KEY)
        : null;
    setPersistOptIn(v !== "0");
  }, []);

  // Load sessions index
  useEffect(() => {
    if (typeof window === "undefined") return;
    try {
      const raw = window.localStorage.getItem(CHAT_SESSIONS_INDEX_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) setSessions(parsed);
    } catch {}
  }, []);

  // Ensure session ID
  useEffect(() => {
    ensureSession()
      .then((id) => setSessionId(id))
      .catch(() => {});
  }, []);

  // Load messages for current session
  useEffect(() => {
    if (!persistOptIn || !sessionKey) return;
    try {
      const raw = localStorage.getItem(
        `${CHAT_SESSION_STORAGE_PREFIX}${sessionKey}`,
      );
      if (raw) {
        const parsed = JSON.parse(raw) as ChatMessage[];
        if (Array.isArray(parsed)) setMessages(parsed);
      } else {
        setMessages([]);
      }
    } catch {}
  }, [persistOptIn, sessionKey]);

  // Save messages on change
  useEffect(() => {
    if (!persistOptIn || !sessionKey) return;
    try {
      localStorage.setItem(
        `${CHAT_SESSION_STORAGE_PREFIX}${sessionKey}`,
        JSON.stringify(messages),
      );
    } catch {}
  }, [messages, persistOptIn, sessionKey]);

  // Handle attached image preview
  useEffect(() => {
    if (!attachedImage) {
      setAttachedPreviewUrl(null);
      return;
    }
    let url: string | null = null;
    try {
      url = URL.createObjectURL(attachedImage);
      setAttachedPreviewUrl(url);
    } catch {
      setAttachedPreviewUrl(null);
    }
    return () => {
      if (url) {
        try {
          URL.revokeObjectURL(url);
        } catch {}
      }
    };
  }, [attachedImage]);

  const push = useCallback((msg: ChatMessage) => {
    setMessages((prev) => [...prev, msg]);
  }, []);

  const togglePersistStorage = useCallback(() => {
    const next = !persistOptIn;
    setPersistOptIn(next);
    try {
      localStorage.setItem(PERSIST_OPTIN_KEY, next ? "1" : "0");
    } catch {}
  }, [persistOptIn]);

  const focusInput = useCallback(() => {
    requestAnimationFrame(() => textareaRef.current?.focus());
  }, []);

  const summary = useMemo(() => {
    if (messages.length === 0) return "";
    const assistants = messages.filter(
      (m) => m.role === "assistant" && m.text.trim(),
    );
    const last = assistants[assistants.length - 1];
    const txt = last?.text || "";
    return txt.length > 160 ? `${txt.slice(0, 160)}…` : txt;
  }, [messages]);

  const pageTitle = useMemo(() => {
    return typeof document !== "undefined" ? document.title : "";
  }, []);

  return {
    // State
    messages,
    setMessages,
    input,
    setInput,
    busy,
    setBusy,
    persistOptIn,
    setPersistOptIn,
    sessionId,
    sessionKey,
    setSessionKey,
    sessions,
    setSessions,
    showSessions,
    setShowSessions,
    showImageDrawer,
    setShowImageDrawer,
    showActionSheet,
    setShowActionSheet,
    selectedSessionIds,
    setSelectedSessionIds,
    isAggregatePrompt,
    setIsAggregatePrompt,
    firstTokenMs,
    setFirstTokenMs,
    questionMode,
    setQuestionMode,
    attachedImage,
    setAttachedImage,
    attachedPreviewUrl,
    setAttachedPreviewUrl,
    uploadedImages,
    setUploadedImages,
    // Refs
    scrollRef,
    abortRef,
    fileInputRef,
    textareaRef,
    lastPromptRef,
    // Computed
    canSend,
    summary,
    pageTitle,
    // Functions
    push,
    togglePersistStorage,
    focusInput,
  };
}

```

### useModels.ts

**Path:** `frontend/src/components/features/chat/widget/hooks/useModels.ts`

```typescript
import { useState, useEffect, useCallback } from 'react';
import { getApiBaseUrl } from '@/utils/apiBase';

export type AIModel = {
  id: string;
  name: string;
  provider: string;
  description?: string;
  isDefault?: boolean;
  capabilities?: string[];
};

export type ModelsResponse = {
  models: AIModel[];
  default: string;
  provider: string;
  warning?: string;
};

const SELECTED_MODEL_KEY = 'chat_selected_model';
const MODELS_CACHE_KEY = 'chat_models_cache';
const MODELS_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

type CachedModels = {
  data: ModelsResponse;
  timestamp: number;
};

/**
 * Hook to fetch and manage AI model selection
 */
export function useModels() {
  const [models, setModels] = useState<AIModel[]>([]);
  const [defaultModel, setDefaultModel] = useState<string>('');
  const [selectedModel, setSelectedModelState] = useState<string>(() => {
    if (typeof window === 'undefined') return '';
    try {
      return localStorage.getItem(SELECTED_MODEL_KEY) || '';
    } catch {
      return '';
    }
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Fetch models from API
  const fetchModels = useCallback(async (force = false) => {
    // Check cache first
    if (!force && typeof window !== 'undefined') {
      try {
        const cached = localStorage.getItem(MODELS_CACHE_KEY);
        if (cached) {
          const parsed: CachedModels = JSON.parse(cached);
          if (Date.now() - parsed.timestamp < MODELS_CACHE_TTL) {
            setModels(parsed.data.models);
            setDefaultModel(parsed.data.default);
            if (!selectedModel) {
              setSelectedModelState(parsed.data.default);
            }
            setLoading(false);
            return;
          }
        }
      } catch {
        // Cache miss or invalid, continue to fetch
      }
    }

    setLoading(true);
    setError(null);

    try {
      const base = getApiBaseUrl();
      const url = `${base.replace(/\/$/, '')}/api/v1/ai/models`;
      
      const res = await fetch(url);
      const json = await res.json();

      if (!json.ok) {
        throw new Error(json.error || 'Failed to fetch models');
      }

      const data: ModelsResponse = json.data;
      setModels(data.models);
      setDefaultModel(data.default);
      
      // Set selected model if not already set
      if (!selectedModel) {
        setSelectedModelState(data.default);
      }

      // Cache the response
      if (typeof window !== 'undefined') {
        try {
          const cached: CachedModels = {
            data,
            timestamp: Date.now(),
          };
          localStorage.setItem(MODELS_CACHE_KEY, JSON.stringify(cached));
        } catch {
          // Cache write failed, ignore
        }
      }
    } catch (err: any) {
      console.error('[useModels] Failed to fetch models:', err);
      setError(err.message || 'Failed to load models');
      
      // Use fallback models on error
      const fallback: AIModel[] = [
        { id: 'gemini-1.5-flash', name: 'Gemini 1.5 Flash', provider: 'Google', isDefault: true },
        { id: 'gpt-4o', name: 'GPT-4o', provider: 'OpenAI' },
        { id: 'claude-3.5-sonnet', name: 'Claude 3.5 Sonnet', provider: 'Anthropic' },
      ];
      setModels(fallback);
      setDefaultModel('gemini-1.5-flash');
      if (!selectedModel) {
        setSelectedModelState('gemini-1.5-flash');
      }
    } finally {
      setLoading(false);
    }
  }, [selectedModel]);

  // Fetch models on mount
  useEffect(() => {
    fetchModels();
  }, [fetchModels]);

  // Set selected model with persistence
  const setSelectedModel = useCallback((modelId: string) => {
    setSelectedModelState(modelId);
    if (typeof window !== 'undefined') {
      try {
        localStorage.setItem(SELECTED_MODEL_KEY, modelId);
      } catch {
        // Storage write failed, ignore
      }
    }
  }, []);

  // Get the current model object
  const currentModel = models.find((m) => m.id === selectedModel) || 
                       models.find((m) => m.isDefault) ||
                       models[0];

  // Group models by provider for UI
  const modelsByProvider = models.reduce<Record<string, AIModel[]>>((acc, model) => {
    const provider = model.provider || 'Other';
    if (!acc[provider]) {
      acc[provider] = [];
    }
    acc[provider].push(model);
    return acc;
  }, {});

  return {
    models,
    modelsByProvider,
    defaultModel,
    selectedModel: selectedModel || defaultModel,
    currentModel,
    setSelectedModel,
    loading,
    error,
    refresh: () => fetchModels(true),
  };
}

```

---

## frontend/src/components/features/memo

### FloatingActionBar.tsx

**Path:** `frontend/src/components/features/memo/FloatingActionBar.tsx`

```tsx
/**
 * FloatingActionBar - Modularized version
 *
 * This file now re-exports from the modularized fab/ directory.
 * The original 1790-line component has been split into:
 *
 * - fab/types.ts - Type definitions
 * - fab/hooks/usePostsManifest.ts - Post manifest loading
 * - fab/hooks/useVirtualFS.ts - Virtual filesystem for shell navigation
 * - fab/hooks/useFabState.ts - FAB state management hooks
 * - fab/hooks/useShellCommander.ts - Shell command execution
 * - fab/components/ShellModal.tsx - Mobile shell modal
 * - fab/components/ShellComponents.tsx - Shell UI components
 * - fab/components/TerminalDock.tsx - Terminal theme dock
 * - fab/components/DefaultDock.tsx - Default theme dock
 * - fab/index.tsx - Main component (~300 lines)
 */
export { default } from "./fab";

```

---

## frontend/src/components/features/memo/fab

### index.tsx

**Path:** `frontend/src/components/features/memo/fab/index.tsx`

```tsx
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { NotebookPen, Sparkles, Layers, Map } from "lucide-react";
import VisitedPostsMinimap, {
  useVisitedPostsState,
} from "@/components/features/navigation/VisitedPostsMinimap";
import ChatWidget from "@/components/features/chat/ChatWidget";
import { useToast } from "@/components/ui/use-toast";
import { useIsMobile } from "@/hooks/use-mobile";
import { useTheme } from "@/contexts/ThemeContext";
import { cn } from "@/lib/utils";

import type { DockAction } from "./types";
import {
  usePostsManifest,
  useVirtualFS,
  isFabEnabled,
  useAIMemoElement,
  useMemoOpen,
  useHistoryOverlayOpen,
  useModalPresence,
  useHistoryBadge,
  useScrollHide,
  useFabPinned,
  hideLegacyLaunchers,
  useFabAnalytics,
} from "./hooks";
import { useShellCommander } from "./hooks/useShellCommander";
import {
  ShellModal,
  ShellOutputOverlay,
  MobileShellBar,
  TerminalDock,
  DefaultDock,
  RealTerminalModal,
} from "./components";

export default function FloatingActionBar() {
  const enabled = isFabEnabled();
  const aiMemoEl = useAIMemoElement();
  const memoOpen = useMemoOpen(aiMemoEl);
  const overlayOpen = useHistoryOverlayOpen(aiMemoEl);
  const modalOpen = useModalPresence();
  const [hasNew, clearBadge] = useHistoryBadge();
  const { items: visitedPosts, storageAvailable } = useVisitedPostsState();
  const [chatOpen, setChatOpen] = useState(false);
  const [chatInitialMessage, setChatInitialMessage] = useState<string | undefined>(undefined);
  const scrollHidden = useScrollHide();
  const [fabPinned] = useFabPinned();
  const { toast } = useToast();
  const isMobile = useIsMobile();
  const { isTerminal } = useTheme();
  const { send, sendImpression, sendMemoContextChange } = useFabAnalytics();

  // Shell Commander state (for terminal theme mobile)
  const [shellOpen, setShellOpen] = useState(false);
  // Real terminal mode (Linux container)
  const [realTerminalOpen, setRealTerminalOpen] = useState(false);

  // Scroll to top button visibility (for mobile terminal shell bar)
  const [showScrollTop, setShowScrollTop] = useState(false);
  useEffect(() => {
    const handleScroll = () => {
      setShowScrollTop(window.scrollY > 300);
    };
    window.addEventListener("scroll", handleScroll, { passive: true });
    handleScroll(); // Initial check
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  // Add viewport height management for mobile keyboard
  const [viewportHeight, setViewportHeight] = useState("100dvh");

  useEffect(() => {
    // Only lock scroll when shell is open AND on mobile AND terminal theme
    if (!isMobile || !shellOpen || !isTerminal) {
      document.body.style.overflow = "";
      return;
    }

    document.body.style.overflow = "hidden";

    const handleResize = () => {
      const vh = window.visualViewport?.height || window.innerHeight;
      setViewportHeight(`${vh}px`);
    };

    window.addEventListener("resize", handleResize);
    window.visualViewport?.addEventListener("resize", handleResize);
    handleResize();

    return () => {
      document.body.style.overflow = "";
      window.removeEventListener("resize", handleResize);
      window.visualViewport?.removeEventListener("resize", handleResize);
    };
  }, [isMobile, shellOpen, isTerminal]);

  // Virtual filesystem for Linux-like navigation
  const posts = usePostsManifest();
  const vfs = useVirtualFS(posts);

  const clickShadowBtn = useCallback(
    (id: string) => {
      try {
        const shadow = (aiMemoEl as any)?.shadowRoot as ShadowRoot | undefined;
        const btn = shadow?.getElementById(id) as HTMLButtonElement | null;
        btn?.click();
      } catch {}
    },
    [aiMemoEl],
  );

  const toggleMemo = useCallback(
    () => clickShadowBtn("launcher"),
    [clickShadowBtn],
  );

  const openHistory = useCallback(() => {
    let opened = false;
    try {
      const anyEl = aiMemoEl as any;
      if (typeof anyEl?.openHistory === "function") {
        anyEl.openHistory();
        opened = true;
      } else if (aiMemoEl) {
        const shadow = anyEl?.shadowRoot as ShadowRoot | undefined;
        const historyLauncher = shadow?.getElementById(
          "historyLauncher",
        ) as HTMLElement | null;
        if (historyLauncher) {
          const prevDisplay = historyLauncher.style.display;
          historyLauncher.style.display = "flex";
          historyLauncher.click();
          setTimeout(() => {
            historyLauncher.style.display = prevDisplay || "none";
          }, 50);
          opened = true;
        }
      }
    } catch {}
    if (!opened) {
      try {
        window.dispatchEvent(new CustomEvent("visitedposts:open"));
      } catch {}
    }
    clearBadge();
    send("fab_history_click");
  }, [aiMemoEl, clearBadge, send]);

  const openStackView = useCallback(() => {
    try {
      window.dispatchEvent(new CustomEvent("visitedposts:open"));
      send("fab_stack_click");
    } catch {}
  }, [send]);

  const stackDisabledReason = useMemo(() => {
    if (!storageAvailable)
      return "이 브라우저에서는 Stack 기능을 사용할 수 없습니다.";
    if (!visitedPosts.length) return "최근 방문한 글이 없습니다.";
    return null;
  }, [storageAvailable, visitedPosts.length]);

  const handleStackClick = useCallback(() => {
    if (stackDisabledReason) {
      toast({ title: "Stack 사용 불가", description: stackDisabledReason });
      return;
    }
    openStackView();
  }, [openStackView, stackDisabledReason, toast]);

  // Shell Commander hook
  const shell = useShellCommander({
    vfs,
    posts,
    onChatOpen: () => setChatOpen(true),
    onChatOpenWithMessage: (message: string) => {
      setChatInitialMessage(message);
      setChatOpen(true);
    },
    onMemoToggle: toggleMemo,
    onStackClick: handleStackClick,
    onShellClose: () => setShellOpen(false),
    send,
  });

  // Auto-focus shell input when opened
  useEffect(() => {
    if (shellOpen && shell.shellInputRef.current) {
      shell.shellInputRef.current.focus();
    }
  }, [shellOpen, shell.shellInputRef]);

  // prevent duplicates while flag is on + watch shadow subtree
  useEffect(() => {
    if (!enabled) return;
    let i = 0;
    const tick = () => {
      i += 1;
      hideLegacyLaunchers(aiMemoEl);
      if (i < 15) setTimeout(tick, 200);
    };
    tick();

    let mo: MutationObserver | null = null;
    const shadow = (aiMemoEl as any)?.shadowRoot as ShadowRoot | undefined;
    if (shadow) {
      mo = new MutationObserver(() => hideLegacyLaunchers(aiMemoEl));
      mo.observe(shadow, { childList: true, subtree: true });
    }
    return () => mo?.disconnect();
  }, [enabled, aiMemoEl]);

  useEffect(() => {
    if (aiMemoEl) {
      const primaryColor = getComputedStyle(
        document.documentElement,
      ).getPropertyValue("--primary");
      aiMemoEl.style.setProperty("--primary-color", primaryColor);
    }
  }, [aiMemoEl, isTerminal]);

  // impression once
  useEffect(() => {
    sendImpression(enabled, modalOpen);
  }, [enabled, modalOpen, sendImpression]);

  // memo contextual visibility change
  useEffect(() => {
    sendMemoContextChange(memoOpen);
  }, [memoOpen, sendMemoContextChange]);

  // Mobile terminal shell bar should always be visible
  const shouldAlwaysShow = isMobile && isTerminal;

  const containerClasses = cn(
    "fixed inset-x-0 z-[var(--z-fab-bar)] px-3 sm:px-4 print:hidden",
    isMobile
      ? "bottom-0 pb-[calc(env(safe-area-inset-bottom,0px))]"
      : "bottom-[calc(16px+env(safe-area-inset-bottom,0px))]",
    "transition-transform transition-opacity duration-200 ease-out",
    shouldAlwaysShow || fabPinned
      ? "translate-y-0 opacity-100"
      : scrollHidden
        ? "translate-y-6 opacity-0 pointer-events-none"
        : "translate-y-0 opacity-100",
  );

  const dockActions: DockAction[] = [
    {
      key: "chat",
      label: "Chat",
      icon: Sparkles,
      onClick: () => {
        setChatOpen(true);
        send("fab_ai_chat_open");
      },
      primary: true,
    },
    {
      key: "memo",
      label: "Memo",
      icon: NotebookPen,
      onClick: () => {
        send("fab_memo_toggle");
        toggleMemo();
      },
    },
    {
      key: "stack",
      label: "Stack",
      icon: Layers,
      onClick: handleStackClick,
      disabled: !!stackDisabledReason,
      title: stackDisabledReason || undefined,
    },
    {
      key: "insight",
      label: "Insight",
      icon: Map,
      onClick: () => {
        send("fab_insight_click");
        clearBadge();
        vfs.navigate("/insight");
      },
      badge: hasNew,
    },
  ];

  if (!enabled) {
    return null;
  }

  const stackSheet = <VisitedPostsMinimap mode="fab" />;
  const toolbarDisabled = modalOpen || overlayOpen;

  return (
    <>
      {stackSheet}

      {/* Mobile Shell Modal - Portal */}
      {isTerminal && isMobile && (
        <ShellModal
          isOpen={shellOpen && !realTerminalOpen}
          onClose={() => {
            setShellOpen(false);
            shell.setShellOutput(null);
          }}
          displayPath={vfs.displayPath}
          viewportHeight={viewportHeight}
          shellInput={shell.shellInput}
          setShellInput={shell.setShellInput}
          shellInputRef={shell.shellInputRef}
          onKeyDown={shell.handleShellKeyDownWithSuggestions}
          suggestions={shell.suggestions}
          selectedSuggestionIndex={shell.selectedSuggestionIndex}
          selectSuggestion={shell.selectSuggestion}
          shellLogs={shell.shellLogs}
          shellOutput={shell.shellOutput}
          consoleEndRef={shell.consoleEndRef}
          executeCommand={shell.executeShellCommandWithLog}
          commandHistory={shell.commandHistory}
          onSwitchToRealTerminal={() => {
            setShellOpen(false);
            setRealTerminalOpen(true);
            send("fab_real_terminal_open");
          }}
        />
      )}

      {/* Real Terminal Modal - Portal */}
      {isTerminal && isMobile && (
        <RealTerminalModal
          isOpen={realTerminalOpen}
          onClose={() => {
            setRealTerminalOpen(false);
            send("fab_real_terminal_close");
          }}
          viewportHeight={viewportHeight}
          onSwitchToVirtual={() => {
            setRealTerminalOpen(false);
            setShellOpen(true);
          }}
        />
      )}

      {/* Shell output overlay for terminal mobile - Portal */}
      {isTerminal && isMobile && !shellOpen && !realTerminalOpen && (
        <ShellOutputOverlay
          output={shell.shellOutput}
          onExpand={() => setShellOpen(true)}
          onClose={() => shell.setShellOutput(null)}
        />
      )}

      {!toolbarDisabled && (
        <div
          role="toolbar"
          aria-label="Floating actions"
          className={containerClasses}
        >
          <nav
            className={cn(
              "mx-auto flex w-full justify-center",
              isMobile ? "max-w-none" : "max-w-md sm:max-w-2xl",
            )}
          >
            {/* Terminal style dock */}
            {isTerminal ? (
              isMobile ? (
                // Mobile TUI: Shell Bar
                !shellOpen && (
                  <MobileShellBar
                    displayPath={vfs.displayPath}
                    onShellOpen={() => setShellOpen(true)}
                    showScrollTop={showScrollTop}
                    hasNew={hasNew}
                  />
                )
              ) : (
                // PC Terminal Dock
                <TerminalDock dockActions={dockActions} isMobile={isMobile} />
              )
            ) : (
              // Default style dock
              <DefaultDock dockActions={dockActions} isMobile={isMobile} />
            )}
          </nav>
        </div>
      )}

      {chatOpen && (
        <ChatWidget
          initialMessage={chatInitialMessage}
          onClose={() => {
            setChatOpen(false);
            setChatInitialMessage(undefined);
            send("fab_ai_chat_close");
          }}
        />
      )}
    </>
  );
}

```

### types.ts

**Path:** `frontend/src/components/features/memo/fab/types.ts`

```typescript
import type { LucideIcon } from "lucide-react";

// Shell command definitions
export type ShellCommand = {
  name: string;
  aliases: string[];
  description: string;
  action: (args?: string) => void;
};

// Virtual filesystem types for blog navigation
export type BlogPost = {
  slug: string;
  title: string;
  category: string;
  date: string;
  tags: string[];
  url: string;
};

export type VirtualFS = {
  currentPath: string;
  posts: BlogPost[];
};

export type DockAction = {
  key: "chat" | "memo" | "stack" | "insight";
  label: string;
  icon: LucideIcon;
  onClick: () => void;
  disabled?: boolean;
  title?: string;
  badge?: boolean;
  primary?: boolean;
};

export type ShellLog = {
  type: "input" | "output";
  text: string;
};

```

---

## frontend/src/components/features/memo/fab/components

### DefaultDock.tsx

**Path:** `frontend/src/components/features/memo/fab/components/DefaultDock.tsx`

```tsx
import React from "react";
import { cn } from "@/lib/utils";
import type { DockAction } from "../types";

type DefaultDockProps = {
  dockActions: DockAction[];
  isMobile: boolean;
};

export function DefaultDock({ dockActions, isMobile }: DefaultDockProps) {
  return (
    <div
      className={cn(
        "flex w-full items-center backdrop-blur-xl",
        isMobile
          ? "rounded-none border-t border-border/30 bg-background/95 px-2 py-1.5 shadow-[0_-4px_16px_rgba(0,0,0,0.06)] dark:bg-background/90 dark:border-white/10"
          : "rounded-[28px] border border-white/20 bg-background/70 px-4 py-3 shadow-[0_8px_32px_rgba(0,0,0,0.08),_0_2px_8px_rgba(0,0,0,0.04)] dark:border-white/10 dark:bg-background/60 dark:shadow-[0_8px_32px_rgba(0,0,0,0.3)]",
      )}
    >
      {isMobile ? (
        // Mobile: 4 buttons displayed compactly
        <div className="flex w-full items-center justify-around">
          {dockActions.map((action) => {
            const Icon = action.icon;
            return (
              <button
                key={action.key}
                type="button"
                onClick={action.onClick}
                disabled={action.disabled}
                aria-label={action.label}
                className={cn(
                  "group relative flex flex-col items-center justify-center gap-0.5 py-1.5 px-3 transition-all active:scale-95",
                  action.disabled && "opacity-40",
                )}
              >
                <span
                  className={cn(
                    "flex items-center justify-center rounded-xl transition-all duration-150",
                    "h-9 w-9",
                    action.primary
                      ? "bg-primary text-primary-foreground shadow-sm shadow-primary/20"
                      : "bg-muted/60 text-foreground/70 dark:bg-white/10 dark:text-white/70",
                  )}
                >
                  <Icon className="h-4 w-4" />
                </span>
                <span className="text-[10px] text-muted-foreground/70 dark:text-white/50">
                  {action.label}
                </span>
                {action.badge && (
                  <span className="absolute top-0.5 right-2 inline-flex h-1.5 w-1.5 rounded-full bg-primary" />
                )}
              </button>
            );
          })}
        </div>
      ) : (
        // PC: Premium hover effects and labels
        <div className="flex items-center justify-center gap-2">
          {dockActions.map((action) => {
            const Icon = action.icon;
            return (
              <button
                key={action.key}
                type="button"
                onClick={action.onClick}
                disabled={action.disabled}
                aria-label={action.label}
                aria-disabled={action.disabled}
                title={action.title}
                className={cn(
                  "group relative flex items-center gap-2.5 rounded-2xl px-4 py-2.5 transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50",
                  action.primary
                    ? "bg-gradient-to-r from-primary to-primary/90 text-primary-foreground shadow-md shadow-primary/20 hover:shadow-lg hover:shadow-primary/30 hover:scale-[1.02]"
                    : "text-muted-foreground hover:bg-muted/60 hover:text-foreground dark:hover:bg-white/10 dark:hover:text-white",
                )}
              >
                <Icon
                  className={cn(
                    "h-[18px] w-[18px]",
                    action.primary && "text-primary-foreground",
                  )}
                />
                <span
                  className={cn(
                    "text-sm font-medium tracking-wide",
                    action.primary
                      ? "text-primary-foreground"
                      : "text-foreground/80 dark:text-white/80",
                  )}
                >
                  {action.label}
                </span>
                {action.badge && (
                  <span
                    className="absolute -top-1 -right-1 inline-flex h-2.5 w-2.5 rounded-full bg-primary ring-2 ring-background animate-pulse"
                    aria-hidden
                  />
                )}
              </button>
            );
          })}
        </div>
      )}
    </div>
  );
}

```

### RealTerminalModal.tsx

**Path:** `frontend/src/components/features/memo/fab/components/RealTerminalModal.tsx`

```tsx
/**
 * RealTerminalModal - Real Linux terminal UI with xterm.js
 *
 * Full-screen terminal modal that connects to a real Docker container
 * via the terminal gateway WebSocket.
 */

import React, { useRef, useEffect, useCallback } from "react";
import { createPortal } from "react-dom";
import { Terminal, X, Wifi, WifiOff, Loader2, RefreshCw } from "lucide-react";
import { cn } from "@/lib/utils";
import { useRealTerminal, type TerminalStatus } from "../hooks/useRealTerminal";

// Dynamic imports for xterm to avoid SSR issues
let XTerm: typeof import("@xterm/xterm").Terminal | null = null;
let FitAddon: typeof import("@xterm/addon-fit").FitAddon | null = null;
let WebLinksAddon: typeof import("@xterm/addon-web-links").WebLinksAddon | null = null;

// Load xterm modules dynamically
const loadXterm = async () => {
  if (!XTerm) {
    const [xtermModule, fitModule, webLinksModule] = await Promise.all([
      import("@xterm/xterm"),
      import("@xterm/addon-fit"),
      import("@xterm/addon-web-links"),
    ]);
    XTerm = xtermModule.Terminal;
    FitAddon = fitModule.FitAddon;
    WebLinksAddon = webLinksModule.WebLinksAddon;
    
    // Import CSS
    await import("@xterm/xterm/css/xterm.css");
  }
  return { XTerm, FitAddon, WebLinksAddon };
};

type RealTerminalModalProps = {
  isOpen: boolean;
  onClose: () => void;
  viewportHeight: string;
  onSwitchToVirtual?: () => void;
};

const StatusIndicator = ({ status }: { status: TerminalStatus }) => {
  const statusConfig = {
    disconnected: {
      icon: WifiOff,
      text: "Disconnected",
      className: "text-muted-foreground",
    },
    connecting: {
      icon: Loader2,
      text: "Connecting...",
      className: "text-yellow-500 animate-spin",
    },
    connected: {
      icon: Wifi,
      text: "Connected",
      className: "text-primary",
    },
    error: {
      icon: WifiOff,
      text: "Error",
      className: "text-destructive",
    },
  };

  const config = statusConfig[status];
  const Icon = config.icon;

  return (
    <div className={cn("flex items-center gap-1.5", config.className)}>
      <Icon className={cn("h-3.5 w-3.5", status === "connecting" && "animate-spin")} />
      <span className="text-xs font-mono">{config.text}</span>
    </div>
  );
};

export function RealTerminalModal({
  isOpen,
  onClose,
  viewportHeight,
  onSwitchToVirtual,
}: RealTerminalModalProps) {
  const terminalContainerRef = useRef<HTMLDivElement>(null);
  const terminalInstanceRef = useRef<InstanceType<typeof import("@xterm/xterm").Terminal> | null>(null);
  const fitAddonRef = useRef<InstanceType<typeof import("@xterm/addon-fit").FitAddon> | null>(null);
  const xtermLoadedRef = useRef(false);

  const handleData = useCallback((data: string) => {
    if (terminalInstanceRef.current) {
      terminalInstanceRef.current.write(data);
    }
  }, []);

  const {
    status,
    error,
    isAvailable,
    connect,
    disconnect,
    send,
    resize,
  } = useRealTerminal({
    cols: 80,
    rows: 24,
    onData: handleData,
  });

  // Initialize xterm when modal opens
  useEffect(() => {
    if (!isOpen || !terminalContainerRef.current || xtermLoadedRef.current) {
      return;
    }

    let mounted = true;

    const initTerminal = async () => {
      const { XTerm: TerminalClass, FitAddon: FitAddonClass, WebLinksAddon: WebLinksAddonClass } =
        await loadXterm();

      if (!mounted || !terminalContainerRef.current || !TerminalClass || !FitAddonClass) {
        return;
      }

      // Create terminal instance
      const term = new TerminalClass({
        theme: {
          background: "hsl(224 71.4% 4.1%)", // Match terminal theme
          foreground: "#e4e4e7",
          cursor: "hsl(142.1 70.6% 45.3%)", // Primary color
          cursorAccent: "#000",
          selectionBackground: "rgba(142, 255, 142, 0.3)",
          black: "#18181b",
          red: "#f87171",
          green: "#4ade80",
          yellow: "#facc15",
          blue: "#60a5fa",
          magenta: "#c084fc",
          cyan: "#22d3ee",
          white: "#e4e4e7",
          brightBlack: "#52525b",
          brightRed: "#fca5a5",
          brightGreen: "#86efac",
          brightYellow: "#fde047",
          brightBlue: "#93c5fd",
          brightMagenta: "#d8b4fe",
          brightCyan: "#67e8f9",
          brightWhite: "#fafafa",
        },
        fontFamily: '"JetBrains Mono", "Fira Code", "SF Mono", Menlo, Monaco, monospace',
        fontSize: 13,
        lineHeight: 1.3,
        cursorBlink: true,
        cursorStyle: "block",
        scrollback: 5000,
        tabStopWidth: 4,
        allowTransparency: true,
      });

      // Add fit addon
      const fitAddon = new FitAddonClass();
      term.loadAddon(fitAddon);
      fitAddonRef.current = fitAddon;

      // Add web links addon
      if (WebLinksAddonClass) {
        const webLinksAddon = new WebLinksAddonClass();
        term.loadAddon(webLinksAddon);
      }

      // Open terminal in container
      term.open(terminalContainerRef.current);

      // Fit to container
      setTimeout(() => {
        fitAddon.fit();
      }, 0);

      // Handle user input
      term.onData((data) => {
        send(data);
      });

      // Handle resize
      term.onResize(({ cols, rows }) => {
        resize(cols, rows);
      });

      terminalInstanceRef.current = term;
      xtermLoadedRef.current = true;

      // Auto-connect if available
      if (isAvailable) {
        connect();
      } else {
        term.writeln("\x1b[33m터미널 서비스에 연결할 수 없습니다.\x1b[0m");
        term.writeln("\x1b[90m로그인이 필요하거나 서비스가 준비되지 않았습니다.\x1b[0m");
        term.writeln("");
        term.writeln('\x1b[90m"Virtual Shell" 버튼을 눌러 가상 쉘을 사용하세요.\x1b[0m');
      }
    };

    initTerminal();

    return () => {
      mounted = false;
    };
  }, [isOpen, isAvailable, connect, send, resize]);

  // Handle window resize
  useEffect(() => {
    if (!isOpen) return;

    const handleResize = () => {
      if (fitAddonRef.current) {
        fitAddonRef.current.fit();
      }
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, [isOpen]);

  // Cleanup on unmount or close
  useEffect(() => {
    if (!isOpen) {
      if (terminalInstanceRef.current) {
        terminalInstanceRef.current.dispose();
        terminalInstanceRef.current = null;
      }
      fitAddonRef.current = null;
      xtermLoadedRef.current = false;
      disconnect();
    }
  }, [isOpen, disconnect]);

  // Handle reconnect
  const handleReconnect = useCallback(() => {
    if (terminalInstanceRef.current) {
      terminalInstanceRef.current.clear();
      terminalInstanceRef.current.writeln("\x1b[33m재연결 중...\x1b[0m");
    }
    disconnect();
    setTimeout(connect, 500);
  }, [connect, disconnect]);

  if (!isOpen) return null;

  return createPortal(
    <div
      className="fixed inset-0 z-[9999] flex flex-col bg-background/95 backdrop-blur-sm animate-in fade-in-0 duration-200"
      style={{ height: viewportHeight }}
    >
      {/* Header */}
      <div className="flex-shrink-0 flex items-center justify-between px-3 py-2 border-b border-border/50 bg-[hsl(var(--terminal-code-bg))]">
        <div className="flex items-center gap-3">
          <div className="flex items-center gap-2">
            <Terminal className="h-4 w-4 text-primary" />
            <span className="font-mono text-xs text-primary font-medium">
              LINUX SHELL
            </span>
          </div>
          <StatusIndicator status={status} />
        </div>

        <div className="flex items-center gap-2">
          {/* Reconnect button */}
          {status !== "connecting" && (
            <button
              type="button"
              onClick={handleReconnect}
              className="p-1.5 text-muted-foreground hover:text-primary transition-colors rounded"
              title="Reconnect"
            >
              <RefreshCw className="h-3.5 w-3.5" />
            </button>
          )}

          {/* Switch to virtual shell */}
          {onSwitchToVirtual && (
            <button
              type="button"
              onClick={onSwitchToVirtual}
              className={cn(
                "px-2 py-1 font-mono text-[10px] uppercase tracking-wider",
                "bg-primary/10 border border-primary/30 rounded",
                "text-primary/80 hover:text-primary hover:bg-primary/20",
                "transition-colors"
              )}
            >
              Virtual Shell
            </button>
          )}

          {/* Close button */}
          <button
            type="button"
            onClick={onClose}
            className="p-1.5 text-muted-foreground hover:text-primary transition-colors"
            aria-label="Close"
          >
            <X className="h-4 w-4" />
          </button>
        </div>
      </div>

      {/* Error banner */}
      {error && (
        <div className="flex-shrink-0 px-3 py-2 bg-destructive/10 border-b border-destructive/30 text-destructive text-xs font-mono">
          {error}
        </div>
      )}

      {/* Terminal container */}
      <div
        ref={terminalContainerRef}
        className="flex-1 min-h-0 p-2 bg-[hsl(224_71.4%_4.1%)]"
      />

      {/* Footer hints */}
      <div className="flex-shrink-0 px-3 py-1.5 border-t border-border/30 bg-[hsl(var(--terminal-code-bg))]">
        <div className="flex items-center justify-between text-[10px] font-mono text-muted-foreground/60">
          <span>Ctrl+C: interrupt | Ctrl+D: exit | Ctrl+L: clear</span>
          <span>Docker sandbox environment</span>
        </div>
      </div>
    </div>,
    document.body
  );
}

```

### ShellComponents.tsx

**Path:** `frontend/src/components/features/memo/fab/components/ShellComponents.tsx`

```tsx
import React from "react";
import { createPortal } from "react-dom";
import { Terminal, X, ChevronRight, ArrowUp } from "lucide-react";
import { cn } from "@/lib/utils";

type ShellOutputOverlayProps = {
  output: string | null;
  onExpand: () => void;
  onClose: () => void;
};

export function ShellOutputOverlay({
  output,
  onExpand,
  onClose,
}: ShellOutputOverlayProps) {
  if (!output) return null;

  return createPortal(
    <div className="fixed inset-x-0 bottom-14 z-[9998] px-3 pb-2 animate-in slide-in-from-bottom-2 duration-150">
      <div className="bg-[hsl(var(--terminal-code-bg))] border border-primary/30 rounded-[4px] shadow-lg shadow-primary/5 overflow-hidden max-h-[50vh]">
        {/* Terminal header */}
        <div className="flex items-center justify-between px-3 py-1.5 bg-primary/10 border-b border-primary/20">
          <div className="flex items-center gap-2">
            <span className="w-2 h-2 rounded-full bg-primary/60 animate-pulse" />
            <span className="font-mono text-[10px] text-primary/80 uppercase tracking-wider">
              // Output
            </span>
          </div>
          <div className="flex items-center gap-1">
            <button
              type="button"
              onClick={onExpand}
              className="p-1 text-muted-foreground hover:text-primary transition-colors"
              aria-label="확장"
            >
              <ChevronRight className="h-3.5 w-3.5 rotate-90" />
            </button>
            <button
              type="button"
              onClick={onClose}
              className="p-0.5 text-muted-foreground hover:text-primary transition-colors"
              aria-label="닫기"
            >
              <X className="h-3.5 w-3.5" />
            </button>
          </div>
        </div>
        {/* Terminal output */}
        <div className="p-3 max-h-48 overflow-auto">
          <pre className="font-mono text-xs text-foreground/90 whitespace-pre-wrap leading-relaxed">
            {output}
          </pre>
        </div>
      </div>
    </div>,
    document.body,
  );
}

type MobileShellBarProps = {
  displayPath: string;
  onShellOpen: () => void;
  showScrollTop: boolean;
  hasNew: boolean;
};

export function MobileShellBar({
  displayPath,
  onShellOpen,
  showScrollTop,
  hasNew,
}: MobileShellBarProps) {
  return (
    <div className="flex w-full items-center gap-2.5 bg-[hsl(var(--terminal-code-bg))] border-t border-primary/30 px-3 py-2.5">
      {/* Terminal button - opens shell */}
      <button
        type="button"
        onClick={onShellOpen}
        aria-label="Open command input"
        className="flex items-center justify-center h-10 w-10 rounded-[4px] bg-primary/20 text-primary border border-primary/40 transition-all active:scale-95 hover:bg-primary/30 hover:border-primary/60 hover:shadow-[0_0_12px_hsl(var(--primary)/0.4)]"
      >
        <Terminal className="h-5 w-5" />
      </button>

      {/* Path display - also opens shell */}
      <div
        role="button"
        tabIndex={0}
        onClick={onShellOpen}
        onKeyDown={(e) => e.key === "Enter" && onShellOpen()}
        className="flex-1 flex items-center gap-2 min-w-0 cursor-pointer hover:opacity-80 transition-opacity"
      >
        <span className="font-mono text-xs text-primary/70 truncate">
          {displayPath}
        </span>
        <span className="text-primary/40 font-mono text-xs">$ _</span>
      </div>

      {/* Scroll to top button - only show when scrolled down */}
      {showScrollTop && (
        <button
          type="button"
          onClick={(e) => {
            e.stopPropagation();
            window.scrollTo({ top: 0, behavior: "smooth" });
          }}
          aria-label="맨 위로 스크롤"
          className="flex items-center justify-center h-8 w-8 rounded-[4px] bg-primary/15 text-primary border border-primary/40 transition-all active:scale-95 hover:bg-primary/25 hover:border-primary/60"
        >
          <ArrowUp className="h-4 w-4" />
        </button>
      )}

      {/* New badge indicator */}
      {hasNew && !showScrollTop && (
        <span className="h-2 w-2 rounded-full bg-primary animate-pulse shrink-0" />
      )}
    </div>
  );
}

```

### ShellModal.tsx

**Path:** `frontend/src/components/features/memo/fab/components/ShellModal.tsx`

```tsx
import React, { useRef, useEffect } from "react";
import { createPortal } from "react-dom";
import { Terminal, X, MonitorUp } from "lucide-react";
import { cn } from "@/lib/utils";
import type { ShellLog } from "../types";
import { hasAuthToken } from "@/services/terminal";

type ShellModalProps = {
  isOpen: boolean;
  onClose: () => void;
  displayPath: string;
  viewportHeight: string;
  shellInput: string;
  setShellInput: (value: string) => void;
  shellInputRef: React.RefObject<HTMLInputElement>;
  onKeyDown: (e: React.KeyboardEvent<HTMLInputElement>) => void;
  suggestions: string[];
  selectedSuggestionIndex: number;
  selectSuggestion: (suggestion: string) => void;
  shellLogs: ShellLog[];
  shellOutput: string | null;
  consoleEndRef: React.RefObject<HTMLDivElement>;
  executeCommand: (cmd: string) => void;
  commandHistory: string[];
  onSwitchToRealTerminal?: () => void;
};

export function ShellModal({
  isOpen,
  onClose,
  displayPath,
  viewportHeight,
  shellInput,
  setShellInput,
  shellInputRef,
  onKeyDown,
  suggestions,
  selectedSuggestionIndex,
  selectSuggestion,
  shellLogs,
  shellOutput,
  consoleEndRef,
  executeCommand,
  commandHistory,
  onSwitchToRealTerminal,
}: ShellModalProps) {
  const shellContentRef = useRef<HTMLDivElement>(null);
  const canSwitchToReal = onSwitchToRealTerminal && hasAuthToken();

  if (!isOpen) return null;

  return createPortal(
    <div
      ref={shellContentRef}
      className="fixed inset-0 z-[9999] flex flex-col bg-background/95 backdrop-blur-sm animate-in fade-in-0 duration-200"
      style={{ height: viewportHeight }}
    >
      {/* Backdrop - clicking closes the shell */}
      <div
        className="absolute inset-0 z-0"
        onClick={onClose}
        aria-hidden="true"
      />
      {/* Content container - must be above backdrop */}
      <div
        className="relative z-10 flex flex-col bg-[hsl(var(--terminal-code-bg))] border-t border-primary/20"
        style={{ height: viewportHeight }}
      >
        {/* Input field at the top - redesigned for long paths */}
        <div className="flex-shrink-0 flex flex-col border-b border-border/50 bg-black/20">
          {/* Path display - separate row */}
          <div className="flex items-center justify-between px-3 pt-2 pb-1">
            <span
              className="text-primary/60 font-mono text-[10px] truncate max-w-[50%]"
              title={displayPath}
            >
              {displayPath}
            </span>
            <div className="flex items-center gap-2">
              {/* Switch to Real Terminal button */}
              {canSwitchToReal && (
                <button
                  type="button"
                  onClick={onSwitchToRealTerminal}
                  className={cn(
                    "flex items-center gap-1 px-2 py-0.5",
                    "text-[10px] font-mono uppercase tracking-wider",
                    "bg-primary/10 border border-primary/30 rounded",
                    "text-primary/70 hover:text-primary hover:bg-primary/20",
                    "transition-colors"
                  )}
                  title="Switch to real Linux terminal"
                >
                  <MonitorUp className="h-3 w-3" />
                  <span>Real Shell</span>
                </button>
              )}
              <button
                type="button"
                onClick={onClose}
                className="p-1 text-muted-foreground hover:text-primary transition-colors"
                aria-label="Close"
              >
                <X className="h-4 w-4" />
              </button>
            </div>
          </div>
          {/* Input row */}
          <div className="relative flex items-center gap-1.5 px-3 pb-2.5">
            <span className="text-primary font-mono text-sm font-bold shrink-0">
              $
            </span>
            <input
              ref={shellInputRef}
              type="text"
              value={shellInput}
              onChange={(e) => setShellInput(e.target.value)}
              onKeyDown={onKeyDown}
              placeholder="Type a command or 'help'"
              className="flex-1 min-w-0 bg-transparent border-none outline-none font-mono text-sm text-foreground placeholder:text-muted-foreground/40"
              autoComplete="off"
              autoCapitalize="off"
              spellCheck={false}
            />
          </div>

          {/* Autocomplete suggestions dropdown */}
          {suggestions.length > 0 && (
            <div className="absolute left-0 right-0 top-full z-50 mx-3 mb-2 bg-[hsl(var(--terminal-code-bg))] border border-primary/30 rounded-[4px] shadow-lg overflow-hidden">
              <div className="text-[9px] font-mono text-primary/50 uppercase tracking-wider px-2 py-1 border-b border-border/30">
                // Suggestions (Tab/Enter to select)
              </div>
              <div className="max-h-40 overflow-y-auto">
                {suggestions.map((suggestion, index) => (
                  <button
                    key={suggestion}
                    type="button"
                    onClick={() => selectSuggestion(suggestion)}
                    className={cn(
                      "w-full text-left px-3 py-1.5 font-mono text-xs transition-colors",
                      index === selectedSuggestionIndex
                        ? "bg-primary/20 text-primary"
                        : "text-foreground/80 hover:bg-primary/10 hover:text-primary",
                    )}
                  >
                    <span className="text-primary/60">$ </span>
                    {suggestion}
                  </button>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* Console Output Window */}
        <div className="flex-1 min-h-0 relative">
          <div className="absolute inset-0 overflow-y-auto p-3 bg-black/30">
            {/* Empty state */}
            {shellLogs.length === 0 && !shellOutput && (
              <div className="flex flex-col items-center justify-center h-full text-muted-foreground/50 text-center">
                <Terminal className="h-8 w-8 mb-2 opacity-30" />
                <p className="text-xs font-mono">
                  Run a command to see output here...
                </p>
                <p className="text-[10px] mt-1 opacity-70">
                  Type 'help' for available commands
                </p>
              </div>
            )}

            {/* Execution logs */}
            {shellLogs.map((log, index) => (
              <div
                key={index}
                className={cn(
                  "mb-1 font-mono text-xs whitespace-pre-wrap break-all leading-relaxed",
                  log.type === "input"
                    ? "text-primary/90 font-medium"
                    : "text-foreground/80 pl-2 border-l-2 border-primary/20",
                )}
              >
                {log.text}
              </div>
            ))}

            {/* Scroll anchor */}
            <div ref={consoleEndRef} />
          </div>
        </div>

        {/* Quick Actions Bar */}
        <div className="flex-shrink-0 border-t border-border/30 bg-black/20 p-2.5">
          <div className="text-[10px] font-mono text-primary/60 uppercase tracking-wider mb-2">
            // Quick Commands
          </div>
          <div className="grid grid-cols-4 gap-1.5">
            {["ls", "find", "help", "clear"].map((cmd) => (
              <button
                key={cmd}
                type="button"
                onClick={() => executeCommand(cmd)}
                className={cn(
                  "py-2 px-1 font-mono text-xs uppercase tracking-wider",
                  "bg-primary/15 border border-primary/40",
                  "text-primary rounded-[4px]",
                  "hover:bg-primary/25 hover:border-primary/60 hover:text-primary",
                  "hover:shadow-[0_0_8px_hsl(var(--primary)/0.3)]",
                  "active:scale-95 transition-all duration-200",
                )}
              >
                {cmd}
              </button>
            ))}
          </div>
          {commandHistory.length > 0 && (
            <div className="mt-2 pt-2 border-t border-border/20">
              <div className="text-[10px] font-mono text-muted-foreground/60 uppercase tracking-wider mb-1.5">
                // History
              </div>
              <div className="flex flex-wrap gap-1">
                {commandHistory
                  .slice(-4)
                  .reverse()
                  .map((cmd, idx) => (
                    <button
                      key={`${cmd}-${idx}`}
                      type="button"
                      onClick={() => executeCommand(cmd)}
                      className={cn(
                        "py-1 px-2 rounded-[4px] text-[10px] font-mono",
                        "bg-primary/10 border border-primary/30",
                        "text-primary/80",
                        "hover:bg-primary/20 hover:text-primary hover:border-primary/50",
                        "transition-colors truncate max-w-[80px]",
                      )}
                    >
                      {cmd}
                    </button>
                  ))}
              </div>
            </div>
          )}
        </div>
      </div>
    </div>,
    document.body,
  );
}

```

### TerminalDock.tsx

**Path:** `frontend/src/components/features/memo/fab/components/TerminalDock.tsx`

```tsx
import React from "react";
import { cn } from "@/lib/utils";
import type { DockAction } from "../types";

type TerminalDockProps = {
  dockActions: DockAction[];
  isMobile: boolean;
};

export function TerminalDock({ dockActions, isMobile }: TerminalDockProps) {
  if (isMobile) {
    // Mobile TUI is handled by MobileShellBar component
    return null;
  }

  // PC Terminal Dock
  return (
    <div className="flex w-full items-center gap-0.5 border border-border bg-[hsl(var(--terminal-code-bg))] backdrop-blur-sm">
      {/* Terminal window controls - macOS style traffic lights */}
      <div className="flex items-center gap-2 px-3 py-2.5 border-r border-border/50">
        <span className="w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-close))]" />
        <span className="w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-minimize))]" />
        <span className="w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-maximize))]" />
      </div>

      {/* Terminal path */}
      <div className="hidden sm:flex items-center gap-1 px-3 text-[11px] font-mono text-muted-foreground border-r border-border/50">
        <span className="text-primary/60">~/</span>
        <span>actions</span>
      </div>

      {/* Action buttons - centered with proper spacing */}
      <div className="flex-1 flex items-center justify-center gap-2 px-3 py-1.5">
        {dockActions.map((action) => {
          const Icon = action.icon;
          return (
            <button
              key={action.key}
              type="button"
              onClick={action.onClick}
              disabled={action.disabled}
              aria-label={action.label}
              aria-disabled={action.disabled}
              title={action.title}
              className={cn(
                "group relative flex items-center gap-1.5 px-4 py-2.5 font-mono text-xs transition-all disabled:cursor-not-allowed disabled:opacity-50",
                action.primary
                  ? "bg-primary/20 text-primary border border-primary/40 hover:bg-primary/30"
                  : "text-muted-foreground hover:text-primary hover:bg-primary/10 border border-transparent hover:border-primary/30",
              )}
            >
              <Icon
                className={cn(
                  "h-4 w-4",
                  action.primary && "terminal-glow",
                )}
              />
              <span className="text-[10px] uppercase tracking-wider">
                {action.label}
              </span>
              {action.badge && (
                <span
                  className="absolute -top-0.5 -right-0.5 inline-flex h-2 w-2 rounded-full bg-primary animate-pulse"
                  aria-hidden
                />
              )}
            </button>
          );
        })}
      </div>

      {/* Terminal status */}
      <div className="hidden sm:flex items-center gap-2 px-3 text-[10px] font-mono text-muted-foreground/60 border-l border-border/50">
        <span className="w-1.5 h-1.5 rounded-full bg-primary/60 animate-pulse" />
        <span>READY</span>
      </div>
    </div>
  );
}

```

### index.ts

**Path:** `frontend/src/components/features/memo/fab/components/index.ts`

```typescript
export { ShellModal } from "./ShellModal";
export { ShellOutputOverlay, MobileShellBar } from "./ShellComponents";
export { TerminalDock } from "./TerminalDock";
export { DefaultDock } from "./DefaultDock";
export { RealTerminalModal } from "./RealTerminalModal";

```

---

## frontend/src/components/features/memo/fab/hooks

### index.ts

**Path:** `frontend/src/components/features/memo/fab/hooks/index.ts`

```typescript
export { usePostsManifest } from "./usePostsManifest";
export { useVirtualFS } from "./useVirtualFS";
export {
  isFabEnabled,
  useAIMemoElement,
  useMemoOpen,
  useHistoryOverlayOpen,
  useModalPresence,
  useHistoryBadge,
  useScrollHide,
  useFabPinned,
  hideLegacyLaunchers,
  useFabAnalytics,
} from "./useFabState";
export { useShellCommander } from "./useShellCommander";
export { useRealTerminal, type UseRealTerminalReturn, type TerminalStatus } from "./useRealTerminal";

```

### useFabState.ts

**Path:** `frontend/src/components/features/memo/fab/hooks/useFabState.ts`

```typescript
import { useCallback, useEffect, useRef, useState } from "react";

// Feature flag: build-time + runtime override
export function isFabEnabled(): boolean {
  let lsValue: boolean | null = null;
  try {
    const stored = localStorage.getItem("aiMemo.fab.enabled");
    if (stored != null) {
      lsValue = JSON.parse(stored);
    }
  } catch {
    lsValue = null;
  }

  if (typeof lsValue === "boolean") {
    return lsValue;
  }

  const envFlag = (import.meta as any).env?.VITE_FEATURE_FAB;
  if (envFlag != null) {
    return envFlag === true || envFlag === "true" || envFlag === "1";
  }

  return true;
}

export function useAIMemoElement(): HTMLElement | null {
  const [el, setEl] = useState<HTMLElement | null>(null);
  useEffect(() => {
    let active = true;
    const find = () =>
      document.querySelector("ai-memo-pad") as HTMLElement | null;
    const loop = () => {
      if (!active) return;
      const e = find();
      if (e) setEl(e);
      else setTimeout(loop, 200);
    };
    loop();
    return () => {
      active = false;
    };
  }, []);
  return el;
}

export function useMemoOpen(aiMemoEl: HTMLElement | null): boolean {
  const [open, setOpen] = useState<boolean>(() => {
    try {
      return !!JSON.parse(localStorage.getItem("aiMemo.isOpen") || "false");
    } catch {
      return false;
    }
  });
  useEffect(() => {
    const onStorage = (e: StorageEvent) => {
      if (!e.key || e.key === "aiMemo.isOpen") {
        try {
          setOpen(
            !!JSON.parse(localStorage.getItem("aiMemo.isOpen") || "false"),
          );
        } catch {}
      }
    };
    window.addEventListener("storage", onStorage);

    let panelObserver: MutationObserver | null = null;
    let shadowObserver: MutationObserver | null = null;
    let pollId: number | null = null;

    const tryAttachPanelObserver = () => {
      const shadow = (aiMemoEl as any)?.shadowRoot as ShadowRoot | undefined;
      const panel = shadow?.getElementById("panel");
      if (!panel) return false;
      const check = () => setOpen(panel.classList.contains("open"));
      check();
      panelObserver?.disconnect();
      panelObserver = new MutationObserver(check);
      panelObserver.observe(panel, {
        attributes: true,
        attributeFilter: ["class"],
      });
      return true;
    };

    // Attempt now; if not present, observe shadowRoot subtree and poll LS briefly
    if (!tryAttachPanelObserver()) {
      const shadow = (aiMemoEl as any)?.shadowRoot as ShadowRoot | undefined;
      if (shadow) {
        shadowObserver = new MutationObserver(() => {
          if (tryAttachPanelObserver()) {
            shadowObserver?.disconnect();
            shadowObserver = null;
          }
        });
        shadowObserver.observe(shadow, { childList: true, subtree: true });
      }
      let tries = 0;
      pollId = window.setInterval(() => {
        tries += 1;
        try {
          setOpen(
            !!JSON.parse(localStorage.getItem("aiMemo.isOpen") || "false"),
          );
        } catch {}
        if (tries > 20) {
          if (pollId) {
            clearInterval(pollId);
            pollId = null;
          }
        }
      }, 250);
    }
    return () => {
      window.removeEventListener("storage", onStorage);
      panelObserver?.disconnect();
      shadowObserver?.disconnect();
      if (pollId) clearInterval(pollId);
    };
  }, [aiMemoEl]);
  return open;
}

export function useHistoryOverlayOpen(aiMemoEl: HTMLElement | null): boolean {
  const [open, setOpen] = useState(false);
  useEffect(() => {
    const shadow = (aiMemoEl as any)?.shadowRoot as ShadowRoot | undefined;
    if (!shadow) {
      setOpen(false);
      return;
    }
    const overlay = shadow.getElementById(
      "historyOverlay",
    ) as HTMLElement | null;
    const compute = () => {
      try {
        if (!overlay) return setOpen(false);
        // visible when style.display !== 'none'
        const visible = overlay.style.display !== "none";
        setOpen(!!visible);
      } catch {
        setOpen(false);
      }
    };
    compute();
    const mo = overlay ? new MutationObserver(compute) : null;
    if (overlay && mo)
      mo.observe(overlay, {
        attributes: true,
        attributeFilter: ["style", "class"],
      });
    return () => {
      if (mo) mo.disconnect();
    };
  }, [aiMemoEl]);
  return open;
}

export function useModalPresence(): boolean {
  const [present, setPresent] = useState(false);
  useEffect(() => {
    const sel =
      '[aria-modal="true"], [role="dialog"][data-state="open"], [role="alertdialog"][data-state="open"], [data-radix-portal] [data-state="open"]';
    const check = () => setPresent(!!document.querySelector(sel));
    const mo = new MutationObserver(check);
    mo.observe(document.body, {
      subtree: true,
      childList: true,
      attributes: true,
    });
    check();
    return () => mo.disconnect();
  }, []);
  return present;
}

export function useHistoryBadge(): [boolean, () => void] {
  const [hasNew, setHasNew] = useState(false);
  const recompute = useCallback(() => {
    let count = 0;
    try {
      const arr = JSON.parse(localStorage.getItem("aiMemo.events") || "[]");
      count = Array.isArray(arr) ? arr.length : 0;
    } catch {}
    let last = 0;
    try {
      last =
        parseInt(localStorage.getItem("aiMemo.history.lastCount") || "0", 10) ||
        0;
    } catch {}
    setHasNew(count > last);
  }, []);
  useEffect(() => {
    const onStorage = (e: StorageEvent) => {
      if (!e.key || e.key === "aiMemo.events") recompute();
    };
    window.addEventListener("storage", onStorage);
    const t = setInterval(recompute, 1500); // local updates within same tab
    recompute();
    return () => {
      window.removeEventListener("storage", onStorage);
      clearInterval(t);
    };
  }, [recompute]);
  const clear = useCallback(() => {
    try {
      const arr = JSON.parse(localStorage.getItem("aiMemo.events") || "[]");
      const len = Array.isArray(arr) ? arr.length : 0;
      localStorage.setItem("aiMemo.history.lastCount", String(len));
    } catch {}
    setHasNew(false);
  }, []);
  return [hasNew, clear];
}

export function useScrollHide(): boolean {
  const [hidden, setHidden] = useState(false);
  useEffect(() => {
    let lastY = window.scrollY || 0;
    let accumulatedDelta = 0;
    const THRESHOLD = 40; // px to accumulate before toggling
    let rafId: number | null = null;
    let lastTime = 0;
    const THROTTLE_MS = 50; // Throttle to 50ms

    const updateHideState = () => {
      const y = window.scrollY || 0;
      const delta = y - lastY;
      lastY = y;

      // Near top: always show
      if (y < 80) {
        setHidden(false);
        accumulatedDelta = 0;
        return;
      }

      // Ignore tiny movements
      if (Math.abs(delta) < 2) return;

      // Accumulate delta in the same direction
      if ((delta > 0 && accumulatedDelta >= 0) || (delta < 0 && accumulatedDelta <= 0)) {
        accumulatedDelta += delta;
      } else {
        // Direction changed, reset
        accumulatedDelta = delta;
      }

      // Trigger hide/show when threshold is reached
      if (accumulatedDelta > THRESHOLD) {
        setHidden(true);
        accumulatedDelta = 0;
      } else if (accumulatedDelta < -THRESHOLD) {
        setHidden(false);
        accumulatedDelta = 0;
      }
    };

    const handleScroll = () => {
      const now = Date.now();
      if (now - lastTime < THROTTLE_MS) return;
      lastTime = now;
      
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(updateHideState);
    };

    window.addEventListener("scroll", handleScroll, { passive: true });
    return () => {
      window.removeEventListener("scroll", handleScroll);
      if (rafId) cancelAnimationFrame(rafId);
    };
  }, []);
  return hidden;
}

// FAB pinned/auto-hide setting hook
export function useFabPinned(): [boolean, () => void] {
  const [pinned, setPinned] = useState(false);

  useEffect(() => {
    try {
      const saved = localStorage.getItem("fab.pinned");
      if (saved != null) setPinned(JSON.parse(saved));
    } catch {}
  }, []);

  const togglePinned = useCallback(() => {
    setPinned((prev) => {
      const next = !prev;
      try {
        localStorage.setItem("fab.pinned", JSON.stringify(next));
      } catch {}
      return next;
    });
  }, []);

  return [pinned, togglePinned];
}

export function hideLegacyLaunchers(aiMemoEl: HTMLElement | null) {
  try {
    if (!aiMemoEl) return;
    const shadow = (aiMemoEl as any).shadowRoot as ShadowRoot | undefined;
    // Hide only legacy floating launchers; keep memo UI intact
    const launcher = shadow?.getElementById("launcher") as HTMLElement | null;
    const historyLauncher = shadow?.getElementById(
      "historyLauncher",
    ) as HTMLElement | null;
    if (launcher) launcher.style.display = "none";
    if (historyLauncher) historyLauncher.style.display = "none";
  } catch {}
}

export function useFabAnalytics() {
  const impressionSent = useRef(false);
  const prevMemoOpen = useRef<boolean | null>(null);

  const send = useCallback((type: string, detail?: Record<string, any>) => {
    try {
      const evt = new CustomEvent("fab:event", {
        detail: { type, ts: Date.now(), ...(detail || {}) },
      });
      window.dispatchEvent(evt);
      // Fallback console for environments without an analytics bridge
      if (
        (import.meta as any).env?.DEV ||
        (typeof localStorage !== "undefined" &&
          localStorage.getItem("aiMemo.fab.debug") === "true")
      ) {
        // eslint-disable-next-line no-console
        console.log("[FAB]", type, detail || "");
      }
    } catch {}
  }, []);

  const sendImpression = useCallback(
    (enabled: boolean, modalOpen: boolean) => {
      if (!enabled || impressionSent.current || modalOpen) return;
      impressionSent.current = true;
      send("fab_impression");
    },
    [send],
  );

  const sendMemoContextChange = useCallback(
    (memoOpen: boolean) => {
      if (prevMemoOpen.current === null) {
        prevMemoOpen.current = memoOpen;
        return;
      }
      if (prevMemoOpen.current !== memoOpen) {
        send(memoOpen ? "fab_context_show" : "fab_context_hide");
        prevMemoOpen.current = memoOpen;
      }
    },
    [send],
  );

  return { send, sendImpression, sendMemoContextChange };
}

```

### usePostsManifest.ts

**Path:** `frontend/src/components/features/memo/fab/hooks/usePostsManifest.ts`

```typescript
import { useEffect, useState } from "react";
import type { BlogPost } from "../types";

// Hook to load posts manifest
export function usePostsManifest(): BlogPost[] {
  const [posts, setPosts] = useState<BlogPost[]>([]);

  useEffect(() => {
    fetch("/posts-manifest.json")
      .then((res) => res.json())
      .then((data) => {
        if (data.items) {
          setPosts(data.items.filter((p: any) => p.published !== false));
        }
      })
      .catch(() => setPosts([]));
  }, []);

  return posts;
}

```

### useRealTerminal.ts

**Path:** `frontend/src/components/features/memo/fab/hooks/useRealTerminal.ts`

```typescript
/**
 * useRealTerminal - Real Linux terminal connection hook
 *
 * Manages WebSocket connection to the terminal gateway for real shell access.
 * Uses the terminal.ts service for connection handling.
 */

import { useCallback, useEffect, useRef, useState } from "react";
import {
  connectTerminal,
  checkTerminalHealth,
  hasAuthToken,
  type TerminalConnection,
  type TerminalOptions,
} from "@/services/terminal";

export type TerminalStatus =
  | "disconnected"
  | "connecting"
  | "connected"
  | "error";

export type UseRealTerminalOptions = {
  cols?: number;
  rows?: number;
  onData?: (data: string) => void;
  onStatusChange?: (status: TerminalStatus) => void;
  autoConnect?: boolean;
};

export type UseRealTerminalReturn = {
  status: TerminalStatus;
  error: string | null;
  isAvailable: boolean;
  connect: () => void;
  disconnect: () => void;
  send: (data: string) => void;
  resize: (cols: number, rows: number) => void;
  checkHealth: () => Promise<boolean>;
};

export function useRealTerminal(
  options: UseRealTerminalOptions = {}
): UseRealTerminalReturn {
  const {
    cols = 80,
    rows = 24,
    onData,
    onStatusChange,
    autoConnect = false,
  } = options;

  const [status, setStatus] = useState<TerminalStatus>("disconnected");
  const [error, setError] = useState<string | null>(null);
  const [isAvailable, setIsAvailable] = useState(false);
  const connectionRef = useRef<TerminalConnection | null>(null);
  const onDataRef = useRef(onData);
  const onStatusChangeRef = useRef(onStatusChange);

  // Keep refs up to date
  useEffect(() => {
    onDataRef.current = onData;
  }, [onData]);

  useEffect(() => {
    onStatusChangeRef.current = onStatusChange;
  }, [onStatusChange]);

  // Notify status changes
  useEffect(() => {
    onStatusChangeRef.current?.(status);
  }, [status]);

  // Check if terminal service is available on mount
  useEffect(() => {
    const checkAvailability = async () => {
      const authOk = hasAuthToken();
      if (!authOk) {
        setIsAvailable(false);
        return;
      }
      const healthOk = await checkTerminalHealth();
      setIsAvailable(healthOk);
    };
    checkAvailability();
  }, []);

  const connect = useCallback(() => {
    // Don't connect if already connected
    if (connectionRef.current?.isConnected()) {
      return;
    }

    // Check auth token
    if (!hasAuthToken()) {
      setError("로그인이 필요합니다");
      setStatus("error");
      return;
    }

    setStatus("connecting");
    setError(null);

    const terminalOptions: TerminalOptions = {
      cols,
      rows,
      onOpen: () => {
        setStatus("connected");
        setError(null);
      },
      onData: (data) => {
        onDataRef.current?.(data);
      },
      onClose: (code, reason) => {
        setStatus("disconnected");
        connectionRef.current = null;
        if (code !== 1000) {
          setError(`연결 종료: ${reason || `코드 ${code}`}`);
        }
      },
      onError: () => {
        setStatus("error");
        setError("터미널 연결에 실패했습니다");
        connectionRef.current = null;
      },
    };

    const connection = connectTerminal(terminalOptions);

    if (!connection) {
      setStatus("error");
      setError("터미널 연결을 시작할 수 없습니다");
      return;
    }

    connectionRef.current = connection;
  }, [cols, rows]);

  const disconnect = useCallback(() => {
    if (connectionRef.current) {
      connectionRef.current.close();
      connectionRef.current = null;
    }
    setStatus("disconnected");
    setError(null);
  }, []);

  const send = useCallback((data: string) => {
    if (connectionRef.current?.isConnected()) {
      connectionRef.current.send(data);
    }
  }, []);

  const resize = useCallback((newCols: number, newRows: number) => {
    if (connectionRef.current?.isConnected()) {
      connectionRef.current.resize(newCols, newRows);
    }
  }, []);

  const checkHealth = useCallback(async () => {
    const result = await checkTerminalHealth();
    setIsAvailable(result && hasAuthToken());
    return result;
  }, []);

  // Auto-connect if enabled
  useEffect(() => {
    if (autoConnect && isAvailable && status === "disconnected") {
      connect();
    }
  }, [autoConnect, isAvailable, status, connect]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (connectionRef.current) {
        connectionRef.current.close();
        connectionRef.current = null;
      }
    };
  }, []);

  return {
    status,
    error,
    isAvailable,
    connect,
    disconnect,
    send,
    resize,
    checkHealth,
  };
}

```

### useShellCommander.ts

**Path:** `frontend/src/components/features/memo/fab/hooks/useShellCommander.ts`

```typescript
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import type { ShellCommand, ShellLog, BlogPost } from "../types";

type UseShellCommanderOptions = {
  vfs: {
    displayPath: string;
    currentPath: string;
    years: string[];
    ls: (path?: string) => string;
    cd: (path: string) => string;
    pwd: () => string;
    cat: (filename: string) => string;
    find: (keyword: string) => string;
    tree: () => string;
    navigate: (path: string) => void;
  };
  posts: BlogPost[];
  onChatOpen: () => void;
  onChatOpenWithMessage: (message: string) => void;
  onMemoToggle: () => void;
  onStackClick: () => void;
  onShellClose: () => void;
  send: (type: string, detail?: Record<string, any>) => void;
};

export function useShellCommander({
  vfs,
  posts,
  onChatOpen,
  onChatOpenWithMessage,
  onMemoToggle,
  onStackClick,
  onShellClose,
  send,
}: UseShellCommanderOptions) {
  const [shellInput, setShellInput] = useState("");
  const [shellOutput, setShellOutput] = useState<string | null>(null);
  const [commandHistory, setCommandHistory] = useState<string[]>([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const [shellLogs, setShellLogs] = useState<ShellLog[]>([]);
  const [suggestions, setSuggestions] = useState<string[]>([]);
  const [selectedSuggestionIndex, setSelectedSuggestionIndex] = useState(-1);
  const shellInputRef = useRef<HTMLInputElement>(null);
  const consoleEndRef = useRef<HTMLDivElement>(null);

  // Shell Commands
  const shellCommands: ShellCommand[] = useMemo(
    () => [
      // Feature commands
      {
        name: "chat",
        aliases: ["c", "ai"],
        description: "AI 채팅 열기",
        action: () => {
          onChatOpen();
          send("fab_ai_chat_open");
          onShellClose();
          setShellOutput(null);
        },
      },
      {
        name: "memo",
        aliases: ["m", "note"],
        description: "메모장 열기/닫기",
        action: () => {
          send("fab_memo_toggle");
          onMemoToggle();
          onShellClose();
          setShellOutput(null);
        },
      },
      {
        name: "stack",
        aliases: ["s", "history"],
        description: "방문 기록 스택 보기",
        action: () => {
          onStackClick();
          onShellClose();
          setShellOutput(null);
        },
      },
      {
        name: "insight",
        aliases: ["i", "map", "graph"],
        description: "인사이트 그래프 페이지 열기",
        action: () => {
          vfs.navigate("/insight");
          onShellClose();
          setShellOutput(null);
        },
      },
      // Linux-like filesystem commands
      {
        name: "ls",
        aliases: ["dir", "ll"],
        description: "현재 디렉토리 목록",
        action: (args?: string) => {
          const result = vfs.ls(args);
          setShellOutput(result);
        },
      },
      {
        name: "cd",
        aliases: [],
        description: "디렉토리 이동 (예: cd /blog/2025)",
        action: (args?: string) => {
          const result = vfs.cd(args || "/");
          if (result) {
            setShellOutput(result);
          } else {
            onShellClose();
            setShellOutput(null);
          }
        },
      },
      {
        name: "pwd",
        aliases: [],
        description: "현재 경로 표시",
        action: () => {
          setShellOutput(vfs.pwd());
        },
      },
      {
        name: "cat",
        aliases: ["open", "view"],
        description: "게시글 열기 (예: cat post-slug.md)",
        action: (args?: string) => {
          if (!args) {
            setShellOutput("cat: missing file operand");
            return;
          }
          const result = vfs.cat(args);
          if (result.startsWith("Opening:")) {
            onShellClose();
            setShellOutput(null);
          } else {
            setShellOutput(result);
          }
        },
      },
      {
        name: "find",
        aliases: ["search", "grep"],
        description: "게시글 검색 (예: find kafka)",
        action: (args?: string) => {
          if (!args) {
            setShellOutput("find: missing search term");
            return;
          }
          setShellOutput(vfs.find(args));
        },
      },
      {
        name: "tree",
        aliases: [],
        description: "블로그 디렉토리 구조 표시",
        action: () => {
          setShellOutput(vfs.tree());
        },
      },
      {
        name: "home",
        aliases: ["~"],
        description: "홈으로 이동",
        action: () => {
          vfs.navigate("/");
          onShellClose();
          setShellOutput(null);
        },
      },
      {
        name: "clear",
        aliases: ["cls"],
        description: "출력 지우기",
        action: () => {
          setShellOutput(null);
          setShellInput("");
        },
      },
    ],
    [send, onMemoToggle, onStackClick, vfs, onChatOpen, onShellClose],
  );

  const executeShellCommand = useCallback(
    (input: string) => {
      const trimmed = input.trim();
      if (!trimmed) return;

      // Add to command history
      setCommandHistory((prev) => [...prev.slice(-20), trimmed]);
      setHistoryIndex(-1);

      // Parse command and arguments
      const parts = trimmed.split(/\s+/);
      const cmdName = parts[0].toLowerCase();
      const args = parts.slice(1).join(" ");

      if (cmdName === "help" || cmdName === "?") {
        const featureCmds = shellCommands.filter((c) =>
          ["chat", "memo", "stack", "insight", "clear"].includes(c.name),
        );
        const fsCmds = shellCommands.filter((c) =>
          ["ls", "cd", "pwd", "cat", "find", "tree", "home"].includes(c.name),
        );

        let helpText = "=== Feature Commands ===\n";
        helpText += featureCmds
          .map((cmd) => `  ${cmd.name.padEnd(8)} ${cmd.description}`)
          .join("\n");
        helpText += "\n\n=== Filesystem Commands ===\n";
        helpText += fsCmds
          .map((cmd) => `  ${cmd.name.padEnd(8)} ${cmd.description}`)
          .join("\n");
        helpText +=
          "\n\n예시:\n  ls              현재 위치 파일 목록\n  cd /blog/2025   2025년 글로 이동\n  find kafka      'kafka' 포함 글 검색\n  cat post.md     게시글 열기";

        setShellOutput(helpText);
        setShellInput("");
        return;
      }

      const cmd = shellCommands.find(
        (c) => c.name === cmdName || c.aliases.includes(cmdName),
      );

      if (cmd) {
        cmd.action(args || undefined);
        setShellInput("");
      } else {
        // Fallback to AI chat for unrecognized commands
        onChatOpenWithMessage(trimmed);
        send("fab_shell_ai_fallback", { input: trimmed });
        onShellClose();
        setShellOutput(null);
        setShellInput("");
      }
    },
    [shellCommands, onChatOpenWithMessage, send, onShellClose],
  );

  // Extended execute with logging
  const executeShellCommandWithLog = useCallback(
    (input: string) => {
      const trimmed = input.trim();
      if (!trimmed) return;

      // Clear suggestions when executing
      setSuggestions([]);
      setSelectedSuggestionIndex(-1);

      // clear command also clears logs
      if (trimmed.toLowerCase() === "clear" || trimmed.toLowerCase() === "cls") {
        setShellLogs([]);
        setShellOutput(null);
        setShellInput("");
        return;
      }

      // Add input log
      const inputLog = `${vfs.displayPath} $ ${trimmed}`;
      setShellLogs((prev) => [
        ...prev.slice(-50),
        { type: "input", text: inputLog },
      ]);

      // Execute command
      executeShellCommand(trimmed);
    },
    [executeShellCommand, vfs.displayPath],
  );

  // Generate dynamic suggestions based on input
  const generateSuggestions = useCallback(
    (input: string): string[] => {
      const trimmed = input.trim().toLowerCase();
      if (!trimmed) return [];

      const parts = trimmed.split(/\s+/);
      const cmd = parts[0];
      const args = parts.slice(1).join(" ");

      // Command completion (no args yet)
      if (parts.length === 1) {
        const cmdMatches = shellCommands
          .filter(
            (c) =>
              c.name.startsWith(cmd) ||
              c.aliases.some((a) => a.startsWith(cmd)),
          )
          .map((c) => c.name);
        return cmdMatches.slice(0, 6);
      }

      // ls command - show directory contents
      if (cmd === "ls" || cmd === "dir" || cmd === "ll") {
        const lsOutput = vfs.ls(args || undefined);
        if (!lsOutput.startsWith("ls:")) {
          const items = lsOutput.split("\n").filter(Boolean).slice(0, 8);
          return items.map(
            (item) =>
              `ls ${args ? args + "/" : ""}${item.replace("/", "")}`,
          );
        }
      }

      // cd command - path autocomplete
      if (cmd === "cd") {
        const cdSuggestions: string[] = [];

        // Always suggest going back
        cdSuggestions.push("cd ..");
        cdSuggestions.push("cd ~");

        // Suggest available years
        if (!args || args === "/blog" || args.startsWith("/blog/")) {
          vfs.years.forEach((year) => {
            cdSuggestions.push(`cd /blog/${year}`);
          });
        }

        // If currently in blog directory, suggest year directories
        if (vfs.currentPath === "/" || vfs.currentPath === "/blog") {
          vfs.years.forEach((year) => {
            if (!args || year.includes(args)) {
              cdSuggestions.push(`cd ${year}`);
            }
          });
        }

        return cdSuggestions
          .filter((s) => s.toLowerCase().includes(args))
          .slice(0, 6);
      }

      // cat/open command - file autocomplete
      if (cmd === "cat" || cmd === "open" || cmd === "view") {
        const currentPosts = vfs.currentPath.startsWith("/blog/")
          ? posts.filter((p) =>
              p.url.includes(vfs.currentPath.split("/")[2]),
            )
          : posts;

        const matches = currentPosts
          .filter((p) => {
            const slug = p.url.split("/").pop() || "";
            return (
              !args ||
              slug.toLowerCase().includes(args.toLowerCase()) ||
              p.title.toLowerCase().includes(args.toLowerCase())
            );
          })
          .slice(0, 6);

        return matches.map((p) => {
          const slug = p.url.split("/").pop();
          return `cat ${slug}.md`;
        });
      }

      // find/search command - keyword suggestions from post titles and tags
      if (cmd === "find" || cmd === "search" || cmd === "grep") {
        if (!args) {
          // Suggest popular keywords from post titles
          const keywords = new Set<string>();
          posts.forEach((p) => {
            // Extract words from title
            p.title.split(/\s+/).forEach((word) => {
              if (word.length > 2) keywords.add(word.toLowerCase());
            });
            // Add tags
            p.tags?.forEach((tag) => keywords.add(tag.toLowerCase()));
            // Add category
            if (p.category) keywords.add(p.category.toLowerCase());
          });
          return Array.from(keywords)
            .slice(0, 8)
            .map((k) => `find ${k}`);
        } else {
          // Filter keywords based on input
          const allKeywords: string[] = [];
          posts.forEach((p) => {
            p.title.split(/\s+/).forEach((word) => {
              if (word.length > 2 && word.toLowerCase().includes(args)) {
                allKeywords.push(word.toLowerCase());
              }
            });
            p.tags?.forEach((tag) => {
              if (tag.toLowerCase().includes(args))
                allKeywords.push(tag.toLowerCase());
            });
          });
          const unique = [...new Set(allKeywords)];
          return unique.slice(0, 6).map((k) => `find ${k}`);
        }
      }

      return [];
    },
    [shellCommands, vfs, posts],
  );

  // Handle key down with history navigation
  const handleShellKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLInputElement>) => {
      if (e.key === "Enter") {
        e.preventDefault();
        executeShellCommand(shellInput);
      } else if (e.key === "Escape") {
        onShellClose();
        setShellOutput(null);
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        if (commandHistory.length > 0) {
          const newIndex =
            historyIndex < commandHistory.length - 1
              ? historyIndex + 1
              : historyIndex;
          setHistoryIndex(newIndex);
          setShellInput(
            commandHistory[commandHistory.length - 1 - newIndex] || "",
          );
        }
      } else if (e.key === "ArrowDown") {
        e.preventDefault();
        if (historyIndex > 0) {
          const newIndex = historyIndex - 1;
          setHistoryIndex(newIndex);
          setShellInput(
            commandHistory[commandHistory.length - 1 - newIndex] || "",
          );
        } else if (historyIndex === 0) {
          setHistoryIndex(-1);
          setShellInput("");
        }
      } else if (e.key === "Tab") {
        e.preventDefault();
        // Simple tab completion for commands
        const trimmed = shellInput.trim().toLowerCase();
        if (trimmed) {
          const matches = shellCommands.filter(
            (c) =>
              c.name.startsWith(trimmed) ||
              c.aliases.some((a) => a.startsWith(trimmed)),
          );
          if (matches.length === 1) {
            setShellInput(matches[0].name + " ");
          } else if (matches.length > 1) {
            setShellOutput(matches.map((m) => m.name).join("  "));
          }
        }
      }
    },
    [
      shellInput,
      executeShellCommand,
      commandHistory,
      historyIndex,
      shellCommands,
      onShellClose,
    ],
  );

  // Handle suggestion selection
  const selectSuggestion = useCallback((suggestion: string) => {
    setShellInput(suggestion);
    setSuggestions([]);
    setSelectedSuggestionIndex(-1);
    shellInputRef.current?.focus();
  }, []);

  // Enhanced key handler with suggestion navigation
  const handleShellKeyDownWithSuggestions = useCallback(
    (e: React.KeyboardEvent<HTMLInputElement>) => {
      if (suggestions.length > 0) {
        if (e.key === "ArrowDown") {
          e.preventDefault();
          setSelectedSuggestionIndex((prev) =>
            prev < suggestions.length - 1 ? prev + 1 : 0,
          );
          return;
        }
        if (e.key === "ArrowUp") {
          e.preventDefault();
          setSelectedSuggestionIndex((prev) =>
            prev > 0 ? prev - 1 : suggestions.length - 1,
          );
          return;
        }
        if (
          e.key === "Tab" ||
          (e.key === "Enter" && selectedSuggestionIndex >= 0)
        ) {
          e.preventDefault();
          const selected =
            selectedSuggestionIndex >= 0
              ? suggestions[selectedSuggestionIndex]
              : suggestions[0];
          if (selected) {
            selectSuggestion(selected);
          }
          return;
        }
        if (e.key === "Escape") {
          setSuggestions([]);
          setSelectedSuggestionIndex(-1);
          return;
        }
      }

      // Fall through to original handler
      if (e.key === "Enter") {
        e.preventDefault();
        executeShellCommandWithLog(shellInput);
        setSuggestions([]);
      } else {
        handleShellKeyDown(e);
      }
    },
    [
      suggestions,
      selectedSuggestionIndex,
      selectSuggestion,
      executeShellCommandWithLog,
      shellInput,
      handleShellKeyDown,
    ],
  );

  // Update suggestions when input changes
  useEffect(() => {
    const newSuggestions = generateSuggestions(shellInput);
    setSuggestions(newSuggestions);
    setSelectedSuggestionIndex(-1);
  }, [shellInput, generateSuggestions]);

  // Add output to logs when shellOutput changes
  useEffect(() => {
    if (shellOutput) {
      setShellLogs((prev) => [
        ...prev.slice(-50),
        { type: "output", text: shellOutput },
      ]);
    }
  }, [shellOutput]);

  // Scroll to bottom when logs update
  useEffect(() => {
    if (consoleEndRef.current) {
      consoleEndRef.current.scrollIntoView({ behavior: "smooth" });
    }
  }, [shellLogs]);

  return {
    shellInput,
    setShellInput,
    shellOutput,
    setShellOutput,
    commandHistory,
    shellLogs,
    setShellLogs,
    suggestions,
    selectedSuggestionIndex,
    shellInputRef,
    consoleEndRef,
    executeShellCommandWithLog,
    handleShellKeyDownWithSuggestions,
    selectSuggestion,
  };
}

```

### useVirtualFS.ts

**Path:** `frontend/src/components/features/memo/fab/hooks/useVirtualFS.ts`

```typescript
import { useCallback, useMemo } from "react";
import { useLocation, useNavigate } from "react-router-dom";
import type { BlogPost } from "../types";

// Virtual filesystem hook
export function useVirtualFS(posts: BlogPost[]) {
  const location = useLocation();
  const navigate = useNavigate();

  // Derive current path from URL
  const currentPath = useMemo(() => {
    const path = location.pathname;
    if (path === "/" || path === "") return "/";
    if (path.startsWith("/blog/")) {
      // /blog/2025/post-slug -> /blog/2025
      const parts = path.split("/").filter(Boolean);
      if (parts.length >= 2) {
        return "/" + parts.slice(0, 2).join("/");
      }
    }
    return path;
  }, [location.pathname]);

  // Get current post info if viewing a post
  const currentPost = useMemo(() => {
    const path = location.pathname;
    if (!path.startsWith("/blog/")) return null;
    const parts = path.split("/").filter(Boolean);
    // /blog/2025/post-slug has 3 parts
    if (parts.length >= 3) {
      const slug = parts[parts.length - 1];
      return (
        posts.find((p) => {
          const postSlug = p.url.split("/").pop();
          return postSlug === slug;
        }) || null
      );
    }
    return null;
  }, [location.pathname, posts]);

  // Get shell-style display path (shorter, more readable)
  const displayPath = useMemo(() => {
    const path = location.pathname;
    if (path === "/" || path === "") return "~";

    // Check different page types
    if (path === "/blog" || path === "/blog/") return "~/blog";
    if (path === "/about" || path === "/about/") return "~/about";
    if (path === "/guestbook" || path === "/guestbook/") return "~/guestbook";

    if (path.startsWith("/blog/")) {
      const parts = path.split("/").filter(Boolean);
      if (parts.length >= 3 && currentPost) {
        // Viewing a specific post - show year and truncated title
        const year = parts[1];
        const title =
          currentPost.title.length > 20
            ? currentPost.title.slice(0, 18) + ".."
            : currentPost.title;
        return `~/${year}/${title}`;
      } else if (parts.length >= 2) {
        // Viewing year directory
        const year = parts[1];
        return `~/${year}`;
      }
    }

    // Default: show path without leading slash
    return "~" + path;
  }, [location.pathname, currentPost]);

  // Get available years
  const years = useMemo(() => {
    const yearSet = new Set(posts.map((p) => p.url.split("/")[2]));
    return Array.from(yearSet).sort().reverse();
  }, [posts]);

  // Get categories
  const categories = useMemo(() => {
    const catSet = new Set(posts.map((p) => p.category));
    return Array.from(catSet).sort();
  }, [posts]);

  // Get posts for current directory
  const getPostsInPath = useCallback(
    (path: string): BlogPost[] => {
      if (path === "/" || path === "/blog") {
        return [];
      }
      const parts = path.split("/").filter(Boolean);
      if (parts[0] === "blog" && parts.length >= 2) {
        const year = parts[1];
        return posts.filter((p) => p.url.includes(`/blog/${year}/`));
      }
      return [];
    },
    [posts],
  );

  // List directory contents
  const ls = useCallback(
    (path?: string): string => {
      const targetPath = path || currentPath;

      if (targetPath === "/" || targetPath === "") {
        return "blog/\n";
      }

      if (targetPath === "/blog") {
        return years.map((y) => `${y}/`).join("\n") + "\n";
      }

      const parts = targetPath.split("/").filter(Boolean);
      if (parts[0] === "blog" && parts.length >= 2) {
        const year = parts[1];
        const yearPosts = posts.filter((p) => p.url.includes(`/blog/${year}/`));
        if (yearPosts.length === 0) {
          return `ls: ${targetPath}: No such directory`;
        }
        return yearPosts
          .map((p) => {
            const slug = p.url.split("/").pop();
            return `${slug}.md`;
          })
          .join("\n");
      }

      return `ls: ${targetPath}: No such directory`;
    },
    [currentPath, years, posts],
  );

  // Change directory
  const cd = useCallback(
    (path: string): string => {
      if (!path || path === "~" || path === "/") {
        navigate("/");
        return "";
      }

      if (path === "..") {
        const parts = currentPath.split("/").filter(Boolean);
        if (parts.length <= 1) {
          navigate("/");
          return "";
        }
        const newPath = "/" + parts.slice(0, -1).join("/");
        if (newPath === "/blog") {
          navigate("/");
          return "";
        }
        navigate(newPath);
        return "";
      }

      // Handle absolute paths
      let targetPath = path;
      if (!path.startsWith("/")) {
        // Relative path
        if (currentPath === "/") {
          targetPath = "/" + path;
        } else {
          targetPath = currentPath + "/" + path;
        }
      }

      // Clean up path
      targetPath = targetPath.replace(/\/+/g, "/").replace(/\/$/, "") || "/";

      // Validate path
      if (targetPath === "/blog") {
        navigate("/");
        return "";
      }

      const parts = targetPath.split("/").filter(Boolean);
      if (parts[0] === "blog" && parts.length >= 2) {
        const year = parts[1];
        if (years.includes(year)) {
          // Navigate to year page (which shows filtered posts)
          navigate(`/blog?year=${year}`);
          return "";
        }
        return `cd: ${targetPath}: No such directory`;
      }

      if (targetPath === "/") {
        navigate("/");
        return "";
      }

      return `cd: ${targetPath}: No such directory`;
    },
    [currentPath, years, navigate],
  );

  // Print working directory
  const pwd = useCallback((): string => {
    return currentPath || "/";
  }, [currentPath]);

  // Cat file (navigate to post)
  const cat = useCallback(
    (filename: string): string => {
      if (!filename) {
        return "cat: missing file operand";
      }

      // Remove .md extension if present
      const slug = filename.replace(/\.md$/, "");

      // Find matching post
      const post = posts.find((p) => {
        const postSlug = p.url.split("/").pop();
        return (
          postSlug === slug || postSlug?.toLowerCase() === slug.toLowerCase()
        );
      });

      if (post) {
        navigate(post.url);
        return `Opening: ${post.title}`;
      }

      return `cat: ${filename}: No such file`;
    },
    [posts, navigate],
  );

  // Find posts by keyword
  const find = useCallback(
    (keyword: string): string => {
      if (!keyword) {
        return "find: missing search term";
      }

      const kw = keyword.toLowerCase();
      const matches = posts.filter(
        (p) =>
          p.title.toLowerCase().includes(kw) ||
          p.slug?.toLowerCase().includes(kw) ||
          p.tags?.some((t) => t.toLowerCase().includes(kw)) ||
          p.category?.toLowerCase().includes(kw),
      );

      if (matches.length === 0) {
        return `No posts found matching: ${keyword}`;
      }

      return (
        matches
          .slice(0, 10)
          .map((p) => {
            const path = p.url;
            return `${path}  ${p.title.slice(0, 30)}${p.title.length > 30 ? "..." : ""}`;
          })
          .join("\n") +
        (matches.length > 10 ? `\n... and ${matches.length - 10} more` : "")
      );
    },
    [posts],
  );

  // Tree view of blog structure
  const tree = useCallback((): string => {
    let output = "/\n└── blog/\n";

    years.forEach((year, yi) => {
      const isLast = yi === years.length - 1;
      const prefix = isLast ? "    └── " : "    ├── ";
      const yearPosts = posts.filter((p) => p.url.includes(`/blog/${year}/`));
      output += `${prefix}${year}/ (${yearPosts.length} posts)\n`;
    });

    return output;
  }, [years, posts]);

  return {
    currentPath,
    displayPath,
    currentPost,
    years,
    categories,
    getPostsInPath,
    ls,
    cd,
    pwd,
    cat,
    find,
    tree,
    navigate,
  };
}

```

---

## frontend/src/components/features/navigation

### Breadcrumb.tsx

**Path:** `frontend/src/components/features/navigation/Breadcrumb.tsx`

```tsx
import { Link } from 'react-router-dom';
import { ChevronRight, Home } from 'lucide-react';
import { cn } from '@/lib/utils';

interface BreadcrumbItem {
  label: string;
  href?: string;
}

interface BreadcrumbProps {
  items: BreadcrumbItem[];
  className?: string;
}

export function Breadcrumb({ items, className }: BreadcrumbProps) {
  return (
    <nav
      className={cn(
        'flex items-center space-x-1 text-sm text-muted-foreground',
        className
      )}
    >
      <Link to='/' className='hover:text-foreground transition-colors'>
        <Home className='h-4 w-4' />
      </Link>
      {items.map((item, index) => (
        <div key={index} className='flex items-center space-x-1'>
          <ChevronRight className='h-4 w-4' />
          {item.href ? (
            <Link
              to={item.href}
              className='hover:text-foreground transition-colors'
            >
              {item.label}
            </Link>
          ) : (
            <span className='text-foreground'>{item.label}</span>
          )}
        </div>
      ))}
    </nav>
  );
}

export default Breadcrumb;

```

### Pagination.tsx

**Path:** `frontend/src/components/features/navigation/Pagination.tsx`

```tsx
import { useState, useCallback, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  ChevronLeft,
  ChevronRight,
  ChevronsLeft,
  ChevronsRight,
  MoreHorizontal,
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  className?: string;
  showFirstLast?: boolean;
  showPageInfo?: boolean;
  showQuickJump?: boolean;
  size?: 'sm' | 'md' | 'lg';
}

const Pagination = ({
  currentPage,
  totalPages,
  onPageChange,
  className = '',
  showFirstLast = true,
  showPageInfo = true,
  showQuickJump = false,
  size = 'md',
}: PaginationProps) => {
  const [jumpValue, setJumpValue] = useState('');
  const [isJumpOpen, setIsJumpOpen] = useState(false);

  if (totalPages <= 1) return null;

  const sizeClasses = {
    sm: { button: 'h-8 w-8 text-xs', icon: 'h-3.5 w-3.5', gap: 'gap-1' },
    md: { button: 'h-10 w-10 text-sm', icon: 'h-4 w-4', gap: 'gap-1.5' },
    lg: { button: 'h-12 w-12 text-base', icon: 'h-5 w-5', gap: 'gap-2' },
  };

  const styles = sizeClasses[size];

  const getVisiblePages = () => {
    const delta = size === 'sm' ? 1 : 2;
    const range: (number | string)[] = [];
    const rangeWithDots: (number | string)[] = [];

    for (
      let i = Math.max(2, currentPage - delta);
      i <= Math.min(totalPages - 1, currentPage + delta);
      i++
    ) {
      range.push(i);
    }

    if (currentPage - delta > 2) {
      rangeWithDots.push(1, 'ellipsis-start');
    } else {
      rangeWithDots.push(1);
    }

    rangeWithDots.push(...range);

    if (currentPage + delta < totalPages - 1) {
      rangeWithDots.push('ellipsis-end', totalPages);
    } else if (totalPages > 1) {
      rangeWithDots.push(totalPages);
    }

    return rangeWithDots;
  };

  const handleJump = useCallback(() => {
    const page = parseInt(jumpValue, 10);
    if (!isNaN(page) && page >= 1 && page <= totalPages && page !== currentPage) {
      onPageChange(page);
    }
    setJumpValue('');
    setIsJumpOpen(false);
  }, [jumpValue, totalPages, currentPage, onPageChange]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === 'Enter') {
        handleJump();
      } else if (e.key === 'Escape') {
        setIsJumpOpen(false);
        setJumpValue('');
      }
    },
    [handleJump]
  );

  const visiblePages = getVisiblePages();

  const NavButton = ({
    onClick,
    disabled,
    children,
    label,
    variant = 'outline',
  }: {
    onClick: () => void;
    disabled: boolean;
    children: React.ReactNode;
    label: string;
    variant?: 'outline' | 'ghost';
  }) => (
    <Button
      variant={variant}
      size='icon'
      onClick={onClick}
      disabled={disabled}
      aria-label={label}
      className={cn(
        styles.button,
        'rounded-xl transition-all duration-200',
        'disabled:opacity-40 disabled:cursor-not-allowed',
        'hover:bg-primary/10 hover:border-primary/30 hover:scale-105',
        'active:scale-95',
        'focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2'
      )}
    >
      {children}
    </Button>
  );

  const PageButton = ({
    page,
    isActive,
  }: {
    page: number;
    isActive: boolean;
  }) => (
    <Button
      variant={isActive ? 'default' : 'ghost'}
      size='icon'
      onClick={() => onPageChange(page)}
      aria-label={`Page ${page}`}
      aria-current={isActive ? 'page' : undefined}
      className={cn(
        styles.button,
        'rounded-xl font-medium transition-all duration-200',
        isActive
          ? 'bg-primary text-primary-foreground shadow-md hover:bg-primary/90 scale-105'
          : 'hover:bg-muted hover:scale-105',
        'active:scale-95',
        'focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2'
      )}
    >
      {page}
    </Button>
  );

  const EllipsisButton = ({ position }: { position: 'start' | 'end' }) => {
    if (!showQuickJump) {
      return (
        <span
          className={cn(
            styles.button,
            'flex items-center justify-center text-muted-foreground'
          )}
          aria-hidden
        >
          <MoreHorizontal className={styles.icon} />
        </span>
      );
    }

    return (
      <div className='relative'>
        <Button
          variant='ghost'
          size='icon'
          onClick={() => setIsJumpOpen(!isJumpOpen)}
          aria-label='Jump to page'
          className={cn(
            styles.button,
            'rounded-xl text-muted-foreground hover:text-foreground hover:bg-muted',
            'transition-all duration-200'
          )}
        >
          <MoreHorizontal className={styles.icon} />
        </Button>
        {isJumpOpen && (
          <div className='absolute top-full left-1/2 -translate-x-1/2 mt-2 z-50'>
            <div className='bg-popover border border-border rounded-xl shadow-lg p-2 flex gap-1.5'>
              <Input
                type='number'
                min={1}
                max={totalPages}
                value={jumpValue}
                onChange={(e) => setJumpValue(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder='Go to'
                className='w-16 h-8 text-xs rounded-lg text-center'
                autoFocus
              />
              <Button
                size='sm'
                onClick={handleJump}
                className='h-8 px-2 text-xs rounded-lg'
              >
                Go
              </Button>
            </div>
          </div>
        )}
      </div>
    );
  };

  return (
    <nav
      role='navigation'
      aria-label='Pagination'
      className={cn('flex flex-col items-center gap-3', className)}
    >
      <div className={cn('flex items-center', styles.gap)}>
        {showFirstLast && (
          <NavButton
            onClick={() => onPageChange(1)}
            disabled={currentPage === 1}
            label='First page'
            variant='ghost'
          >
            <ChevronsLeft className={styles.icon} />
          </NavButton>
        )}

        <NavButton
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
          label='Previous page'
        >
          <ChevronLeft className={styles.icon} />
        </NavButton>

        <div className={cn('flex items-center', styles.gap, 'mx-1')}>
          {visiblePages.map((page, index) =>
            typeof page === 'string' ? (
              <EllipsisButton
                key={page}
                position={page === 'ellipsis-start' ? 'start' : 'end'}
              />
            ) : (
              <PageButton key={page} page={page} isActive={currentPage === page} />
            )
          )}
        </div>

        <NavButton
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
          label='Next page'
        >
          <ChevronRight className={styles.icon} />
        </NavButton>

        {showFirstLast && (
          <NavButton
            onClick={() => onPageChange(totalPages)}
            disabled={currentPage === totalPages}
            label='Last page'
            variant='ghost'
          >
            <ChevronsRight className={styles.icon} />
          </NavButton>
        )}
      </div>

      {showPageInfo && (
        <p className='text-xs text-muted-foreground'>
          Page <span className='font-medium text-foreground'>{currentPage}</span> of{' '}
          <span className='font-medium text-foreground'>{totalPages}</span>
        </p>
      )}
    </nav>
  );
};

export default Pagination;

```

### PostNavigation.tsx

**Path:** `frontend/src/components/features/navigation/PostNavigation.tsx`

```tsx
import { Link, useLocation } from 'react-router-dom';
import { BlogPost } from '@/types/blog';
import { Card, CardContent } from '@/components/ui/card';
import { ChevronLeft, ChevronRight } from 'lucide-react';

interface PostNavigationProps {
  currentPost: BlogPost;
  posts: BlogPost[];
  fromState?: unknown;
}

export function PostNavigation({
  currentPost,
  posts,
  fromState,
}: PostNavigationProps) {
  const location = useLocation();
  const preservedFrom =
    fromState ?? (location.state as { from?: unknown })?.from ?? location;
  const preservedSearch =
    (preservedFrom as { search?: string })?.search ?? location.search ?? '';
  const currentIndex = posts.findIndex(post => post.slug === currentPost.slug);
  const previousPost =
    currentIndex < posts.length - 1 ? posts[currentIndex + 1] : null;
  const nextPost = currentIndex > 0 ? posts[currentIndex - 1] : null;

  if (!previousPost && !nextPost) return null;

  return (
    <div className='grid gap-4 md:grid-cols-2 mt-12'>
      {previousPost && (
        <Card className='group hover:shadow-md transition-shadow'>
          <CardContent className='p-6'>
            <Link
              to={{
                pathname: `/blog/${previousPost.year}/${previousPost.slug}`,
                search: preservedSearch || undefined,
              }}
              state={{ from: preservedFrom }}
              className='block'
            >
              <div className='flex items-center text-sm text-muted-foreground mb-2'>
                <ChevronLeft className='h-4 w-4 mr-1' />
                Previous Post
              </div>
              <h3 className='font-semibold group-hover:text-primary transition-colors line-clamp-2'>
                {previousPost.title}
              </h3>
            </Link>
          </CardContent>
        </Card>
      )}

      {nextPost && (
        <Card className='group hover:shadow-md transition-shadow'>
          <CardContent className='p-6'>
            <Link
              to={{
                pathname: `/blog/${nextPost.year}/${nextPost.slug}`,
                search: preservedSearch || undefined,
              }}
              state={{ from: preservedFrom }}
              className='block'
            >
              <div className='flex items-center justify-end text-sm text-muted-foreground mb-2'>
                Next Post
                <ChevronRight className='h-4 w-4 ml-1' />
              </div>
              <h3 className='font-semibold group-hover:text-primary transition-colors line-clamp-2 text-right'>
                {nextPost.title}
              </h3>
            </Link>
          </CardContent>
        </Card>
      )}
    </div>
  );
}

export default PostNavigation;

```

### VisitedPostsMinimap.tsx

**Path:** `frontend/src/components/features/navigation/VisitedPostsMinimap.tsx`

```tsx
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { X, Clock, Map } from 'lucide-react';
import { cn } from '@/lib/utils';
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from '@/components/ui/sheet';
import { useIsMobile } from '@/hooks/use-mobile';

export type VisitedPostItem = {
  path: string; // "/blog/:year/:slug"
  title: string;
  coverImage?: string;
  year: string;
  slug: string;
};

const STORAGE_KEY = 'visited.posts';

type ChatSessionLite = {
  id: string;
  title?: string;
  summary?: string;
  articleUrl?: string;
  articleTitle?: string;
  updatedAt?: string;
};

export function useVisitedPostsState() {
  const [items, setItems] = useState<VisitedPostItem[]>([]);
  const [storageAvailable, setStorageAvailable] = useState(true);

  const read = useCallback(() => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        setItems([]);
        setStorageAvailable(true);
        return;
      }
      const parsed = JSON.parse(raw);
      // Validate that it's an array with proper structure
      if (!Array.isArray(parsed)) {
        // Invalid data - reset to empty array
        localStorage.setItem(STORAGE_KEY, JSON.stringify([]));
        setItems([]);
        setStorageAvailable(true);
        return;
      }
      // Filter out any malformed items
      const validItems = parsed.filter(
        (item: any) =>
          item &&
          typeof item === 'object' &&
          typeof item.path === 'string' &&
          typeof item.title === 'string'
      );
      setItems(validItems);
      setStorageAvailable(true);
    } catch (e) {
      // JSON parse failed or other error - reset storage
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify([]));
      } catch {
        // localStorage completely unavailable
      }
      setItems([]);
      setStorageAvailable(false);
    }
  }, []);

  useEffect(() => {
    read();
    const onStorage = (e: StorageEvent) => {
      if (!e.key || e.key === STORAGE_KEY) read();
    };
    const onCustom = () => read();
    const onStorageError = () => {
      setItems([]);
      setStorageAvailable(false);
    };
    window.addEventListener('storage', onStorage);
    window.addEventListener('visitedposts:update', onCustom as EventListener);
    window.addEventListener('visitedposts:error', onStorageError);
    return () => {
      window.removeEventListener('storage', onStorage);
      window.removeEventListener(
        'visitedposts:update',
        onCustom as EventListener
      );
      window.removeEventListener('visitedposts:error', onStorageError);
    };
  }, [read]);

  return { items, storageAvailable };
}

export function useVisitedPosts() {
  return useVisitedPostsState().items;
}

function FallbackAvatar({ title }: { title: string }) {
  const ch = (title || '?').trim().charAt(0).toUpperCase() || '?';
  return (
    <div
      className='flex h-8 w-8 items-center justify-center rounded-full bg-gradient-to-br from-primary/80 to-primary text-primary-foreground text-xs font-bold ring-2 ring-background shadow'
      aria-hidden
    >
      {ch}
    </div>
  );
}

type VisitedPostsMinimapMode = 'default' | 'fab';

type VisitedPostsMinimapProps = {
  mode?: VisitedPostsMinimapMode;
};

export function VisitedPostsMinimap({
  mode = 'default',
}: VisitedPostsMinimapProps = {}) {
  const { items, storageAvailable } = useVisitedPostsState();
  const [open, setOpen] = useState(false);
  const navigate = useNavigate();
  const [activeIndex, setActiveIndex] = useState(0);
  const [view, setView] = useState<'list' | 'graph'>('list');
  const [chatSessions, setChatSessions] = useState<ChatSessionLite[]>([]);
  const [selectedSessionIds, setSelectedSessionIds] = useState<string[]>([]);
  const isMobile = useIsMobile();
  const listContainerRef = useRef<HTMLDivElement | null>(null);

  const topStack = useMemo(() => items.slice(0, 4), [items]);
  const externalTrigger = mode === 'fab';

  const go = (p: VisitedPostItem) => {
    setOpen(false);
    navigate(p.path);
  };

  const clearAll = () => {
    if (!storageAvailable) return;
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify([]));
      window.dispatchEvent(new CustomEvent('visitedposts:update'));
    } catch {}
  };

  useEffect(() => {
    const readSessions = () => {
      try {
        const raw = localStorage.getItem('ai_chat_sessions_index');
        if (!raw) {
          setChatSessions([]);
          return;
        }
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
          // Invalid data - reset
          try {
            localStorage.setItem('ai_chat_sessions_index', JSON.stringify([]));
          } catch {}
          setChatSessions([]);
          return;
        }
        // Filter valid sessions
        const validSessions = parsed.filter(
          (s: any) => s && typeof s === 'object' && typeof s.id === 'string'
        );
        setChatSessions(validSessions);
      } catch {
        setChatSessions([]);
      }
    };
    readSessions();
    window.addEventListener(
      'aiChat:sessionsUpdated',
      readSessions as EventListener
    );
    return () => {
      window.removeEventListener(
        'aiChat:sessionsUpdated',
        readSessions as EventListener
      );
    };
  }, []);

  useEffect(() => {
    if (!externalTrigger) return;
    const onRequestOpen = () => {
      if (!items.length) return;
      setOpen(true);
      setTimeout(() => listContainerRef.current?.focus(), 0);
    };
    window.addEventListener(
      'visitedposts:open',
      onRequestOpen as EventListener
    );
    return () =>
      window.removeEventListener(
        'visitedposts:open',
        onRequestOpen as EventListener
      );
  }, [externalTrigger, items.length]);

  useEffect(() => {
    if (!items.length && open) setOpen(false);
  }, [items.length, open]);

  if (!storageAvailable && !items.length) return null;
  if (!items.length) return null;

  const sheet = (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetContent
        side={isMobile ? 'bottom' : 'right'}
        hideClose
        className={cn(
          'p-0 bg-background/95',
          // Only apply backdrop-blur on desktop for performance
          !isMobile && 'backdrop-blur supports-[backdrop-filter]:backdrop-blur-lg',
          isMobile
            ? 'max-h-[75vh] rounded-t-[24px] border-x border-t border-border/60 shadow-[0_-18px_50px_rgba(15,23,42,0.18)]'
            : 'h-full w-[420px] border-l border-border/40'
        )}
        aria-describedby={undefined}
        style={
          isMobile
            ? { paddingBottom: 'env(safe-area-inset-bottom)' }
            : undefined
        }
      >
        <SheetHeader className='sticky top-0 z-10 border-b border-border/60 bg-background/98 px-5 pb-4 pt-5'>
          {isMobile && (
            <div className='mx-auto mb-4 h-1.5 w-12 rounded-full bg-muted-foreground/30' aria-hidden />
          )}
          {/* Title row with count */}
          <div className='flex items-center gap-3'>
            <Map className='h-5 w-5 text-muted-foreground' />
            <SheetTitle className='text-base font-semibold'>
              방문 기록
            </SheetTitle>
            <span className='text-xs text-muted-foreground bg-muted px-2 py-0.5 rounded-full'>
              {items.length}개
            </span>
          </div>
          {/* Thumbnail stack row */}
          <div className='flex items-center gap-2 mt-3'>
            <div className='relative h-8 w-[100px]' aria-hidden>
              {topStack.map((p, i) => (
                <div
                  key={p.path}
                  className='absolute top-0 h-8 w-8 overflow-hidden rounded-full ring-2 ring-background shadow'
                  style={{ left: i * 20 }}
                  title={p.title}
                >
                  {p.coverImage ? (
                    <img
                      src={p.coverImage}
                      alt=''
                      className='h-full w-full object-cover'
                    />
                  ) : (
                    <FallbackAvatar title={p.title} />
                  )}
                </div>
              ))}
            </div>
          </div>
          {/* View toggle buttons */}
          <div className='flex items-center gap-1 text-xs bg-muted rounded-full p-0.5 mt-3 w-fit'>
            <button
              type='button'
              className={cn(
                'px-3 py-1.5 rounded-full transition-colors',
                view === 'list'
                  ? 'bg-primary text-primary-foreground'
                  : 'text-muted-foreground hover:bg-muted-foreground/10'
              )}
              onClick={() => setView('list')}
            >
              리스트
            </button>
            <button
              type='button'
              className={cn(
                'px-3 py-1.5 rounded-full transition-colors',
                view === 'graph'
                  ? 'bg-primary text-primary-foreground'
                  : 'text-muted-foreground hover:bg-muted-foreground/10'
              )}
              onClick={() => setView('graph')}
            >
              그래프
            </button>
          </div>
        </SheetHeader>
        {view === 'list' ? (
          <div
            ref={listContainerRef}
            tabIndex={0}
            className={cn(
              'overflow-y-auto px-4 pb-8 pt-4 focus:outline-none',
              isMobile ? 'max-h-[calc(75vh-160px)]' : 'flex-1'
            )}
            onKeyDown={e => {
              if (e.key === 'ArrowDown') {
                e.preventDefault();
                setActiveIndex(i => Math.min(i + 1, items.length - 1));
              }
              if (e.key === 'ArrowUp') {
                e.preventDefault();
                setActiveIndex(i => Math.max(i - 1, 0));
              }
              if (e.key === 'Enter') {
                e.preventDefault();
                const p = items[activeIndex];
                if (p) go(p);
              }
            }}
            role='region'
            aria-label='Visited posts list'
          >
            <ul className='space-y-2'>
              {items.map((p, idx) => (
                <li key={p.path}>
                  <button
                    onClick={() => go(p)}
                    className={cn(
                      'group flex w-full items-center gap-4 rounded-xl px-4 py-4 text-left transition-colors hover:bg-muted/60 focus:outline-none focus:ring-2 focus:ring-ring',
                      activeIndex === idx && 'ring-2 ring-primary bg-primary/5'
                    )}
                  >
                    <div className='h-12 w-12 overflow-hidden rounded-lg shrink-0'>
                      {p.coverImage ? (
                        <img
                          src={p.coverImage}
                          alt=''
                          className='h-12 w-12 object-cover'
                        />
                      ) : (
                        <div className='flex h-12 w-12 items-center justify-center rounded-lg bg-gradient-to-br from-primary/80 to-primary text-primary-foreground text-sm font-bold'>
                          {(p.title || '?').charAt(0).toUpperCase()}
                        </div>
                      )}
                    </div>
                    <div className='min-w-0 flex-1'>
                      <div className='text-sm font-medium leading-snug text-left group-hover:text-primary line-clamp-2'>
                        {p.title}
                      </div>
                      <div className='flex items-center gap-1.5 mt-1 text-xs text-muted-foreground'>
                        <Clock className='h-3.5 w-3.5' />
                        <span>
                          {p.year}/{p.slug}
                        </span>
                      </div>
                    </div>
                  </button>
                </li>
              ))}
            </ul>
            {/* 기록 지우기 버튼 */}
            <div className='mt-6 pt-4 border-t'>
              <Button
                variant='outline'
                size='sm'
                onClick={clearAll}
                className='w-full h-11'
              >
                기록 지우기
              </Button>
            </div>
          </div>
        ) : (
          <div className={cn(
            'overflow-y-auto px-4 pb-8 pt-4 space-y-3',
            isMobile ? 'max-h-[calc(75vh-160px)]' : 'flex-1'
          )}>
            {items.map(p => {
              const related = chatSessions.filter(s =>
                s.articleUrl && s.articleUrl.endsWith(p.path)
              );
              if (!related.length) return null;
              return (
                <div
                  key={p.path}
                  className='rounded-xl border bg-card/50 p-4 shadow-sm'
                >
                  <div className='text-sm font-semibold truncate'>{p.title}</div>
                  <div className='text-xs text-muted-foreground mb-2'>
                    {p.year}/{p.slug}
                  </div>
                  <ul className='mt-2 space-y-2'>
                    {related.map(s => {
                      const checked = selectedSessionIds.includes(s.id);
                      return (
                        <li
                          key={s.id}
                          className='flex items-center gap-3 py-2 px-3 rounded-lg bg-muted/40'
                        >
                          <input
                            type='checkbox'
                            className='h-4 w-4 rounded'
                            checked={checked}
                            onChange={() => {
                              setSelectedSessionIds(prev =>
                                prev.includes(s.id)
                                  ? prev.filter(x => x !== s.id)
                                  : [...prev, s.id]
                              );
                            }}
                          />
                          <div className='min-w-0 flex-1'>
                            <span className='text-sm font-medium truncate block'>
                              {s.title || s.articleTitle || 'AI Chat 세션'}
                            </span>
                            {s.updatedAt && (
                              <span className='text-xs text-muted-foreground'>
                                {new Date(s.updatedAt).toLocaleDateString()}
                              </span>
                            )}
                          </div>
                        </li>
                      );
                    })}
                  </ul>
                </div>
              );
            })}
            {!chatSessions.length && (
              <div className='text-sm text-muted-foreground px-2 py-8 text-center'>
                아직 저장된 AI Chat 세션이 없습니다.<br/>
                대화를 나누고 기록 저장을 켜면 여기에서 연결 관계를 볼 수 있어요.
              </div>
            )}
            {chatSessions.length > 0 && (
              <div className='mt-4 flex items-center justify-between border-t pt-4 px-1'>
                <span className='text-sm text-muted-foreground'>
                  선택: {selectedSessionIds.length}개
                </span>
                <Button
                  type='button'
                  size='sm'
                  className='h-10 px-4'
                  disabled={!selectedSessionIds.length}
                  onClick={() => {
                    if (!selectedSessionIds.length) return;
                    try {
                      window.dispatchEvent(
                        new CustomEvent('aiChat:aggregateFromGraph', {
                          detail: { sessionIds: selectedSessionIds },
                        })
                      );
                    } catch {}
                  }}
                >
                  통합 질문하기
                </Button>
              </div>
            )}
          </div>
        )}
      </SheetContent>
    </Sheet>
  );

  if (externalTrigger) {
    return sheet;
  }

  return (
    <div className='fixed bottom-8 right-24 z-50 select-none'>{sheet}</div>
  );
}

export default VisitedPostsMinimap;

```

### index.ts

**Path:** `frontend/src/components/features/navigation/index.ts`

```typescript
export { default as Breadcrumb } from './Breadcrumb';
export { default as Pagination } from './Pagination';
export { default as PostNavigation } from './PostNavigation';

```

---

## frontend/src/components/features/search

### SearchBar.tsx

**Path:** `frontend/src/components/features/search/SearchBar.tsx`

```tsx
import { useState, useEffect, useMemo } from "react";
import Fuse from "fuse.js";
import { BlogPost } from "@/types/blog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { X, Search, Terminal, ChevronRight } from "lucide-react";
import { useTheme } from "@/contexts/ThemeContext";
import { cn } from "@/lib/utils";

interface SearchBarProps {
  posts: BlogPost[];
  onSearchResults: (posts: BlogPost[]) => void;
  placeholder?: string;
}

export function SearchBar({
  posts,
  onSearchResults,
  placeholder = "블로그 검색...",
}: SearchBarProps) {
  const [query, setQuery] = useState("");
  const { isTerminal } = useTheme();

  // Fuse.js 설정
  const fuse = useMemo(
    () =>
      new Fuse(posts, {
        keys: [
          { name: "title", weight: 3 },
          { name: "description", weight: 2 },
          { name: "content", weight: 1 },
          { name: "tags", weight: 2 },
          { name: "category", weight: 2 },
        ],
        threshold: 0.3,
        includeScore: true,
      }),
    [posts],
  );

  useEffect(() => {
    if (query.trim() === "") {
      onSearchResults(posts);
    } else {
      const results = fuse.search(query);
      onSearchResults(results.map((result) => result.item));
    }
  }, [query, posts, onSearchResults, fuse]);

  const handleClear = () => {
    setQuery("");
  };

  // Terminal style search bar
  if (isTerminal) {
    return (
      <div className="relative w-full font-mono">
        <div className="relative group">
          <div className="flex items-center border border-border bg-[hsl(var(--terminal-code-bg))]">
            {/* Terminal prompt prefix */}
            <div className="flex items-center gap-1.5 px-3 py-2.5 border-r border-border/50 text-primary select-none shrink-0">
              <Terminal className="w-4 h-4" />
              <span className="text-sm font-bold">grep</span>
            </div>

            {/* Input field */}
            <div className="flex-1 flex items-center">
              <Input
                type="text"
                placeholder='--pattern "search query"'
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                className="flex-1 h-10 border-0 bg-transparent px-3 text-sm text-foreground placeholder:text-muted-foreground/50 focus-visible:ring-0 focus-visible:ring-offset-0"
              />
            </div>

            {/* Actions */}
            <div className="flex items-center gap-1 px-2">
              {query && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={handleClear}
                  className="h-7 w-7 p-0 text-destructive/70 hover:text-destructive hover:bg-destructive/10 rounded-none"
                >
                  <X className="w-3.5 h-3.5" />
                </Button>
              )}
              <div className="h-7 w-7 flex items-center justify-center text-primary/70">
                <ChevronRight className="w-4 h-4" />
              </div>
            </div>
          </div>

          {/* Terminal-style cursor blink indicator when focused */}
          <div className="absolute inset-x-0 bottom-0 h-[2px] bg-primary/50 transform scale-x-0 group-focus-within:scale-x-100 transition-transform duration-300" />
        </div>

        {query && (
          <div className="mt-2 px-3 py-2 border border-border/50 bg-[hsl(var(--terminal-code-bg))] text-xs">
            <div className="flex items-center gap-2 text-muted-foreground">
              <span className="text-primary/60">$</span>
              <span>
                grep -r "<span className="text-primary">{query}</span>" ./posts
              </span>
            </div>
            <div className="mt-1 text-primary/70"># Searching...</div>
          </div>
        )}
      </div>
    );
  }

  // Default style search bar
  return (
    <div className="relative w-full">
      <div className="relative group">
        <div className="absolute left-3 top-1/2 transform -translate-y-1/2 transition-colors group-focus-within:text-primary">
          <Search className="w-4 h-4" />
        </div>
        <Input
          type="text"
          placeholder={placeholder}
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          className="pl-11 pr-10 h-11 rounded-xl border border-border/60 bg-background shadow-none focus:border-primary/60 focus:ring-0 transition-colors duration-200 placeholder:text-muted-foreground/60"
        />
        {query && (
          <Button
            variant="ghost"
            size="sm"
            onClick={handleClear}
            className="absolute right-2 top-1/2 transform -translate-y-1/2 h-7 w-7 p-0 hover:bg-destructive/10 hover:text-destructive transition-colors rounded-full"
          >
            <X className="w-3 h-3" />
          </Button>
        )}

        {/* Search indicator */}
        <div className="absolute inset-x-0 bottom-0 h-0.5 bg-gradient-to-r from-primary to-accent transform scale-x-0 group-focus-within:scale-x-100 transition-transform duration-300 rounded-full" />
      </div>

      {query && (
        <div className="mt-3 p-2 rounded-lg bg-muted/30 border border-border/30">
          <div className="flex items-center gap-2 text-xs text-muted-foreground">
            <div className="w-1.5 h-1.5 rounded-full bg-primary animate-pulse"></div>
            <span className="font-medium">'{query}' 검색 결과</span>
          </div>
        </div>
      )}
    </div>
  );
}

export default SearchBar;

```

### index.ts

**Path:** `frontend/src/components/features/search/index.ts`

```typescript
export { default as SearchBar } from './SearchBar';

```

---

## frontend/src/components/features/sentio

### DebateRoom.tsx

**Path:** `frontend/src/components/features/sentio/DebateRoom.tsx`

```tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import {
  X,
  Send,
  Loader2,
  MessageSquare,
  Sparkles,
  ThumbsUp,
  ThumbsDown,
  RotateCcw,
  Lightbulb,
  Users,
  ArrowRight,
  ChevronDown,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { useTheme } from '@/contexts/ThemeContext';
import { streamChatEvents, ensureSession } from '@/services/chat';
import { PrismResult } from '@/services/ai';
import ChatMarkdown from '@/components/features/chat/ChatMarkdown';

export type DebateMessage = {
  id: string;
  role: 'user' | 'ai' | 'system';
  content: string;
  stance?: 'agree' | 'disagree' | 'neutral';
  timestamp: number;
};

export type DebateTopic = {
  title: string;
  context: string;
  facets?: PrismResult['facets'];
  originalParagraph?: string;
};

type DebateRoomProps = {
  topic: DebateTopic;
  onClose: () => void;
  postTitle?: string;
};

const DEBATE_STARTERS = [
  { label: '이 부분이 특히 신경 쓰여요', stance: 'agree' as const, icon: ThumbsUp },
  { label: '이 부분이 조금 불편해요', stance: 'disagree' as const, icon: ThumbsDown },
  { label: '조금 더 이해하고 정리하고 싶어요', stance: 'neutral' as const, icon: Lightbulb },
];

const FOLLOW_UP_PROMPTS = [
  '내 상황에 맞게 풀어서 설명해줘',
  '다른 관점에서 보면 어떻게 느낄 수 있을까?',
  '앞으로 내가 어떤 선택을 할 수 있을지 같이 정리해줘',
  '지금 내가 놓치고 있는 포인트가 있다면 알려줘',
];

function buildDebateSystemPrompt(topic: DebateTopic, stance?: 'agree' | 'disagree' | 'neutral'): string {
  const lines: string[] = [
    '당신은 사려 깊은 상담 파트너입니다. 다음 지침을 따르세요:',
    '',
    '1. 사용자의 감정과 생각을 먼저 공감하고, 차분하게 응답합니다.',
    '2. 옳고 그름을 판단하기보다, 사용자가 스스로 정리하고 선택할 수 있도록 도와줍니다.',
    '3. 조언이 필요할 때에는 예의 바르게, 구체적인 예시와 함께 제안합니다.',
    '4. 사용자가 새로운 관점이나 선택지를 발견하도록 부드럽게 질문을 던집니다.',
    '5. 말투는 친근하고 따뜻하게 유지하되, 과도하게 가볍지 않게 균형을 잡습니다.',
    '6. 응답은 2~4문장 정도로 간결하게, 지금 대화에서 가장 중요한 한두 가지에 집중합니다.',
    '',
    '---',
    '',
    '[상담 주제]',
    topic.title,
    '',
    '[맥락]',
    topic.context,
  ];

  if (topic.facets && topic.facets.length > 0) {
    lines.push('', '[참고할 수 있는 관점들]');
    topic.facets.forEach((f, i) => {
      lines.push(`${i + 1}. ${f.title}`);
      f.points.forEach(p => lines.push(`   - ${p}`));
    });
  }

  if (stance === 'agree') {
    lines.push('', '사용자는 이 내용에 어느 정도 공감하고 있습니다. 그 공감을 바탕으로 조금 더 깊이 이해하고 정리할 수 있도록 도와주세요.');
  } else if (stance === 'disagree') {
    lines.push('', '사용자는 이 내용에 대해 불편함 또는 다른 시각을 가지고 있습니다. 그 감정을 존중하면서 안전한 분위기에서 생각을 풀어낼 수 있도록 도와주세요.');
  }

  return lines.join('\n');
}

export default function DebateRoom({ topic, onClose, postTitle }: DebateRoomProps) {
  const { isTerminal } = useTheme();
  const [messages, setMessages] = useState<DebateMessage[]>([]);
  const [input, setInput] = useState('');
  const [busy, setBusy] = useState(false);
  const [currentStance, setCurrentStance] = useState<'agree' | 'disagree' | 'neutral' | null>(null);
  const [showStarters, setShowStarters] = useState(true);
  const scrollRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);
  const abortRef = useRef<AbortController | null>(null);

  const canSend = input.trim().length > 0 && !busy;

  // Auto-scroll on new messages
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [messages, busy]);

  // Focus input on mount
  useEffect(() => {
    setTimeout(() => inputRef.current?.focus(), 100);
  }, []);

  const addMessage = useCallback((msg: DebateMessage) => {
    setMessages(prev => [...prev, msg]);
  }, []);

  const startDebate = useCallback(async (stance: 'agree' | 'disagree' | 'neutral') => {
    setCurrentStance(stance);
    setShowStarters(false);
    setBusy(true);

    const userMsg: DebateMessage = {
      id: `user_${Date.now()}`,
      role: 'user',
      content: DEBATE_STARTERS.find(s => s.stance === stance)?.label || '',
      stance,
      timestamp: Date.now(),
    };
    addMessage(userMsg);

    const aiId = `ai_${Date.now()}`;
    addMessage({
      id: aiId,
      role: 'ai',
      content: '',
      timestamp: Date.now(),
    });

    const timeoutId = { current: null as ReturnType<typeof setTimeout> | null };
    try {
      abortRef.current?.abort();
      const controller = new AbortController();
      abortRef.current = controller;

      // Set 30-second timeout
      timeoutId.current = setTimeout(() => controller.abort(), 30000);

      const systemPrompt = buildDebateSystemPrompt(topic, stance);
      const starterText = stance === 'agree'
        ? '이 부분이 특히 신경 쓰여요. 조금 더 이해하고 정리하고 싶어요.'
        : stance === 'disagree'
        ? '이 부분이 조금 불편해요. 다른 관점에서 생각해볼 수 있을까요?'
        : '조금 더 이해하고 정리하고 싶어요. 핵심 논점이 무엇인가요?';

      let acc = '';
      for await (const ev of streamChatEvents({
        text: `${systemPrompt}\n\n---\n\n사용자: ${starterText}`,
        signal: controller.signal,
        useArticleContext: false,
      })) {
        if (ev.type === 'text') {
          acc += ev.text;
          setMessages(prev =>
            prev.map(m => (m.id === aiId ? { ...m, content: acc } : m))
          );
        }
      }
    } catch (err) {
      const error = err as Error;
      if (error.name === 'AbortError') {
        // Check if it was a timeout (no content received yet)
        const aiMsg = messages.find(m => m.id === aiId);
        if (!aiMsg?.content) {
          setMessages(prev =>
            prev.map(m =>
              m.id === aiId
                ? { ...m, content: '응답 시간이 초과되었어요. 다시 시도해주세요.' }
                : m
            )
          );
        }
      } else {
        setMessages(prev =>
          prev.map(m =>
            m.id === aiId
              ? { ...m, content: '죄송해요, 응답을 생성하지 못했어요. 다시 시도해주세요.' }
              : m
          )
        );
      }
    } finally {
      if (timeoutId.current) clearTimeout(timeoutId.current);
      setBusy(false);
    }
  }, [topic, addMessage]);

  const sendMessage = useCallback(async () => {
    if (!canSend) return;

    const text = input.trim();
    setInput('');

    const userMsg: DebateMessage = {
      id: `user_${Date.now()}`,
      role: 'user',
      content: text,
      timestamp: Date.now(),
    };
    addMessage(userMsg);

    const aiId = `ai_${Date.now()}`;
    addMessage({
      id: aiId,
      role: 'ai',
      content: '',
      timestamp: Date.now(),
    });

    setBusy(true);

    const timeoutId = { current: null as ReturnType<typeof setTimeout> | null };
    try {
      abortRef.current?.abort();
      const controller = new AbortController();
      abortRef.current = controller;

      // Set 30-second timeout
      timeoutId.current = setTimeout(() => controller.abort(), 30000);

      // Build conversation history
      const history = messages
        .filter(m => m.role !== 'system')
        .map(m => `${m.role === 'user' ? '사용자' : 'AI'}: ${m.content}`)
        .join('\n\n');

      const systemPrompt = buildDebateSystemPrompt(topic, currentStance || undefined);
      const fullPrompt = [
        systemPrompt,
        '',
        '---',
        '',
        '[대화 기록]',
        history,
        '',
        `사용자: ${text}`,
      ].join('\n');

      let acc = '';
      for await (const ev of streamChatEvents({
        text: fullPrompt,
        signal: controller.signal,
        useArticleContext: false,
      })) {
        if (ev.type === 'text') {
          acc += ev.text;
          setMessages(prev =>
            prev.map(m => (m.id === aiId ? { ...m, content: acc } : m))
          );
        }
      }
    } catch (err) {
      const error = err as Error;
      if (error.name === 'AbortError') {
        // Check if it was a timeout (no content received yet)
        setMessages(prev => {
          const aiMsg = prev.find(m => m.id === aiId);
          if (!aiMsg?.content) {
            return prev.map(m =>
              m.id === aiId
                ? { ...m, content: '응답 시간이 초과되었어요. 다시 시도해주세요.' }
                : m
            );
          }
          return prev;
        });
      } else {
        setMessages(prev =>
          prev.map(m =>
            m.id === aiId
              ? { ...m, content: '죄송해요, 응답을 생성하지 못했어요.' }
              : m
          )
        );
      }
    } finally {
      if (timeoutId.current) clearTimeout(timeoutId.current);
      setBusy(false);
    }
  }, [canSend, input, messages, topic, currentStance, addMessage]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (canSend) sendMessage();
      }
    },
    [canSend, sendMessage]
  );

  const resetDebate = useCallback(() => {
    abortRef.current?.abort();
    setMessages([]);
    setCurrentStance(null);
    setShowStarters(true);
    setInput('');
    setBusy(false);
  }, []);

  const useFollowUp = useCallback((prompt: string) => {
    setInput(prompt);
    inputRef.current?.focus();
  }, []);

  return (
    <div
      className={cn(
        'flex flex-col h-full max-h-[80vh] sm:max-h-[600px] overflow-hidden rounded-2xl border shadow-xl',
        isTerminal
          ? 'bg-[hsl(var(--terminal-code-bg))] border-primary/30 font-mono shadow-[0_0_30px_hsl(var(--terminal-glow)/0.15)]'
          : 'bg-card border-border'
      )}
    >
      {/* Header */}
      <div
        className={cn(
          'flex items-center justify-between px-4 py-3.5 border-b shrink-0',
          isTerminal
            ? 'border-primary/20 bg-[hsl(var(--terminal-titlebar))]'
            : 'border-border/40 bg-muted/40'
        )}
      >
        {/* Terminal window buttons */}
        {isTerminal && (
          <div className="flex items-center gap-1.5 mr-3">
            <div className="w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-close))]" />
            <div className="w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-minimize))]" />
            <div className="w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-maximize))]" />
          </div>
        )}
        <div className="flex items-center gap-3 min-w-0 flex-1">
          <div
            className={cn(
              'flex items-center justify-center h-10 w-10 rounded-full shrink-0',
              isTerminal ? 'bg-primary/20 border border-primary/30' : 'bg-primary/10'
            )}
          >
            <Users className={cn('h-5 w-5', isTerminal ? 'text-primary' : 'text-primary')} />
          </div>
          <div className="min-w-0">
            <h3
              className={cn(
                'font-semibold text-base truncate',
                isTerminal && 'font-mono text-primary terminal-glow'
              )}
            >
              {isTerminal ? '>_ AI 상담실' : 'AI 상담실'}
            </h3>
            <p className="text-xs text-muted-foreground truncate max-w-[200px] sm:max-w-[280px]">
              {topic.title}
            </p>
          </div>
        </div>
        <div className="flex items-center gap-1.5 shrink-0">
          {messages.length > 0 && (
            <button
              type="button"
              onClick={resetDebate}
              className={cn(
                'flex items-center justify-center h-9 w-9 rounded-full transition-colors',
                isTerminal
                  ? 'hover:bg-primary/20 text-primary/70 hover:text-primary'
                  : 'hover:bg-muted text-muted-foreground hover:text-foreground'
              )}
              aria-label="상담 초기화"
            >
              <RotateCcw className="h-4 w-4" />
            </button>
          )}
          <button
            type="button"
            onClick={onClose}
            className={cn(
              'flex items-center justify-center h-9 w-9 rounded-full transition-colors',
              isTerminal
                ? 'hover:bg-primary/20 text-primary/70 hover:text-primary'
                : 'hover:bg-muted text-muted-foreground hover:text-foreground'
            )}
            aria-label="닫기"
          >
            <X className="h-4 w-4" />
          </button>
        </div>
      </div>

      {/* Messages Area */}
      <div ref={scrollRef} className="flex-1 overflow-y-auto px-4 py-5 space-y-5">
        {/* Initial Topic Display */}
        {showStarters && (
          <div className="space-y-5 animate-in fade-in-0 slide-in-from-bottom-2 duration-300">
            {/* Topic Card */}
            <div
              className={cn(
                'rounded-xl px-4 py-4 border',
                isTerminal
                  ? 'bg-primary/5 border-primary/30'
                  : 'bg-muted/40 border-border/60'
              )}
            >
              <div className="flex items-start gap-3">
                <div
                  className={cn(
                    'flex items-center justify-center h-9 w-9 rounded-lg shrink-0 mt-0.5',
                    isTerminal ? 'bg-primary/20' : 'bg-primary/10'
                  )}
                >
                  <MessageSquare className="h-4 w-4 text-primary" />
                </div>
                <div className="min-w-0 flex-1">
                  <h4 className="font-medium text-sm mb-2">{topic.title}</h4>
                  <p className="text-sm text-muted-foreground leading-relaxed">
                    {topic.context.length > 200
                      ? `${topic.context.slice(0, 200)}...`
                      : topic.context}
                  </p>
                </div>
              </div>
            </div>

            {/* Facets Preview */}
            {topic.facets && topic.facets.length > 0 && (
              <div className="space-y-2">
                <p className="text-xs text-muted-foreground px-1">관련 관점들:</p>
                <div className="flex flex-wrap gap-2">
                  {topic.facets.slice(0, 3).map((f, i) => (
                    <span
                      key={i}
                      className={cn(
                        'inline-flex items-center px-3 py-1.5 rounded-full text-xs',
                        isTerminal
                          ? 'bg-primary/10 text-primary border border-primary/20'
                          : 'bg-secondary text-secondary-foreground'
                      )}
                    >
                      {f.title}
                    </span>
                  ))}
                </div>
              </div>
            )}

            {/* Stance Selection */}
            <div className="space-y-4 pt-3">
              <p className="text-sm text-center text-muted-foreground">
                어떤 마음으로 상담을 시작할까요?
              </p>
              <div className="grid grid-cols-1 gap-2.5">
                {DEBATE_STARTERS.map(starter => {
                  const Icon = starter.icon;
                  return (
                    <button
                      key={starter.stance}
                      type="button"
                      onClick={() => startDebate(starter.stance)}
                      disabled={busy}
                      className={cn(
                        'flex items-center gap-3 px-4 py-3.5 rounded-xl border transition-all',
                        'hover:scale-[1.01] active:scale-[0.99]',
                        isTerminal
                          ? 'border-primary/30 hover:border-primary/50 hover:bg-primary/10'
                          : 'border-border hover:border-primary/40 hover:bg-muted/50',
                        busy && 'opacity-50 cursor-not-allowed'
                      )}
                    >
                      <div
                        className={cn(
                          'flex items-center justify-center h-9 w-9 rounded-lg',
                          starter.stance === 'agree' && 'bg-emerald-500/15 text-emerald-600 dark:text-emerald-400',
                          starter.stance === 'disagree' && 'bg-orange-500/15 text-orange-600 dark:text-orange-400',
                          starter.stance === 'neutral' && 'bg-blue-500/15 text-blue-600 dark:text-blue-400'
                        )}
                      >
                        <Icon className="h-4 w-4" />
                      </div>
                      <span className="text-sm font-medium flex-1 text-left">{starter.label}</span>
                      <ArrowRight className="h-4 w-4 text-muted-foreground" />
                    </button>
                  );
                })}
              </div>
            </div>
          </div>
        )}

        {/* Conversation Messages */}
        {messages.map(msg => (
          <div
            key={msg.id}
            className={cn(
              'flex',
              msg.role === 'user' ? 'justify-end' : 'justify-start'
            )}
          >
            <div
              className={cn(
                'max-w-[88%] rounded-2xl px-4 py-3',
                msg.role === 'user' && 'bg-primary text-primary-foreground rounded-br-md',
                msg.role === 'ai' &&
                  (isTerminal
                    ? 'bg-primary/10 border border-primary/30 rounded-bl-md'
                    : 'bg-secondary text-secondary-foreground rounded-bl-md'),
                msg.role === 'system' && 'bg-muted text-muted-foreground'
              )}
            >
              {msg.role === 'ai' && msg.content ? (
                <ChatMarkdown content={msg.content} />
              ) : msg.role === 'ai' && !msg.content ? (
                <div className="flex items-center gap-2 text-sm text-muted-foreground">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  <span>생각하는 중...</span>
                </div>
              ) : (
                <p className="text-sm leading-relaxed whitespace-pre-wrap">{msg.content}</p>
              )}

              {/* Stance badge for user messages */}
              {msg.role === 'user' && msg.stance && (
                <div className="flex items-center gap-1 mt-2 pt-2 border-t border-primary-foreground/20">
                  {msg.stance === 'agree' && <ThumbsUp className="h-3 w-3" />}
                  {msg.stance === 'disagree' && <ThumbsDown className="h-3 w-3" />}
                  {msg.stance === 'neutral' && <Lightbulb className="h-3 w-3" />}
                  <span className="text-xs opacity-80">
                    {msg.stance === 'agree' && '동의'}
                    {msg.stance === 'disagree' && '반대'}
                    {msg.stance === 'neutral' && '탐구'}
                  </span>
                </div>
              )}
            </div>
          </div>
        ))}

        {/* Quick Follow-ups after AI response */}
        {!busy && messages.length > 0 && messages[messages.length - 1]?.role === 'ai' && (
          <div className="flex flex-wrap gap-2 pt-3">
            {FOLLOW_UP_PROMPTS.slice(0, 3).map((prompt, i) => (
              <button
                key={i}
                type="button"
                onClick={() => useFollowUp(prompt)}
                className={cn(
                  'text-xs px-3 py-2 rounded-full transition-colors',
                  isTerminal
                    ? 'bg-primary/15 text-primary/90 hover:bg-primary/25 hover:text-primary border border-primary/30'
                    : 'bg-muted hover:bg-muted/80 text-muted-foreground hover:text-foreground'
                )}
              >
                {prompt}
              </button>
            ))}
          </div>
        )}
      </div>

      {/* Input Area */}
      {!showStarters && (
        <div
          className={cn(
            'border-t px-4 py-4 shrink-0',
            isTerminal ? 'border-primary/20 bg-primary/5' : 'border-border/40 bg-muted/30'
          )}
        >
          <div
            className={cn(
              'flex items-end gap-2.5 rounded-xl border px-3 py-2.5',
              isTerminal ? 'border-primary/30 bg-background/60' : 'border-border bg-background'
            )}
          >
            <textarea
              ref={inputRef}
              value={input}
              onChange={e => setInput(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder="생각을 나눠보세요..."
              rows={1}
              className={cn(
                'flex-1 resize-none border-0 bg-transparent py-2 text-sm focus:outline-none focus:ring-0',
                'placeholder:text-muted-foreground/50',
                isTerminal && 'font-mono'
              )}
              style={{ maxHeight: '120px' }}
            />
            <button
              type="button"
              onClick={sendMessage}
              disabled={!canSend}
              className={cn(
                'flex items-center justify-center h-10 w-10 rounded-lg transition-colors shrink-0',
                canSend
                  ? isTerminal
                    ? 'bg-primary/25 text-primary hover:bg-primary/35 border border-primary/40'
                    : 'bg-primary text-primary-foreground hover:bg-primary/90'
                  : 'bg-muted text-muted-foreground cursor-not-allowed'
              )}
              aria-label="보내기"
            >
              {busy ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <Send className="h-4 w-4" />
              )}
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

```

### SparkInline.tsx

**Path:** `frontend/src/components/features/sentio/SparkInline.tsx`

```tsx
import React, { useMemo, useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import {
  sketch,
  prism,
  chain,
  SketchResult,
  PrismResult,
  ChainResult,
} from '@/services/ai';
import { cn } from '@/lib/utils';
import { useTheme } from '@/contexts/ThemeContext';
import { Sparkles, Loader2, X, Lightbulb, Layers, Link2, MessageCircle } from 'lucide-react';
import DebateRoom, { DebateTopic } from './DebateRoom';

// Minimal telemetry to localStorage for future learning
function logEvent(event: Record<string, unknown>) {
  try {
    const key = 'aiMemo.events';
    const prev = JSON.parse(localStorage.getItem(key) || '[]');
    prev.push({ t: Date.now(), ...event });
    localStorage.setItem(key, JSON.stringify(prev.slice(-500))); // cap
  } catch {
    void 0;
  }
}

function emitAiMemoLog(detail: Record<string, unknown>) {
  if (typeof window === 'undefined') return;
  try {
    window.dispatchEvent(
      new CustomEvent('aiMemo:log', {
        detail,
      })
    );
  } catch {}
}

function extractText(children: React.ReactNode): string {
  const parts: string[] = [];
  const walk = (node: React.ReactNode) => {
    if (node == null || node === false) return;
    if (typeof node === 'string' || typeof node === 'number') {
      parts.push(String(node));
      return;
    }
    if (Array.isArray(node)) {
      node.forEach(walk);
      return;
    }
    if (React.isValidElement(node)) {
      walk(node.props.children);
    }
  };
  walk(children);
  return parts.join(' ').replace(/\s+/g, ' ').trim();
}

type Mode = 'idle' | 'sketch' | 'prism' | 'chain';

const ModeConfig: Record<Mode, { label: string; icon: React.ComponentType<{ className?: string }>; color: string; description: string }> = {
  idle: { label: 'Idle', icon: Sparkles, color: 'text-muted-foreground', description: '' },
  sketch: { label: 'Sketch', icon: Lightbulb, color: 'text-amber-500 dark:text-amber-400', description: '감정과 핵심 포인트' },
  prism: { label: 'Prism', icon: Layers, color: 'text-violet-500 dark:text-violet-400', description: '다각도 분석' },
  chain: { label: 'Chain', icon: Link2, color: 'text-emerald-500 dark:text-emerald-400', description: '연쇄 질문' },
};

function formatSketchResult(res: SketchResult): string {
  const bullets = res.bullets.map(b => `- ${b}`).join('\n');
  return [`**Mood:** ${res.mood}`, '', bullets].join('\n');
}

function formatPrismResult(res: PrismResult): string {
  return res.facets
    .map(f => `### ${f.title}\n${f.points.map(p => `- ${p}`).join('\n')}`)
    .join('\n\n');
}

function formatChainResult(res: ChainResult): string {
  return res.questions
    .map(q => `- **${q.q}**${q.why ? ` — ${q.why}` : ''}`)
    .join('\n');
}

export default function SparkInline({
  children,
  postTitle,
}: {
  children: React.ReactNode;
  postTitle?: string;
}) {
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState<Mode>('idle');
  const [error, setError] = useState<string | null>(null);
  const [sketchRes, setSketchRes] = useState<SketchResult | null>(null);
  const [prismRes, setPrismRes] = useState<PrismResult | null>(null);
  const [chainRes, setChainRes] = useState<ChainResult | null>(null);
  const [activeMode, setActiveMode] = useState<Mode>('idle');
  const [showDebate, setShowDebate] = useState(false);
  const [debateTopic, setDebateTopic] = useState<DebateTopic | null>(null);
  const { isTerminal } = useTheme();

  const text = useMemo(() => extractText(children), [children]);
  const hasText = text && text.length > 0;

  const run = async (which: Mode) => {
    if (!hasText) return;
    setOpen(true);
    setError(null);
    setLoading(which);
    setActiveMode(which);
    // clear previous
    setSketchRes(null);
    setPrismRes(null);
    setChainRes(null);
    try {
      if (which === 'sketch') {
        const res = await sketch({ paragraph: text, postTitle });
        setSketchRes(res);
        logEvent({ type: 'sketch', len: text.length });
        emitAiMemoLog({
          type: 'ai_qna',
          mode: 'sketch',
          question: text,
          answer: formatSketchResult(res),
          postTitle,
        });
      } else if (which === 'prism') {
        const res = await prism({ paragraph: text, postTitle });
        setPrismRes(res);
        logEvent({ type: 'prism', len: text.length });
        emitAiMemoLog({
          type: 'ai_qna',
          mode: 'prism',
          question: text,
          answer: formatPrismResult(res),
          postTitle,
        });
      } else if (which === 'chain') {
        const res = await chain({ paragraph: text, postTitle });
        setChainRes(res);
        logEvent({ type: 'chain', len: text.length });
        emitAiMemoLog({
          type: 'ai_qna',
          mode: 'chain',
          question: text,
          answer: formatChainResult(res),
          postTitle,
        });
      }
    } catch (e: unknown) {
      const msg =
        e instanceof Error
          ? e.message
          : 'AI 호출 실패';
      setError(msg);
    } finally {
      setLoading('idle');
    }
  };

  const hasResult = sketchRes || prismRes || chainRes;
  const activeModeConfig = ModeConfig[activeMode];

  return (
    <>
      <p className='mb-4 leading-relaxed inline-block w-full group/spark relative'>
        {children}
        {hasText && (
          <button
            type='button'
            title='AI로 문단 분석하기'
            aria-label='AI로 문단 분석하기'
            aria-expanded={open}
            onClick={() => setOpen(v => !v)}
            className={cn(
              'ml-2 inline-flex items-center justify-center rounded-full transition-all duration-200',
              'min-h-[36px] min-w-[36px] md:min-h-[28px] md:min-w-[28px]',
              'opacity-40 hover:opacity-100 group-hover/spark:opacity-70',
              'hover:bg-primary/10 hover:scale-110',
              'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/60',
              isTerminal && 'text-primary',
            )}
          >
            <Sparkles className={cn(
              'h-4 w-4 md:h-3.5 md:w-3.5',
              open && 'text-primary',
            )} />
          </button>
        )}
      </p>
      
      {open && (
        <div
          className={cn(
            '-mt-2 mb-6 overflow-hidden transition-all duration-300',
            // iOS-style card design
            'rounded-2xl border shadow-sm',
            isTerminal 
              ? 'bg-[hsl(var(--terminal-code-bg))] border-primary/20' 
              : 'bg-card/80 backdrop-blur-sm border-border/60',
          )}
          role='region'
          aria-label='AI 분석 패널'
        >
          {/* Header with mode tabs */}
          <div className={cn(
            'flex items-center justify-between px-4 py-3 border-b',
            isTerminal ? 'border-primary/10 bg-primary/5' : 'border-border/40 bg-muted/30',
          )}>
            {/* Mode buttons - iOS segmented control style */}
            <div className={cn(
              'inline-flex rounded-xl p-1 gap-1',
              isTerminal ? 'bg-primary/10' : 'bg-muted/60',
            )}>
              {(['sketch', 'prism', 'chain'] as Mode[]).map((mode) => {
                const config = ModeConfig[mode];
                const Icon = config.icon;
                const isActive = activeMode === mode && hasResult;
                const isLoading = loading === mode;
                
                return (
                  <button
                    key={mode}
                    className={cn(
                      'flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-medium transition-all duration-200',
                      'min-h-[32px] min-w-[70px] justify-center',
                      'disabled:opacity-50 disabled:cursor-not-allowed',
                      isActive && !isTerminal && 'bg-background shadow-sm text-foreground',
                      isActive && isTerminal && 'bg-primary/20 text-primary shadow-sm',
                      !isActive && 'text-muted-foreground hover:text-foreground hover:bg-background/50',
                      isLoading && 'animate-pulse',
                    )}
                    disabled={loading !== 'idle'}
                    onClick={() => run(mode)}
                  >
                    {isLoading ? (
                      <Loader2 className="h-3.5 w-3.5 animate-spin" />
                    ) : (
                      <Icon className={cn('h-3.5 w-3.5', isActive && config.color)} />
                    )}
                    <span>{config.label}</span>
                  </button>
                );
              })}
            </div>
            
            {/* Close button */}
            <button
              className={cn(
                'flex items-center justify-center rounded-full transition-all duration-200',
                'h-8 w-8 hover:bg-muted/80',
                isTerminal && 'hover:bg-primary/10 text-primary/60 hover:text-primary',
              )}
              onClick={() => setOpen(false)}
              aria-label='닫기'
            >
              <X className='h-4 w-4' />
            </button>
          </div>

          {/* Content area */}
          <div className='px-4 py-4'>
            {/* Loading state */}
            {loading !== 'idle' && (
              <div className={cn(
                'flex items-center gap-3 py-6 justify-center',
                isTerminal ? 'text-primary' : 'text-muted-foreground',
              )}>
                <Loader2 className='h-5 w-5 animate-spin' />
                <span className='text-sm'>
                  {activeModeConfig.label} 분석 중...
                </span>
              </div>
            )}
            
            {/* Error state */}
            {error && (
              <div className={cn(
                'rounded-xl px-4 py-3 text-sm',
                'bg-destructive/10 text-destructive border border-destructive/20',
              )}>
                {error}
              </div>
            )}

            {/* Sketch Result - iOS Notes style */}
            {sketchRes && loading === 'idle' && (
              <div className='space-y-4 animate-in fade-in-0 slide-in-from-bottom-2 duration-300'>
                {/* Mood badge */}
                <div className='flex items-center gap-2'>
                  <span className={cn(
                    'inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium',
                    isTerminal 
                      ? 'bg-amber-500/20 text-amber-400 border border-amber-500/30' 
                      : 'bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300',
                  )}>
                    <Lightbulb className='h-3 w-3' />
                    {sketchRes.mood}
                  </span>
                </div>
                
                {/* Bullets */}
                <ul className='space-y-2'>
                  {sketchRes.bullets.map((b, i) => (
                    <li 
                      key={i}
                      className={cn(
                        'flex items-start gap-3 text-sm leading-relaxed',
                        isTerminal ? 'text-foreground/90' : 'text-foreground',
                      )}
                    >
                      <span className={cn(
                        'flex-shrink-0 w-1.5 h-1.5 rounded-full mt-2',
                        isTerminal ? 'bg-primary/60' : 'bg-amber-500/60',
                      )} />
                      <span>{b}</span>
                    </li>
                  ))}
                </ul>
              </div>
            )}

            {/* Prism Result - Card grid style */}
            {prismRes && loading === 'idle' && (
              <div className='space-y-3 animate-in fade-in-0 slide-in-from-bottom-2 duration-300'>
                {prismRes.facets.map((f, i) => (
                  <div 
                    key={i} 
                    className={cn(
                      'rounded-xl px-4 py-3 border',
                      isTerminal 
                        ? 'bg-primary/5 border-primary/20' 
                        : 'bg-violet-50/50 border-violet-200/50 dark:bg-violet-900/10 dark:border-violet-800/30',
                    )}
                  >
                    <div className={cn(
                      'font-medium text-sm mb-2 flex items-center gap-2',
                      isTerminal ? 'text-primary' : 'text-violet-700 dark:text-violet-300',
                    )}>
                      <Layers className='h-3.5 w-3.5' />
                      {f.title}
                    </div>
                    <ul className='space-y-1.5'>
                      {f.points.map((p, j) => (
                        <li 
                          key={j}
                          className='flex items-start gap-2 text-sm leading-relaxed text-foreground/80'
                        >
                          <span className={cn(
                            'flex-shrink-0 w-1 h-1 rounded-full mt-2',
                            isTerminal ? 'bg-primary/40' : 'bg-violet-400/60',
                          )} />
                          <span>{p}</span>
                        </li>
                      ))}
                    </ul>
                  </div>
                ))}
                
                {/* Debate Button */}
                <button
                  type='button'
                  onClick={() => {
                    setDebateTopic({
                      title: prismRes.facets[0]?.title || '다각도 분석',
                      context: text,
                      facets: prismRes.facets,
                      originalParagraph: text,
                    });
                    setShowDebate(true);
                  }}
                  className={cn(
                    'w-full flex items-center justify-center gap-2 px-4 py-3 rounded-xl border transition-all',
                    'hover:scale-[1.01] active:scale-[0.99]',
                    isTerminal 
                      ? 'bg-primary/10 border-primary/30 text-primary hover:bg-primary/20' 
                      : 'bg-violet-100/50 border-violet-300/50 text-violet-700 hover:bg-violet-100 dark:bg-violet-900/20 dark:border-violet-700/30 dark:text-violet-300 dark:hover:bg-violet-900/30',
                  )}
                >
                  <MessageCircle className='h-4 w-4' />
                  <span className='text-sm font-medium'>이 주제로 상담 시작하기</span>
                </button>
              </div>
            )}

            {/* Chain Result - Question cards */}
            {chainRes && loading === 'idle' && (
              <div className='space-y-2.5 animate-in fade-in-0 slide-in-from-bottom-2 duration-300'>
                {chainRes.questions.map((q, i) => (
                  <button 
                    key={i}
                    type='button'
                    onClick={() => {
                      // Start debate with this question as the topic
                      setDebateTopic({
                        title: q.q,
                        context: `${text}\n\n질문: ${q.q}${q.why ? `\n이유: ${q.why}` : ''}`,
                        originalParagraph: text,
                      });
                      setShowDebate(true);
                    }}
                    className={cn(
                      'w-full text-left rounded-xl px-4 py-3 border transition-all',
                      'hover:scale-[1.01] active:scale-[0.99]',
                      isTerminal 
                        ? 'bg-primary/5 border-primary/20 hover:bg-primary/10' 
                        : 'bg-emerald-50/50 border-emerald-200/50 dark:bg-emerald-900/10 dark:border-emerald-800/30 hover:bg-emerald-50 dark:hover:bg-emerald-900/20',
                    )}
                  >
                    <div className={cn(
                      'font-medium text-sm flex items-start gap-2',
                      isTerminal ? 'text-primary' : 'text-emerald-700 dark:text-emerald-300',
                    )}>
                      <Link2 className='h-3.5 w-3.5 mt-0.5 flex-shrink-0' />
                      <span>{q.q}</span>
                    </div>
                    {q.why && (
                      <p className='text-xs text-muted-foreground mt-1.5 ml-5'>
                        {q.why}
                      </p>
                    )}
                  </button>
                ))}
                
                {/* Debate prompt */}
                <p className='text-xs text-center text-muted-foreground pt-2'>
                  질문을 클릭하여 AI와 상담을 시작하세요
                </p>
              </div>
            )}

            {/* Empty state - when opened but no result yet */}
            {!hasResult && loading === 'idle' && !error && (
              <div className='py-8 flex flex-col items-center justify-center min-h-[180px]'>
                <div className={cn(
                  'flex items-center justify-center w-12 h-12 rounded-2xl mb-3',
                  isTerminal ? 'bg-primary/10' : 'bg-muted',
                )}>
                  <Sparkles className={cn(
                    'h-6 w-6',
                    isTerminal ? 'text-primary' : 'text-muted-foreground',
                  )} />
                </div>
                <p className='text-sm text-muted-foreground text-center'>
                  위 버튼을 눌러 AI 분석을 시작하세요
                </p>
                <div className='flex flex-wrap justify-center gap-4 mt-4 text-xs text-muted-foreground/70'>
                  <span><strong>Sketch</strong> - 핵심 포인트</span>
                  <span><strong>Prism</strong> - 다각도 분석</span>
                  <span><strong>Chain</strong> - 연쇄 질문</span>
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Debate Room Modal - Portal to body to escape parent overflow constraints */}
      {showDebate && (debateTopic || prismRes) && createPortal(
        <div className='fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm animate-in fade-in-0 duration-200'>
          <div className='w-full max-w-lg animate-in zoom-in-95 slide-in-from-bottom-4 duration-300'>
            <DebateRoom
              topic={debateTopic || {
                title: prismRes?.facets[0]?.title || '다각도 분석',
                context: text,
                facets: prismRes?.facets,
                originalParagraph: text,
              }}
              postTitle={postTitle}
              onClose={() => {
                setShowDebate(false);
                setDebateTopic(null);
              }}
            />
          </div>
        </div>,
        document.body
      )}
    </>
  );
}

```

---

## frontend/src/components/molecules

### NavigationItem.tsx

**Path:** `frontend/src/components/molecules/NavigationItem.tsx`

```tsx
import { Link, useLocation } from 'react-router-dom';
import { LucideIcon } from 'lucide-react';
import { cn } from '@/lib/utils';

interface NavigationItemProps {
  name: string;
  href: string;
  icon: LucideIcon;
  isMobile?: boolean;
  onClick?: () => void;
  className?: string;
}

export function NavigationItem({
  name,
  href,
  icon: Icon,
  isMobile = false,
  onClick,
  className = '',
}: NavigationItemProps) {
  const location = useLocation();
  const isActive = location.pathname === href;

  const baseClasses = isMobile
    ? 'flex items-center gap-3 rounded-md px-3 py-2 text-base font-medium transition-colors'
    : 'flex items-center gap-2 text-sm font-medium transition-colors hover:text-primary';

  const activeClasses = isMobile
    ? 'bg-primary/10 text-primary'
    : 'text-primary';

  const inactiveClasses = isMobile
    ? 'text-muted-foreground hover:bg-accent hover:text-accent-foreground'
    : 'text-muted-foreground';

  return (
    <Link
      to={href}
      className={cn(
        baseClasses,
        isActive ? activeClasses : inactiveClasses,
        className
      )}
      onClick={onClick}
    >
      <Icon className={isMobile ? 'h-5 w-5' : 'h-4 w-4'} />
      {name}
    </Link>
  );
}

```

### index.ts

**Path:** `frontend/src/components/molecules/index.ts`

```typescript
export { NavigationItem } from './NavigationItem';

```

---

## frontend/src/components/organisms

### Footer.tsx

**Path:** `frontend/src/components/organisms/Footer.tsx`

```tsx
import { Link } from 'react-router-dom';
import { Github, Twitter, Linkedin, Mail } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { site } from '@/config/site';
import { useTheme } from '@/contexts/ThemeContext';
import { cn } from '@/lib/utils';

export function Footer() {
  const currentYear = new Date().getFullYear();
  const { isTerminal } = useTheme();

  return (
    <footer className={cn(
      'border-t bg-background',
      isTerminal && 'border-primary/30'
    )}>
      <div className='container mx-auto px-4 sm:px-6 lg:px-8'>
        <div className='py-10 md:py-14'>
          <div className='grid grid-cols-1 gap-8 md:grid-cols-4'>
            <div className='space-y-4'>
              <h3 className={cn(
                'text-lg font-semibold',
                isTerminal && 'font-mono text-primary'
              )}>
                {isTerminal ? '>_ Nodove Blog' : 'Nodove Blog'}
              </h3>
              <p className='text-sm text-muted-foreground'>
                최신 기술 트렌드를 놓치지 마세요!
              </p>
              <p className='text-sm text-muted-foreground'>
                유용한 글을 메일로 보내드려요.
              </p>
              <div className='flex space-x-4'>
                <Button 
                  variant='ghost' 
                  size='icon' 
                  asChild
                  className={cn(isTerminal && 'text-primary hover:text-primary hover:bg-primary/10')}
                >
                  <a
                    href={site.social.github}
                    target='_blank'
                    rel='noopener noreferrer'
                  >
                    <Github className='h-5 w-5' />
                    <span className='sr-only'>GitHub</span>
                  </a>
                </Button>
                <Button 
                  variant='ghost' 
                  size='icon' 
                  asChild
                  className={cn(isTerminal && 'text-primary hover:text-primary hover:bg-primary/10')}
                >
                  <a
                    href={site.social.twitter}
                    target='_blank'
                    rel='noopener noreferrer'
                  >
                    <Twitter className='h-5 w-5' />
                    <span className='sr-only'>Twitter</span>
                  </a>
                </Button>
                <Button 
                  variant='ghost' 
                  size='icon' 
                  asChild
                  className={cn(isTerminal && 'text-primary hover:text-primary hover:bg-primary/10')}
                >
                  <a
                    href={site.social.linkedin}
                    target='_blank'
                    rel='noopener noreferrer'
                  >
                    <Linkedin className='h-5 w-5' />
                    <span className='sr-only'>LinkedIn</span>
                  </a>
                </Button>
                <Button 
                  variant='ghost' 
                  size='icon' 
                  asChild
                  className={cn(isTerminal && 'text-primary hover:text-primary hover:bg-primary/10')}
                >
                  <a href={`mailto:${site.email}`}>
                    <Mail className='h-5 w-5' />
                    <span className='sr-only'>Email</span>
                  </a>
                </Button>
              </div>
            </div>

            <div className='space-y-4'>
              <h4 className={cn(
                'text-sm font-semibold',
                isTerminal && 'font-mono text-primary'
              )}>
                {isTerminal ? '$ nav' : 'Navigation'}
              </h4>
              <ul className={cn(
                'space-y-2 text-sm',
                isTerminal && 'font-mono'
              )}>
                <li>
                  <Link
                    to='/'
                    className='text-muted-foreground hover:text-primary transition-colors'
                  >
                    Home
                  </Link>
                </li>
                <li>
                  <Link
                    to='/blog'
                    className='text-muted-foreground hover:text-primary transition-colors'
                  >
                    Blog
                  </Link>
                </li>
                <li>
                  <Link
                    to='/about'
                    className='text-muted-foreground hover:text-primary transition-colors'
                  >
                    About
                  </Link>
                </li>
                <li>
                  <Link
                    to='/contact'
                    className='text-muted-foreground hover:text-primary transition-colors'
                  >
                    Contact
                  </Link>
                </li>
              </ul>
            </div>

            <div className='space-y-4'>
              <h4 className={cn(
                'text-sm font-semibold',
                isTerminal && 'font-mono text-primary'
              )}>
                {isTerminal ? '$ categories' : 'Categories'}
              </h4>
              <ul className={cn(
                'space-y-2 text-sm',
                isTerminal && 'font-mono'
              )}>
                <li>
                  <Link
                    to='/blog?category=ai'
                    className='text-muted-foreground hover:text-primary transition-colors'
                  >
                    AI & Machine Learning
                  </Link>
                </li>
                <li>
                  <Link
                    to='/blog?category=web'
                    className='text-muted-foreground hover:text-primary transition-colors'
                  >
                    Web Development
                  </Link>
                </li>
                <li>
                  <Link
                    to='/blog?category=devops'
                    className='text-muted-foreground hover:text-primary transition-colors'
                  >
                    DevOps
                  </Link>
                </li>
                <li>
                  <Link
                    to='/blog?category=algorithms'
                    className='text-muted-foreground hover:text-primary transition-colors'
                  >
                    Algorithms
                  </Link>
                </li>
              </ul>
            </div>

            <div className='space-y-4'>
              <h4 className={cn(
                'text-sm font-semibold',
                isTerminal && 'font-mono text-primary'
              )}>
                {isTerminal ? '$ subscribe' : 'Subscribe'}
              </h4>
              <p className={cn(
                'text-sm text-muted-foreground',
                isTerminal && 'font-mono'
              )}>
                최신 글을 메일로 받아보세요.
              </p>
              <form className='space-y-2'>
                <input
                  type='email'
                  placeholder={isTerminal ? 'email@example.com' : 'Enter your email'}
                  className={cn(
                    'w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
                    isTerminal && 'font-mono border-primary/40 bg-primary/5 text-primary placeholder:text-primary/50 focus:ring-primary/50 focus:border-primary/60'
                  )}
                />
                <Button 
                  type='submit' 
                  className={cn(
                    'w-full',
                    isTerminal && 'font-mono bg-primary/20 text-primary border border-primary/40 hover:bg-primary/30 hover:shadow-[0_0_10px_rgba(0,255,65,0.3)]'
                  )}
                  variant={isTerminal ? 'outline' : 'default'}
                >
                  {isTerminal ? '> Subscribe' : 'Subscribe'}
                </Button>
              </form>
            </div>
          </div>

          <div className={cn(
            'mt-8 border-t pt-8',
            isTerminal && 'border-primary/30'
          )}>
            <p className={cn(
              'text-center text-sm text-muted-foreground',
              isTerminal && 'font-mono'
            )}>
              © {currentYear} Nodove Blog. All rights reserved.
            </p>
          </div>
        </div>
      </div>
    </footer>
  );
}

```

### Header.tsx

**Path:** `frontend/src/components/organisms/Header.tsx`

```tsx
import { Link, useLocation } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { LanguageToggle, ThemeToggle } from '@/components/common';
import { Menu, X, Home, BookOpen, User, Mail, Shield, Settings, Globe, Moon, Sun, Monitor, Terminal } from 'lucide-react';
import { useEffect, useState } from 'react';
import { cn } from '@/lib/utils';
import { NavigationItem } from '@/components/molecules';
import { useTheme } from '@/contexts/ThemeContext';
import { useLanguage } from '@/contexts/LanguageContext';
import { useIsMobile } from '@/hooks/use-mobile';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
  DropdownMenuLabel,
} from '@/components/ui/dropdown-menu';

const baseNavigation = [
  { name: 'Home', href: '/', icon: Home },
  { name: 'Blog', href: '/blog', icon: BookOpen },
  { name: 'About', href: '/about', icon: User },
  { name: 'Contact', href: '/contact', icon: Mail },
];

// Terminal window buttons component
function TerminalWindowButtons() {
  return (
    <div className='flex items-center gap-1.5 mr-4'>
      <span className='w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-close))]' />
      <span className='w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-minimize))]' />
      <span className='w-3 h-3 rounded-full bg-[hsl(var(--terminal-window-btn-maximize))]' />
    </div>
  );
}

// Terminal path display component
function TerminalPath() {
  const location = useLocation();
  const path = location.pathname === '/' ? '~' : `~${location.pathname}`;

  return (
    <div className='hidden sm:flex items-center gap-2 font-mono text-xs text-muted-foreground'>
      <span className='text-primary'>user@blog:</span>
      <span>{path}</span>
      <span className='terminal-cursor' />
    </div>
  );
}

export function Header() {
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [hasAdmin, setHasAdmin] = useState<boolean>(false);
  const { theme, setTheme, isTerminal } = useTheme();
  const { language, setLanguage } = useLanguage();
  const isMobile = useIsMobile();

  useEffect(() => {
    const check = () => {
      try {
        setHasAdmin(!!localStorage.getItem('admin.token'));
      } catch {
        setHasAdmin(false);
      }
    };
    check();
    const handler = () => check();
    window.addEventListener('admin-auth-changed', handler);
    return () => window.removeEventListener('admin-auth-changed', handler);
  }, []);

  const navigation = hasAdmin
    ? [
        ...baseNavigation,
        { name: 'Admin', href: '/admin/new-post', icon: Shield },
      ]
    : baseNavigation;

  const closeMobileMenu = () => setMobileMenuOpen(false);

  return (
    <header
      className={cn(
        'sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60',
        isTerminal && 'bg-[hsl(var(--terminal-titlebar))] border-border'
      )}
    >
      <nav
        className='container mx-auto px-4 sm:px-6 lg:px-8'
        aria-label='Global'
      >
        <div className='flex h-16 items-center justify-between'>
          <div className='flex items-center gap-x-12'>
            {/* Terminal window buttons - only show in terminal mode */}
            {isTerminal && <TerminalWindowButtons />}

            <Link
              to='/'
              className={cn(
                'flex items-center space-x-2 no-terminal-style',
                isTerminal && 'no-underline'
              )}
            >
              <span
                className={cn(
                  'text-2xl font-bold',
                  isTerminal
                    ? 'font-mono text-primary terminal-glow'
                    : 'bg-gradient-to-r from-primary to-primary/60 bg-clip-text text-transparent'
                )}
              >
                {isTerminal ? '>_Nodove' : 'Nodove'}
              </span>
            </Link>

            {/* Terminal path - only show in terminal mode */}
            {isTerminal && <TerminalPath />}

            <div className='hidden md:flex md:gap-x-8'>
              {navigation.map(item => (
                <NavigationItem
                  key={item.name}
                  name={item.name}
                  href={item.href}
                  icon={item.icon}
                  className={cn(
                    isTerminal && 'font-mono text-sm no-terminal-style'
                  )}
                />
              ))}
            </div>
          </div>
          <div className='flex items-center gap-x-2 sm:gap-x-4'>
            {/* PC: 개별 토글 버튼들 */}
            {!isMobile && (
              <>
                <LanguageToggle />
                <ThemeToggle />
              </>
            )}
            
            {/* 모바일: 통합 설정 드롭다운 */}
            {isMobile && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant='ghost'
                    size='icon'
                    className={cn(
                      'h-9 w-9',
                      isTerminal && 'text-primary hover:text-primary hover:bg-primary/10'
                    )}
                    aria-label='설정'
                  >
                    <Settings className='h-5 w-5' />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent 
                  align='end' 
                  className={cn(
                    'w-48',
                    isTerminal && 'border-primary/40 bg-background/95 backdrop-blur'
                  )}
                >
                  <DropdownMenuLabel className={cn(
                    'text-xs text-muted-foreground',
                    isTerminal && 'font-mono text-primary/70'
                  )}>
                    {isTerminal ? '$ language' : '언어 설정'}
                  </DropdownMenuLabel>
                  <DropdownMenuItem
                    onClick={() => setLanguage('ko')}
                    className={cn(
                      'flex items-center justify-between',
                      isTerminal && 'font-mono hover:bg-primary/10 hover:text-primary focus:bg-primary/10 focus:text-primary',
                      isTerminal && language === 'ko' && 'bg-primary/15 text-primary'
                    )}
                  >
                    <span className='flex items-center gap-2'>
                      <Globe className='h-4 w-4' />
                      한국어
                    </span>
                    {language === 'ko' && <span className='text-primary'>✓</span>}
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => setLanguage('en')}
                    className={cn(
                      'flex items-center justify-between',
                      isTerminal && 'font-mono hover:bg-primary/10 hover:text-primary focus:bg-primary/10 focus:text-primary',
                      isTerminal && language === 'en' && 'bg-primary/15 text-primary'
                    )}
                  >
                    <span className='flex items-center gap-2'>
                      <Globe className='h-4 w-4' />
                      English
                    </span>
                    {language === 'en' && <span className='text-primary'>✓</span>}
                  </DropdownMenuItem>
                  
                  <DropdownMenuSeparator className={cn(isTerminal && 'bg-primary/30')} />
                  
                  <DropdownMenuLabel className={cn(
                    'text-xs text-muted-foreground',
                    isTerminal && 'font-mono text-primary/70'
                  )}>
                    {isTerminal ? '$ theme' : '테마 설정'}
                  </DropdownMenuLabel>
                  <DropdownMenuItem
                    onClick={() => setTheme('light')}
                    className={cn(
                      'flex items-center justify-between', 
                      theme === 'light' && 'bg-accent',
                      isTerminal && 'font-mono hover:bg-primary/10 hover:text-primary focus:bg-primary/10 focus:text-primary'
                    )}
                  >
                    <span className='flex items-center gap-2'>
                      <Sun className='h-4 w-4' />
                      Light
                    </span>
                    {theme === 'light' && <span className='text-primary'>✓</span>}
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => setTheme('dark')}
                    className={cn(
                      'flex items-center justify-between', 
                      theme === 'dark' && 'bg-accent',
                      isTerminal && 'font-mono hover:bg-primary/10 hover:text-primary focus:bg-primary/10 focus:text-primary'
                    )}
                  >
                    <span className='flex items-center gap-2'>
                      <Moon className='h-4 w-4' />
                      Dark
                    </span>
                    {theme === 'dark' && <span className='text-primary'>✓</span>}
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => setTheme('system')}
                    className={cn(
                      'flex items-center justify-between', 
                      theme === 'system' && 'bg-accent',
                      isTerminal && 'font-mono hover:bg-primary/10 hover:text-primary focus:bg-primary/10 focus:text-primary'
                    )}
                  >
                    <span className='flex items-center gap-2'>
                      <Monitor className='h-4 w-4' />
                      System
                    </span>
                    {theme === 'system' && <span className='text-primary'>✓</span>}
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => setTheme('terminal')}
                    className={cn(
                      'flex items-center justify-between font-mono',
                      theme === 'terminal' && 'bg-primary/15',
                      isTerminal && 'hover:bg-primary/10 hover:text-primary focus:bg-primary/10 focus:text-primary'
                    )}
                  >
                    <span className='flex items-center gap-2'>
                      <Terminal className={cn('h-4 w-4', theme === 'terminal' && 'text-primary')} />
                      <span className={cn(theme === 'terminal' && 'text-primary')}>Terminal</span>
                    </span>
                    {theme === 'terminal' && <span className='text-primary'>✓</span>}
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            )}
            
            <div className='flex md:hidden'>
              <Button
                variant='ghost'
                size='icon'
                onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
                aria-label='Toggle main menu'
                className={cn(isTerminal && 'text-primary hover:text-primary')}
              >
                <span className='sr-only'>Open main menu</span>
                {mobileMenuOpen ? (
                  <X className='h-6 w-6' aria-hidden='true' />
                ) : (
                  <Menu className='h-6 w-6' aria-hidden='true' />
                )}
              </Button>
            </div>
          </div>
        </div>
      </nav>

      {/* Mobile menu */}
      <div className={cn('md:hidden', mobileMenuOpen ? 'block' : 'hidden')}>
        <div
          className={cn(
            'space-y-1 px-4 pb-3 pt-2',
            isTerminal && 'bg-[hsl(var(--terminal-code-bg))]'
          )}
        >
          {navigation.map(item => (
            <NavigationItem
              key={item.name}
              name={item.name}
              href={item.href}
              icon={item.icon}
              isMobile
              onClick={closeMobileMenu}
              className={cn(isTerminal && 'font-mono no-terminal-style')}
            />
          ))}
        </div>
      </div>
    </header>
  );
}

```

### index.ts

**Path:** `frontend/src/components/organisms/index.ts`

```typescript
export { Header } from './Header';
export { Footer } from './Footer';

```

---

## frontend/src/components/ui

### accordion.tsx

**Path:** `frontend/src/components/ui/accordion.tsx`

```tsx
import * as React from 'react';
import * as AccordionPrimitive from '@radix-ui/react-accordion';
import { ChevronDown } from 'lucide-react';

import { cn } from '@/lib/utils';

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn('border-b', className)}
    {...props}
  />
));
AccordionItem.displayName = 'AccordionItem';

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className='flex'>
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        'flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180',
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className='h-4 w-4 shrink-0 transition-transform duration-200' />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className='overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down'
    {...props}
  >
    <div className={cn('pb-4 pt-0', className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };

```

### alert-dialog.tsx

**Path:** `frontend/src/components/ui/alert-dialog.tsx`

```tsx
import * as React from 'react';
import * as AlertDialogPrimitive from '@radix-ui/react-alert-dialog';

import { cn } from '@/lib/utils';
import { buttonVariants } from '@/components/ui/button';

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
AlertDialogHeader.displayName = 'AlertDialogHeader';

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
AlertDialogFooter.displayName = 'AlertDialogFooter';

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold', className)}
    {...props}
  />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: 'outline' }),
      'mt-2 sm:mt-0',
      className
    )}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};

```

### alert.tsx

**Path:** `frontend/src/components/ui/alert.tsx`

```tsx
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const alertVariants = cva(
  'relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground',
  {
    variants: {
      variant: {
        default: 'bg-background text-foreground',
        destructive:
          'border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role='alert'
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
));
Alert.displayName = 'Alert';

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn('mb-1 font-medium leading-none tracking-tight', className)}
    {...props}
  />
));
AlertTitle.displayName = 'AlertTitle';

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('text-sm [&_p]:leading-relaxed', className)}
    {...props}
  />
));
AlertDescription.displayName = 'AlertDescription';

export { Alert, AlertTitle, AlertDescription };

```

### aspect-ratio.tsx

**Path:** `frontend/src/components/ui/aspect-ratio.tsx`

```tsx
import * as AspectRatioPrimitive from '@radix-ui/react-aspect-ratio';

const AspectRatio = AspectRatioPrimitive.Root;

export { AspectRatio };

```

### avatar.tsx

**Path:** `frontend/src/components/ui/avatar.tsx`

```tsx
import * as React from 'react';
import * as AvatarPrimitive from '@radix-ui/react-avatar';

import { cn } from '@/lib/utils';

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      'relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full',
      className
    )}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn('aspect-square h-full w-full', className)}
    {...props}
  />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      'flex h-full w-full items-center justify-center rounded-full bg-muted',
      className
    )}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarImage, AvatarFallback };

```

### badge.tsx

**Path:** `frontend/src/components/ui/badge.tsx`

```tsx
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const badgeVariants = cva(
  'inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground hover:bg-primary/80',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
        destructive:
          'border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80',
        outline: 'text-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

```

### breadcrumb.tsx

**Path:** `frontend/src/components/ui/breadcrumb.tsx`

```tsx
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { ChevronRight, MoreHorizontal } from 'lucide-react';

import { cn } from '@/lib/utils';

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<'nav'> & {
    separator?: React.ReactNode;
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label='breadcrumb' {...props} />);
Breadcrumb.displayName = 'Breadcrumb';

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<'ol'>
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      'flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5',
      className
    )}
    {...props}
  />
));
BreadcrumbList.displayName = 'BreadcrumbList';

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<'li'>
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn('inline-flex items-center gap-1.5', className)}
    {...props}
  />
));
BreadcrumbItem.displayName = 'BreadcrumbItem';

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<'a'> & {
    asChild?: boolean;
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : 'a';

  return (
    <Comp
      ref={ref}
      className={cn('transition-colors hover:text-foreground', className)}
      {...props}
    />
  );
});
BreadcrumbLink.displayName = 'BreadcrumbLink';

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<'span'>
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role='link'
    aria-disabled='true'
    aria-current='page'
    className={cn('font-normal text-foreground', className)}
    {...props}
  />
));
BreadcrumbPage.displayName = 'BreadcrumbPage';

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<'li'>) => (
  <li
    role='presentation'
    aria-hidden='true'
    className={cn('[&>svg]:size-3.5', className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
);
BreadcrumbSeparator.displayName = 'BreadcrumbSeparator';

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<'span'>) => (
  <span
    role='presentation'
    aria-hidden='true'
    className={cn('flex h-9 w-9 items-center justify-center', className)}
    {...props}
  >
    <MoreHorizontal className='h-4 w-4' />
    <span className='sr-only'>More</span>
  </span>
);
BreadcrumbEllipsis.displayName = 'BreadcrumbElipssis';

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};

```

### button.tsx

**Path:** `frontend/src/components/ui/button.tsx`

```tsx
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const buttonVariants = cva(
  'inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-xl text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive:
          'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline:
          'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
        secondary:
          'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
        // Terminal/Cyber-Minimalism variants
        terminal:
          'bg-transparent border border-[hsl(var(--terminal-inactive-border,var(--border)))] text-muted-foreground font-mono uppercase tracking-wider hover:border-primary hover:text-primary hover:shadow-[0_0_10px_hsl(var(--primary)/0.4)] hover:[text-shadow:0_0_5px_hsl(var(--primary))]',
        'terminal-active':
          'bg-primary text-[hsl(210_50%_2%)] border border-primary font-mono uppercase tracking-wider shadow-[0_0_10px_hsl(var(--primary)/0.4)]',
        'terminal-danger':
          'bg-transparent border border-destructive/50 text-destructive font-mono uppercase tracking-wider hover:bg-destructive hover:text-white hover:shadow-[0_0_10px_hsl(var(--destructive)/0.5)]',
      },
      size: {
        default: 'h-10 px-4 py-2 rounded-xl',
        sm: 'h-9 rounded-xl px-3',
        lg: 'h-11 rounded-xl px-8',
        icon: 'h-10 w-10 rounded-xl',
        // Terminal size: 더 날렵한 radius
        terminal: 'h-9 px-4 py-2 rounded-[4px] text-xs',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button';
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = 'Button';

export { Button, buttonVariants };

```

### calendar.tsx

**Path:** `frontend/src/components/ui/calendar.tsx`

```tsx
import * as React from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { DayPicker } from 'react-day-picker';

import { cn } from '@/lib/utils';
import { buttonVariants } from '@/components/ui/button';

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn('p-3', className)}
      classNames={{
        months: 'flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0',
        month: 'space-y-4',
        caption: 'flex justify-center pt-1 relative items-center',
        caption_label: 'text-sm font-medium',
        nav: 'space-x-1 flex items-center',
        nav_button: cn(
          buttonVariants({ variant: 'outline' }),
          'h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100'
        ),
        nav_button_previous: 'absolute left-1',
        nav_button_next: 'absolute right-1',
        table: 'w-full border-collapse space-y-1',
        head_row: 'flex',
        head_cell:
          'text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]',
        row: 'flex w-full mt-2',
        cell: 'h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20',
        day: cn(
          buttonVariants({ variant: 'ghost' }),
          'h-9 w-9 p-0 font-normal aria-selected:opacity-100'
        ),
        day_range_end: 'day-range-end',
        day_selected:
          'bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground',
        day_today: 'bg-accent text-accent-foreground',
        day_outside:
          'day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30',
        day_disabled: 'text-muted-foreground opacity-50',
        day_range_middle:
          'aria-selected:bg-accent aria-selected:text-accent-foreground',
        day_hidden: 'invisible',
        ...classNames,
      }}
      components={{
        IconLeft: ({ ..._props }) => <ChevronLeft className='h-4 w-4' />,
        IconRight: ({ ..._props }) => <ChevronRight className='h-4 w-4' />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = 'Calendar';

export { Calendar };

```

### card.tsx

**Path:** `frontend/src/components/ui/card.tsx`

```tsx
import * as React from 'react';

import { cn } from '@/lib/utils';

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'rounded-lg border bg-card text-card-foreground shadow-sm',
      className
    )}
    {...props}
  />
));
Card.displayName = 'Card';

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
));
CardHeader.displayName = 'CardHeader';

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      'text-2xl font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));
CardTitle.displayName = 'CardTitle';

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
CardDescription.displayName = 'CardDescription';

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
));
CardContent.displayName = 'CardContent';

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex items-center p-6 pt-0', className)}
    {...props}
  />
));
CardFooter.displayName = 'CardFooter';

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};

```

### carousel.tsx

**Path:** `frontend/src/components/ui/carousel.tsx`

```tsx
import * as React from 'react';
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from 'embla-carousel-react';
import { ArrowLeft, ArrowRight } from 'lucide-react';

import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: 'horizontal' | 'vertical';
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error('useCarousel must be used within a <Carousel />');
  }

  return context;
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = 'horizontal',
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === 'horizontal' ? 'x' : 'y',
      },
      plugins
    );
    const [canScrollPrev, setCanScrollPrev] = React.useState(false);
    const [canScrollNext, setCanScrollNext] = React.useState(false);

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return;
      }

      setCanScrollPrev(api.canScrollPrev());
      setCanScrollNext(api.canScrollNext());
    }, []);

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev();
    }, [api]);

    const scrollNext = React.useCallback(() => {
      api?.scrollNext();
    }, [api]);

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === 'ArrowLeft') {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === 'ArrowRight') {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext]
    );

    React.useEffect(() => {
      if (!api || !setApi) {
        return;
      }

      setApi(api);
    }, [api, setApi]);

    React.useEffect(() => {
      if (!api) {
        return;
      }

      onSelect(api);
      api.on('reInit', onSelect);
      api.on('select', onSelect);

      return () => {
        api?.off('select', onSelect);
      };
    }, [api, onSelect]);

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api,
          opts,
          orientation:
            orientation || (opts?.axis === 'y' ? 'vertical' : 'horizontal'),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn('relative', className)}
          role='region'
          aria-roledescription='carousel'
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    );
  }
);
Carousel.displayName = 'Carousel';

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel();

  return (
    <div ref={carouselRef} className='overflow-hidden'>
      <div
        ref={ref}
        className={cn(
          'flex',
          orientation === 'horizontal' ? '-ml-4' : '-mt-4 flex-col',
          className
        )}
        {...props}
      />
    </div>
  );
});
CarouselContent.displayName = 'CarouselContent';

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel();

  return (
    <div
      ref={ref}
      role='group'
      aria-roledescription='slide'
      className={cn(
        'min-w-0 shrink-0 grow-0 basis-full',
        orientation === 'horizontal' ? 'pl-4' : 'pt-4',
        className
      )}
      {...props}
    />
  );
});
CarouselItem.displayName = 'CarouselItem';

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = 'outline', size = 'icon', ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        'absolute  h-8 w-8 rounded-full',
        orientation === 'horizontal'
          ? '-left-12 top-1/2 -translate-y-1/2'
          : '-top-12 left-1/2 -translate-x-1/2 rotate-90',
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className='h-4 w-4' />
      <span className='sr-only'>Previous slide</span>
    </Button>
  );
});
CarouselPrevious.displayName = 'CarouselPrevious';

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = 'outline', size = 'icon', ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        'absolute h-8 w-8 rounded-full',
        orientation === 'horizontal'
          ? '-right-12 top-1/2 -translate-y-1/2'
          : '-bottom-12 left-1/2 -translate-x-1/2 rotate-90',
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className='h-4 w-4' />
      <span className='sr-only'>Next slide</span>
    </Button>
  );
});
CarouselNext.displayName = 'CarouselNext';

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
};

```

### chart.tsx

**Path:** `frontend/src/components/ui/chart.tsx`

```tsx
import * as React from 'react';
import * as RechartsPrimitive from 'recharts';

import { cn } from '../../lib/utils';

// Chart styling without inline styles to comply with CSP

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode;
    icon?: React.ComponentType;
    color?: string;
    theme?: {
      light?: string;
      dark?: string;
    };
  };
};

type ChartContextProps = {
  config: ChartConfig;
};

const ChartContext = React.createContext<ChartContextProps | null>(null);

function useChart() {
  const context = React.useContext(ChartContext);

  if (!context) {
    throw new Error('useChart must be used within a <ChartContainer />');
  }

  return context;
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & {
    config: ChartConfig;
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >['children'];
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId();
  const chartId = `chart-${id || uniqueId.replace(/:/g, '')}`;

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
});
ChartContainer.displayName = 'Chart';

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  );

  if (!colorConfig.length) {
    return null;
  }

  // Create CSS variables object instead of inline styles
  const cssVariables = colorConfig.reduce(
    (acc, [key, itemConfig]) => {
      const color = itemConfig.theme?.light || itemConfig.color;
      if (color) acc[`--color-${key}`] = color;
      return acc;
    },
    {} as Record<string, string>
  );

  return (
    <div data-chart={id} style={cssVariables} className='chart-container' />
  );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<'div'> & {
      hideLabel?: boolean;
      hideIndicator?: boolean;
      indicator?: 'line' | 'dot' | 'dashed';
      nameKey?: string;
      labelKey?: string;
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = 'dot',
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart();

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null;
      }

      const [item] = payload;
      const key = `${labelKey || item.dataKey || item.name || 'value'}`;
      const itemConfig = getPayloadConfigFromPayload(config, item, key);
      const value =
        !labelKey && typeof label === 'string'
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label;

      if (labelFormatter) {
        return (
          <div className={cn('font-medium', labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        );
      }

      if (!value) {
        return null;
      }

      return <div className={cn('font-medium', labelClassName)}>{value}</div>;
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ]);

    if (!active || !payload?.length) {
      return null;
    }

    const nestLabel = payload.length === 1 && indicator !== 'dot';

    return (
      <div
        ref={ref}
        className={cn(
          'grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl',
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className='grid gap-1.5'>
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || 'value'}`;
            const itemConfig = getPayloadConfigFromPayload(config, item, key);
            const indicatorColor = color || item.payload.fill || item.color;

            return (
              <div
                key={item.dataKey}
                className={cn(
                  'flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground',
                  indicator === 'dot' && 'items-center'
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            'shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]',
                            {
                              'h-2.5 w-2.5': indicator === 'dot',
                              'w-1': indicator === 'line',
                              'w-0 border-[1.5px] border-dashed bg-transparent':
                                indicator === 'dashed',
                              'my-0.5': nestLabel && indicator === 'dashed',
                            }
                          )}
                          style={
                            {
                              '--color-bg': indicatorColor,
                              '--color-border': indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        'flex flex-1 justify-between leading-none',
                        nestLabel ? 'items-end' : 'items-center'
                      )}
                    >
                      <div className='grid gap-1.5'>
                        {nestLabel ? tooltipLabel : null}
                        <span className='text-muted-foreground'>
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className='font-mono font-medium tabular-nums text-foreground'>
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            );
          })}
        </div>
      </div>
    );
  }
);
ChartTooltipContent.displayName = 'ChartTooltip';

const ChartLegend = RechartsPrimitive.Legend;

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> &
    Pick<RechartsPrimitive.LegendProps, 'payload' | 'verticalAlign'> & {
      hideIcon?: boolean;
      nameKey?: string;
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = 'bottom', nameKey },
    ref
  ) => {
    const { config } = useChart();

    if (!payload?.length) {
      return null;
    }

    return (
      <div
        ref={ref}
        className={cn(
          'flex items-center justify-center gap-4',
          verticalAlign === 'top' ? 'pb-3' : 'pt-3',
          className
        )}
      >
        {payload.map(item => {
          const key = `${nameKey || item.dataKey || 'value'}`;
          const itemConfig = getPayloadConfigFromPayload(config, item, key);

          return (
            <div
              key={item.value}
              className={cn(
                'flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground'
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className='h-2 w-2 shrink-0 rounded-[2px]'
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          );
        })}
      </div>
    );
  }
);
ChartLegendContent.displayName = 'ChartLegend';

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== 'object' || payload === null) {
    return undefined;
  }

  const payloadPayload =
    'payload' in payload &&
    typeof payload.payload === 'object' &&
    payload.payload !== null
      ? payload.payload
      : undefined;

  let configLabelKey: string = key;

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === 'string'
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string;
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === 'string'
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string;
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config];
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
};

```

### checkbox.tsx

**Path:** `frontend/src/components/ui/checkbox.tsx`

```tsx
import * as React from 'react';
import * as CheckboxPrimitive from '@radix-ui/react-checkbox';
import { Check } from 'lucide-react';

import { cn } from '@/lib/utils';

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      'peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground',
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn('flex items-center justify-center text-current')}
    >
      <Check className='h-4 w-4' />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

```

### collapsible.tsx

**Path:** `frontend/src/components/ui/collapsible.tsx`

```tsx
import * as CollapsiblePrimitive from '@radix-ui/react-collapsible';

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleTrigger, CollapsibleContent };

```

### command-bar.tsx

**Path:** `frontend/src/components/ui/command-bar.tsx`

```tsx
import * as React from 'react';
import { cn } from '@/lib/utils';

/**
 * CommandBar - 터미널 스타일의 탭/버튼 그룹 컴포넌트
 * 
 * Design Philosophy: "키보드 키캡" 느낌의 날렵한 버튼
 * - Shape: 둥근 모서리 제거, radius 4px 유지
 * - Border: Neon Green 컬러와 Glow 효과
 * - Typography: Monospace 폰트 사용
 */

interface CommandBarProps extends React.HTMLAttributes<HTMLElement> {
  children: React.ReactNode;
}

const CommandBar = React.forwardRef<HTMLElement, CommandBarProps>(
  ({ className, children, ...props }, ref) => (
    <nav
      ref={ref}
      className={cn(
        'flex items-center justify-between',
        'border-b border-border/30 pb-3 mb-5',
        className
      )}
      {...props}
    >
      {children}
    </nav>
  )
);
CommandBar.displayName = 'CommandBar';

interface CommandGroupProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

const CommandGroup = React.forwardRef<HTMLDivElement, CommandGroupProps>(
  ({ className, children, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('flex items-center gap-3', className)}
      {...props}
    >
      {children}
    </div>
  )
);
CommandGroup.displayName = 'CommandGroup';

interface CommandButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  active?: boolean;
  variant?: 'default' | 'close' | 'danger';
}

const CommandButton = React.forwardRef<HTMLButtonElement, CommandButtonProps>(
  ({ className, active = false, variant = 'default', children, ...props }, ref) => {
    const baseStyles = cn(
      // Base styles
      'bg-transparent',
      'px-4 py-2',
      'font-mono text-sm font-bold',
      'rounded-[4px]',
      'cursor-pointer',
      'transition-all duration-200',
      'uppercase tracking-wider',
      // Border
      'border',
      // Focus states
      'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-background',
      // Disabled
      'disabled:cursor-not-allowed disabled:opacity-50',
    );

    const variantStyles = {
      default: cn(
        'border-[hsl(var(--terminal-inactive-border))] text-muted-foreground',
        // Hover: 네온 그린 점등
        'hover:border-primary hover:text-primary',
        'hover:shadow-[var(--glow-shadow)]',
        'hover:[text-shadow:0_0_5px_hsl(var(--primary))]',
        // Active: 선택된 탭 - Dark text on neon green
        active && [
          'bg-primary text-[hsl(210_50%_2%)]',
          'border-primary',
          'shadow-[var(--glow-shadow)]',
        ],
      ),
      close: cn(
        'border-destructive/50 text-destructive',
        'hover:bg-destructive hover:text-white',
        'hover:border-destructive',
        'hover:shadow-[0_0_10px_hsl(var(--destructive)/0.5)]',
      ),
      danger: cn(
        'border-destructive/50 text-destructive',
        'hover:bg-destructive hover:text-white',
        'hover:border-destructive',
        'hover:shadow-[0_0_10px_hsl(var(--destructive)/0.5)]',
      ),
    };

    return (
      <button
        ref={ref}
        className={cn(baseStyles, variantStyles[variant], className)}
        {...props}
      >
        {children}
      </button>
    );
  }
);
CommandButton.displayName = 'CommandButton';

export { CommandBar, CommandGroup, CommandButton };

```

### command.tsx

**Path:** `frontend/src/components/ui/command.tsx`

```tsx
import * as React from 'react';
import { type DialogProps } from '@radix-ui/react-dialog';
import { Command as CommandPrimitive } from 'cmdk';
import { Search } from 'lucide-react';

import { cn } from '@/lib/utils';
import { Dialog, DialogContent } from '@/components/ui/dialog';

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      'flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground',
      className
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

type CommandDialogProps = DialogProps;

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className='overflow-hidden p-0 shadow-lg'>
        <Command className='[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5'>
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className='flex items-center border-b px-3' cmdk-input-wrapper=''>
    <Search className='mr-2 h-4 w-4 shrink-0 opacity-50' />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        'flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn('max-h-[300px] overflow-y-auto overflow-x-hidden', className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className='py-6 text-center text-sm'
    {...props}
  />
));

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      'overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground',
      className
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 h-px bg-border', className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        'ml-auto text-xs tracking-widest text-muted-foreground',
        className
      )}
      {...props}
    />
  );
};
CommandShortcut.displayName = 'CommandShortcut';

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};

```

### context-menu.tsx

**Path:** `frontend/src/components/ui/context-menu.tsx`

```tsx
import * as React from 'react';
import * as ContextMenuPrimitive from '@radix-ui/react-context-menu';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className='ml-auto h-4 w-4' />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className='absolute left-2 flex h-3.5 w-3.5 items-center justify-center'>
      <ContextMenuPrimitive.ItemIndicator>
        <Check className='h-4 w-4' />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className='absolute left-2 flex h-3.5 w-3.5 items-center justify-center'>
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className='h-2 w-2 fill-current' />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold text-foreground',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-border', className)}
    {...props}
  />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        'ml-auto text-xs tracking-widest text-muted-foreground',
        className
      )}
      {...props}
    />
  );
};
ContextMenuShortcut.displayName = 'ContextMenuShortcut';

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};

```

### dialog.tsx

**Path:** `frontend/src/components/ui/dialog.tsx`

```tsx
import * as React from 'react';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className='absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground'>
        <X className='h-4 w-4' />
        <span className='sr-only'>Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-1.5 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = 'DialogHeader';

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = 'DialogFooter';

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

```

### drawer.tsx

**Path:** `frontend/src/components/ui/drawer.tsx`

```tsx
import * as React from 'react';
import { Drawer as DrawerPrimitive } from 'vaul';

import { cn } from '@/lib/utils';

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
);
Drawer.displayName = 'Drawer';

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn('fixed inset-0 z-50 bg-black/80', className)}
    {...props}
  />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        'fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background',
        className
      )}
      {...props}
    >
      <div className='mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted' />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
));
DrawerContent.displayName = 'DrawerContent';

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('grid gap-1.5 p-4 text-center sm:text-left', className)}
    {...props}
  />
);
DrawerHeader.displayName = 'DrawerHeader';

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('mt-auto flex flex-col gap-2 p-4', className)}
    {...props}
  />
);
DrawerFooter.displayName = 'DrawerFooter';

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
};

```

### dropdown-menu.tsx

**Path:** `frontend/src/components/ui/dropdown-menu.tsx`

```tsx
import * as React from 'react';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className='ml-auto h-4 w-4' />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className='absolute left-2 flex h-3.5 w-3.5 items-center justify-center'>
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className='h-4 w-4' />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className='absolute left-2 flex h-3.5 w-3.5 items-center justify-center'>
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className='h-2 w-2 fill-current' />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest opacity-60', className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = 'DropdownMenuShortcut';

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};

```

### form.tsx

**Path:** `frontend/src/components/ui/form.tsx`

```tsx
import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot } from '@radix-ui/react-slot';
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from 'react-hook-form';

import { cn } from '@/lib/utils';
import { Label } from '@/components/ui/label';

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>');
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn('space-y-2', className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = 'FormItem';

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && 'text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = 'FormLabel';

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = 'FormControl';

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn('text-sm text-muted-foreground', className)}
      {...props}
    />
  );
});
FormDescription.displayName = 'FormDescription';

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn('text-sm font-medium text-destructive', className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = 'FormMessage';

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};

```

### hover-card.tsx

**Path:** `frontend/src/components/ui/hover-card.tsx`

```tsx
import * as React from 'react';
import * as HoverCardPrimitive from '@radix-ui/react-hover-card';

import { cn } from '@/lib/utils';

const HoverCard = HoverCardPrimitive.Root;

const HoverCardTrigger = HoverCardPrimitive.Trigger;

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      'z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName;

export { HoverCard, HoverCardTrigger, HoverCardContent };

```

### index.ts

**Path:** `frontend/src/components/ui/index.ts`

```typescript
// UI Components exports
export * from './accordion';
export * from './alert';
export * from './alert-dialog';
export * from './aspect-ratio';
export * from './avatar';
export * from './badge';
export * from './breadcrumb';
export * from './button';
export * from './calendar';
export * from './card';
export * from './carousel';
export * from './chart';
export * from './checkbox';
export * from './collapsible';
export * from './command';
export * from './command-bar';
export * from './context-menu';
export * from './dialog';
export * from './drawer';
export * from './dropdown-menu';
export * from './form';
export * from './hover-card';
export * from './input';
export * from './input-otp';
export * from './label';
export * from './menubar';
export * from './navigation-menu';
export * from './popover';
export * from './progress';
export * from './radio-group';
export * from './resizable';
export * from './scroll-area';
export * from './select';
export * from './separator';
export * from './sheet';
export * from './sidebar';
export * from './skeleton';
export * from './slider';
export * from './switch';
export * from './table';
export * from './tabs';
export * from './terminal-panel';
export * from './textarea';
export * from './toggle';
export * from './toggle-group';
export * from './tooltip';
export * from './use-toast';

```

### input-otp.tsx

**Path:** `frontend/src/components/ui/input-otp.tsx`

```tsx
import * as React from 'react';
import { OTPInput, OTPInputContext } from 'input-otp';
import { Dot } from 'lucide-react';

import { cn } from '@/lib/utils';

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      'flex items-center gap-2 has-[:disabled]:opacity-50',
      containerClassName
    )}
    className={cn('disabled:cursor-not-allowed', className)}
    {...props}
  />
));
InputOTP.displayName = 'InputOTP';

const InputOTPGroup = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('flex items-center', className)} {...props} />
));
InputOTPGroup.displayName = 'InputOTPGroup';

const InputOTPSlot = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext);
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index];

  return (
    <div
      ref={ref}
      className={cn(
        'relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md',
        isActive && 'z-10 ring-2 ring-ring ring-offset-background',
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className='pointer-events-none absolute inset-0 flex items-center justify-center'>
          <div className='h-4 w-px animate-caret-blink bg-foreground duration-1000' />
        </div>
      )}
    </div>
  );
});
InputOTPSlot.displayName = 'InputOTPSlot';

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'>
>(({ ...props }, ref) => (
  <div ref={ref} role='separator' {...props}>
    <Dot />
  </div>
));
InputOTPSeparator.displayName = 'InputOTPSeparator';

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator };

```

### input.tsx

**Path:** `frontend/src/components/ui/input.tsx`

```tsx
import * as React from 'react';

import { cn } from '@/lib/utils';

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<'input'>>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = 'Input';

export { Input };

```

### label.tsx

**Path:** `frontend/src/components/ui/label.tsx`

```tsx
import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const labelVariants = cva(
  'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70'
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

```

### menubar.tsx

**Path:** `frontend/src/components/ui/menubar.tsx`

```tsx
import * as React from 'react';
import * as MenubarPrimitive from '@radix-ui/react-menubar';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const MenubarMenu = MenubarPrimitive.Menu;

const MenubarGroup = MenubarPrimitive.Group;

const MenubarPortal = MenubarPrimitive.Portal;

const MenubarSub = MenubarPrimitive.Sub;

const MenubarRadioGroup = MenubarPrimitive.RadioGroup;

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      'flex h-10 items-center space-x-1 rounded-md border bg-background p-1',
      className
    )}
    {...props}
  />
));
Menubar.displayName = MenubarPrimitive.Root.displayName;

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      className
    )}
    {...props}
  />
));
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName;

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className='ml-auto h-4 w-4' />
  </MenubarPrimitive.SubTrigger>
));
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName;

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName;

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = 'start', alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          'z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
);
MenubarContent.displayName = MenubarPrimitive.Content.displayName;

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
MenubarItem.displayName = MenubarPrimitive.Item.displayName;

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className='absolute left-2 flex h-3.5 w-3.5 items-center justify-center'>
      <MenubarPrimitive.ItemIndicator>
        <Check className='h-4 w-4' />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
));
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName;

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className='absolute left-2 flex h-3.5 w-3.5 items-center justify-center'>
      <MenubarPrimitive.ItemIndicator>
        <Circle className='h-2 w-2 fill-current' />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
));
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName;

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
MenubarLabel.displayName = MenubarPrimitive.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName;

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        'ml-auto text-xs tracking-widest text-muted-foreground',
        className
      )}
      {...props}
    />
  );
};
MenubarShortcut.displayname = 'MenubarShortcut';

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
};

```

### navigation-menu.tsx

**Path:** `frontend/src/components/ui/navigation-menu.tsx`

```tsx
import * as React from 'react';
import * as NavigationMenuPrimitive from '@radix-ui/react-navigation-menu';
import { cva } from 'class-variance-authority';
import { ChevronDown } from 'lucide-react';

import { cn } from '@/lib/utils';

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      'relative z-10 flex max-w-max flex-1 items-center justify-center',
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      'group flex flex-1 list-none items-center justify-center space-x-1',
      className
    )}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  'group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50'
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), 'group', className)}
    {...props}
  >
    {children}{' '}
    <ChevronDown
      className='relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180'
      aria-hidden='true'
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      'left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ',
      className
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn('absolute left-0 top-full flex justify-center')}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        'origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]',
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      'top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in',
      className
    )}
    {...props}
  >
    <div className='relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md' />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName;

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
};

```

### pagination.tsx

**Path:** `frontend/src/components/ui/pagination.tsx`

```tsx
import * as React from 'react';
import { ChevronLeft, ChevronRight, MoreHorizontal } from 'lucide-react';

import { cn } from '@/lib/utils';
import { ButtonProps, buttonVariants } from '@/components/ui/button';

const Pagination = ({ className, ...props }: React.ComponentProps<'nav'>) => (
  <nav
    role='navigation'
    aria-label='pagination'
    className={cn('mx-auto flex w-full justify-center', className)}
    {...props}
  />
);
Pagination.displayName = 'Pagination';

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<'ul'>
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn('flex flex-row items-center gap-1', className)}
    {...props}
  />
));
PaginationContent.displayName = 'PaginationContent';

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<'li'>
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn('', className)} {...props} />
));
PaginationItem.displayName = 'PaginationItem';

type PaginationLinkProps = {
  isActive?: boolean;
} & Pick<ButtonProps, 'size'> &
  React.ComponentProps<'a'>;

const PaginationLink = ({
  className,
  isActive,
  size = 'icon',
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? 'page' : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? 'outline' : 'ghost',
        size,
      }),
      className
    )}
    {...props}
  />
);
PaginationLink.displayName = 'PaginationLink';

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label='Go to previous page'
    size='default'
    className={cn('gap-1 pl-2.5', className)}
    {...props}
  >
    <ChevronLeft className='h-4 w-4' />
    <span>Previous</span>
  </PaginationLink>
);
PaginationPrevious.displayName = 'PaginationPrevious';

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label='Go to next page'
    size='default'
    className={cn('gap-1 pr-2.5', className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className='h-4 w-4' />
  </PaginationLink>
);
PaginationNext.displayName = 'PaginationNext';

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<'span'>) => (
  <span
    aria-hidden
    className={cn('flex h-9 w-9 items-center justify-center', className)}
    {...props}
  >
    <MoreHorizontal className='h-4 w-4' />
    <span className='sr-only'>More pages</span>
  </span>
);
PaginationEllipsis.displayName = 'PaginationEllipsis';

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
};

```

### popover.tsx

**Path:** `frontend/src/components/ui/popover.tsx`

```tsx
import * as React from 'react';
import * as PopoverPrimitive from '@radix-ui/react-popover';

import { cn } from '@/lib/utils';

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        'z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };

```

### progress.tsx

**Path:** `frontend/src/components/ui/progress.tsx`

```tsx
import * as React from 'react';
import * as ProgressPrimitive from '@radix-ui/react-progress';

import { cn } from '@/lib/utils';

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      'relative h-4 w-full overflow-hidden rounded-full bg-secondary',
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className='h-full w-full flex-1 bg-primary transition-all'
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };

```

### radio-group.tsx

**Path:** `frontend/src/components/ui/radio-group.tsx`

```tsx
import * as React from 'react';
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group';
import { Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn('grid gap-2', className)}
      {...props}
      ref={ref}
    />
  );
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        'aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className='flex items-center justify-center'>
        <Circle className='h-2.5 w-2.5 fill-current text-current' />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };

```

### resizable.tsx

**Path:** `frontend/src/components/ui/resizable.tsx`

```tsx
import { GripVertical } from 'lucide-react';
import * as ResizablePrimitive from 'react-resizable-panels';

import { cn } from '@/lib/utils';

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      'flex h-full w-full data-[panel-group-direction=vertical]:flex-col',
      className
    )}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      'relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90',
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className='z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border'>
        <GripVertical className='h-2.5 w-2.5' />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizablePanelGroup, ResizablePanel, ResizableHandle };

```

### scroll-area.tsx

**Path:** `frontend/src/components/ui/scroll-area.tsx`

```tsx
import * as React from 'react';
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';

import { cn } from '@/lib/utils';

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn('relative overflow-hidden', className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className='h-full w-full rounded-[inherit]'>
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = 'vertical', ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      'flex touch-none select-none transition-colors',
      orientation === 'vertical' &&
        'h-full w-2.5 border-l border-l-transparent p-[1px]',
      orientation === 'horizontal' &&
        'h-2.5 flex-col border-t border-t-transparent p-[1px]',
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className='relative flex-1 rounded-full bg-border' />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };

```

### select.tsx

**Path:** `frontend/src/components/ui/select.tsx`

```tsx
import * as React from 'react';
import * as SelectPrimitive from '@radix-ui/react-select';
import { Check, ChevronDown, ChevronUp } from 'lucide-react';

import { cn } from '@/lib/utils';

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className='h-4 w-4 opacity-50' />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className
    )}
    {...props}
  >
    <ChevronUp className='h-4 w-4' />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className
    )}
    {...props}
  >
    <ChevronDown className='h-4 w-4' />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]'
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className='absolute left-2 flex h-3.5 w-3.5 items-center justify-center'>
      <SelectPrimitive.ItemIndicator>
        <Check className='h-4 w-4' />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};

```

### separator.tsx

**Path:** `frontend/src/components/ui/separator.tsx`

```tsx
import * as React from 'react';
import * as SeparatorPrimitive from '@radix-ui/react-separator';

import { cn } from '@/lib/utils';

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = 'horizontal', decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        'shrink-0 bg-border',
        orientation === 'horizontal' ? 'h-[1px] w-full' : 'h-full w-[1px]',
        className
      )}
      {...props}
    />
  )
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };

```

### sheet.tsx

**Path:** `frontend/src/components/ui/sheet.tsx`

```tsx
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';
import * as React from 'react';

import { cn } from '@/lib/utils';

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-[10020] bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  'fixed z-[10030] gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  }
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {
  hideClose?: boolean;
}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, hideClose = false, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      {!hideClose && (
        <SheetPrimitive.Close className='absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary'>
          <X className='h-4 w-4' />
          <span className='sr-only'>Close</span>
        </SheetPrimitive.Close>
      )}
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
SheetHeader.displayName = 'SheetHeader';

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
SheetFooter.displayName = 'SheetFooter';

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetOverlay,
  SheetPortal,
  SheetTitle,
  SheetTrigger,
};

```

### sidebar.tsx

**Path:** `frontend/src/components/ui/sidebar.tsx`

```tsx
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { VariantProps, cva } from 'class-variance-authority';
import { PanelLeft } from 'lucide-react';

import { useIsMobile } from '@/hooks/use-mobile';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Separator } from '@/components/ui/separator';
import { Sheet, SheetContent } from '@/components/ui/sheet';
import { Skeleton } from '@/components/ui/skeleton';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';

const SIDEBAR_COOKIE_NAME = 'sidebar:state';
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = '16rem';
const SIDEBAR_WIDTH_MOBILE = '18rem';
const SIDEBAR_WIDTH_ICON = '3rem';
const SIDEBAR_KEYBOARD_SHORTCUT = 'b';

type SidebarContext = {
  state: 'expanded' | 'collapsed';
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContext | null>(null);

function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error('useSidebar must be used within a SidebarProvider.');
  }

  return context;
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & {
    defaultOpen?: boolean;
    open?: boolean;
    onOpenChange?: (open: boolean) => void;
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile();
    const [openMobile, setOpenMobile] = React.useState(false);

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen);
    const open = openProp ?? _open;
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === 'function' ? value(open) : value;
        if (setOpenProp) {
          setOpenProp(openState);
        } else {
          _setOpen(openState);
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
      },
      [setOpenProp, open]
    );

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile ? setOpenMobile(open => !open) : setOpen(open => !open);
    }, [isMobile, setOpen, setOpenMobile]);

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault();
          toggleSidebar();
        }
      };

      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }, [toggleSidebar]);

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? 'expanded' : 'collapsed';

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    );

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                '--sidebar-width': SIDEBAR_WIDTH,
                '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              'group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar',
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    );
  }
);
SidebarProvider.displayName = 'SidebarProvider';

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & {
    side?: 'left' | 'right';
    variant?: 'sidebar' | 'floating' | 'inset';
    collapsible?: 'offcanvas' | 'icon' | 'none';
  }
>(
  (
    {
      side = 'left',
      variant = 'sidebar',
      collapsible = 'offcanvas',
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

    if (collapsible === 'none') {
      return (
        <div
          className={cn(
            'flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground',
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      );
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar='sidebar'
            data-mobile='true'
            className='w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden'
            style={
              {
                '--sidebar-width': SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className='flex h-full w-full flex-col'>{children}</div>
          </SheetContent>
        </Sheet>
      );
    }

    return (
      <div
        ref={ref}
        className='group peer hidden md:block text-sidebar-foreground'
        data-state={state}
        data-collapsible={state === 'collapsed' ? collapsible : ''}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            'duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear',
            'group-data-[collapsible=offcanvas]:w-0',
            'group-data-[side=right]:rotate-180',
            variant === 'floating' || variant === 'inset'
              ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]'
              : 'group-data-[collapsible=icon]:w-[--sidebar-width-icon]'
          )}
        />
        <div
          className={cn(
            'duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex',
            side === 'left'
              ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'
              : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',
            // Adjust the padding for floating and inset variants.
            variant === 'floating' || variant === 'inset'
              ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]'
              : 'group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l',
            className
          )}
          {...props}
        >
          <div
            data-sidebar='sidebar'
            className='flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow'
          >
            {children}
          </div>
        </div>
      </div>
    );
  }
);
Sidebar.displayName = 'Sidebar';

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar();

  return (
    <Button
      ref={ref}
      data-sidebar='trigger'
      variant='ghost'
      size='icon'
      className={cn('h-7 w-7', className)}
      onClick={event => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelLeft />
      <span className='sr-only'>Toggle Sidebar</span>
    </Button>
  );
});
SidebarTrigger.displayName = 'SidebarTrigger';

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<'button'>
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar();

  return (
    <button
      ref={ref}
      data-sidebar='rail'
      aria-label='Toggle Sidebar'
      tabIndex={-1}
      onClick={toggleSidebar}
      title='Toggle Sidebar'
      className={cn(
        'absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex',
        '[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize',
        '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',
        'group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar',
        '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',
        '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',
        className
      )}
      {...props}
    />
  );
});
SidebarRail.displayName = 'SidebarRail';

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'main'>
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        'relative flex min-h-svh flex-1 flex-col bg-background',
        'peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow',
        className
      )}
      {...props}
    />
  );
});
SidebarInset.displayName = 'SidebarInset';

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar='input'
      className={cn(
        'h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring',
        className
      )}
      {...props}
    />
  );
});
SidebarInput.displayName = 'SidebarInput';

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'>
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar='header'
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  );
});
SidebarHeader.displayName = 'SidebarHeader';

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'>
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar='footer'
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  );
});
SidebarFooter.displayName = 'SidebarFooter';

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar='separator'
      className={cn('mx-2 w-auto bg-sidebar-border', className)}
      {...props}
    />
  );
});
SidebarSeparator.displayName = 'SidebarSeparator';

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'>
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar='content'
      className={cn(
        'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',
        className
      )}
      {...props}
    />
  );
});
SidebarContent.displayName = 'SidebarContent';

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'>
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar='group'
      className={cn('relative flex w-full min-w-0 flex-col p-2', className)}
      {...props}
    />
  );
});
SidebarGroup.displayName = 'SidebarGroup';

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : 'div';

  return (
    <Comp
      ref={ref}
      data-sidebar='group-label'
      className={cn(
        'duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',
        className
      )}
      {...props}
    />
  );
});
SidebarGroupLabel.displayName = 'SidebarGroupLabel';

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<'button'> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : 'button';

  return (
    <Comp
      ref={ref}
      data-sidebar='group-action'
      className={cn(
        'absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        // Increases the hit area of the button on mobile.
        'after:absolute after:-inset-2 after:md:hidden',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
});
SidebarGroupAction.displayName = 'SidebarGroupAction';

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar='group-content'
    className={cn('w-full text-sm', className)}
    {...props}
  />
));
SidebarGroupContent.displayName = 'SidebarGroupContent';

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<'ul'>
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar='menu'
    className={cn('flex w-full min-w-0 flex-col gap-1', className)}
    {...props}
  />
));
SidebarMenu.displayName = 'SidebarMenu';

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<'li'>
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar='menu-item'
    className={cn('group/menu-item relative', className)}
    {...props}
  />
));
SidebarMenuItem.displayName = 'SidebarMenuItem';

const sidebarMenuButtonVariants = cva(
  'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',
        outline:
          'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',
      },
      size: {
        default: 'h-8 text-sm',
        sm: 'h-7 text-xs',
        lg: 'h-12 text-sm group-data-[collapsible=icon]:!p-0',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<'button'> & {
    asChild?: boolean;
    isActive?: boolean;
    tooltip?: string | React.ComponentProps<typeof TooltipContent>;
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = 'default',
      size = 'default',
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : 'button';
    const { isMobile, state } = useSidebar();

    const button = (
      <Comp
        ref={ref}
        data-sidebar='menu-button'
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    );

    if (!tooltip) {
      return button;
    }

    if (typeof tooltip === 'string') {
      tooltip = {
        children: tooltip,
      };
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side='right'
          align='center'
          hidden={state !== 'collapsed' || isMobile}
          {...tooltip}
        />
      </Tooltip>
    );
  }
);
SidebarMenuButton.displayName = 'SidebarMenuButton';

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<'button'> & {
    asChild?: boolean;
    showOnHover?: boolean;
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : 'button';

  return (
    <Comp
      ref={ref}
      data-sidebar='menu-action'
      className={cn(
        'absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0',
        // Increases the hit area of the button on mobile.
        'after:absolute after:-inset-2 after:md:hidden',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        showOnHover &&
          'group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0',
        className
      )}
      {...props}
    />
  );
});
SidebarMenuAction.displayName = 'SidebarMenuAction';

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar='menu-badge'
    className={cn(
      'absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none',
      'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',
      'peer-data-[size=sm]/menu-button:top-1',
      'peer-data-[size=default]/menu-button:top-1.5',
      'peer-data-[size=lg]/menu-button:top-2.5',
      'group-data-[collapsible=icon]:hidden',
      className
    )}
    {...props}
  />
));
SidebarMenuBadge.displayName = 'SidebarMenuBadge';

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & {
    showIcon?: boolean;
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);

  return (
    <div
      ref={ref}
      data-sidebar='menu-skeleton'
      className={cn('rounded-md h-8 flex gap-2 px-2 items-center', className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className='size-4 rounded-md'
          data-sidebar='menu-skeleton-icon'
        />
      )}
      <Skeleton
        className='h-4 flex-1 max-w-[--skeleton-width]'
        data-sidebar='menu-skeleton-text'
        style={
          {
            '--skeleton-width': width,
          } as React.CSSProperties
        }
      />
    </div>
  );
});
SidebarMenuSkeleton.displayName = 'SidebarMenuSkeleton';

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<'ul'>
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar='menu-sub'
    className={cn(
      'mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5',
      'group-data-[collapsible=icon]:hidden',
      className
    )}
    {...props}
  />
));
SidebarMenuSub.displayName = 'SidebarMenuSub';

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<'li'>
>(({ ...props }, ref) => <li ref={ref} {...props} />);
SidebarMenuSubItem.displayName = 'SidebarMenuSubItem';

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<'a'> & {
    asChild?: boolean;
    size?: 'sm' | 'md';
    isActive?: boolean;
  }
>(({ asChild = false, size = 'md', isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : 'a';

  return (
    <Comp
      ref={ref}
      data-sidebar='menu-sub-button'
      data-size={size}
      data-active={isActive}
      className={cn(
        'flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground',
        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',
        size === 'sm' && 'text-xs',
        size === 'md' && 'text-sm',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
});
SidebarMenuSubButton.displayName = 'SidebarMenuSubButton';

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};

```

### skeleton.tsx

**Path:** `frontend/src/components/ui/skeleton.tsx`

```tsx
import { cn } from '@/lib/utils';

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn('animate-pulse rounded-md bg-muted', className)}
      {...props}
    />
  );
}

export { Skeleton };

```

### slider.tsx

**Path:** `frontend/src/components/ui/slider.tsx`

```tsx
import * as React from 'react';
import * as SliderPrimitive from '@radix-ui/react-slider';

import { cn } from '@/lib/utils';

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      'relative flex w-full touch-none select-none items-center',
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className='relative h-2 w-full grow overflow-hidden rounded-full bg-secondary'>
      <SliderPrimitive.Range className='absolute h-full bg-primary' />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className='block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50' />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };

```

### sonner.tsx

**Path:** `frontend/src/components/ui/sonner.tsx`

```tsx
import { useTheme } from '@/contexts/ThemeContext';
import { Toaster as Sonner, toast } from 'sonner';

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className='toaster group'
      toastOptions={{
        classNames: {
          toast:
            'group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg',
          description: 'group-[.toast]:text-muted-foreground',
          actionButton:
            'group-[.toast]:bg-primary group-[.toast]:text-primary-foreground',
          cancelButton:
            'group-[.toast]:bg-muted group-[.toast]:text-muted-foreground',
        },
      }}
      {...props}
    />
  );
};

export { Toaster, toast };

```

### switch.tsx

**Path:** `frontend/src/components/ui/switch.tsx`

```tsx
import * as React from 'react';
import * as SwitchPrimitives from '@radix-ui/react-switch';

import { cn } from '@/lib/utils';

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      'peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input',
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        'pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0'
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };

```

### table.tsx

**Path:** `frontend/src/components/ui/table.tsx`

```tsx
import * as React from 'react';

import { cn } from '@/lib/utils';

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className='relative w-full overflow-auto'>
    <table
      ref={ref}
      className={cn('w-full caption-bottom text-sm', className)}
      {...props}
    />
  </div>
));
Table.displayName = 'Table';

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn('[&_tr]:border-b', className)} {...props} />
));
TableHeader.displayName = 'TableHeader';

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn('[&_tr:last-child]:border-0', className)}
    {...props}
  />
));
TableBody.displayName = 'TableBody';

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      'border-t bg-muted/50 font-medium [&>tr]:last:border-b-0',
      className
    )}
    {...props}
  />
));
TableFooter.displayName = 'TableFooter';

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      'border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted',
      className
    )}
    {...props}
  />
));
TableRow.displayName = 'TableRow';

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      'h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0',
      className
    )}
    {...props}
  />
));
TableHead.displayName = 'TableHead';

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn('p-4 align-middle [&:has([role=checkbox])]:pr-0', className)}
    {...props}
  />
));
TableCell.displayName = 'TableCell';

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn('mt-4 text-sm text-muted-foreground', className)}
    {...props}
  />
));
TableCaption.displayName = 'TableCaption';

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};

```

### tabs.tsx

**Path:** `frontend/src/components/ui/tabs.tsx`

```tsx
import * as React from 'react';
import * as TabsPrimitive from '@radix-ui/react-tabs';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const Tabs = TabsPrimitive.Root;

const tabsListVariants = cva(
  'inline-flex items-center justify-center',
  {
    variants: {
      variant: {
        default: 'h-10 rounded-md bg-muted p-1 text-muted-foreground',
        terminal: [
          'gap-3 border-b border-border/30 pb-3',
          'bg-transparent rounded-none p-0',
        ],
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

interface TabsListProps
  extends React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>,
    VariantProps<typeof tabsListVariants> {}

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  TabsListProps
>(({ className, variant, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(tabsListVariants({ variant }), className)}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const tabsTriggerVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default: [
          'rounded-sm px-3 py-1.5 text-sm font-medium',
          'data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm',
        ],
        terminal: [
          // Base styles
          'bg-transparent px-4 py-2',
          'font-mono text-xs font-bold uppercase tracking-wider',
          'rounded-[4px]',
          'border border-[hsl(var(--terminal-inactive-border,var(--border)))]',
          'text-muted-foreground',
          // Hover effects
          'hover:border-primary hover:text-primary',
          'hover:shadow-[0_0_10px_hsl(var(--primary)/0.4)]',
          'hover:[text-shadow:0_0_5px_hsl(var(--primary))]',
          // Active state - Dark text on neon green background
          'data-[state=active]:bg-primary data-[state=active]:text-[hsl(210_50%_2%)]',
          'data-[state=active]:border-primary',
          'data-[state=active]:shadow-[0_0_10px_hsl(var(--primary)/0.4)]',
        ],
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

interface TabsTriggerProps
  extends React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>,
    VariantProps<typeof tabsTriggerVariants> {}

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  TabsTriggerProps
>(({ className, variant, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(tabsTriggerVariants({ variant }), className)}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      'mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
      className
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

```

### terminal-panel.tsx

**Path:** `frontend/src/components/ui/terminal-panel.tsx`

```tsx
import * as React from 'react';
import { cn } from '@/lib/utils';

/**
 * TerminalPanel - 터미널 출력 창 스타일의 정보 패널 컴포넌트
 * 
 * Design Philosophy: "터미널 출력 창처럼 보여야 한다"
 * - 왼쪽 강조 라인 (Neon Green)
 * - OUTPUT_LOG 라벨
 * - Monospace 폰트 섹션 제목
 * - > 프롬프트 스타일 리스트
 */

interface TerminalPanelProps extends React.HTMLAttributes<HTMLDivElement> {
  label?: string;
  children: React.ReactNode;
}

const TerminalPanel = React.forwardRef<HTMLDivElement, TerminalPanelProps>(
  ({ className, label = 'OUTPUT_LOG', children, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        // Background
        'bg-[hsl(var(--terminal-panel,var(--card)))]',
        'bg-opacity-95',
        // Border
        'border border-[hsl(var(--terminal-inactive-border,var(--border)))]',
        'border-l-[3px] border-l-primary',
        // Spacing & Shape
        'p-6 rounded-[4px]',
        // Typography
        'text-foreground',
        // Position for pseudo-element
        'relative',
        className
      )}
      {...props}
    >
      {/* OUTPUT_LOG label */}
      <span
        className={cn(
          'absolute -top-2.5 right-3',
          'bg-background px-2',
          'text-muted-foreground/60',
          'font-mono text-[10px] uppercase tracking-wider'
        )}
        aria-hidden
      >
        {label}
      </span>
      {children}
    </div>
  )
);
TerminalPanel.displayName = 'TerminalPanel';

interface TerminalSectionProps extends React.HTMLAttributes<HTMLDivElement> {
  title: string;
  children: React.ReactNode;
}

const TerminalSection = React.forwardRef<HTMLDivElement, TerminalSectionProps>(
  ({ className, title, children, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('mb-6 last:mb-0', className)}
      {...props}
    >
      {/* 주석(//) 스타일 제목 */}
      <h3 className={cn(
        'text-muted-foreground',
        'font-mono text-sm',
        'mb-3',
        'font-normal'
      )}>
        {title.startsWith('//') ? title : `// ${title}`}
      </h3>
      {children}
    </div>
  )
);
TerminalSection.displayName = 'TerminalSection';

interface TerminalListProps extends React.HTMLAttributes<HTMLUListElement> {
  children: React.ReactNode;
}

const TerminalList = React.forwardRef<HTMLUListElement, TerminalListProps>(
  ({ className, children, ...props }, ref) => (
    <ul
      ref={ref}
      className={cn('list-none p-0 m-0 space-y-2', className)}
      {...props}
    >
      {children}
    </ul>
  )
);
TerminalList.displayName = 'TerminalList';

interface TerminalListItemProps extends React.LiHTMLAttributes<HTMLLIElement> {
  highlight?: boolean;
  children: React.ReactNode;
}

const TerminalListItem = React.forwardRef<HTMLLIElement, TerminalListItemProps>(
  ({ className, highlight = false, children, ...props }, ref) => (
    <li
      ref={ref}
      className={cn(
        'flex items-start gap-2.5',
        'text-sm leading-relaxed',
        highlight && [
          'text-foreground',
          '[text-shadow:0_0_2px_rgba(255,255,255,0.5)]',
        ],
        className
      )}
      {...props}
    >
      {/* 프롬프트 아이콘 (>) */}
      <span
        className={cn(
          'text-primary font-bold font-mono',
          'select-none shrink-0'
        )}
        aria-hidden
      >
        {'>'}
      </span>
      <span className="flex-1">{children}</span>
    </li>
  )
);
TerminalListItem.displayName = 'TerminalListItem';

/**
 * TerminalOutput - 명령어 실행 결과 표시용 컴포넌트
 */
interface TerminalOutputProps extends React.HTMLAttributes<HTMLPreElement> {
  children: React.ReactNode;
}

const TerminalOutput = React.forwardRef<HTMLPreElement, TerminalOutputProps>(
  ({ className, children, ...props }, ref) => (
    <pre
      ref={ref}
      className={cn(
        'font-mono text-xs',
        'text-foreground/90',
        'whitespace-pre-wrap',
        'leading-relaxed',
        'p-4',
        'bg-[hsl(var(--terminal-code-bg))]',
        'border border-border/30',
        'rounded-[4px]',
        'overflow-auto',
        className
      )}
      {...props}
    >
      {children}
    </pre>
  )
);
TerminalOutput.displayName = 'TerminalOutput';

/**
 * TerminalPrompt - 입력 프롬프트 스타일 컴포넌트
 */
interface TerminalPromptProps extends React.HTMLAttributes<HTMLDivElement> {
  path?: string;
  children?: React.ReactNode;
}

const TerminalPrompt = React.forwardRef<HTMLDivElement, TerminalPromptProps>(
  ({ className, path = '~', children, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        'flex items-center gap-2',
        'font-mono text-sm',
        className
      )}
      {...props}
    >
      <span className="text-primary/60">{path}</span>
      <span className="text-primary font-bold">$</span>
      {children && <span className="text-foreground">{children}</span>}
    </div>
  )
);
TerminalPrompt.displayName = 'TerminalPrompt';

export {
  TerminalPanel,
  TerminalSection,
  TerminalList,
  TerminalListItem,
  TerminalOutput,
  TerminalPrompt,
};

```

### textarea.tsx

**Path:** `frontend/src/components/ui/textarea.tsx`

```tsx
import * as React from 'react';

import { cn } from '@/lib/utils';

export type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>;

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = 'Textarea';

export { Textarea };

```

### toast.tsx

**Path:** `frontend/src/components/ui/toast.tsx`

```tsx
import * as React from 'react';
import * as ToastPrimitives from '@radix-ui/react-toast';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive',
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600',
      className
    )}
    toast-close=''
    {...props}
  >
    <X className='h-4 w-4' />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold', className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

```

### toaster.tsx

**Path:** `frontend/src/components/ui/toaster.tsx`

```tsx
import { useToast } from '@/hooks/use-toast';
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast';

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className='grid gap-1'>
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}

```

### toggle-group.tsx

**Path:** `frontend/src/components/ui/toggle-group.tsx`

```tsx
import * as React from 'react';
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group';
import { type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';
import { toggleVariants } from '@/components/ui/toggle';

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: 'default',
  variant: 'default',
});

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn('flex items-center justify-center gap-1', className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
));

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName;

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
});

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName;

export { ToggleGroup, ToggleGroupItem };

```

### toggle.tsx

**Path:** `frontend/src/components/ui/toggle.tsx`

```tsx
import * as React from 'react';
import * as TogglePrimitive from '@radix-ui/react-toggle';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const toggleVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        outline:
          'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
      },
      size: {
        default: 'h-10 px-3',
        sm: 'h-9 px-2.5',
        lg: 'h-11 px-5',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };

```

### tooltip.tsx

**Path:** `frontend/src/components/ui/tooltip.tsx`

```tsx
import * as React from 'react';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';

import { cn } from '@/lib/utils';

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      'z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

```

### use-toast.ts

**Path:** `frontend/src/components/ui/use-toast.ts`

```typescript
import { useToast, toast } from '@/hooks/use-toast';

export { useToast, toast };

```

---

## frontend/src/config

### site.ts

**Path:** `frontend/src/config/site.ts`

```typescript
export const site = {
  author: 'Nodove',
  email: 'nodove@nodove.com',
  social: {
    github: 'https://github.com/choisimo',
    twitter: 'https://twitter.com',
    linkedin: 'https://linkedin.com',
  },
  // Optional: editor's picks list (year/slug)
  featured: [] as Array<{ year: string; slug: string }>,
};

export type SiteConfig = typeof site;

```

---

## frontend/src/contexts

### LanguageContext.tsx

**Path:** `frontend/src/contexts/LanguageContext.tsx`

```tsx
import { createContext, useContext, useEffect, useMemo, useState } from 'react';
import type { ReactNode } from 'react';
import type { SupportedLanguage } from '@/types/blog';

interface LanguageContextValue {
  language: SupportedLanguage;
  setLanguage: (language: SupportedLanguage) => void;
  toggleLanguage: () => void;
}

const LanguageContext = createContext<LanguageContextValue | undefined>(
  undefined
);

const STORAGE_KEY = 'site.language';
const DEFAULT_LANGUAGE: SupportedLanguage = 'ko';

export function LanguageProvider({ children }: { children: ReactNode }) {
  const [language, setLanguageState] = useState<SupportedLanguage>(
    DEFAULT_LANGUAGE
  );

  useEffect(() => {
    if (typeof window === 'undefined') return;
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored === 'ko' || stored === 'en') {
        setLanguageState(stored);
        return;
      }
      const browserLanguage = navigator.language?.toLowerCase() ?? '';
      if (browserLanguage.startsWith('en')) {
        setLanguageState('en');
      }
    } catch {
      // ignore storage errors
    }
  }, []);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    const handleStorage = (event: StorageEvent) => {
      if (event.key !== STORAGE_KEY) return;
      const value = event.newValue === 'en' ? 'en' : 'ko';
      setLanguageState(prev => (prev === value ? prev : value));
    };
    window.addEventListener('storage', handleStorage);
    return () => window.removeEventListener('storage', handleStorage);
  }, []);

  const persistLanguage = (lang: SupportedLanguage) => {
    if (typeof window === 'undefined') return;
    try {
      localStorage.setItem(STORAGE_KEY, lang);
    } catch {
      // ignore storage errors
    }
  };

  const setLanguage = (lang: SupportedLanguage) => {
    setLanguageState(prev => (prev === lang ? prev : lang));
    persistLanguage(lang);
  };

  const toggleLanguage = () => {
    const next = language === 'ko' ? 'en' : 'ko';
    setLanguageState(next);
    persistLanguage(next);
  };

  const value = useMemo(
    () => ({ language, setLanguage, toggleLanguage }),
    [language]
  );

  return (
    <LanguageContext.Provider value={value}>{children}</LanguageContext.Provider>
  );
}

export function useLanguage(): LanguageContextValue {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
}

```

### ThemeContext.tsx

**Path:** `frontend/src/contexts/ThemeContext.tsx`

```tsx
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useRef,
  useState,
} from 'react';
import { toast } from '@/hooks/use-toast';

type Theme = 'light' | 'dark' | 'system' | 'terminal';

interface ThemeContextType {
  theme: Theme;
  setTheme: (theme: Theme) => void;
  isTerminal: boolean;
}

const THEME_LABELS: Record<Theme, string> = {
  light: 'Light',
  dark: 'Dark',
  system: 'System',
  terminal: 'Terminal',
};

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setThemeState] = useState<Theme>(() => {
    const savedTheme = localStorage.getItem('theme') as Theme;
    return savedTheme || 'terminal';
  });
  const isInitialMount = useRef(true);

  const isTerminal = theme === 'terminal';

  const setTheme = useCallback((newTheme: Theme) => {
    setThemeState(newTheme);

    // Show toast notification on theme change (not on initial mount)
    if (!isInitialMount.current) {
      const label = THEME_LABELS[newTheme];
      if (newTheme === 'terminal') {
        toast({
          title: `>_ ${label} mode activated`,
          description: 'Welcome to the matrix',
        });
      } else {
        toast({
          title: `Theme: ${label}`,
          description: `Switched to ${label.toLowerCase()} mode`,
        });
      }
    }
  }, []);

  useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove('light', 'dark', 'terminal');

    if (theme === 'system') {
      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)')
        .matches
        ? 'dark'
        : 'light';
      root.classList.add(systemTheme);
    } else if (theme === 'terminal') {
      // Terminal uses dark as base with additional terminal class
      root.classList.add('dark', 'terminal');
    } else {
      root.classList.add(theme);
    }

    localStorage.setItem('theme', theme);

    // Mark initial mount as complete after first theme application
    if (isInitialMount.current) {
      isInitialMount.current = false;
    }
  }, [theme]);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    const handleChange = () => {
      if (theme === 'system') {
        const root = window.document.documentElement;
        root.classList.remove('light', 'dark', 'terminal');
        root.classList.add(mediaQuery.matches ? 'dark' : 'light');
      }
    };

    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, [theme]);

  return (
    <ThemeContext.Provider value={{ theme, setTheme, isTerminal }}>
      {children}
    </ThemeContext.Provider>
  );
}

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

```

---

## frontend/src/data

### posts.ts

**Path:** `frontend/src/data/posts.ts`

```typescript
import { PostService } from '../services/postService';
import type { BlogPost, BlogCategory, BlogTag, PostsPage } from '../types/blog';

// Main function to get all posts from markdown files
export const getPosts = async (): Promise<BlogPost[]> => {
  try {
    return await PostService.getAllPosts();
  } catch (error) {
    console.error('Error loading posts:', error);
    return [];
  }
};

// Get a single post by year and slug
export const getPostBySlug = async (
  year: string,
  slug: string
): Promise<BlogPost | null> => {
  try {
    return await PostService.getPostBySlug(year, slug);
  } catch (error) {
    console.error(`Error loading post ${year}/${slug}:`, error);
    return null;
  }
};

// Paginated posts (metadata-only) with server-side filters/sort
export type PostsQuery = {
  page?: number;
  pageSize?: number;
  category?: string;
  tags?: string[];
  search?: string;
  sort?: 'date' | 'title' | 'readTime';
};

export const getPostsPage = async (
  q: PostsQuery
): Promise<PostsPage<BlogPost>> => {
  try {
    return await PostService.getPostsPage(q);
  } catch (error) {
    console.error('Error loading paginated posts:', error);
    return {
      items: [],
      page: q.page ?? 1,
      pageSize: q.pageSize ?? 12,
      total: 0,
      totalPages: 1,
      hasMore: false,
    };
  }
};

// Prefetch a single post's markdown content (fire-and-forget)
export const prefetchPost = async (
  year: string,
  slug: string
): Promise<void> => {
  try {
    await PostService.prefetchPost(year, slug);
  } catch {
    // ignore prefetch errors
  }
};

// Legacy function for backward compatibility
export const getPostBySlugLegacy = async (
  slug: string
): Promise<BlogPost | null> => {
  try {
    const posts = await PostService.getAllPosts();
    return (
      posts.find(
        post => post.slug === slug || `${post.year}/${post.slug}` === slug
      ) || null
    );
  } catch (error) {
    console.error(`Error loading post ${slug}:`, error);
    return null;
  }
};

// Get posts by category
export const getPostsByCategory = async (
  category: string
): Promise<BlogPost[]> => {
  try {
    return await PostService.getPostsByCategory(category);
  } catch (error) {
    console.error(`Error loading posts for category ${category}:`, error);
    return [];
  }
};

// Get posts by tag
export const getPostsByTag = async (tag: string): Promise<BlogPost[]> => {
  try {
    return await PostService.getPostsByTag(tag);
  } catch (error) {
    console.error(`Error loading posts for tag ${tag}:`, error);
    return [];
  }
};

// Search posts
export const searchPosts = async (query: string): Promise<BlogPost[]> => {
  try {
    return await PostService.searchPosts(query);
  } catch (error) {
    console.error(`Error searching posts with query "${query}":`, error);
    return [];
  }
};

// Get categories with post counts
export const getCategories = async (): Promise<BlogCategory[]> => {
  try {
    const posts = await PostService.getAllPosts();
    const categoryMap = new Map<string, number>();

    posts.forEach(post => {
      const count = categoryMap.get(post.category) || 0;
      categoryMap.set(post.category, count + 1);
    });

    return Array.from(categoryMap.entries()).map(([name, count]) => ({
      name,
      count,
      slug: name.toLowerCase().replace(/\s+/g, '-'),
    }));
  } catch (error) {
    console.error('Error loading categories:', error);
    return [];
  }
};

// Get tags with post counts
export const getTags = async (): Promise<BlogTag[]> => {
  try {
    const posts = await PostService.getAllPosts();
    const tagMap = new Map<string, number>();

    posts.forEach(post => {
      post.tags.forEach(tag => {
        const count = tagMap.get(tag) || 0;
        tagMap.set(tag, count + 1);
      });
    });

    return Array.from(tagMap.entries()).map(([name, count]) => ({
      name,
      count,
      slug: name.toLowerCase().replace(/\s+/g, '-'),
    }));
  } catch (error) {
    console.error('Error loading tags:', error);
    return [];
  }
};

// Get all unique categories
export const getAllCategories = async (): Promise<string[]> => {
  try {
    const posts = await PostService.getAllPosts();
    const categories = new Set(posts.map(post => post.category));
    return Array.from(categories);
  } catch (error) {
    console.error('Error loading categories:', error);
    return [];
  }
};

// Get all unique tags
export const getAllTags = async (): Promise<string[]> => {
  try {
    const posts = await PostService.getAllPosts();
    const tags = new Set(posts.flatMap(post => post.tags));
    return Array.from(tags);
  } catch (error) {
    console.error('Error loading tags:', error);
    return [];
  }
};

// Clear cache (useful for development)
export const clearPostsCache = (): void => {
  PostService.clearCache();
};

// Legacy support - keep existing variable export for backward compatibility
let posts: BlogPost[] = [];
let postsLoaded = false;

const initializePosts = async () => {
  if (!postsLoaded) {
    posts = await getPosts();
    postsLoaded = true;
  }
};

// Start loading posts
initializePosts();

export { posts };

```

---

## frontend/src/hooks

### use-mobile.tsx

**Path:** `frontend/src/hooks/use-mobile.tsx`

```tsx
import * as React from 'react';

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener('change', onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener('change', onChange);
  }, []);

  return !!isMobile;
}

```

### use-toast.ts

**Path:** `frontend/src/hooks/use-toast.ts`

```typescript
import * as React from 'react';

import type { ToastActionElement, ToastProps } from '@/components/ui/toast';

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType['ADD_TOAST'];
      toast: ToasterToast;
    }
  | {
      type: ActionType['UPDATE_TOAST'];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType['DISMISS_TOAST'];
      toastId?: ToasterToast['id'];
    }
  | {
      type: ActionType['REMOVE_TOAST'];
      toastId?: ToasterToast['id'];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: 'REMOVE_TOAST',
      toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map(t =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case 'DISMISS_TOAST': {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach(toast => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map(t =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter(t => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach(listener => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, 'id'>;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id });

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: open => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  };
}

export { useToast, toast };

```

### useDebounce.ts

**Path:** `frontend/src/hooks/useDebounce.ts`

```typescript
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

```

### useLanguage.ts

**Path:** `frontend/src/hooks/useLanguage.ts`

```typescript
export { useLanguage as default, useLanguage } from '@/contexts/LanguageContext';

```

---

## frontend/src/hooks/seo

### useSEO.ts

**Path:** `frontend/src/hooks/seo/useSEO.ts`

```typescript
import { useEffect } from 'react';
import { SEOData } from '../../utils/seo/seo';

export const useSEO = (seoData: SEOData) => {
  useEffect(() => {
    // Update document title
    document.title = seoData.title;

    // Helper function to update or create meta tags
    const updateMetaTag = (
      name: string,
      content: string,
      property?: boolean
    ) => {
      const attribute = property ? 'property' : 'name';
      let element = document.querySelector(
        `meta[${attribute}="${name}"]`
      ) as HTMLMetaElement;

      if (element) {
        element.content = content;
      } else {
        element = document.createElement('meta');
        element.setAttribute(attribute, name);
        element.content = content;
        document.head.appendChild(element);
      }
    };

    // Update meta description
    updateMetaTag('description', seoData.description);

    // Update keywords
    if (seoData.keywords.length > 0) {
      updateMetaTag('keywords', seoData.keywords.join(', '));
    }

    // Update canonical URL
    if (seoData.canonicalUrl) {
      let canonical = document.querySelector(
        'link[rel="canonical"]'
      ) as HTMLLinkElement;
      if (canonical) {
        canonical.href = seoData.canonicalUrl;
      } else {
        canonical = document.createElement('link');
        canonical.rel = 'canonical';
        canonical.href = seoData.canonicalUrl;
        document.head.appendChild(canonical);
      }
    }

    // Update Open Graph tags
    updateMetaTag('og:title', seoData.title, true);
    updateMetaTag('og:description', seoData.description, true);

    if (seoData.ogImage) {
      updateMetaTag('og:image', seoData.ogImage, true);
    }

    if (seoData.ogType) {
      updateMetaTag('og:type', seoData.ogType, true);
    }

    if (seoData.canonicalUrl) {
      updateMetaTag('og:url', seoData.canonicalUrl, true);
    }

    // Update Twitter Card tags
    updateMetaTag('twitter:card', 'summary_large_image');
    updateMetaTag('twitter:title', seoData.title);
    updateMetaTag('twitter:description', seoData.description);

    if (seoData.ogImage) {
      updateMetaTag('twitter:image', seoData.ogImage);
    }

    // Update article-specific tags
    if (seoData.publishedTime) {
      updateMetaTag('article:published_time', seoData.publishedTime, true);
    }

    if (seoData.modifiedTime) {
      updateMetaTag('article:modified_time', seoData.modifiedTime, true);
    }

    if (seoData.author) {
      updateMetaTag('article:author', seoData.author, true);
    }

    if (seoData.section) {
      updateMetaTag('article:section', seoData.section, true);
    }

    if (seoData.tags) {
      seoData.tags.forEach(tag => {
        const tagElement = document.createElement('meta');
        tagElement.setAttribute('property', 'article:tag');
        tagElement.content = tag;
        document.head.appendChild(tagElement);
      });
    }
  }, [seoData]);
};

```

---

## frontend/src/lib

### utils.ts

**Path:** `frontend/src/lib/utils.ts`

```typescript
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

```

---

## frontend/src/pages

### About.tsx

**Path:** `frontend/src/pages/About.tsx`

```tsx
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Github, Linkedin, Mail, Globe } from 'lucide-react';

const About = () => {
  const skills = [
    'React',
    'TypeScript',
    'Node.js',
    'Python',
    'Docker',
    'Kubernetes',
    'AWS',
    'Machine Learning',
    'DevOps',
    'Spring Boot',
  ];

  return (
    <div className='container mx-auto px-4 py-12 max-w-4xl'>
      <div className='space-y-8'>
        <div className='text-center space-y-4'>
          <h1 className='text-4xl font-bold tracking-tight'>About Me</h1>
          <p className='text-xl text-muted-foreground'>
            Software Developer | Tech Enthusiast | Problem Solver
          </p>
        </div>

        <Card>
          <CardHeader>
            <CardTitle>Hi, I'm Nodove 👋</CardTitle>
            <CardDescription>
              Passionate about building innovative solutions
            </CardDescription>
          </CardHeader>
          <CardContent className='space-y-6'>
            <div className='prose prose-neutral dark:prose-invert max-w-none'>
              <p>
                I'm a software developer with a passion for creating efficient,
                scalable, and user-friendly applications. With expertise in both
                frontend and backend technologies, I enjoy tackling complex
                problems and turning ideas into reality.
              </p>
              <p>
                Through this blog, I share my experiences, insights, and
                learnings from various projects and technologies. Whether it's
                about the latest AI models, web development frameworks, or
                DevOps practices, I aim to provide valuable content that helps
                fellow developers in their journey.
              </p>
            </div>

            <div>
              <h3 className='text-lg font-semibold mb-3'>
                Skills & Technologies
              </h3>
              <div className='flex flex-wrap gap-2'>
                {skills.map(skill => (
                  <Badge key={skill} variant='secondary'>
                    {skill}
                  </Badge>
                ))}
              </div>
            </div>

            <div>
              <h3 className='text-lg font-semibold mb-3'>Connect with me</h3>
              <div className='flex flex-wrap gap-3'>
                <Button variant='outline' size='sm' asChild>
                  <a
                    href='https://github.com'
                    target='_blank'
                    rel='noopener noreferrer'
                  >
                    <Github className='mr-2 h-4 w-4' />
                    GitHub
                  </a>
                </Button>
                <Button variant='outline' size='sm' asChild>
                  <a
                    href='https://linkedin.com'
                    target='_blank'
                    rel='noopener noreferrer'
                  >
                    <Linkedin className='mr-2 h-4 w-4' />
                    LinkedIn
                  </a>
                </Button>
                <Button variant='outline' size='sm' asChild>
                  <a href='mailto:contact@nodove.com'>
                    <Mail className='mr-2 h-4 w-4' />
                    Email
                  </a>
                </Button>
                <Button variant='outline' size='sm' asChild>
                  <a
                    href='https://nodove.com'
                    target='_blank'
                    rel='noopener noreferrer'
                  >
                    <Globe className='mr-2 h-4 w-4' />
                    Website
                  </a>
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>My Mission</CardTitle>
          </CardHeader>
          <CardContent>
            <p className='text-muted-foreground'>
              To contribute to the tech community by sharing knowledge, creating
              useful tools, and helping others grow in their software
              development journey. I believe in continuous learning and the
              power of collaboration to drive innovation forward.
            </p>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default About;

```

### AdminConfig.tsx

**Path:** `frontend/src/pages/AdminConfig.tsx`

```tsx
import { useState, useEffect } from 'react';
import { ConfigManager } from '@/components/features/admin/ConfigManager';
import { WorkersManager } from '@/components/features/admin/WorkersManager';
import { AIManager } from '@/components/features/admin/ai';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Lock, Settings, Cloud, Bot } from 'lucide-react';

export default function AdminConfig() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [token, setToken] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const storedToken = localStorage.getItem('adminToken');
    if (storedToken) {
      verifyToken(storedToken);
    } else {
      setLoading(false);
    }
  }, []);

  const verifyToken = async (tokenToVerify: string) => {
    try {
      const res = await fetch(
        `${import.meta.env.VITE_API_BASE_URL || ''}/api/v1/admin/config/categories`,
        {
          headers: { Authorization: `Bearer ${tokenToVerify}` },
        }
      );
      if (res.ok) {
        localStorage.setItem('adminToken', tokenToVerify);
        setIsAuthenticated(true);
      } else {
        localStorage.removeItem('adminToken');
        setError('Invalid or expired token');
      }
    } catch {
      setError('Failed to verify token');
    } finally {
      setLoading(false);
    }
  };

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setLoading(true);
    await verifyToken(token);
  };

  const handleLogout = () => {
    localStorage.removeItem('adminToken');
    setIsAuthenticated(false);
    setToken('');
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[50vh]">
        <div className="animate-spin h-8 w-8 border-4 border-primary border-t-transparent rounded-full" />
      </div>
    );
  }

  if (!isAuthenticated) {
    return (
      <div className="flex items-center justify-center min-h-[50vh] p-4">
        <Card className="w-full max-w-md">
          <CardHeader className="text-center">
            <div className="mx-auto mb-4 h-12 w-12 rounded-full bg-primary/10 flex items-center justify-center">
              <Lock className="h-6 w-6 text-primary" />
            </div>
            <CardTitle>Admin Authentication</CardTitle>
            <CardDescription>Enter your admin bearer token to access configuration</CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleLogin} className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="token">Bearer Token</Label>
                <Input
                  id="token"
                  type="password"
                  value={token}
                  onChange={(e) => setToken(e.target.value)}
                  placeholder="Enter your admin token"
                  autoFocus
                />
              </div>
              {error && <p className="text-sm text-destructive">{error}</p>}
              <Button type="submit" className="w-full" disabled={!token}>
                Authenticate
              </Button>
            </form>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-6">
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-bold">Admin Dashboard</h1>
          <p className="text-muted-foreground">환경변수, Workers, AI 모델 관리</p>
        </div>
        <Button variant="outline" onClick={handleLogout}>
          Logout
        </Button>
      </div>

      <Tabs defaultValue="config" className="space-y-6">
        <TabsList className="grid w-full max-w-lg grid-cols-3">
          <TabsTrigger value="config" className="flex items-center gap-2">
            <Settings className="h-4 w-4" />
            환경변수
          </TabsTrigger>
          <TabsTrigger value="workers" className="flex items-center gap-2">
            <Cloud className="h-4 w-4" />
            Workers
          </TabsTrigger>
          <TabsTrigger value="ai" className="flex items-center gap-2">
            <Bot className="h-4 w-4" />
            AI Models
          </TabsTrigger>
        </TabsList>

        <TabsContent value="config">
          <ConfigManager />
        </TabsContent>

        <TabsContent value="workers">
          <WorkersManager />
        </TabsContent>

        <TabsContent value="ai">
          <AIManager />
        </TabsContent>
      </Tabs>
    </div>
  );
}

```

### Blog.tsx

**Path:** `frontend/src/pages/Blog.tsx`

```tsx
import { useState, useEffect, useCallback, useMemo } from 'react';
import { Link, useLocation, useSearchParams } from 'react-router-dom';
import { BlogCard, BlogCardSkeleton } from '@/components';
import { Pagination } from '@/components';
import { getPostsPage, getAllCategories, getAllTags } from '@/data/posts';
import { BlogPost, PostsPage } from '@/types/blog';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Search, X, ChevronDown, ChevronUp } from 'lucide-react';
import { useDebounce } from '@/hooks/useDebounce';
import { formatDate } from '@/utils/blog';

const POSTS_PER_PAGE = 12;
const TAGS_PER_PAGE = 20;

const Blog = () => {
  const location = useLocation();
  const [searchParams, setSearchParams] = useSearchParams();
  const categoryParam = searchParams.get('category');
  const pageParam = searchParams.get('page');

  const initialCategory = useMemo(
    () => categoryParam ?? 'all',
    [categoryParam]
  );
  const initialPage = useMemo(() => {
    const parsed = pageParam ? parseInt(pageParam, 10) : NaN;
    return !Number.isNaN(parsed) && parsed > 0 ? parsed : 1;
  }, [pageParam]);

  const [pageData, setPageData] = useState<PostsPage<BlogPost>>({
    items: [],
    page: 1,
    pageSize: POSTS_PER_PAGE,
    total: 0,
    totalPages: 1,
    hasMore: false,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState(initialCategory);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [sortBy, setSortBy] = useState('date');
  const [currentPage, setCurrentPage] = useState(initialPage);
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [categories, setCategories] = useState<string[]>([]);
  const [allTags, setAllTags] = useState<string[]>([]);
  const [siteTotalPosts, setSiteTotalPosts] = useState(0);
  const [showAllTags, setShowAllTags] = useState(false);
  const [tagSearchTerm, setTagSearchTerm] = useState('');
  const [tagPage, setTagPage] = useState(1);

  // Debounce search term to avoid excessive filtering
  const debouncedSearchTerm = useDebounce(searchTerm, 300);
  const debouncedTagSearch = useDebounce(tagSearchTerm, 200);

  // Filter and paginate tags
  const filteredTags = useMemo(() => {
    if (!debouncedTagSearch) return allTags;
    const lower = debouncedTagSearch.toLowerCase();
    return allTags.filter(tag => tag.toLowerCase().includes(lower));
  }, [allTags, debouncedTagSearch]);

  const totalTagPages = Math.ceil(filteredTags.length / TAGS_PER_PAGE);
  const displayedTags = useMemo(() => {
    const start = (tagPage - 1) * TAGS_PER_PAGE;
    return filteredTags.slice(start, start + TAGS_PER_PAGE);
  }, [filteredTags, tagPage]);

  // Reset tag page when search changes
  useEffect(() => {
    setTagPage(1);
  }, [debouncedTagSearch]);

  const syncStateFromParams = useCallback(
    (nextCategory: string, nextPage: number) => {
      setSelectedCategory(nextCategory);
      setCurrentPage(nextPage);
    },
    []
  );

  // Sync URL -> state whenever params change
  useEffect(() => {
    const paramsCategory = searchParams.get('category') || 'all';
    const paramsPageRaw = searchParams.get('page');
    const paramsPage = paramsPageRaw ? Math.max(1, parseInt(paramsPageRaw, 10)) : 1;

    if (paramsCategory !== selectedCategory || paramsPage !== currentPage) {
      syncStateFromParams(paramsCategory, paramsPage);
    }
  }, [searchParams, selectedCategory, currentPage, syncStateFromParams]);

  // Load a page of posts (metadata-only) whenever filters/sort/page change
  useEffect(() => {
    let cancelled = false;
    const loadPage = async () => {
      try {
        setLoading(true);
        setError(null);
        const res = await getPostsPage({
          page: currentPage,
          pageSize: POSTS_PER_PAGE,
          category: selectedCategory,
          tags: selectedTags,
          search: debouncedSearchTerm,
          sort: sortBy as 'date' | 'title' | 'readTime',
        });
        if (!cancelled) setPageData(res);
      } catch (error) {
        console.error('Failed to load posts page:', error);
        if (!cancelled)
          setError('Failed to load blog posts. Please try again later.');
      } finally {
        if (!cancelled) setLoading(false);
      }
    };
    loadPage();
    return () => {
      cancelled = true;
    };
  }, [
    debouncedSearchTerm,
    selectedCategory,
    selectedTags,
    sortBy,
    currentPage,
  ]);

  // Load global metadata (categories, tags, total posts)
  useEffect(() => {
    let cancelled = false;
    const loadMeta = async () => {
      try {
        const [cats, tags, totalPage] = await Promise.all([
          getAllCategories(),
          getAllTags(),
          getPostsPage({ page: 1, pageSize: 1 }),
        ]);
        if (cancelled) return;
        setCategories(cats.sort());
        setAllTags(tags.sort());
        setSiteTotalPosts(totalPage.total);
      } catch {
        // ignore meta errors
      }
    };
    loadMeta();
    return () => {
      cancelled = true;
    };
  }, []);

  // Pagination info from server
  const totalPages = pageData.totalPages;

  const handleTagToggle = useCallback((tag: string) => {
    setSelectedTags(prev =>
      prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]
    );
  }, []);

  const handleClearTagFilters = useCallback(() => {
    setSelectedTags([]);
  }, []);

  const clearFilters = useCallback(() => {
    setSearchTerm('');
    setSelectedCategory('all');
    setSelectedTags([]);
    setSortBy('date');
    setCurrentPage(1);
    setSearchParams({});
  }, [setSearchParams]);

  const handleCategoryChange = useCallback(
    (category: string) => {
      setSelectedCategory(category);
      setCurrentPage(1);
      setSearchParams(prev => {
        const params = new URLSearchParams(prev);
        if (!category || category === 'all') {
          params.delete('category');
        } else {
          params.set('category', category);
        }
        params.delete('page');
        return params;
      });
    },
    [setSearchParams]
  );

  const handlePageChange = useCallback(
    (page: number) => {
      setCurrentPage(page);
      setSearchParams(prev => {
        const params = new URLSearchParams(prev);
        if (page <= 1) {
          params.delete('page');
        } else {
          params.set('page', page.toString());
        }
        return params;
      });
      // Scroll to top when page changes
      window.scrollTo({ top: 0, behavior: 'smooth' });
    },
    [setSearchParams]
  );

  const featuredPost = pageData.items[0];
  const spotlightPosts = pageData.items.slice(1, 3);
  const listPosts = pageData.items.slice(3);

  return (
    <div className='min-h-screen bg-gradient-to-b from-[#f7f7fb] via-[#f9fafc] to-background dark:from-[#050509] dark:via-[#0d1016] dark:to-[#0d1016]'>
      <div className='mx-auto w-full max-w-5xl px-4 pb-28 pt-8 sm:pt-12'>
        <header className='mb-8 space-y-4'>
          <div className='flex items-center justify-between'>
            <div>
              <p className='text-sm uppercase tracking-[0.2em] text-muted-foreground'>
                Discover
              </p>
              <h1 className='text-3xl font-semibold tracking-tight text-foreground dark:text-white'>Blog Posts</h1>
            </div>
          </div>
          <div className='relative'>
            <Search className='absolute left-4 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground' />
            <Input
              type='text'
              placeholder='Search posts, tags, or content...'
              aria-label='Search posts'
              value={searchTerm}
              onChange={e => setSearchTerm(e.target.value)}
              className='h-12 rounded-2xl border border-transparent bg-white pl-12 text-base shadow-sm focus-visible:ring-2 focus-visible:ring-primary dark:border-white/10 dark:bg-[#191f29] dark:text-white dark:placeholder:text-white/60'
            />
          </div>
        </header>

        <section className='mb-8 space-y-3'>
          <div className='flex flex-wrap items-center gap-2'>
            {['All', ...categories.slice(0, 5)].map(category => {
              const isActive =
                (category === 'All' && selectedCategory === 'all') ||
                category === selectedCategory;
              return (
                <button
                  key={category}
                  type='button'
                  onClick={() =>
                    category === 'All'
                      ? setSelectedCategory('all')
                      : setSelectedCategory(category)
                  }
                  className={[
                    'rounded-full px-4 py-1 text-sm transition-colors',
                    isActive
                      ? 'bg-primary text-primary-foreground shadow-sm'
                      : 'bg-white text-muted-foreground shadow-sm dark:border dark:border-white/10 dark:bg-[#191f29] dark:text-white/80',
                  ].join(' ')}
                >
                  {category}
                </button>
              );
            })}
            {allTags.length > 0 && (
              <button
                type='button'
                className='flex items-center gap-1 text-sm text-muted-foreground hover:text-foreground transition-colors'
                onClick={() => {
                  setShowAllTags(v => !v);
                  if (!showAllTags) {
                    setTagPage(1);
                    setTagSearchTerm('');
                  }
                }}
                aria-expanded={showAllTags}
              >
                {showAllTags ? (
                  <>
                    <ChevronUp className='h-4 w-4' />
                    Hide tags
                  </>
                ) : (
                  <>
                    <ChevronDown className='h-4 w-4' />
                    More tags ({allTags.length})
                  </>
                )}
              </button>
            )}
          </div>

          {/* Selected tags display */}
          {selectedTags.length > 0 && (
            <div className='flex flex-wrap items-center gap-2'>
              <span className='text-xs text-muted-foreground'>Filtered by:</span>
              {selectedTags.map(tag => (
                <Badge
                  key={tag}
                  variant='default'
                  className='cursor-pointer rounded-full px-3 py-1 text-xs gap-1'
                  onClick={() => handleTagToggle(tag)}
                >
                  #{tag}
                  <X className='h-3 w-3' />
                </Badge>
              ))}
              <button
                type='button'
                className='text-xs text-muted-foreground underline hover:text-foreground'
                onClick={handleClearTagFilters}
              >
                Clear all
              </button>
            </div>
          )}

          {/* Tags panel with search and pagination */}
          {showAllTags && (
            <div className='rounded-2xl border border-border/40 bg-white p-4 shadow-soft dark:border-white/5 dark:bg-[#191f29] space-y-3'>
              {/* Tag search */}
              <div className='relative'>
                <Search className='absolute left-3 top-1/2 -translate-y-1/2 h-3.5 w-3.5 text-muted-foreground' />
                <Input
                  type='text'
                  placeholder='Search tags...'
                  value={tagSearchTerm}
                  onChange={e => setTagSearchTerm(e.target.value)}
                  className='h-9 pl-9 text-sm rounded-lg'
                />
                {tagSearchTerm && (
                  <button
                    type='button'
                    className='absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground'
                    onClick={() => setTagSearchTerm('')}
                  >
                    <X className='h-3.5 w-3.5' />
                  </button>
                )}
              </div>

              {/* Tags grid */}
              {displayedTags.length > 0 ? (
                <div className='flex flex-wrap gap-2'>
                  {displayedTags.map(tag => (
                    <Badge
                      key={tag}
                      variant={selectedTags.includes(tag) ? 'default' : 'outline'}
                      className='cursor-pointer rounded-full px-3 py-1 text-xs hover:bg-primary/10'
                      onClick={() => handleTagToggle(tag)}
                    >
                      #{tag}
                    </Badge>
                  ))}
                </div>
              ) : (
                <p className='text-sm text-muted-foreground text-center py-4'>
                  No tags found matching "{tagSearchTerm}"
                </p>
              )}

              {/* Tag pagination */}
              {totalTagPages > 1 && (
                <div className='flex items-center justify-between pt-2 border-t border-border/40'>
                  <span className='text-xs text-muted-foreground'>
                    {filteredTags.length} tags found
                  </span>
                  <div className='flex items-center gap-2'>
                    <Button
                      variant='ghost'
                      size='sm'
                      className='h-7 px-2 text-xs'
                      disabled={tagPage <= 1}
                      onClick={() => setTagPage(p => Math.max(1, p - 1))}
                    >
                      Prev
                    </Button>
                    <span className='text-xs text-muted-foreground'>
                      {tagPage} / {totalTagPages}
                    </span>
                    <Button
                      variant='ghost'
                      size='sm'
                      className='h-7 px-2 text-xs'
                      disabled={tagPage >= totalTagPages}
                      onClick={() => setTagPage(p => Math.min(totalTagPages, p + 1))}
                    >
                      Next
                    </Button>
                  </div>
                </div>
              )}
            </div>
          )}
        </section>

        {featuredPost && (
          <section className='mb-10 space-y-5'>
            <div className='rounded-[28px] border border-border/40 bg-white p-5 shadow-soft dark:border-white/5 dark:bg-[#1b202b] dark:text-white'>
              <div className='space-y-4'>
                <div className='overflow-hidden rounded-3xl bg-muted dark:bg-white/5'>
                  {featuredPost.coverImage ? (
                    <img
                      src={featuredPost.coverImage}
                      alt={featuredPost.title}
                      className='h-64 w-full object-cover'
                    />
                  ) : (
                    <div className='flex h-64 items-center justify-center text-muted-foreground'>
                      <span>No cover</span>
                    </div>
                  )}
                </div>
                <div className='flex flex-wrap items-center gap-3 text-sm text-muted-foreground'>
                  <Badge variant='secondary' className='rounded-full px-3 py-1 dark:bg-white/10'>
                    {featuredPost.category}
                  </Badge>
                  <span>{formatDate(featuredPost.date)}</span>
                  {featuredPost.readingTime && <span>{featuredPost.readingTime}</span>}
                </div>
                <Link
                  to={`/blog/${featuredPost.year}/${featuredPost.slug}`}
                  className='block space-y-3'
                  state={{ from: { pathname: location.pathname, search: location.search } }}
                  data-testid='post-link'
                >
                  <h2 className='text-2xl font-semibold leading-tight text-foreground dark:text-white'>
                    {featuredPost.title}
                  </h2>
                  <p className='text-muted-foreground dark:text-white/70'>{featuredPost.excerpt || featuredPost.description}</p>
                </Link>
              </div>
            </div>

            {spotlightPosts.length > 0 && (
              <div className='grid gap-4 md:grid-cols-2'>
                {spotlightPosts.map(post => (
                  <Link
                    key={post.slug}
                    to={`/blog/${post.year}/${post.slug}`}
                    className='flex gap-4 rounded-2xl border border-border/40 bg-white p-4 shadow-soft dark:border-white/5 dark:bg-[#1a1f2a] dark:text-white'
                    state={{ from: { pathname: location.pathname, search: location.search } }}
                    data-testid='post-link'
                  >
                    <div className='h-24 w-24 flex-shrink-0 overflow-hidden rounded-xl bg-muted dark:bg-white/10'>
                      {post.coverImage ? (
                        <img src={post.coverImage} alt={post.title} className='h-full w-full object-cover' />
                      ) : (
                        <div className='flex h-full w-full items-center justify-center text-xs text-muted-foreground'>
                          No image
                        </div>
                      )}
                    </div>
                    <div className='space-y-2 text-sm'>
                      <div className='inline-flex items-center rounded-full bg-muted/60 px-2 py-1 text-[11px] uppercase tracking-wide dark:bg-white/10'>
                        {post.category}
                      </div>
                      <h3 className='text-base font-semibold leading-snug text-foreground dark:text-white'>
                        {post.title}
                      </h3>
                      <p className='line-clamp-2 text-muted-foreground dark:text-white/70'>{post.excerpt || post.description}</p>
                    </div>
                  </Link>
                ))}
              </div>
            )}
          </section>
        )}

        <section className='space-y-4'>
          <div className='flex items-center justify-between'>
            <h2 className='text-lg font-semibold'>All posts</h2>
            {totalPages > 1 && (
              <p className='text-sm text-muted-foreground'>Page {currentPage} of {totalPages}</p>
            )}
          </div>

          {loading ? (
            <div className='grid gap-4'>
              {Array.from({ length: pageData.pageSize || POSTS_PER_PAGE }).map((_, index) => (
                <BlogCardSkeleton key={index} />
              ))}
            </div>
          ) : error ? (
            <div className='text-center py-12'>
              <p className='text-red-500 mb-4'>{error}</p>
              <Button variant='outline' onClick={() => window.location.reload()}>
                Try again
              </Button>
            </div>
          ) : pageData.items.length > 0 ? (
            <div className='space-y-4'>
              {(listPosts.length > 0 ? listPosts : pageData.items).map(post => (
                <Link
                  key={post.slug}
                  to={`/blog/${post.year}/${post.slug}`}
                  className='flex gap-4 rounded-2xl border border-border/40 bg-white p-4 shadow-soft dark:border-white/5 dark:bg-[#181d27] dark:text-white'
                  state={{ from: { pathname: location.pathname, search: location.search } }}
                  data-testid='post-link'
                >
                  <div className='h-20 w-20 flex-shrink-0 overflow-hidden rounded-xl bg-muted dark:bg-white/10'>
                    {post.coverImage ? (
                      <img src={post.coverImage} alt={post.title} className='h-full w-full object-cover' />
                    ) : (
                      <div className='flex h-full w-full items-center justify-center text-xs text-muted-foreground'>
                        No image
                      </div>
                    )}
                  </div>
                  <div className='flex-1 space-y-1 text-sm'>
                    <div className='flex items-center gap-2 text-[11px] uppercase tracking-wide text-muted-foreground dark:text-white/70'>
                      <span>{post.category}</span>
                      <span>•</span>
                      <span>{formatDate(post.date)}</span>
                    </div>
                    <h3 className='text-base font-semibold leading-snug text-foreground dark:text-white'>
                      {post.title}
                    </h3>
                    <p className='line-clamp-2 text-muted-foreground dark:text-white/70'>{post.excerpt || post.description}</p>
                  </div>
                </Link>
              ))}
            </div>
          ) : (
            <div className='text-center py-12'>
              <Search className='mx-auto mb-4 h-14 w-14 text-muted-foreground/40' />
              <p className='text-lg font-medium mb-2'>No posts found</p>
              <p className='text-muted-foreground mb-4'>
                {debouncedSearchTerm || selectedCategory !== 'all' || selectedTags.length > 0
                  ? 'Try adjusting your search criteria or filters.'
                  : 'No blog posts are available at the moment.'}
              </p>
              <Button variant='outline' onClick={clearFilters}>
                Clear filters
              </Button>
            </div>
          )}

          {totalPages > 1 && (
            <div className='pt-6'>
              <Pagination
                currentPage={currentPage}
                totalPages={totalPages}
                onPageChange={handlePageChange}
                className='justify-center'
              />
            </div>
          )}
        </section>
      </div>
    </div>
  );
}
;

export default Blog;

```

### BlogPost.tsx

**Path:** `frontend/src/pages/BlogPost.tsx`

```tsx
import {
  useParams,
  Link,
  Navigate,
  useNavigate,
  useLocation,
} from 'react-router-dom';
import {
  Suspense,
  lazy,
  useCallback,
  useEffect,
  useMemo,
  useState,
} from 'react';
import { ReadingProgress } from '@/components/common/ReadingProgress';
import { ScrollToTop } from '@/components/common/ScrollToTop';
import { getPostBySlug, getPostsPage, prefetchPost } from '@/data/posts';
import { BlogPost as BlogPostType } from '@/types/blog';
import {
  formatDate,
  getAvailableLanguages,
  resolveLocalizedPost,
} from '@/utils/blog';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Skeleton } from '@/components/ui/skeleton';
import { CommentSection } from '@/components/features/blog';
import {
  ArrowLeft,
  Calendar,
  Clock,
  Tag,
  Share2,
  BookOpen,
  User,
  Languages,
  MessageCircle,
  Loader2,
  Sparkles,
} from 'lucide-react';
import { useToast } from '@/components/ui/use-toast';
import useLanguage from '@/hooks/useLanguage';
import { useTheme } from '@/contexts/ThemeContext';
import { cn } from '@/lib/utils';
import { recordView } from '@/services/analytics';
import { translatePost, getCachedTranslation, type TranslationResult } from '@/services/translate';
import { curiosityTracker } from '@/services/curiosity';
// import SparkInline from '@/components/features/sentio/SparkInline';

const MarkdownRenderer = lazy(
  () => import('@/components/features/blog/MarkdownRenderer')
);

type VisitedPostItem = {
  path: string;
  title: string;
  coverImage?: string;
  year: string;
  slug: string;
};

const BlogPost = () => {
  const { year, slug } = useParams();
  const navigate = useNavigate();
  const location = useLocation();
  const from = (location.state as { from?: unknown })?.from;
  const preservedFrom =
    from && typeof from === 'object' && 'pathname' in from
      ? (from as { pathname: string; search?: string })
      : undefined;
  const preservedSearch =
    preservedFrom?.search ??
    (typeof location.search === 'string' ? location.search : '');
  const { toast } = useToast();
  const { language, setLanguage } = useLanguage();
  const { isTerminal } = useTheme();

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(false);
  const [post, setPost] = useState<BlogPostType | null>(null);
  const [relatedPosts, setRelatedPosts] = useState<BlogPostType[]>([]);
  const [inlineEnabled, setInlineEnabled] = useState<boolean>(true);

  // AI Translation state
  const [translating, setTranslating] = useState(false);
  const [aiTranslation, setAiTranslation] = useState<TranslationResult | null>(null);
  const [translationError, setTranslationError] = useState<{
    message: string;
    retryable: boolean;
  } | null>(null);

  // Check if native translation exists for the selected language
  const hasNativeTranslation = useMemo(() => {
    if (!post) return false;
    const defaultLang = post.defaultLanguage || post.language || 'ko';
    if (language === defaultLang) return true;
    return !!post.translations?.[language];
  }, [post, language]);

  // Resolve localized content (prefer AI translation if native not available)
  const localized = useMemo(() => {
    if (!post) return null;
    
    // If AI translation is available and native translation doesn't exist, use AI
    if (aiTranslation && !hasNativeTranslation) {
      return {
        title: aiTranslation.title,
        description: aiTranslation.description,
        excerpt: aiTranslation.description,
        content: aiTranslation.content,
      };
    }
    
    // Otherwise use native localization
    return resolveLocalizedPost(post, language);
  }, [post, language, aiTranslation, hasNativeTranslation]);

  const availableLanguages = useMemo(
    () => (post ? getAvailableLanguages(post) : []),
    [post]
  );

  const readingTimeLabel = useMemo(() => {
    if (!post) return '';
    const raw = post.readingTime || (post.readTime ? `${post.readTime} min read` : '');
    if (!raw) return '';
    const match = raw.match(/(\d+)/);
    if (language === 'ko') {
      const minutes = match ? match[1] : '';
      if (minutes) return `${minutes}분 읽기`;
      return raw.includes('분') ? raw : raw.replace('min read', '분 읽기');
    }
    if (raw.includes('분')) {
      const minutes = match ? match[1] : '';
      if (minutes) return `${minutes} min read`;
    }
    return raw;
  }, [language, post]);

  const resolveLanguageName = useCallback((code: string) => {
    if (code === 'ko') return '한국어';
    if (code === 'en') return 'English';
    return code.toUpperCase();
  }, []);

  const safeAreaPaddingStyle = useMemo(
    () => ({ paddingBottom: 'calc(120px + env(safe-area-inset-bottom))' }),
    []
  );

  const backLabel = language === 'ko' ? '블로그로 돌아가기' : 'Back to Blog';
  const shareLabel = language === 'ko' ? '공유하기' : 'Share';
  const relatedLabel = language === 'ko' ? '관련 글' : 'Related Posts';
  const commentsLabel = language === 'ko' ? '댓글' : 'Comments';

  const handleBackToBlog = () => {
    if (preservedFrom) {
      navigate(`${preservedFrom.pathname}${preservedFrom.search || ''}`);
    } else {
      navigate(`/blog${preservedSearch || ''}`);
    }
  };

  // Ensure scroll starts at top when navigating between posts
  useEffect(() => {
    window.scrollTo({ top: 0, left: 0, behavior: 'auto' });
  }, [year, slug]);

  useEffect(() => {
    const loadData = async () => {
      try {
        setLoading(true);
        setError(false);
        // Reset translation states on route change to prevent stale content
        setAiTranslation(null);
        setTranslating(false);
        setTranslationError(null);

        if (!year || !slug) {
          setError(true);
          setLoading(false);
          return;
        }

        // Load the specific post
        const foundPost = await getPostBySlug(year, slug);

        if (!foundPost) {
          setError(true);
          setLoading(false);
          return;
        }

        setPost(foundPost);
        setLoading(false);
      } catch (err) {
        console.error('Error loading blog post:', err);
        setError(true);
        setLoading(false);
      }
    };

    loadData();
  }, [year, slug]);

  // After post loads, record it to visited posts and track view
  useEffect(() => {
    if (!post) return;

    // Record view to D1 analytics (fire and forget)
    recordView(post.year, post.slug).catch(() => {});

    // Track to Curiosity (Web of Curiosity feature)
    const postId = `${post.year}/${post.slug}`;
    const path = `/blog/${post.year}/${post.slug}`;
    curiosityTracker.trackPostView(postId, path, post.title, post.tags || []);

    // Save to local visited posts
    try {
      const key = 'visited.posts';
      const raw = localStorage.getItem(key);
      const items: VisitedPostItem[] = raw ? JSON.parse(raw) : [];
      const path = `/blog/${post.year}/${post.slug}`;
      const next: VisitedPostItem = {
        path,
        title: post.title,
        coverImage: post.coverImage,
        year: post.year,
        slug: post.slug,
      };
      const deduped = [next, ...items.filter(i => i.path !== path)].slice(
        0,
        12
      );
      localStorage.setItem(key, JSON.stringify(deduped));
      window.dispatchEvent(new CustomEvent('visitedposts:update'));
    } catch (err) {
      try {
        window.dispatchEvent(new CustomEvent('visitedposts:error'));
      } catch {}
      console.warn('Failed to persist visited posts', err);
    }
  }, [post]);

  // Auto-translate when language changes and no native translation exists
  useEffect(() => {
    if (!post || !year || !slug) return;
    
    const defaultLang = post.defaultLanguage || post.language || 'ko';
    
    // If viewing in default language or native translation exists, clear AI translation
    if (language === defaultLang || post.translations?.[language]) {
      setAiTranslation(null);
      setTranslationError(null);
      return;
    }

    // Need AI translation
    let cancelled = false;

    const loadTranslation = async () => {
      setTranslating(true);
      setTranslationError(null);

      try {
        // First, try to get cached translation
        const cached = await getCachedTranslation(year, slug, language);
        
        if (cached && !cancelled) {
          setAiTranslation(cached);
          setTranslating(false);
          return;
        }

        // No cache, request AI translation
        const result = await translatePost({
          year,
          slug,
          targetLang: language,
          sourceLang: defaultLang,
          title: post.title,
          description: post.description,
          content: post.content,
        });

        if (!cancelled) {
          setAiTranslation(result);
        }
      } catch (err) {
        console.error('Translation failed:', err);
        if (!cancelled) {
          const errMsg = err instanceof Error ? err.message : '';
          const isTimeout = errMsg.includes('504') || errMsg.includes('응답 지연') || errMsg.includes('timeout');
          const isAiError = errMsg.includes('502') || errMsg.includes('AI 서버');
          
          setTranslationError({
            message: isTimeout 
              ? 'AI 서버 응답이 지연되고 있습니다.'
              : isAiError
                ? 'AI 번역 서버에서 오류가 발생했습니다.'
                : '번역 중 오류가 발생했습니다.',
            retryable: isTimeout || isAiError,
          });
        }
      } finally {
        if (!cancelled) {
          setTranslating(false);
        }
      }
    };

    loadTranslation();

    return () => {
      cancelled = true;
    };
  }, [post, language, year, slug]);

  useEffect(() => {
    if (!post) return;
    if (typeof document === 'undefined') return;
    const title = (post.title || '').trim();
    document.title = title || document.title;
  }, [post]);

  // sync inline feature flag from localStorage and storage events
  useEffect(() => {
    const read = () => {
      try {
        const v = localStorage.getItem('aiMemo.inline.enabled');
        setInlineEnabled(!!JSON.parse(v || 'true'));
      } catch {
        setInlineEnabled(true);
      }
    };
    read();
    const onStorage = (e: StorageEvent) => {
      if (e.key === 'aiMemo.inline.enabled') {
        read();
      }
    };
    window.addEventListener('storage', onStorage);
    window.addEventListener('focus', read);
    return () => {
      window.removeEventListener('storage', onStorage);
      window.removeEventListener('focus', read);
    };
  }, [year, slug]);

  // Load related posts using paginated metadata without fetching all posts
  useEffect(() => {
    let cancelled = false;
    const loadRelated = async () => {
      if (!post) return;
      try {
        const byCategory = await getPostsPage({
          page: 1,
          pageSize: 6,
          category: post.category,
          sort: 'date',
        });
        const candidates = byCategory.items.filter(
          p => `${p.year}/${p.slug}` !== `${post.year}/${post.slug}`
        );
        let selected = candidates.slice(0, 3);
        if (selected.length < 3 && post.tags && post.tags.length) {
          const byTag = await getPostsPage({
            page: 1,
            pageSize: 6,
            search: post.tags[0],
            sort: 'date',
          });
          const more = byTag.items.filter(
            p =>
              `${p.year}/${p.slug}` !== `${post.year}/${post.slug}` &&
              !selected.some(s => s.year === p.year && s.slug === p.slug)
          );
          selected = selected.concat(more).slice(0, 3);
        }
        if (!cancelled) setRelatedPosts(selected);
      } catch {
        if (!cancelled) setRelatedPosts([]);
      }
    };
    loadRelated();
    return () => {
      cancelled = true;
    };
  }, [post]);

  const handleShare = async () => {
    const url = window.location.href;
    if (navigator.share) {
      try {
        await navigator.share({
          title: post?.title,
          text: post?.description,
          url,
        });
      } catch (err) {
        console.log('Error sharing:', err);
      }
    } else {
      navigator.clipboard.writeText(url);
      toast({
        title: 'Link copied!',
        description: 'The post URL has been copied to your clipboard.',
      });
    }
  };

  if (loading) {
    return (
      <div className='container mx-auto max-w-4xl px-4 py-12'>
        <div className='space-y-4 animate-pulse rounded-3xl border border-border/60 bg-card/60 p-6 shadow-sm'>
          <div className='h-4 w-24 rounded bg-muted'></div>
          <div className='h-10 w-3/4 rounded bg-muted'></div>
          <div className='h-4 w-1/2 rounded bg-muted'></div>
          <div className='mt-8 space-y-2'>
            <div className='h-4 rounded bg-muted'></div>
            <div className='h-4 rounded bg-muted'></div>
            <div className='h-4 w-5/6 rounded bg-muted'></div>
          </div>
        </div>
      </div>
    );
  }

  if (error || !post) {
    return <Navigate to='/404' replace />;
  }

  // Related posts are loaded lazily via paginated metadata

  return (
    <>
      <ReadingProgress />
      <div
        className={cn(
          'min-h-screen bg-gradient-to-b from-[#f5f6fb] via-background to-background/70 dark:from-[#04050a] dark:via-[#0b0f18] dark:to-[#111827]',
          isTerminal && 'bg-background from-background via-background to-background'
        )}
      >
        <div
          className='mx-auto w-full max-w-6xl px-4 pt-6 pb-32 sm:pt-12'
          style={safeAreaPaddingStyle}
        >
          <article
            className={cn(
              'mx-auto max-w-4xl space-y-12',
              isTerminal && 'terminal-card p-4 sm:p-6'
            )}
          >
            <header className='space-y-6'>
              <div className='flex flex-wrap items-center justify-between gap-3'>
                <Button
                  variant='ghost'
                  onClick={handleBackToBlog}
                  className={cn(
                    'hover:bg-primary/10 dark:text-white',
                    isTerminal && 'font-mono text-primary hover:text-primary'
                  )}
                  size='sm'
                >
                  <ArrowLeft className='mr-2 h-4 w-4' />
                  {isTerminal ? `< ${backLabel}` : backLabel}
                </Button>
                <Button
                  onClick={handleShare}
                  variant='outline'
                  size='sm'
                  className={cn(
                    'gap-2 rounded-full border-border bg-white/70 text-foreground backdrop-blur hover:bg-primary/10 dark:border-white/10 dark:bg-white/5 dark:text-white',
                    isTerminal && 'font-mono border-border bg-transparent'
                  )}
                >
                  <Share2 className='h-4 w-4' />
                  {shareLabel}
                </Button>
              </div>

              <div
                className={cn(
                  'rounded-[32px] border border-white/60 bg-white/80 p-6 shadow-xl backdrop-blur dark:border-white/10 dark:bg-[#131a26] sm:p-8',
                  isTerminal && 'rounded-lg border-border bg-card'
                )}
              >
                <div className='space-y-5'>
                  {/* Terminal-style path indicator */}
                  {isTerminal && (
                    <div className='font-mono text-xs text-muted-foreground'>
                      <span className='text-primary'>cat</span>{' '}
                      ~/blog/{year}/{slug}.md
                    </div>
                  )}

                  <div
                    className={cn(
                      'inline-flex items-center gap-2 rounded-full bg-primary/10 px-3 py-1 text-xs font-semibold uppercase tracking-[0.35em] text-primary',
                      isTerminal && 'rounded font-mono tracking-wider'
                    )}
                  >
                    {isTerminal && '['}{post.category}{isTerminal && ']'}
                  </div>

                  <h1
                    className={cn(
                      'text-3xl font-bold leading-tight tracking-tight text-foreground dark:text-white sm:text-4xl lg:text-5xl',
                      isTerminal && 'font-mono terminal-glow'
                    )}
                  >
                    {isTerminal && '> '}
                    {localized?.title ?? post.title}
                  </h1>

                  {post.description && (
                    <p
                      className={cn(
                        'text-base leading-relaxed text-muted-foreground dark:text-white/70 sm:text-lg',
                        isTerminal && 'border-l-2 border-primary/30 pl-4'
                      )}
                    >
                      {localized?.description ?? post.description}
                    </p>
                  )}

                  {post.coverImage && (
                    <div
                      className={cn(
                        'overflow-hidden rounded-3xl border border-white/40 bg-muted shadow-sm dark:border-white/10 dark:bg-white/5',
                        isTerminal && 'rounded-lg border-border'
                      )}
                    >
                      <img
                        src={post.coverImage}
                        alt={localized?.title ?? post.title}
                        className='h-64 w-full object-cover sm:h-80'
                      />
                    </div>
                  )}

                  <div
                    className={cn(
                      'grid gap-3 text-sm text-muted-foreground sm:grid-cols-3',
                      isTerminal && 'font-mono text-xs'
                    )}
                  >
                    <div
                      className={cn(
                        'flex items-center gap-2 rounded-2xl bg-white/70 px-3 py-2 shadow-sm dark:bg-[#0f1724] dark:text-white',
                        isTerminal && 'rounded bg-[hsl(var(--terminal-code-bg))]'
                      )}
                    >
                      <Calendar className='h-4 w-4 text-foreground/70' />
                      <span>{isTerminal ? `date: ${formatDate(post.date)}` : formatDate(post.date)}</span>
                    </div>
                    {readingTimeLabel && (
                      <div
                        className={cn(
                          'flex items-center gap-2 rounded-2xl bg-white/70 px-3 py-2 shadow-sm dark:bg-[#0f1724] dark:text-white',
                          isTerminal && 'rounded bg-[hsl(var(--terminal-code-bg))]'
                        )}
                      >
                        <Clock className='h-4 w-4 text-foreground/70' />
                        <span>{isTerminal ? `time: ${readingTimeLabel}` : readingTimeLabel}</span>
                      </div>
                    )}
                    {post.author && (
                      <div
                        className={cn(
                          'flex items-center gap-2 rounded-2xl bg-white/70 px-3 py-2 shadow-sm dark:bg-[#0f1724] dark:text-white',
                          isTerminal && 'rounded bg-[hsl(var(--terminal-code-bg))]'
                        )}
                      >
                        <User className='h-4 w-4 text-foreground/70' />
                        <span>{isTerminal ? `author: ${post.author}` : post.author}</span>
                      </div>
                    )}
                  </div>

                  {/* Language Selection - Always show for translation support */}
                  <div
                    className={cn(
                      'flex flex-wrap items-center gap-2 rounded-2xl border border-dashed border-primary/30 bg-primary/5 px-4 py-3 text-xs font-medium text-muted-foreground dark:border-primary/40 dark:bg-primary/10 dark:text-white/80',
                      isTerminal && 'rounded-lg font-mono border-solid',
                      translating && 'animate-pulse'
                    )}
                  >
                    <Languages className='h-4 w-4 text-primary' />
                    <span className='uppercase tracking-wide'>
                      {language === 'ko' ? '읽기 언어' : 'Reading language'}
                    </span>
                    <div className='flex flex-wrap gap-2'>
                      {(['ko', 'en'] as const).map(code => (
                        <button
                          key={code}
                          type='button'
                          onClick={() => setLanguage(code)}
                          disabled={translating}
                          className={cn(
                            'rounded-full px-3 py-1 text-sm transition-colors',
                            language === code
                              ? 'bg-primary text-primary-foreground shadow-sm'
                              : 'bg-white/70 text-foreground/70 dark:bg-background/60 hover:bg-white dark:hover:bg-background/80',
                            isTerminal && 'rounded font-mono',
                            translating && 'opacity-50 cursor-not-allowed'
                          )}
                        >
                          {resolveLanguageName(code)}
                        </button>
                      ))}
                    </div>
                    {/* Translation status indicators */}
                    {translating && (
                      <div className='flex items-center gap-1.5 ml-2 text-primary'>
                        <Loader2 className='h-3.5 w-3.5 animate-spin' />
                        <span className='text-xs'>
                          {language === 'ko' ? '번역 중...' : 'Translating...'}
                        </span>
                      </div>
                    )}
                    {aiTranslation && !translating && !hasNativeTranslation && (
                      <div className='flex items-center gap-1.5 ml-2 text-amber-600 dark:text-amber-400'>
                        <Sparkles className='h-3.5 w-3.5' />
                        <span className='text-xs'>
                          {language === 'ko' ? 'AI 번역' : 'AI Translated'}
                        </span>
                      </div>
                    )}
                  </div>

                  {/* Translation error message */}
                  {translationError && (
                    <div className={cn(
                      'rounded-lg border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-700 dark:border-red-800 dark:bg-red-900/20 dark:text-red-400',
                      isTerminal && 'font-mono'
                    )}>
                      <div className='flex items-start justify-between gap-3'>
                        <div>
                          <p className='font-medium mb-1'>
                            {language === 'ko' ? '번역 실패' : 'Translation Failed'}
                          </p>
                          <p className='text-xs opacity-80'>{translationError.message}</p>
                          <p className='text-xs mt-1 opacity-60'>
                            {language === 'ko' 
                              ? '원본 콘텐츠를 표시합니다.' 
                              : 'Showing original content.'}
                          </p>
                        </div>
                        {translationError.retryable && (
                          <Button
                            size='sm'
                            variant='outline'
                            onClick={() => {
                              setTranslationError(null);
                              setAiTranslation(null);
                            }}
                            className={cn(
                              'shrink-0 text-xs h-8',
                              isTerminal && 'font-mono border-primary/40 text-primary hover:bg-primary/10'
                            )}
                          >
                            {language === 'ko' ? '다시 시도' : 'Retry'}
                          </Button>
                        )}
                      </div>
                    </div>
                  )}

                  {post.tags && post.tags.length > 0 && (
                    <div
                      className={cn(
                        'flex flex-wrap items-center gap-2 text-muted-foreground dark:text-white/70',
                        isTerminal && 'font-mono text-xs'
                      )}
                    >
                      <Tag className='h-4 w-4 text-muted-foreground dark:text-white/70' />
                      {isTerminal && <span className='text-primary'>tags:</span>}
                      {post.tags.map(tag => (
                        <Badge
                          key={tag}
                          variant='outline'
                          className={cn(
                            'rounded-full px-3 py-1 text-xs dark:border-white/20 dark:text-white cursor-pointer hover:bg-primary/10 transition-colors',
                            isTerminal && 'rounded border-primary/40 text-primary hover:bg-primary/20'
                          )}
                          onClick={() => {
                            curiosityTracker.trackTagClick(tag, `${post.year}/${post.slug}`);
                            navigate(`/blog?tag=${encodeURIComponent(tag)}`);
                          }}
                        >
                          {isTerminal ? `[${tag}]` : `#${tag}`}
                        </Badge>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </header>

            <section
              className={cn(
                'rounded-[32px] border border-white/50 bg-card/70 p-4 shadow-soft backdrop-blur-sm dark:border-white/5 dark:bg-[#141927]/90 sm:p-8 -mx-2 sm:mx-0',
                isTerminal && 'rounded-lg border-border bg-[hsl(var(--terminal-code-bg))]'
              )}
            >
              <div
                className={cn(
                  'prose prose-gray max-w-none dark:prose-invert',
                  isTerminal && 'prose-headings:font-mono prose-headings:terminal-glow'
                )}
              >
                <Suspense
                  fallback={
                    <div className='space-y-3' aria-label='Loading article content'>
                      <Skeleton className='h-6 w-3/4' />
                      <Skeleton className='h-4 w-full' />
                      <Skeleton className='h-4 w-11/12' />
                      <Skeleton className='h-4 w-10/12' />
                      <Skeleton className='h-4 w-9/12' />
                      <Skeleton className='h-4 w-1/2' />
                    </div>
                  }
                >
                  <MarkdownRenderer
                    content={localized?.content ?? post.content}
                    inlineEnabled={inlineEnabled}
                    postTitle={localized?.title ?? post.title}
                  />
                </Suspense>
              </div>
            </section>

            <CommentSection postId={`${post.year}/${post.slug}`} />

            {relatedPosts.length > 0 && (
              <section className='space-y-6'>
                <div className='flex items-center gap-3'>
                  <div
                    className={cn(
                      'rounded-full bg-secondary/20 p-2 text-secondary-foreground dark:bg-white/10 dark:text-white',
                      isTerminal && 'rounded bg-[hsl(var(--terminal-code-bg))]'
                    )}
                  >
                    <BookOpen className='h-5 w-5' />
                  </div>
                  <div>
                    <h2
                      className={cn(
                        'text-xl font-semibold text-foreground dark:text-white',
                        isTerminal && 'font-mono text-primary'
                      )}
                    >
                      {isTerminal ? `> ${relatedLabel}` : relatedLabel}
                    </h2>
                    <p
                      className={cn(
                        'text-sm text-muted-foreground dark:text-white/70',
                        isTerminal && 'font-mono text-xs'
                      )}
                    >
                      {language === 'ko'
                        ? '비슷한 맥락의 글을 더 읽어보세요.'
                        : 'Continue reading with similar perspectives.'}
                    </p>
                  </div>
                </div>
                <div className='grid gap-4 md:grid-cols-3'>
                  {relatedPosts.map(relatedPost => (
                    <Link
                      key={`${relatedPost.year}/${relatedPost.slug}`}
                      to={{
                        pathname: `/blog/${relatedPost.year}/${relatedPost.slug}`,
                        search: preservedSearch || undefined,
                      }}
                      state={
                        preservedFrom ? { from: preservedFrom } : undefined
                      }
                      className={cn(
                        'group rounded-2xl border border-border/60 bg-card/70 p-5 shadow-sm transition hover:-translate-y-1 hover:border-primary/40 hover:shadow-lg dark:border-white/10 dark:bg-[#141b2a]',
                        isTerminal && 'rounded-lg border-border bg-[hsl(var(--terminal-code-bg))] hover:border-primary'
                      )}
                      onMouseEnter={() =>
                        prefetchPost(relatedPost.year, relatedPost.slug)
                      }
                      onFocus={() =>
                        prefetchPost(relatedPost.year, relatedPost.slug)
                      }
                    >
                      <Badge
                        variant='secondary'
                        className={cn(
                          'mb-3 rounded-full px-3 py-1 text-xs dark:bg-white/10 dark:text-white',
                          isTerminal && 'rounded font-mono text-primary bg-transparent border border-primary/40'
                        )}
                      >
                        {isTerminal ? `[${relatedPost.category}]` : relatedPost.category}
                      </Badge>
                      <h3
                        className={cn(
                          'text-base font-semibold leading-snug text-foreground dark:text-white group-hover:text-primary',
                          isTerminal && 'font-mono'
                        )}
                      >
                        {relatedPost.title}
                      </h3>
                      <p className='mt-2 line-clamp-2 text-sm text-muted-foreground dark:text-white/70'>
                        {relatedPost.excerpt || relatedPost.description}
                      </p>
                      {(relatedPost.readingTime || relatedPost.readTime) && (
                        <p
                          className={cn(
                            'mt-3 text-xs uppercase tracking-wide text-muted-foreground dark:text-white/60',
                            isTerminal && 'font-mono'
                          )}
                        >
                          {relatedPost.readingTime || `${relatedPost.readTime} min read`}
                        </p>
                      )}
                    </Link>
                  ))}
                </div>
              </section>
            )}
          </article>
        </div>
      </div>
      <ScrollToTop />
    </>
  );
};

export default BlogPost;

```

### Contact.tsx

**Path:** `frontend/src/pages/Contact.tsx`

```tsx
import { useState } from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/components/ui/use-toast';
import { Mail, MessageSquare, Send } from 'lucide-react';
import { site } from '@/config/site';

const Contact = () => {
  const { toast } = useToast();
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    subject: '',
    message: '',
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    // Here you would typically send the form data to your backend
    toast({
      title: 'Message sent!',
      description: "Thank you for your message. I'll get back to you soon.",
    });
    setFormData({ name: '', email: '', subject: '', message: '' });
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value,
    });
  };

  return (
    <div className='container mx-auto px-4 py-12 max-w-4xl'>
      <div className='space-y-8'>
        <div className='text-center space-y-4'>
          <h1 className='text-4xl font-bold tracking-tight'>Get in Touch</h1>
          <p className='text-xl text-muted-foreground'>
            Have a question or want to work together? I'd love to hear from you.
          </p>
        </div>

        <div className='grid gap-8 md:grid-cols-3'>
          <Card className='md:col-span-2'>
            <CardHeader>
              <CardTitle>Send me a message</CardTitle>
              <CardDescription>
                Fill out the form below and I'll get back to you as soon as
                possible.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <form onSubmit={handleSubmit} className='space-y-6'>
                <div className='grid gap-4 sm:grid-cols-2'>
                  <div className='space-y-2'>
                    <Label htmlFor='name'>Name</Label>
                    <Input
                      id='name'
                      name='name'
                      placeholder='Your name'
                      value={formData.name}
                      onChange={handleChange}
                      required
                    />
                  </div>
                  <div className='space-y-2'>
                    <Label htmlFor='email'>Email</Label>
                    <Input
                      id='email'
                      name='email'
                      type='email'
                      placeholder='your@email.com'
                      value={formData.email}
                      onChange={handleChange}
                      required
                    />
                  </div>
                </div>
                <div className='space-y-2'>
                  <Label htmlFor='subject'>Subject</Label>
                  <Input
                    id='subject'
                    name='subject'
                    placeholder="What's this about?"
                    value={formData.subject}
                    onChange={handleChange}
                    required
                  />
                </div>
                <div className='space-y-2'>
                  <Label htmlFor='message'>Message</Label>
                  <Textarea
                    id='message'
                    name='message'
                    placeholder='Your message...'
                    rows={6}
                    value={formData.message}
                    onChange={handleChange}
                    required
                  />
                </div>
                <Button type='submit' className='w-full sm:w-auto'>
                  <Send className='mr-2 h-4 w-4' />
                  Send Message
                </Button>
              </form>
            </CardContent>
          </Card>

          <div className='space-y-4'>
            <Card>
              <CardHeader>
                <CardTitle className='flex items-center gap-2'>
                  <Mail className='h-5 w-5' />
                  Email
                </CardTitle>
              </CardHeader>
              <CardContent>
                <a
                  href={`mailto:${site.email}`}
                  className='text-sm text-muted-foreground hover:text-primary'
                >
                  {site.email}
                </a>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle className='flex items-center gap-2'>
                  <MessageSquare className='h-5 w-5' />
                  Social
                </CardTitle>
              </CardHeader>
              <CardContent className='space-y-2'>
                <a
                  href={site.social.github}
                  target='_blank'
                  rel='noopener noreferrer'
                  className='block text-sm text-muted-foreground hover:text-primary'
                >
                  GitHub: @choisimo
                </a>
                <a
                  href={site.social.twitter}
                  target='_blank'
                  rel='noopener noreferrer'
                  className='block text-sm text-muted-foreground hover:text-primary'
                >
                  Twitter: @nodove
                </a>
                <a
                  href={site.social.linkedin}
                  target='_blank'
                  rel='noopener noreferrer'
                  className='block text-sm text-muted-foreground hover:text-primary'
                >
                  LinkedIn: nodove
                </a>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Contact;

```

### Index.tsx

**Path:** `frontend/src/pages/Index.tsx`

```tsx
import { useEffect, useMemo, useRef, useState } from 'react';
import { Link } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import {
  Card,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import {
  ArrowRight,
  BookOpen,
  ChevronLeft,
  ChevronRight,
  Clock,
  Code2,
  Sparkles,
  TrendingUp,
} from 'lucide-react';
import { BlogCard, BlogCardSkeleton } from '@/components';
import { getPosts, getPostsPage, getPostBySlug } from '@/data/posts';
import type { BlogPost } from '@/types/blog';
import { SearchBar } from '@/components/features/search/SearchBar';
import { site } from '@/config/site';
import { useTheme } from '@/contexts/ThemeContext';
import { cn } from '@/lib/utils';
import { OptimizedImage } from '@/components/common/OptimizedImage';
import { formatDate } from '@/utils/blog';
import { getEditorPicks, type EditorPick } from '@/services/analytics';

// Shape used by visited posts in localStorage
// Matches VisitedPostsMinimap
interface VisitedPostItem {
  path: string; // "/blog/:year/:slug"
  title: string;
  coverImage?: string;
  year: string;
  slug: string;
}

const STORAGE_KEY = 'visited.posts';

const Index = () => {
  const { isTerminal } = useTheme();
  
  // Latest posts state
  const [latestPosts, setLatestPosts] = useState<BlogPost[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // All posts for search
  const [allPosts, setAllPosts] = useState<BlogPost[]>([]);
  const [searchResults, setSearchResults] = useState<BlogPost[] | null>(null);
  const [searchActive, setSearchActive] = useState(false);

  // Editor's Picks
  const [featuredPosts, setFeaturedPosts] = useState<BlogPost[]>([]);
  const [featuredLoading, setFeaturedLoading] = useState(true);

  // Recently Viewed (from localStorage)
  const [recentlyViewed, setRecentlyViewed] = useState<VisitedPostItem[]>([]);

  useEffect(() => {
    let cancelled = false;

    const loadLatest = async () => {
      try {
        setLoading(true);
        setError(null);
        const res = await getPostsPage({ page: 1, pageSize: 3, sort: 'date' });
        if (!cancelled) setLatestPosts(res.items);
      } catch (e) {
        if (!cancelled) setError('Failed to load latest posts.');
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    const loadAllForSearch = async () => {
      try {
        const posts = await getPosts();
        if (!cancelled) setAllPosts(posts);
      } catch {
        // ignore search preload errors
      }
    };

    const loadFeatured = async () => {
      try {
        setFeaturedLoading(true);

        // 1. Try to load from D1 database (analytics-based editor picks)
        const dbPicks = await getEditorPicks(3);
        
        if (dbPicks.length > 0) {
          // Resolve posts from D1 picks
          const resolved = await Promise.all(
            dbPicks.map(async (pick: EditorPick) => {
              const post = await getPostBySlug(pick.year, pick.post_slug);
              return post || null;
            })
          );
          const filtered = resolved.filter((p): p is BlogPost => !!p);
          
          if (filtered.length > 0) {
            setFeaturedPosts(filtered);
            return;
          }
        }

        // 2. Fallback: Use static site.featured config
        const picks = site.featured || [];
        if (picks.length > 0) {
          const resolved = await Promise.all(
            picks.map(async p => (await getPostBySlug(p.year, p.slug)) || null)
          );
          const filtered = resolved
            .filter((p): p is BlogPost => !!p)
            .slice(0, 3);
          if (filtered.length > 0) {
            setFeaturedPosts(filtered);
            return;
          }
        }

        // 3. Final fallback: Latest posts
        const res = await getPostsPage({
          page: 1,
          pageSize: 3,
          sort: 'date',
        });
        setFeaturedPosts(res.items);
      } catch {
        // Fallback to latest posts on error
        try {
          const res = await getPostsPage({
            page: 1,
            pageSize: 3,
            sort: 'date',
          });
          setFeaturedPosts(res.items);
        } catch {
          setFeaturedPosts([]);
        }
      } finally {
        setFeaturedLoading(false);
      }
    };

    loadLatest();
    loadAllForSearch();
    loadFeatured();

    return () => {
      cancelled = true;
    };
  }, []);

  // Read recently viewed from localStorage and keep in sync
  useEffect(() => {
    const read = () => {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        const arr: VisitedPostItem[] = raw ? JSON.parse(raw) : [];
        setRecentlyViewed(Array.isArray(arr) ? arr.slice(0, 6) : []);
      } catch {
        setRecentlyViewed([]);
      }
    };
    read();
    const onStorage = (e: StorageEvent) => {
      if (!e.key || e.key === STORAGE_KEY) read();
    };
    const onCustom = () => read();
    window.addEventListener('storage', onStorage);
    window.addEventListener('visitedposts:update', onCustom as EventListener);
    return () => {
      window.removeEventListener('storage', onStorage);
      window.removeEventListener(
        'visitedposts:update',
        onCustom as EventListener
      );
    };
  }, []);

  // Featured categories (static placeholders)
  const categories = useMemo(
    () => [
      { name: 'AI & ML', icon: Sparkles, count: 12, color: 'text-purple-500' },
      { name: 'Web Dev', icon: Code2, count: 18, color: 'text-blue-500' },
      {
        name: 'Algorithms',
        icon: TrendingUp,
        count: 15,
        color: 'text-green-500',
      },
      { name: 'DevOps', icon: BookOpen, count: 10, color: 'text-orange-500' },
    ],
    []
  );

  // Hero featured post (first from Editor's Picks)
  const heroFeatured = featuredPosts[0];

  // Carousel scroll handlers
  const carouselRef = useRef<HTMLDivElement>(null);
  const scrollCarousel = (direction: 'left' | 'right') => {
    if (carouselRef.current) {
      const scrollAmount = 300;
      carouselRef.current.scrollBy({
        left: direction === 'left' ? -scrollAmount : scrollAmount,
        behavior: 'smooth',
      });
    }
  };

  return (
    <div className='container mx-auto px-4 pt-8 pb-28'>
      {/* ============================================
          Hero Section - Split Layout with Featured Post
          ============================================ */}
      <section className='mb-16'>
        <div className='grid lg:grid-cols-12 gap-8 items-center'>
          {/* Left: Typography & CTA */}
          <div className='lg:col-span-5 space-y-6 text-left'>
            <div className='space-y-2'>
              <p className={cn(
                'text-sm font-medium tracking-widest uppercase',
                isTerminal ? 'text-primary font-mono' : 'text-muted-foreground'
              )}>
                {isTerminal ? '> WELCOME_TO' : 'Welcome to'}
              </p>
              <h1 className={cn(
                'text-4xl sm:text-5xl lg:text-6xl font-bold tracking-tight leading-[1.1]',
                isTerminal && 'font-mono'
              )}>
                <span className={cn(
                  isTerminal 
                    ? 'text-foreground' 
                    : 'bg-gradient-to-r from-foreground to-foreground/70 bg-clip-text text-transparent'
                )}>
                  Architecting
                </span>
                <br />
                <span className={cn(
                  isTerminal 
                    ? 'text-primary terminal-glow' 
                    : 'bg-gradient-to-r from-primary to-primary/60 bg-clip-text text-transparent'
                )}>
                  Intelligence
                </span>
              </h1>
            </div>
            <p className={cn(
              'text-lg leading-relaxed max-w-md',
              isTerminal ? 'text-muted-foreground' : 'text-muted-foreground'
            )}>
              AI, 시스템 설계, 그리고 코드의 본질을 탐구하는 기술 블로그
            </p>
            
            {/* Search Bar */}
            <div className='max-w-md'>
              <SearchBar
                posts={allPosts}
                onSearchResults={results => {
                  setSearchResults(results);
                  setSearchActive(results !== allPosts);
                }}
                placeholder='Search posts, tags, categories...'
              />
            </div>
            
            {/* CTA Buttons */}
            <div className='flex flex-wrap gap-3 pt-2'>
              <Button 
                asChild 
                size='lg' 
                variant={isTerminal ? 'terminal-active' : 'default'}
                className={cn(
                  isTerminal && 'shadow-[0_0_16px_hsl(var(--primary)/0.4)] hover:shadow-[0_0_20px_hsl(var(--primary)/0.5)]'
                )}
              >
                <Link to='/blog'>
                  <BookOpen className='mr-2 h-5 w-5' />
                  Explore Posts
                </Link>
              </Button>
              <Button 
                asChild 
                variant='outline' 
                size='lg'
                className={cn(
                  isTerminal && 'font-mono border-border text-foreground hover:border-primary hover:text-primary'
                )}
              >
                <Link to='/about'>
                  About Me
                  <ArrowRight className='ml-2 h-5 w-5' />
                </Link>
              </Button>
            </div>
          </div>

          {/* Right: Featured Post Card (Large) */}
          <div className='lg:col-span-7'>
            {featuredLoading ? (
              <div className={cn(
                'aspect-[16/10] rounded-2xl animate-pulse',
                isTerminal ? 'bg-card border border-border' : 'bg-muted'
              )} />
            ) : heroFeatured ? (
              <Link 
                to={`/blog/${heroFeatured.year}/${heroFeatured.slug}`}
                className='group block'
              >
                <div className={cn(
                  'relative aspect-[16/10] rounded-2xl overflow-hidden',
                  isTerminal 
                    ? 'border border-border hover:border-primary/50 transition-all duration-300' 
                    : 'shadow-lg hover:shadow-xl transition-all duration-300'
                )}>
                  {/* Background Image */}
                  {heroFeatured.coverImage ? (
                    <OptimizedImage
                      src={heroFeatured.coverImage}
                      alt={heroFeatured.title}
                      className='w-full h-full object-cover group-hover:scale-105 transition-transform duration-500'
                    />
                  ) : (
                    <div className={cn(
                      'w-full h-full',
                      isTerminal 
                        ? 'bg-gradient-to-br from-card to-background' 
                        : 'bg-gradient-to-br from-slate-200 to-slate-100 dark:from-slate-800 dark:to-slate-900'
                    )} />
                  )}
                  
                  {/* Overlay Gradient */}
                  <div className={cn(
                    'absolute inset-0',
                    isTerminal 
                      ? 'bg-gradient-to-t from-background via-background/60 to-transparent' 
                      : 'bg-gradient-to-t from-black/80 via-black/40 to-transparent'
                  )} />
                  
                  {/* Content */}
                  <div className='absolute bottom-0 left-0 right-0 p-6 md:p-8'>
                    <div className='flex items-center gap-3 mb-3'>
                      <span className={cn(
                        'px-3 py-1 text-xs font-medium rounded-full',
                        isTerminal 
                          ? 'bg-primary/20 text-primary border border-primary/30' 
                          : 'bg-white/20 text-white backdrop-blur-sm'
                      )}>
                        {heroFeatured.category}
                      </span>
                      <span className={cn(
                        'text-sm',
                        isTerminal ? 'text-muted-foreground' : 'text-white/70'
                      )}>
                        {formatDate(heroFeatured.date)}
                      </span>
                    </div>
                    <h2 className={cn(
                      'text-2xl md:text-3xl font-bold mb-2 line-clamp-2',
                      isTerminal 
                        ? 'text-foreground group-hover:text-primary transition-colors' 
                        : 'text-white'
                    )}>
                      {heroFeatured.title}
                    </h2>
                    {heroFeatured.description && (
                      <p className={cn(
                        'text-sm md:text-base line-clamp-2 max-w-2xl',
                        isTerminal ? 'text-muted-foreground' : 'text-white/80'
                      )}>
                        {heroFeatured.description}
                      </p>
                    )}
                  </div>

                  {/* Terminal Glow Effect on Hover */}
                  {isTerminal && (
                    <div className='absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none border-2 border-primary/30 rounded-2xl shadow-[inset_0_0_30px_hsl(var(--primary)/0.1)]' />
                  )}
                </div>
              </Link>
            ) : null}
          </div>
        </div>
      </section>

      {/* ============================================
          Search Results Section
          ============================================ */}
      {searchActive && searchResults && (
        <section className='mb-16'>
          <div className='flex items-center justify-between mb-6'>
            <h2 className={cn(
              'text-2xl font-bold',
              isTerminal && 'font-mono'
            )}>
              {isTerminal ? '> search_results' : 'Search Results'}
            </h2>
            <div className='text-sm text-muted-foreground'>
              {searchResults.length} match
              {searchResults.length === 1 ? '' : 'es'}
            </div>
          </div>
          <div className='grid gap-6 md:grid-cols-2 lg:grid-cols-3'>
            {searchResults.slice(0, 9).map(post => (
              <BlogCard key={`${post.year}/${post.slug}`} post={post} />
            ))}
          </div>
        </section>
      )}

      {/* ============================================
          Editor's Picks - Bento Grid (1 Main + 2 Side)
          ============================================ */}
      <section className='mb-16'>
        <div className='flex items-center justify-between mb-8'>
          <h2 className={cn(
            'text-2xl font-bold',
            isTerminal && 'font-mono'
          )}>
            {isTerminal ? '// editor_picks' : "Editor's Picks"}
          </h2>
        </div>
        
        {featuredLoading ? (
          <div className='grid lg:grid-cols-3 gap-6'>
            {Array.from({ length: 3 }).map((_, i) => (
              <BlogCardSkeleton key={i} />
            ))}
          </div>
        ) : featuredPosts.length > 0 ? (
          <div className='grid lg:grid-cols-3 gap-6'>
            {/* Main Featured Card (2/3 width on desktop) */}
            <div className='lg:col-span-2'>
              <Link 
                to={`/blog/${featuredPosts[0].year}/${featuredPosts[0].slug}`}
                className='group block h-full'
              >
                <div className={cn(
                  'relative h-full min-h-[400px] rounded-2xl overflow-hidden',
                  isTerminal 
                    ? 'border border-border bg-card/50 backdrop-blur-sm hover:border-primary/50' 
                    : 'bg-card shadow-md hover:shadow-xl',
                  'transition-all duration-300'
                )}>
                  {featuredPosts[0].coverImage ? (
                    <OptimizedImage
                      src={featuredPosts[0].coverImage}
                      alt={featuredPosts[0].title}
                      className='w-full h-full object-cover group-hover:scale-105 transition-transform duration-500'
                    />
                  ) : (
                    <div className={cn(
                      'w-full h-full',
                      isTerminal 
                        ? 'bg-gradient-to-br from-primary/5 to-card' 
                        : 'bg-gradient-to-br from-slate-100 to-slate-200 dark:from-slate-800 dark:to-slate-900'
                    )} />
                  )}
                  
                  <div className={cn(
                    'absolute inset-0',
                    isTerminal 
                      ? 'bg-gradient-to-t from-background via-background/70 to-transparent' 
                      : 'bg-gradient-to-t from-black/80 via-black/40 to-transparent'
                  )} />
                  
                  <div className='absolute bottom-0 left-0 right-0 p-8'>
                    <div className='flex items-center gap-3 mb-4'>
                      <span className={cn(
                        'px-3 py-1 text-xs font-medium rounded-full',
                        isTerminal 
                          ? 'bg-primary/20 text-primary border border-primary/30' 
                          : 'bg-primary text-primary-foreground'
                      )}>
                        {featuredPosts[0].category}
                      </span>
                      {featuredPosts[0].readingTime && (
                        <span className={cn(
                          'flex items-center gap-1 text-sm',
                          isTerminal ? 'text-muted-foreground' : 'text-white/70'
                        )}>
                          <Clock className='h-3.5 w-3.5' />
                          {featuredPosts[0].readingTime}
                        </span>
                      )}
                    </div>
                    <h3 className={cn(
                      'text-2xl md:text-3xl font-bold mb-3 line-clamp-2',
                      isTerminal 
                        ? 'text-foreground group-hover:text-primary' 
                        : 'text-white',
                      'transition-colors'
                    )}>
                      {featuredPosts[0].title}
                    </h3>
                    {featuredPosts[0].description && (
                      <p className={cn(
                        'line-clamp-2 max-w-xl',
                        isTerminal ? 'text-muted-foreground' : 'text-white/80'
                      )}>
                        {featuredPosts[0].description}
                      </p>
                    )}
                  </div>

                  {isTerminal && (
                    <div className='absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none border-2 border-primary/30 rounded-2xl' />
                  )}
                </div>
              </Link>
            </div>

            {/* Side Cards (1/3 width, stacked) */}
            <div className='flex flex-col gap-6'>
              {featuredPosts.slice(1, 3).map(post => (
                <Link 
                  key={`${post.year}/${post.slug}`}
                  to={`/blog/${post.year}/${post.slug}`}
                  className='group flex-1'
                >
                  <div className={cn(
                    'h-full rounded-xl overflow-hidden flex flex-col',
                    isTerminal 
                      ? 'border border-border bg-card/30 backdrop-blur-sm hover:border-primary/50 hover:bg-card/50' 
                      : 'bg-card border border-border/50 shadow-sm hover:shadow-lg',
                    'transition-all duration-300'
                  )}>
                    {post.coverImage && (
                      <div className='aspect-[16/9] overflow-hidden'>
                        <OptimizedImage
                          src={post.coverImage}
                          alt={post.title}
                          className='w-full h-full object-cover group-hover:scale-105 transition-transform duration-300'
                        />
                      </div>
                    )}
                    <div className='p-5 flex-1 flex flex-col'>
                      <div className='flex items-center gap-2 mb-2'>
                        <span className={cn(
                          'px-2 py-0.5 text-xs rounded',
                          isTerminal 
                            ? 'bg-primary/10 text-primary' 
                            : 'bg-secondary text-secondary-foreground'
                        )}>
                          {post.category}
                        </span>
                        <span className='text-xs text-muted-foreground'>
                          {formatDate(post.date)}
                        </span>
                      </div>
                      <h3 className={cn(
                        'font-semibold line-clamp-2 flex-1',
                        isTerminal 
                          ? 'text-foreground group-hover:text-primary' 
                          : 'group-hover:text-primary',
                        'transition-colors'
                      )}>
                        {post.title}
                      </h3>
                    </div>
                  </div>
                </Link>
              ))}
            </div>
          </div>
        ) : null}
      </section>

      {/* ============================================
          Recently Viewed - Horizontal Carousel
          ============================================ */}
      {recentlyViewed.length > 0 && (
        <section className='mb-16'>
          <div className='flex items-center justify-between mb-6'>
            <h2 className={cn(
              'text-2xl font-bold',
              isTerminal && 'font-mono'
            )}>
              {isTerminal ? '// recently_viewed' : 'Recently Viewed'}
            </h2>
            <div className='flex items-center gap-2'>
              <Button 
                variant='ghost' 
                size='icon'
                className={cn(
                  'h-8 w-8 rounded-full',
                  isTerminal && 'hover:bg-primary/10 hover:text-primary'
                )}
                onClick={() => scrollCarousel('left')}
              >
                <ChevronLeft className='h-4 w-4' />
              </Button>
              <Button 
                variant='ghost' 
                size='icon'
                className={cn(
                  'h-8 w-8 rounded-full',
                  isTerminal && 'hover:bg-primary/10 hover:text-primary'
                )}
                onClick={() => scrollCarousel('right')}
              >
                <ChevronRight className='h-4 w-4' />
              </Button>
              <Button asChild variant='ghost' size='sm'>
                <Link to='/blog' className={cn(
                  isTerminal && 'hover:text-primary'
                )}>
                  View all
                  <ArrowRight className='ml-1 h-3 w-3' />
                </Link>
              </Button>
            </div>
          </div>
          
          {/* Carousel Container */}
          <div 
            ref={carouselRef}
            className='flex gap-4 overflow-x-auto scrollbar-hide pb-4 -mx-4 px-4 snap-x snap-mandatory'
            style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
          >
            {recentlyViewed.map(item => (
              <Link 
                key={item.path} 
                to={item.path} 
                className='group flex-shrink-0 w-[280px] snap-start'
              >
                <div className={cn(
                  'rounded-xl overflow-hidden h-full',
                  isTerminal 
                    ? 'border border-border bg-card/30 backdrop-blur-sm hover:border-primary/50 hover:bg-card/50' 
                    : 'bg-card border border-border/50 shadow-sm hover:shadow-md',
                  'transition-all duration-300'
                )}>
                  {item.coverImage ? (
                    <div className='aspect-[16/9] overflow-hidden'>
                      <img
                        src={item.coverImage}
                        alt=''
                        className='h-full w-full object-cover group-hover:scale-105 transition-transform duration-300'
                      />
                    </div>
                  ) : (
                    <div className={cn(
                      'aspect-[16/9]',
                      isTerminal 
                        ? 'bg-gradient-to-br from-primary/5 to-card' 
                        : 'bg-gradient-to-br from-muted to-muted/50'
                    )} />
                  )}
                  <div className='p-4'>
                    <div className='text-xs text-muted-foreground mb-1'>
                      {item.year}/{item.slug}
                    </div>
                    <h3 className={cn(
                      'font-medium line-clamp-2 text-sm',
                      isTerminal 
                        ? 'text-foreground group-hover:text-primary' 
                        : 'group-hover:text-primary',
                      'transition-colors'
                    )}>
                      {item.title}
                    </h3>
                  </div>
                </div>
              </Link>
            ))}
          </div>
        </section>
      )}

      {/* ============================================
          Categories Section - Compact Grid
          ============================================ */}
      <section className='mb-16'>
        <h2 className={cn(
          'text-2xl font-bold mb-6 text-center',
          isTerminal && 'font-mono'
        )}>
          {isTerminal ? '// categories' : 'Popular Categories'}
        </h2>
        <div className='grid grid-cols-2 md:grid-cols-4 gap-3'>
          {categories.map(category => (
            <Card
              key={category.name}
              className={cn(
                'group cursor-pointer transition-all duration-300',
                isTerminal 
                  ? 'bg-card/30 backdrop-blur-sm border-border hover:border-primary/50 hover:bg-card/50' 
                  : 'hover:shadow-lg hover:-translate-y-0.5'
              )}
            >
              <CardHeader className='text-center py-4 px-3'>
                <category.icon
                  className={cn(
                    'h-6 w-6 mx-auto mb-2 transition-colors',
                    isTerminal ? 'text-primary' : category.color,
                    'group-hover:scale-110 transition-transform'
                  )}
                />
                <CardTitle className={cn(
                  'text-sm font-medium',
                  isTerminal && 'font-mono'
                )}>
                  {category.name}
                </CardTitle>
                <CardDescription className='text-xs'>
                  {category.count} posts
                </CardDescription>
              </CardHeader>
            </Card>
          ))}
        </div>
      </section>

      {/* ============================================
          Latest Posts - List View (Magazine Style)
          ============================================ */}
      <section>
        <div className='flex justify-between items-center mb-6'>
          <h2 className={cn(
            'text-2xl font-bold',
            isTerminal && 'font-mono'
          )}>
            {isTerminal ? '// latest_posts' : 'Latest Posts'}
          </h2>
          <Button asChild variant='ghost' size='sm'>
            <Link to='/blog' className={cn(
              isTerminal && 'hover:text-primary'
            )}>
              View all posts
              <ArrowRight className='ml-2 h-4 w-4' />
            </Link>
          </Button>
        </div>

        {error ? (
          <div className='text-center py-8'>
            <p className='text-red-500 mb-4'>{error}</p>
            <Button variant='outline' onClick={() => window.location.reload()}>
              Try again
            </Button>
          </div>
        ) : loading ? (
          <div className='space-y-4'>
            {Array.from({ length: 3 }).map((_, i) => (
              <div 
                key={i} 
                className={cn(
                  'h-32 rounded-xl animate-pulse',
                  isTerminal ? 'bg-card border border-border' : 'bg-muted'
                )}
              />
            ))}
          </div>
        ) : (
          <div className='space-y-4'>
            {latestPosts.map(post => (
              <Link
                key={`${post.year}/${post.slug}`}
                to={`/blog/${post.year}/${post.slug}`}
                className='group block'
              >
                <article className={cn(
                  'flex gap-5 rounded-xl p-4 transition-all duration-300',
                  isTerminal 
                    ? 'border border-border bg-card/30 backdrop-blur-sm hover:border-primary/50 hover:bg-card/50' 
                    : 'bg-card border border-border/50 shadow-sm hover:shadow-md'
                )}>
                  {/* Thumbnail */}
                  <div className='flex-shrink-0 w-32 md:w-48 aspect-[16/10] rounded-lg overflow-hidden'>
                    {post.coverImage ? (
                      <OptimizedImage
                        src={post.coverImage}
                        alt={post.title}
                        className='w-full h-full object-cover group-hover:scale-105 transition-transform duration-300'
                      />
                    ) : (
                      <div className={cn(
                        'w-full h-full flex items-center justify-center',
                        isTerminal 
                          ? 'bg-gradient-to-br from-primary/5 to-card' 
                          : 'bg-gradient-to-br from-muted to-muted/50'
                      )}>
                        <BookOpen className='h-8 w-8 text-muted-foreground/50' />
                      </div>
                    )}
                  </div>
                  
                  {/* Content */}
                  <div className='flex-1 min-w-0 flex flex-col justify-center'>
                    <div className='flex flex-wrap items-center gap-2 mb-2'>
                      <span className={cn(
                        'px-2 py-0.5 text-xs font-medium rounded',
                        isTerminal 
                          ? 'bg-primary/10 text-primary' 
                          : 'bg-secondary text-secondary-foreground'
                      )}>
                        {post.category}
                      </span>
                      <span className='text-xs text-muted-foreground'>
                        {formatDate(post.date)}
                      </span>
                      {post.readingTime && (
                        <span className='text-xs text-muted-foreground flex items-center gap-1'>
                          <Clock className='h-3 w-3' />
                          {post.readingTime}
                        </span>
                      )}
                    </div>
                    <h3 className={cn(
                      'font-semibold text-lg mb-1 line-clamp-1',
                      isTerminal 
                        ? 'text-foreground group-hover:text-primary' 
                        : 'group-hover:text-primary',
                      'transition-colors'
                    )}>
                      {post.title}
                    </h3>
                    {post.description && (
                      <p className='text-sm text-muted-foreground line-clamp-2 hidden md:block'>
                        {post.description}
                      </p>
                    )}
                  </div>

                  {/* Arrow indicator */}
                  <div className={cn(
                    'hidden md:flex items-center justify-center w-10',
                    'opacity-0 group-hover:opacity-100 transition-opacity'
                  )}>
                    <ArrowRight className={cn(
                      'h-5 w-5',
                      isTerminal ? 'text-primary' : 'text-muted-foreground'
                    )} />
                  </div>
                </article>
              </Link>
            ))}
          </div>
        )}
      </section>
    </div>
  );
};

export default Index;

```

### Insight.tsx

**Path:** `frontend/src/pages/Insight.tsx`

```tsx
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useTheme } from '@/contexts/ThemeContext';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { ArrowLeft, ZoomIn, ZoomOut, RotateCcw, Network, MessageSquare, FileText, Sparkles, X, Lightbulb, PenLine, Calendar, ExternalLink, Tag, Search, Filter } from 'lucide-react';
import { getPosts } from '@/data/posts';
import { BlogPost } from '@/types/blog';
import { curiosityTracker, type CuriosityEvent } from '@/services/curiosity';

// ─────────────────────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────────────────────

type NodeType = 'post' | 'chat' | 'comment' | 'question' | 'memo' | 'tag' | 'search';

interface GraphNode {
  id: string;
  type: NodeType;
  label: string;
  x: number;
  y: number;
  vx: number;
  vy: number;
  data?: any;
  ts?: number; // timestamp for filtering
}

interface GraphEdge {
  source: string;
  target: string;
  weight: number;
  type: 'category' | 'tag' | 'chat' | 'comment' | 'curiosity';
}

interface ChatSession {
  id: string;
  title?: string;
  summary?: string;
  articleUrl?: string;
  articleTitle?: string;
  updatedAt?: string;
  messages?: Array<{ role: string; content: string }>;
}

interface MemoEvent {
  type: string;
  t: number;
  label?: string;
  content?: string;
  page?: {
    url?: string;
    title?: string;
    post?: {
      year: number;
      slug: string;
      title?: string;
    };
  };
}

interface RelatedContent {
  chats: ChatSession[];
  memos: MemoEvent[];
  thoughts: MemoEvent[];
}

// ─────────────────────────────────────────────────────────────────────────────
// Dijkstra Algorithm for finding shortest paths
// ─────────────────────────────────────────────────────────────────────────────

function buildAdjacencyList(nodes: GraphNode[], edges: GraphEdge[]): Map<string, Map<string, number>> {
  const adj = new Map<string, Map<string, number>>();
  
  nodes.forEach(n => adj.set(n.id, new Map()));
  
  edges.forEach(e => {
    adj.get(e.source)?.set(e.target, e.weight);
    adj.get(e.target)?.set(e.source, e.weight);
  });
  
  return adj;
}

function dijkstra(adj: Map<string, Map<string, number>>, start: string): Map<string, number> {
  const dist = new Map<string, number>();
  const visited = new Set<string>();
  
  adj.forEach((_, id) => dist.set(id, Infinity));
  dist.set(start, 0);
  
  const pq: [string, number][] = [[start, 0]];
  
  while (pq.length > 0) {
    pq.sort((a, b) => a[1] - b[1]);
    const [u, d] = pq.shift()!;
    
    if (visited.has(u)) continue;
    visited.add(u);
    
    const neighbors = adj.get(u);
    if (!neighbors) continue;
    
    neighbors.forEach((w, v) => {
      const alt = d + w;
      if (alt < (dist.get(v) ?? Infinity)) {
        dist.set(v, alt);
        pq.push([v, alt]);
      }
    });
  }
  
  return dist;
}

// ─────────────────────────────────────────────────────────────────────────────
// Force-directed layout simulation with collision avoidance
// ─────────────────────────────────────────────────────────────────────────────

function simulateForces(
  nodes: GraphNode[],
  edges: GraphEdge[],
  width: number,
  height: number,
  iterations: number = 150
): GraphNode[] {
  const result = nodes.map(n => ({ ...n }));
  
  // Minimum distance between nodes (based on node sizes)
  const minDistance = 80; // Nodes are ~24-28px radius, so 80px prevents overlap
  
  // Initialize positions using a grid-based approach to reduce initial overlap
  const cols = Math.ceil(Math.sqrt(result.length));
  const cellWidth = (width - 120) / cols;
  const cellHeight = (height - 120) / Math.ceil(result.length / cols);
  
  result.forEach((n, i) => {
    if (n.x === 0 && n.y === 0) {
      const col = i % cols;
      const row = Math.floor(i / cols);
      // Add some randomness within the cell to avoid perfect grid
      n.x = 60 + col * cellWidth + cellWidth / 2 + (Math.random() - 0.5) * cellWidth * 0.5;
      n.y = 60 + row * cellHeight + cellHeight / 2 + (Math.random() - 0.5) * cellHeight * 0.5;
    }
    n.vx = 0;
    n.vy = 0;
  });
  
  // Build edge map for faster lookups
  const edgeMap = new Map<string, Set<string>>();
  result.forEach(n => edgeMap.set(n.id, new Set()));
  edges.forEach(e => {
    edgeMap.get(e.source)?.add(e.target);
    edgeMap.get(e.target)?.add(e.source);
  });
  
  const idealDist = Math.sqrt((width * height) / result.length) * 0.6;
  const gravity = 0.08;
  const damping = 0.8;
  
  for (let iter = 0; iter < iterations; iter++) {
    // Temperature decreases over iterations (simulated annealing)
    const temp = 1 - iter / iterations;
    const forceScale = 0.1 * (1 + temp);
    
    // Repulsive forces between all nodes
    for (let i = 0; i < result.length; i++) {
      for (let j = i + 1; j < result.length; j++) {
        let dx = result[j].x - result[i].x;
        let dy = result[j].y - result[i].y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        
        // Prevent division by zero and handle overlapping nodes
        if (dist < 1) {
          // Push apart in random direction
          const angle = Math.random() * Math.PI * 2;
          dx = Math.cos(angle);
          dy = Math.sin(angle);
          dist = 1;
        }
        
        // Strong repulsion when nodes are too close (collision avoidance)
        let force: number;
        if (dist < minDistance) {
          // Very strong repulsion to prevent overlap
          force = ((minDistance - dist) / minDistance) * idealDist * 2;
        } else {
          // Standard Coulomb-like repulsion
          force = (idealDist * idealDist) / dist;
        }
        
        const fx = (dx / dist) * force * forceScale;
        const fy = (dy / dist) * force * forceScale;
        
        result[i].vx -= fx;
        result[i].vy -= fy;
        result[j].vx += fx;
        result[j].vy += fy;
      }
    }
    
    // Attractive forces along edges (Hooke's law)
    edges.forEach(e => {
      const source = result.find(n => n.id === e.source);
      const target = result.find(n => n.id === e.target);
      if (!source || !target) return;
      
      const dx = target.x - source.x;
      const dy = target.y - source.y;
      const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);
      
      // Target distance based on edge weight (higher weight = closer)
      const targetDist = idealDist * (0.8 + e.weight * 0.2);
      const force = (dist - targetDist) * 0.05 * temp;
      
      const fx = (dx / dist) * force;
      const fy = (dy / dist) * force;
      
      source.vx += fx;
      source.vy += fy;
      target.vx -= fx;
      target.vy -= fy;
    });
    
    // Gravity towards center (weaker for nodes with many connections)
    result.forEach(n => {
      const connections = edgeMap.get(n.id)?.size || 0;
      const gravityMod = 1 / (1 + connections * 0.3); // Less gravity for well-connected nodes
      
      const dx = width / 2 - n.x;
      const dy = height / 2 - n.y;
      n.vx += dx * gravity * 0.01 * gravityMod;
      n.vy += dy * gravity * 0.01 * gravityMod;
    });
    
    // Apply velocities with damping
    result.forEach(n => {
      n.vx *= damping;
      n.vy *= damping;
      
      // Limit max velocity
      const speed = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
      const maxSpeed = 20 * temp + 5;
      if (speed > maxSpeed) {
        n.vx = (n.vx / speed) * maxSpeed;
        n.vy = (n.vy / speed) * maxSpeed;
      }
      
      n.x += n.vx;
      n.y += n.vy;
      
      // Keep within bounds with padding
      const padding = 80;
      n.x = Math.max(padding, Math.min(width - padding, n.x));
      n.y = Math.max(padding, Math.min(height - padding, n.y));
    });
  }
  
  // Final pass: resolve any remaining overlaps
  for (let pass = 0; pass < 10; pass++) {
    let hasOverlap = false;
    for (let i = 0; i < result.length; i++) {
      for (let j = i + 1; j < result.length; j++) {
        const dx = result[j].x - result[i].x;
        const dy = result[j].y - result[i].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < minDistance) {
          hasOverlap = true;
          const overlap = (minDistance - dist) / 2 + 1;
          const angle = dist > 0 ? Math.atan2(dy, dx) : Math.random() * Math.PI * 2;
          
          result[i].x -= Math.cos(angle) * overlap;
          result[i].y -= Math.sin(angle) * overlap;
          result[j].x += Math.cos(angle) * overlap;
          result[j].y += Math.sin(angle) * overlap;
          
          // Keep within bounds
          result[i].x = Math.max(80, Math.min(width - 80, result[i].x));
          result[i].y = Math.max(80, Math.min(height - 80, result[i].y));
          result[j].x = Math.max(80, Math.min(width - 80, result[j].x));
          result[j].y = Math.max(80, Math.min(height - 80, result[j].y));
        }
      }
    }
    if (!hasOverlap) break;
  }
  
  return result;
}

// ─────────────────────────────────────────────────────────────────────────────
// Graph Canvas Component
// ─────────────────────────────────────────────────────────────────────────────

interface GraphCanvasProps {
  nodes: GraphNode[];
  edges: GraphEdge[];
  selectedNode: string | null;
  hoveredNode: string | null;
  pathNodes: Set<string>;
  onNodeClick: (id: string) => void;
  onNodeHover: (id: string | null) => void;
  zoom: number;
  offset: { x: number; y: number };
  isTerminal: boolean;
}

function GraphCanvas({
  nodes,
  edges,
  selectedNode,
  hoveredNode,
  pathNodes,
  onNodeClick,
  onNodeHover,
  zoom,
  offset,
  isTerminal,
}: GraphCanvasProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>(0);
  const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });
  
  // Handle resize
  useEffect(() => {
    const container = canvasRef.current?.parentElement;
    if (!container) return;
    
    const observer = new ResizeObserver(entries => {
      const { width, height } = entries[0].contentRect;
      setCanvasSize({ width, height });
    });
    
    observer.observe(container);
    return () => observer.disconnect();
  }, []);
  
  // Draw the graph
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    const dpr = window.devicePixelRatio || 1;
    canvas.width = canvasSize.width * dpr;
    canvas.height = canvasSize.height * dpr;
    ctx.scale(dpr, dpr);
    
    const draw = () => {
      // Clear
      ctx.fillStyle = isTerminal ? '#0a0a0f' : '#fafafa';
      ctx.fillRect(0, 0, canvasSize.width, canvasSize.height);
      
      ctx.save();
      ctx.translate(offset.x, offset.y);
      ctx.scale(zoom, zoom);
      
      // Draw grid
      ctx.strokeStyle = isTerminal ? 'rgba(80, 250, 123, 0.05)' : 'rgba(0, 0, 0, 0.03)';
      ctx.lineWidth = 1 / zoom;
      const gridSize = 40;
      for (let x = 0; x < canvasSize.width / zoom; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasSize.height / zoom);
        ctx.stroke();
      }
      for (let y = 0; y < canvasSize.height / zoom; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvasSize.width / zoom, y);
        ctx.stroke();
      }
      
      // Draw edges
      edges.forEach(e => {
        const source = nodes.find(n => n.id === e.source);
        const target = nodes.find(n => n.id === e.target);
        if (!source || !target) return;
        
        const isPath = pathNodes.has(source.id) && pathNodes.has(target.id);
        const isHovered = hoveredNode === source.id || hoveredNode === target.id;
        
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.lineTo(target.x, target.y);
        
        if (isPath) {
          ctx.strokeStyle = isTerminal ? '#bd93f9' : '#8b5cf6';
          ctx.lineWidth = 3 / zoom;
        } else if (isHovered) {
          ctx.strokeStyle = isTerminal ? 'rgba(80, 250, 123, 0.6)' : 'rgba(59, 130, 246, 0.6)';
          ctx.lineWidth = 2 / zoom;
        } else {
          ctx.strokeStyle = isTerminal ? 'rgba(80, 250, 123, 0.15)' : 'rgba(0, 0, 0, 0.1)';
          ctx.lineWidth = 1 / zoom;
        }
        ctx.stroke();
      });
      
      // Draw nodes
      nodes.forEach(n => {
        const isSelected = selectedNode === n.id;
        const isHovered = hoveredNode === n.id;
        const isInPath = pathNodes.has(n.id);
        
        // Node colors by type
        let fillColor: string;
        let strokeColor: string;
        let size = 24;
        
        switch (n.type) {
          case 'post':
            fillColor = isTerminal ? '#50fa7b' : '#22c55e';
            strokeColor = isTerminal ? '#50fa7b' : '#16a34a';
            size = 28;
            break;
          case 'chat':
            fillColor = isTerminal ? '#bd93f9' : '#8b5cf6';
            strokeColor = isTerminal ? '#bd93f9' : '#7c3aed';
            size = 22;
            break;
          case 'comment':
            fillColor = isTerminal ? '#8be9fd' : '#06b6d4';
            strokeColor = isTerminal ? '#8be9fd' : '#0891b2';
            size = 18;
            break;
          case 'question':
            fillColor = isTerminal ? '#ffb86c' : '#f59e0b';
            strokeColor = isTerminal ? '#ffb86c' : '#d97706';
            size = 20;
            break;
          case 'memo':
            fillColor = isTerminal ? '#ff79c6' : '#ec4899';
            strokeColor = isTerminal ? '#ff79c6' : '#db2777';
            size = 20;
            break;
          case 'tag':
            fillColor = isTerminal ? '#f1fa8c' : '#eab308';
            strokeColor = isTerminal ? '#f1fa8c' : '#ca8a04';
            size = 18;
            break;
          case 'search':
            fillColor = isTerminal ? '#8be9fd' : '#0ea5e9';
            strokeColor = isTerminal ? '#8be9fd' : '#0284c7';
            size = 18;
            break;
          default:
            fillColor = isTerminal ? '#6272a4' : '#64748b';
            strokeColor = isTerminal ? '#6272a4' : '#475569';
            size = 20;
        }
        
        if (isSelected || isInPath) {
          size *= 1.3;
        }
        
        // Draw glow for selected/hovered
        if (isSelected || isHovered) {
          ctx.shadowColor = fillColor;
          ctx.shadowBlur = 20;
        }
        
        // Draw node
        ctx.beginPath();
        ctx.arc(n.x, n.y, size / 2, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.strokeStyle = isSelected ? '#fff' : strokeColor;
        ctx.lineWidth = isSelected ? 3 / zoom : 2 / zoom;
        ctx.stroke();
        
        ctx.shadowBlur = 0;
        
        // Draw icon inside node - use dark color for contrast on bright backgrounds
        ctx.fillStyle = isTerminal ? '#1a1a2e' : '#fff';
        ctx.font = `bold ${size * 0.5}px monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        let icon: string;
        switch (n.type) {
          case 'post': icon = 'P'; break;
          case 'chat': icon = 'C'; break;
          case 'comment': icon = 'M'; break;
          case 'question': icon = '?'; break;
          case 'memo': icon = '✎'; break;
          case 'tag': icon = '#'; break;
          case 'search': icon = '⌕'; break;
          default: icon = '•';
        }
        ctx.fillText(icon, n.x, n.y);
        
        // Draw label
        if (isSelected || isHovered || zoom > 0.8) {
          const label = n.label.length > 20 ? n.label.slice(0, 20) + '...' : n.label;
          ctx.font = `${11 / zoom}px monospace`;
          ctx.fillStyle = isTerminal ? 'rgba(80, 250, 123, 0.9)' : 'rgba(0, 0, 0, 0.8)';
          ctx.fillText(label, n.x, n.y + size / 2 + 12 / zoom);
        }
      });
      
      ctx.restore();
      
      animationRef.current = requestAnimationFrame(draw);
    };
    
    draw();
    return () => cancelAnimationFrame(animationRef.current);
  }, [nodes, edges, selectedNode, hoveredNode, pathNodes, zoom, offset, isTerminal, canvasSize]);
  
  // Mouse interaction
  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offset.x) / zoom;
    const y = (e.clientY - rect.top - offset.y) / zoom;
    
    const hovered = nodes.find(n => {
      const dx = n.x - x;
      const dy = n.y - y;
      return Math.sqrt(dx * dx + dy * dy) < 20;
    });
    
    onNodeHover(hovered?.id || null);
    canvas.style.cursor = hovered ? 'pointer' : 'grab';
  };
  
  const handleClick = (e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offset.x) / zoom;
    const y = (e.clientY - rect.top - offset.y) / zoom;
    
    const clicked = nodes.find(n => {
      const dx = n.x - x;
      const dy = n.y - y;
      return Math.sqrt(dx * dx + dy * dy) < 20;
    });
    
    if (clicked) {
      onNodeClick(clicked.id);
    }
  };
  
  return (
    <canvas
      ref={canvasRef}
      width={canvasSize.width}
      height={canvasSize.height}
      style={{ width: '100%', height: '100%' }}
      onMouseMove={handleMouseMove}
      onClick={handleClick}
      onMouseLeave={() => onNodeHover(null)}
    />
  );
}

// ─────────────────────────────────────────────────────────────────────────────
// Main Insight Page Component
// ─────────────────────────────────────────────────────────────────────────────

const Insight = () => {
  const { isTerminal } = useTheme();
  const navigate = useNavigate();
  
  const [nodes, setNodes] = useState<GraphNode[]>([]);
  const [edges, setEdges] = useState<GraphEdge[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedNode, setSelectedNode] = useState<string | null>(null);
  const [hoveredNode, setHoveredNode] = useState<string | null>(null);
  const [pathNodes, setPathNodes] = useState<Set<string>>(new Set());
  const [zoom, setZoom] = useState(1);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [showPreview, setShowPreview] = useState(false);
  const [relatedContent, setRelatedContent] = useState<RelatedContent>({ chats: [], memos: [], thoughts: [] });
  const [allMemoEvents, setAllMemoEvents] = useState<MemoEvent[]>([]);
  const [allChatSessions, setAllChatSessions] = useState<ChatSession[]>([]);
  const [allCuriosityEvents, setAllCuriosityEvents] = useState<CuriosityEvent[]>([]);
  const containerRef = useRef<HTMLDivElement>(null);
  
  // Timeline filter state
  const [timeFilter, setTimeFilter] = useState<'all' | '1d' | '7d' | '30d'>('all');
  const [typeFilters, setTypeFilters] = useState<Set<NodeType>>(new Set(['post', 'chat', 'memo', 'tag', 'search']));
  const [showFilters, setShowFilters] = useState(false);
  
  // Load data and build graph
  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      
      try {
        // Load posts
        const posts = await getPosts();
        
        // Load AI chat sessions from localStorage
        let chatSessions: ChatSession[] = [];
        try {
          const raw = localStorage.getItem('ai_chat_sessions_index');
          if (raw) {
            chatSessions = JSON.parse(raw).filter((s: any) => s && s.id);
          }
        } catch {}
        setAllChatSessions(chatSessions);
        
        // Load memo events from localStorage
        let memoEvents: MemoEvent[] = [];
        try {
          const raw = localStorage.getItem('aiMemo.events');
          if (raw) {
            memoEvents = JSON.parse(raw).filter((e: any) => e && typeof e.t === 'number');
          }
        } catch {}
        setAllMemoEvents(memoEvents);
        
        // Load visited posts
        let visitedPosts: any[] = [];
        try {
          const raw = localStorage.getItem('visited.posts');
          if (raw) {
            visitedPosts = JSON.parse(raw);
          }
        } catch {}
        
        // Load curiosity events
        let curiosityEvents: CuriosityEvent[] = [];
        try {
          curiosityEvents = curiosityTracker.getEvents();
          setAllCuriosityEvents(curiosityEvents);
        } catch {}
        
        // Build nodes
        const newNodes: GraphNode[] = [];
        const newEdges: GraphEdge[] = [];
        
        // Track unique tags and searches from curiosity events
        const tagNodes = new Map<string, { count: number; linkedPosts: string[]; ts: number }>();
        const searchNodes = new Map<string, { count: number; ts: number; queryText?: string }>();
        const memoNodes: { id: string; postId: string; ts: number; snippet?: string }[] = [];
        
        // Process curiosity events
        curiosityEvents.forEach(event => {
          if (event.type === 'tag_click' && event.context.tag) {
            const tag = event.context.tag;
            const existing = tagNodes.get(tag);
            if (existing) {
              existing.count++;
              if (event.context.postId && !existing.linkedPosts.includes(event.context.postId)) {
                existing.linkedPosts.push(event.context.postId);
              }
              if (event.ts > existing.ts) existing.ts = event.ts;
            } else {
              tagNodes.set(tag, {
                count: 1,
                linkedPosts: event.context.postId ? [event.context.postId] : [],
                ts: event.ts,
              });
            }
          } else if (event.type === 'search' && event.context.queryHash) {
            const hash = event.context.queryHash;
            const existing = searchNodes.get(hash);
            if (existing) {
              existing.count++;
              if (event.ts > existing.ts) existing.ts = event.ts;
            } else {
              searchNodes.set(hash, {
                count: 1,
                ts: event.ts,
                queryText: event.context.queryText,
              });
            }
          } else if (event.type === 'memo_create' && event.context.postId) {
            memoNodes.push({
              id: event.id,
              postId: event.context.postId,
              ts: event.ts,
              snippet: event.context.snippet,
            });
          }
        });
        
        // Add post nodes (only visited ones for now, or limit to recent)
        const recentPosts = posts.slice(0, 30);
        recentPosts.forEach((p, i) => {
          newNodes.push({
            id: `post-${p.slug}`,
            type: 'post',
            label: p.title,
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            data: p,
          });
        });
        
        // Add chat session nodes
        chatSessions.slice(0, 20).forEach((s, i) => {
          newNodes.push({
            id: `chat-${s.id}`,
            type: 'chat',
            label: s.title || s.articleTitle || 'AI Chat',
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            data: s,
          });
          
          // Link chat to its article
          if (s.articleUrl) {
            const slug = s.articleUrl.split('/').pop();
            const postId = `post-${slug}`;
            if (newNodes.find(n => n.id === postId)) {
              newEdges.push({
                source: `chat-${s.id}`,
                target: postId,
                weight: 1,
                type: 'chat',
              });
            }
          }
        });
        
        // Add tag nodes from curiosity events
        tagNodes.forEach((data, tag) => {
          const tagId = `tag-${tag}`;
          newNodes.push({
            id: tagId,
            type: 'tag',
            label: `#${tag}`,
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            ts: data.ts,
            data: { tag, count: data.count },
          });
          
          // Link tag to related posts
          data.linkedPosts.forEach(postId => {
            // postId from curiosity event could be slug or year/slug
            const parts = postId.split('/');
            const slug = parts[parts.length - 1];
            const targetPostId = `post-${slug}`;
            if (newNodes.find(n => n.id === targetPostId)) {
              newEdges.push({
                source: tagId,
                target: targetPostId,
                weight: 1,
                type: 'curiosity',
              });
            }
          });
        });
        
        // Add search nodes from curiosity events (limit to top 10)
        const sortedSearches = Array.from(searchNodes.entries())
          .sort((a, b) => b[1].ts - a[1].ts)
          .slice(0, 10);
          
        sortedSearches.forEach(([hash, data]) => {
          const searchId = `search-${hash}`;
          newNodes.push({
            id: searchId,
            type: 'search',
            label: data.queryText || `Search #${data.count}`,
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            ts: data.ts,
            data: { hash, count: data.count, queryText: data.queryText },
          });
        });
        
        // Add memo nodes from curiosity events (limit to 15)
        memoNodes.slice(0, 15).forEach((memo, i) => {
          const memoId = `memo-${memo.id}`;
          newNodes.push({
            id: memoId,
            type: 'memo',
            label: memo.snippet?.slice(0, 30) || 'Memo',
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            ts: memo.ts,
            data: memo,
          });
          
          // Link memo to its post
          const parts = memo.postId.split('/');
          const slug = parts[parts.length - 1];
          const targetPostId = `post-${slug}`;
          if (newNodes.find(n => n.id === targetPostId)) {
            newEdges.push({
              source: memoId,
              target: targetPostId,
              weight: 1,
              type: 'curiosity',
            });
          }
        });
        
        // Build edges based on shared tags/categories
        for (let i = 0; i < recentPosts.length; i++) {
          for (let j = i + 1; j < recentPosts.length; j++) {
            const p1 = recentPosts[i];
            const p2 = recentPosts[j];
            
            // Same category = connected
            if (p1.category === p2.category) {
              newEdges.push({
                source: `post-${p1.slug}`,
                target: `post-${p2.slug}`,
                weight: 2,
                type: 'category',
              });
            }
            
            // Shared tags = connected
            const sharedTags = p1.tags.filter(t => p2.tags.includes(t));
            if (sharedTags.length > 0) {
              newEdges.push({
                source: `post-${p1.slug}`,
                target: `post-${p2.slug}`,
                weight: 3 - Math.min(sharedTags.length, 2),
                type: 'tag',
              });
            }
          }
        }
        
        // Apply force-directed layout
        const containerWidth = containerRef.current?.clientWidth || 800;
        const containerHeight = containerRef.current?.clientHeight || 600;
        const layoutedNodes = simulateForces(newNodes, newEdges, containerWidth, containerHeight, 150);
        
        setNodes(layoutedNodes);
        setEdges(newEdges);
      } catch (err) {
        console.error('Failed to load insight data:', err);
      } finally {
        setLoading(false);
      }
    };
    
    loadData();
  }, []);
  
  // Handle node selection and path finding
  const handleNodeClick = useCallback((id: string) => {
    if (selectedNode === id) {
      // Double-click: open preview panel for posts
      const node = nodes.find(n => n.id === id);
      if (node?.type === 'post') {
        setShowPreview(true);
      } else if (node?.type === 'post' && node.data) {
        navigate(`/blog/${node.data.year}/${node.data.slug}`);
      }
      return;
    }
    
    // Find related content for the selected node
    const node = nodes.find(n => n.id === id);
    if (node?.type === 'post' && node.data) {
      const postKey = `${node.data.year}/${node.data.slug}`;
      
      // Find related chats
      const relatedChats = allChatSessions.filter(s => {
        if (!s.articleUrl) return false;
        return s.articleUrl.includes(node.data.slug);
      });
      
      // Find related memo events (memos and thoughts for this post)
      const relatedMemos = allMemoEvents.filter(e => {
        if (!e.page?.post) return false;
        const eventKey = `${e.page.post.year}/${e.page.post.slug}`;
        return eventKey === postKey && (e.type === 'memo' || e.type === 'save');
      });
      
      const relatedThoughts = allMemoEvents.filter(e => {
        if (!e.page?.post) return false;
        const eventKey = `${e.page.post.year}/${e.page.post.slug}`;
        return eventKey === postKey && e.type === 'thought';
      });
      
      setRelatedContent({
        chats: relatedChats,
        memos: relatedMemos,
        thoughts: relatedThoughts,
      });
    } else {
      setRelatedContent({ chats: [], memos: [], thoughts: [] });
    }
    
    if (selectedNode) {
      // Find shortest path between selected and clicked
      const adj = buildAdjacencyList(nodes, edges);
      const distances = dijkstra(adj, selectedNode);
      
      // Reconstruct path (simplified - just highlight connected nodes)
      const path = new Set<string>([selectedNode, id]);
      
      // Add intermediate nodes with short distances
      nodes.forEach(n => {
        const d = distances.get(n.id);
        if (d !== undefined && d < 5 && d > 0) {
          path.add(n.id);
        }
      });
      
      setPathNodes(path);
    }
    
    setSelectedNode(id);
  }, [selectedNode, nodes, edges, navigate, allChatSessions, allMemoEvents]);
  
  // Zoom controls
  const handleZoomIn = () => setZoom(z => Math.min(z * 1.2, 3));
  const handleZoomOut = () => setZoom(z => Math.max(z / 1.2, 0.3));
  const handleReset = () => {
    setZoom(1);
    setOffset({ x: 0, y: 0 });
    setSelectedNode(null);
    setPathNodes(new Set());
    setShowPreview(false);
    setRelatedContent({ chats: [], memos: [], thoughts: [] });
  };
  
  // Pan controls
  const handleMouseDown = (e: React.MouseEvent) => {
    if (e.button === 0) {
      setIsDragging(true);
      setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y });
    }
  };
  
  const handleMouseMove = (e: React.MouseEvent) => {
    if (isDragging) {
      setOffset({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y,
      });
    }
  };
  
  const handleMouseUp = () => setIsDragging(false);
  
  // Time filter cutoff calculation
  const timeCutoff = useMemo(() => {
    const now = Date.now();
    switch (timeFilter) {
      case '1d': return now - 24 * 60 * 60 * 1000;
      case '7d': return now - 7 * 24 * 60 * 60 * 1000;
      case '30d': return now - 30 * 24 * 60 * 60 * 1000;
      default: return 0;
    }
  }, [timeFilter]);
  
  // Filter nodes based on type and time
  const filteredNodes = useMemo(() => {
    return nodes.filter(n => {
      // Type filter
      if (!typeFilters.has(n.type)) return false;
      
      // Time filter (only for curiosity-based nodes with timestamps)
      if (timeFilter !== 'all' && n.ts && n.ts < timeCutoff) {
        return false;
      }
      
      return true;
    });
  }, [nodes, typeFilters, timeFilter, timeCutoff]);
  
  // Filter edges to only include those connecting visible nodes
  const filteredEdges = useMemo(() => {
    const visibleNodeIds = new Set(filteredNodes.map(n => n.id));
    return edges.filter(e => visibleNodeIds.has(e.source) && visibleNodeIds.has(e.target));
  }, [edges, filteredNodes]);
  
  // Stats based on filtered data
  const stats = useMemo(() => ({
    posts: filteredNodes.filter(n => n.type === 'post').length,
    chats: filteredNodes.filter(n => n.type === 'chat').length,
    connections: filteredEdges.length,
  }), [filteredNodes, filteredEdges]);
  
  return (
    <div className={cn(
      'min-h-screen flex flex-col',
      isTerminal
        ? 'bg-[#0a0a0f] text-[#50fa7b]'
        : 'bg-gradient-to-b from-[#fafafa] to-white'
    )}>
      {/* Header */}
      <header className={cn(
        'sticky top-0 z-50 border-b px-4 py-3',
        isTerminal
          ? 'bg-[#0a0a0f]/95 border-[#50fa7b]/20 backdrop-blur'
          : 'bg-white/95 border-gray-200 backdrop-blur'
      )}>
        <div className='max-w-7xl mx-auto flex items-center justify-between gap-4'>
          <div className='flex items-center gap-3'>
            <Button
              variant='ghost'
              size='icon'
              onClick={() => navigate(-1)}
              className={cn(
                'h-9 w-9',
                isTerminal && 'text-[#50fa7b] hover:bg-[#50fa7b]/10'
              )}
            >
              <ArrowLeft className='h-5 w-5' />
            </Button>
            <div>
              <h1 className={cn(
                'text-lg font-semibold',
                isTerminal && 'font-mono'
              )}>
                {isTerminal ? '// insight_graph' : 'Insight Graph'}
              </h1>
              <p className={cn(
                'text-xs',
                isTerminal ? 'text-[#50fa7b]/60' : 'text-muted-foreground'
              )}>
                {isTerminal ? '> dijkstra_map v1.0' : 'Your content universe'}
              </p>
            </div>
          </div>
          
          {/* Zoom controls */}
          <div className='flex items-center gap-1'>
            <Button
              variant='ghost'
              size='icon'
              onClick={handleZoomOut}
              className={cn('h-8 w-8', isTerminal && 'text-[#50fa7b] hover:bg-[#50fa7b]/10')}
            >
              <ZoomOut className='h-4 w-4' />
            </Button>
            <span className={cn(
              'text-xs font-mono w-12 text-center',
              isTerminal ? 'text-[#50fa7b]/80' : 'text-muted-foreground'
            )}>
              {Math.round(zoom * 100)}%
            </span>
            <Button
              variant='ghost'
              size='icon'
              onClick={handleZoomIn}
              className={cn('h-8 w-8', isTerminal && 'text-[#50fa7b] hover:bg-[#50fa7b]/10')}
            >
              <ZoomIn className='h-4 w-4' />
            </Button>
            <Button
              variant='ghost'
              size='icon'
              onClick={handleReset}
              className={cn('h-8 w-8', isTerminal && 'text-[#50fa7b] hover:bg-[#50fa7b]/10')}
            >
              <RotateCcw className='h-4 w-4' />
            </Button>
          </div>
        </div>
      </header>
      
      {/* Stats bar with filters */}
      <div className={cn(
        'border-b px-4 py-2',
        isTerminal
          ? 'bg-[#0d0d14] border-[#50fa7b]/10'
          : 'bg-gray-50 border-gray-100'
      )}>
        <div className='max-w-7xl mx-auto flex items-center justify-between gap-4 text-xs'>
          <div className='flex items-center gap-4 md:gap-6'>
            <div className='flex items-center gap-2'>
              <FileText className={cn('h-3.5 w-3.5', isTerminal ? 'text-[#50fa7b]' : 'text-green-500')} />
              <span className={isTerminal ? 'font-mono' : ''}>
                {isTerminal ? `posts: ${stats.posts}` : `${stats.posts} Posts`}
              </span>
            </div>
            <div className='flex items-center gap-2'>
              <Sparkles className={cn('h-3.5 w-3.5', isTerminal ? 'text-[#bd93f9]' : 'text-purple-500')} />
              <span className={isTerminal ? 'font-mono' : ''}>
                {isTerminal ? `chats: ${stats.chats}` : `${stats.chats} AI Chats`}
              </span>
            </div>
            <div className='hidden sm:flex items-center gap-2'>
              <Network className={cn('h-3.5 w-3.5', isTerminal ? 'text-[#8be9fd]' : 'text-cyan-500')} />
              <span className={isTerminal ? 'font-mono' : ''}>
                {isTerminal ? `edges: ${stats.connections}` : `${stats.connections} Connections`}
              </span>
            </div>
          </div>
          
          {/* Filter controls */}
          <div className='flex items-center gap-2'>
            {/* Time filter buttons */}
            <div className='hidden md:flex items-center gap-1 border rounded-md p-0.5' style={{
              borderColor: isTerminal ? 'rgba(80, 250, 123, 0.2)' : undefined
            }}>
              {(['1d', '7d', '30d', 'all'] as const).map(t => (
                <button
                  key={t}
                  onClick={() => setTimeFilter(t)}
                  className={cn(
                    'px-2 py-0.5 rounded text-xs transition-colors',
                    timeFilter === t
                      ? isTerminal
                        ? 'bg-[#50fa7b]/20 text-[#50fa7b] font-mono'
                        : 'bg-primary/10 text-primary font-medium'
                      : isTerminal
                        ? 'text-[#50fa7b]/60 hover:bg-[#50fa7b]/10 font-mono'
                        : 'text-muted-foreground hover:bg-muted'
                  )}
                >
                  {t === 'all' ? 'All' : t}
                </button>
              ))}
            </div>
            
            {/* Filter toggle button */}
            <Button
              variant='ghost'
              size='sm'
              onClick={() => setShowFilters(!showFilters)}
              className={cn(
                'h-7 px-2 gap-1',
                isTerminal && 'text-[#50fa7b] hover:bg-[#50fa7b]/10',
                showFilters && (isTerminal ? 'bg-[#50fa7b]/10' : 'bg-muted')
              )}
            >
              <Filter className='h-3.5 w-3.5' />
              <span className='hidden sm:inline'>{isTerminal ? 'filter' : 'Filter'}</span>
            </Button>
          </div>
        </div>
        
        {/* Expanded filter panel */}
        {showFilters && (
          <div className={cn(
            'max-w-7xl mx-auto pt-3 mt-2 border-t flex flex-wrap items-center gap-3',
            isTerminal ? 'border-[#50fa7b]/10' : 'border-gray-200'
          )}>
            {/* Mobile time filter */}
            <div className='md:hidden flex items-center gap-1 border rounded-md p-0.5' style={{
              borderColor: isTerminal ? 'rgba(80, 250, 123, 0.2)' : undefined
            }}>
              {(['1d', '7d', '30d', 'all'] as const).map(t => (
                <button
                  key={t}
                  onClick={() => setTimeFilter(t)}
                  className={cn(
                    'px-2 py-0.5 rounded text-xs transition-colors',
                    timeFilter === t
                      ? isTerminal
                        ? 'bg-[#50fa7b]/20 text-[#50fa7b] font-mono'
                        : 'bg-primary/10 text-primary font-medium'
                      : isTerminal
                        ? 'text-[#50fa7b]/60 hover:bg-[#50fa7b]/10 font-mono'
                        : 'text-muted-foreground hover:bg-muted'
                  )}
                >
                  {t === 'all' ? 'All' : t}
                </button>
              ))}
            </div>
            
            {/* Node type toggles */}
            <div className='flex flex-wrap items-center gap-2'>
              <span className={cn(
                'text-xs',
                isTerminal ? 'font-mono text-[#50fa7b]/60' : 'text-muted-foreground'
              )}>
                {isTerminal ? 'show:' : 'Show:'}
              </span>
              {([
                { type: 'post' as NodeType, label: 'Post', color: isTerminal ? '#50fa7b' : '#22c55e' },
                { type: 'chat' as NodeType, label: 'Chat', color: isTerminal ? '#bd93f9' : '#8b5cf6' },
                { type: 'memo' as NodeType, label: 'Memo', color: isTerminal ? '#ff79c6' : '#ec4899' },
                { type: 'tag' as NodeType, label: 'Tag', color: isTerminal ? '#f1fa8c' : '#eab308' },
                { type: 'search' as NodeType, label: 'Search', color: isTerminal ? '#8be9fd' : '#0ea5e9' },
              ]).map(({ type, label, color }) => (
                <button
                  key={type}
                  onClick={() => {
                    const newFilters = new Set(typeFilters);
                    if (newFilters.has(type)) {
                      newFilters.delete(type);
                    } else {
                      newFilters.add(type);
                    }
                    setTypeFilters(newFilters);
                  }}
                  className={cn(
                    'flex items-center gap-1.5 px-2 py-1 rounded-full text-xs transition-all',
                    typeFilters.has(type)
                      ? 'border-2'
                      : 'border border-dashed opacity-50'
                  )}
                  style={{
                    borderColor: color,
                    backgroundColor: typeFilters.has(type) ? `${color}20` : 'transparent',
                    color: isTerminal ? '#50fa7b' : undefined,
                  }}
                >
                  <div 
                    className='w-2.5 h-2.5 rounded-full'
                    style={{ backgroundColor: typeFilters.has(type) ? color : 'transparent', borderColor: color }}
                  />
                  <span className={isTerminal ? 'font-mono' : ''}>{label}</span>
                </button>
              ))}
            </div>
          </div>
        )}
      </div>
      
      {/* Graph container */}
      <div
        ref={containerRef}
        className='flex-1 relative overflow-hidden cursor-grab active:cursor-grabbing'
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
      >
        {loading ? (
          <div className='absolute inset-0 flex items-center justify-center'>
            <div className={cn(
              'text-center space-y-3',
              isTerminal && 'font-mono'
            )}>
              <div className={cn(
                'w-8 h-8 border-2 rounded-full animate-spin mx-auto',
                isTerminal
                  ? 'border-[#50fa7b]/30 border-t-[#50fa7b]'
                  : 'border-gray-200 border-t-primary'
              )} />
              <p className={isTerminal ? 'text-[#50fa7b]/60' : 'text-muted-foreground'}>
                {isTerminal ? '> loading graph data...' : 'Building your insight graph...'}
              </p>
            </div>
          </div>
        ) : filteredNodes.length === 0 ? (
          <div className='absolute inset-0 flex items-center justify-center'>
            <div className={cn(
              'text-center space-y-4 max-w-sm px-4',
              isTerminal && 'font-mono'
            )}>
              <Network className={cn(
                'h-16 w-16 mx-auto',
                isTerminal ? 'text-[#50fa7b]/30' : 'text-muted-foreground/30'
              )} />
              <h2 className={cn(
                'text-lg font-semibold',
                isTerminal ? 'text-[#50fa7b]' : ''
              )}>
                {nodes.length > 0
                  ? isTerminal ? '> no_matching_nodes' : 'No matching nodes'
                  : isTerminal ? '> no_data_found' : 'No data yet'}
              </h2>
              <p className={cn(
                'text-sm',
                isTerminal ? 'text-[#50fa7b]/60' : 'text-muted-foreground'
              )}>
                {nodes.length > 0
                  ? isTerminal
                    ? '// adjust filters to see more nodes'
                    : 'Try adjusting your filters to see more content.'
                  : isTerminal
                    ? '// read posts and chat with AI to build your knowledge graph'
                    : 'Read some posts and chat with AI to start building your insight graph.'}
              </p>
              {nodes.length === 0 && (
                <Button
                  onClick={() => navigate('/blog')}
                  className={cn(
                    isTerminal && 'bg-[#50fa7b] text-[#052e16] hover:bg-[#50fa7b]/80 font-semibold'
                  )}
                >
                  {isTerminal ? '> explore_posts' : 'Explore Posts'}
                </Button>
              )}
              {nodes.length > 0 && (
                <Button
                  variant='outline'
                  onClick={() => {
                    setTimeFilter('all');
                    setTypeFilters(new Set(['post', 'chat', 'memo', 'tag', 'search']));
                  }}
                  className={cn(
                    isTerminal && 'border-[#50fa7b]/40 text-[#50fa7b] hover:bg-[#50fa7b]/10'
                  )}
                >
                  {isTerminal ? '> reset_filters' : 'Reset Filters'}
                </Button>
              )}
            </div>
          </div>
        ) : (
          <GraphCanvas
            nodes={filteredNodes}
            edges={filteredEdges}
            selectedNode={selectedNode}
            hoveredNode={hoveredNode}
            pathNodes={pathNodes}
            onNodeClick={handleNodeClick}
            onNodeHover={setHoveredNode}
            zoom={zoom}
            offset={offset}
            isTerminal={isTerminal}
          />
        )}
      </div>
      
      {/* Legend */}
      <div className={cn(
        'border-t px-4 py-3',
        isTerminal
          ? 'bg-[#0d0d14] border-[#50fa7b]/10'
          : 'bg-gray-50 border-gray-100'
      )}>
        <div className='max-w-7xl mx-auto flex flex-wrap items-center justify-center gap-4 text-xs'>
          <div className='flex items-center gap-2'>
            <div className={cn(
              'w-4 h-4 rounded-full',
              isTerminal ? 'bg-[#50fa7b]' : 'bg-green-500'
            )} />
            <span className={isTerminal ? 'font-mono text-[#50fa7b]/80' : 'text-muted-foreground'}>
              Post
            </span>
          </div>
          <div className='flex items-center gap-2'>
            <div className={cn(
              'w-4 h-4 rounded-full',
              isTerminal ? 'bg-[#bd93f9]' : 'bg-purple-500'
            )} />
            <span className={isTerminal ? 'font-mono text-[#50fa7b]/80' : 'text-muted-foreground'}>
              AI Chat
            </span>
          </div>
          <div className='flex items-center gap-2'>
            <div className={cn(
              'w-4 h-4 rounded-full',
              isTerminal ? 'bg-[#8be9fd]' : 'bg-cyan-500'
            )} />
            <span className={isTerminal ? 'font-mono text-[#50fa7b]/80' : 'text-muted-foreground'}>
              Comment
            </span>
          </div>
          <div className='flex items-center gap-2'>
            <div className={cn(
              'w-4 h-4 rounded-full',
              isTerminal ? 'bg-[#ffb86c]' : 'bg-amber-500'
            )} />
            <span className={isTerminal ? 'font-mono text-[#50fa7b]/80' : 'text-muted-foreground'}>
              Question
            </span>
          </div>
          <div className='flex items-center gap-2'>
            <div className={cn(
              'w-4 h-4 rounded-full',
              isTerminal ? 'bg-[#ff79c6]' : 'bg-pink-500'
            )} />
            <span className={isTerminal ? 'font-mono text-[#50fa7b]/80' : 'text-muted-foreground'}>
              Memo
            </span>
          </div>
          <div className='flex items-center gap-2'>
            <div className={cn(
              'w-4 h-4 rounded-full',
              isTerminal ? 'bg-[#f1fa8c]' : 'bg-yellow-500'
            )} />
            <span className={isTerminal ? 'font-mono text-[#50fa7b]/80' : 'text-muted-foreground'}>
              Tag
            </span>
          </div>
          <div className='flex items-center gap-2'>
            <div className={cn(
              'w-4 h-4 rounded-full',
              isTerminal ? 'bg-[#8be9fd]' : 'bg-sky-500'
            )} />
            <span className={isTerminal ? 'font-mono text-[#50fa7b]/80' : 'text-muted-foreground'}>
              Search
            </span>
          </div>
          <span className={cn(
            'hidden sm:inline',
            isTerminal ? 'font-mono text-[#50fa7b]/40' : 'text-muted-foreground/60'
          )}>
            {isTerminal ? '| click: select | double-click: preview |' : '• Click to select • Double-click to preview'}
          </span>
        </div>
      </div>
      
      {/* Selected node info panel (compact) */}
      {selectedNode && !showPreview && (
        <div className={cn(
          'fixed bottom-20 left-4 right-4 md:left-auto md:right-4 md:w-80 rounded-xl border p-4 shadow-lg',
          isTerminal
            ? 'bg-[#0d0d14]/95 border-[#50fa7b]/20 backdrop-blur'
            : 'bg-white/95 border-gray-200 backdrop-blur'
        )}>
          {(() => {
            const node = nodes.find(n => n.id === selectedNode);
            if (!node) return null;
            
            const hasRelated = relatedContent.chats.length > 0 || relatedContent.memos.length > 0 || relatedContent.thoughts.length > 0;
            
            return (
              <div className='space-y-2'>
                <div className='flex items-center justify-between'>
                  <div className='flex items-center gap-2'>
                    {node.type === 'post' && <FileText className={cn('h-4 w-4', isTerminal ? 'text-[#50fa7b]' : 'text-green-500')} />}
                    {node.type === 'chat' && <Sparkles className={cn('h-4 w-4', isTerminal ? 'text-[#bd93f9]' : 'text-purple-500')} />}
                    {node.type === 'comment' && <MessageSquare className={cn('h-4 w-4', isTerminal ? 'text-[#8be9fd]' : 'text-cyan-500')} />}
                    <span className={cn(
                      'text-xs uppercase tracking-wide',
                      isTerminal ? 'font-mono text-[#50fa7b]/60' : 'text-muted-foreground'
                    )}>
                      {node.type}
                    </span>
                  </div>
                  {hasRelated && (
                    <span className={cn(
                      'text-xs px-2 py-0.5 rounded-full',
                      isTerminal ? 'bg-[#bd93f9]/20 text-[#bd93f9] font-mono' : 'bg-purple-100 text-purple-700'
                    )}>
                      +{relatedContent.chats.length + relatedContent.memos.length + relatedContent.thoughts.length} related
                    </span>
                  )}
                </div>
                <h3 className={cn(
                  'font-semibold line-clamp-2',
                  isTerminal && 'font-mono text-[#50fa7b]'
                )}>
                  {node.label}
                </h3>
                {node.data?.category && (
                  <p className={cn(
                    'text-xs',
                    isTerminal ? 'font-mono text-[#50fa7b]/60' : 'text-muted-foreground'
                  )}>
                    {isTerminal ? `category: ${node.data.category}` : node.data.category}
                  </p>
                )}
                <div className='flex gap-2 mt-3'>
                  {node.type === 'post' && (
                    <Button
                      size='sm'
                      variant='outline'
                      className={cn(
                        'flex-1',
                        isTerminal 
                          ? 'border-[#50fa7b]/40 text-[#50fa7b] hover:bg-[#50fa7b]/10 font-mono' 
                          : 'border-gray-300 hover:border-primary/60 hover:bg-primary/5'
                      )}
                      onClick={() => setShowPreview(true)}
                    >
                      {isTerminal ? '> preview' : 'Preview'}
                    </Button>
                  )}
                  <Button
                    size='sm'
                    className={cn(
                      'flex-1',
                      isTerminal 
                        ? 'bg-[#50fa7b] text-[#052e16] hover:bg-[#50fa7b]/80 font-mono font-semibold' 
                        : 'bg-primary text-primary-foreground hover:bg-primary/90'
                    )}
                    onClick={() => {
                      if (node.type === 'post' && node.data) {
                        navigate(`/blog/${node.data.year}/${node.data.slug}`);
                      }
                    }}
                  >
                    {isTerminal ? '> open' : 'Open'}
                  </Button>
                </div>
              </div>
            );
          })()}
        </div>
      )}
      
      {/* Full preview panel with aggregated content */}
      {showPreview && selectedNode && (
        <div className={cn(
          'fixed inset-4 md:left-auto md:right-4 md:top-20 md:bottom-20 md:w-[400px] rounded-xl border shadow-xl overflow-hidden flex flex-col',
          isTerminal
            ? 'bg-[#0d0d14] border-[#50fa7b]/20'
            : 'bg-white border-gray-200'
        )}>
          {(() => {
            const node = nodes.find(n => n.id === selectedNode);
            if (!node) return null;
            
            return (
              <>
                {/* Header */}
                <div className={cn(
                  'flex items-start justify-between gap-3 p-4 border-b',
                  isTerminal ? 'border-[#50fa7b]/10' : 'border-gray-100'
                )}>
                  <div className='flex-1 min-w-0'>
                    <div className='flex items-center gap-2 mb-2'>
                      <FileText className={cn('h-4 w-4 shrink-0', isTerminal ? 'text-[#50fa7b]' : 'text-green-500')} />
                      <span className={cn(
                        'text-xs uppercase tracking-wide',
                        isTerminal ? 'font-mono text-[#50fa7b]/60' : 'text-muted-foreground'
                      )}>
                        {node.type}
                      </span>
                    </div>
                    <h3 className={cn(
                      'font-semibold text-lg leading-tight',
                      isTerminal && 'font-mono text-[#50fa7b]'
                    )}>
                      {node.label}
                    </h3>
                    {node.data?.category && (
                      <p className={cn(
                        'text-xs mt-1',
                        isTerminal ? 'font-mono text-[#50fa7b]/60' : 'text-muted-foreground'
                      )}>
                        {node.data.category}
                        {node.data?.date && ` • ${new Date(node.data.date).toLocaleDateString()}`}
                      </p>
                    )}
                  </div>
                  <Button
                    variant='ghost'
                    size='icon'
                    onClick={() => setShowPreview(false)}
                    className={cn('h-8 w-8 shrink-0', isTerminal && 'text-[#50fa7b] hover:bg-[#50fa7b]/10')}
                  >
                    <X className='h-4 w-4' />
                  </Button>
                </div>
                
                {/* Content */}
                <div className={cn(
                  'flex-1 overflow-y-auto p-4 space-y-4',
                  isTerminal ? 'scrollbar-thin scrollbar-thumb-[#50fa7b]/20' : ''
                )}>
                  {/* Post excerpt */}
                  {node.data?.excerpt && (
                    <div className={cn(
                      'p-3 rounded-lg',
                      isTerminal ? 'bg-[#50fa7b]/5 border border-[#50fa7b]/10' : 'bg-gray-50'
                    )}>
                      <p className={cn(
                        'text-sm',
                        isTerminal ? 'font-mono text-[#50fa7b]/80' : 'text-muted-foreground'
                      )}>
                        {node.data.excerpt}
                      </p>
                    </div>
                  )}
                  
                  {/* Tags */}
                  {node.data?.tags?.length > 0 && (
                    <div className='flex flex-wrap gap-1.5'>
                      {node.data.tags.map((tag: string) => (
                        <span
                          key={tag}
                          className={cn(
                            'text-xs px-2 py-0.5 rounded-full',
                            isTerminal
                              ? 'bg-[#50fa7b]/10 text-[#50fa7b]/80 font-mono'
                              : 'bg-gray-100 text-gray-600'
                          )}
                        >
                          #{tag}
                        </span>
                      ))}
                    </div>
                  )}
                  
                  {/* Related AI Chats */}
                  {relatedContent.chats.length > 0 && (
                    <div>
                      <h4 className={cn(
                        'flex items-center gap-2 text-sm font-medium mb-2',
                        isTerminal ? 'font-mono text-[#bd93f9]' : 'text-purple-600'
                      )}>
                        <Sparkles className='h-3.5 w-3.5' />
                        AI Conversations ({relatedContent.chats.length})
                      </h4>
                      <div className='space-y-2'>
                        {relatedContent.chats.slice(0, 5).map((chat) => (
                          <div
                            key={chat.id}
                            className={cn(
                              'p-2.5 rounded-lg text-sm cursor-pointer transition-colors',
                              isTerminal
                                ? 'bg-[#bd93f9]/10 hover:bg-[#bd93f9]/20 border border-[#bd93f9]/20'
                                : 'bg-purple-50 hover:bg-purple-100'
                            )}
                          >
                            <p className={cn(
                              'font-medium line-clamp-1',
                              isTerminal ? 'font-mono text-[#bd93f9]' : 'text-purple-700'
                            )}>
                              {chat.title || chat.summary || 'AI Chat Session'}
                            </p>
                            {chat.updatedAt && (
                              <p className={cn(
                                'text-xs mt-0.5 flex items-center gap-1',
                                isTerminal ? 'text-[#bd93f9]/60' : 'text-purple-500'
                              )}>
                                <Calendar className='h-3 w-3' />
                                {new Date(chat.updatedAt).toLocaleDateString()}
                              </p>
                            )}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Related Memos */}
                  {relatedContent.memos.length > 0 && (
                    <div>
                      <h4 className={cn(
                        'flex items-center gap-2 text-sm font-medium mb-2',
                        isTerminal ? 'font-mono text-[#8be9fd]' : 'text-cyan-600'
                      )}>
                        <PenLine className='h-3.5 w-3.5' />
                        Saved Memos ({relatedContent.memos.length})
                      </h4>
                      <div className='space-y-2'>
                        {relatedContent.memos.slice(0, 5).map((memo, i) => (
                          <div
                            key={`memo-${i}`}
                            className={cn(
                              'p-2.5 rounded-lg text-sm',
                              isTerminal
                                ? 'bg-[#8be9fd]/10 border border-[#8be9fd]/20'
                                : 'bg-cyan-50'
                            )}
                          >
                            <p className={cn(
                              'line-clamp-2',
                              isTerminal ? 'font-mono text-[#8be9fd]/80' : 'text-cyan-700'
                            )}>
                              {memo.label || memo.content || 'Memo saved'}
                            </p>
                            <p className={cn(
                              'text-xs mt-1 flex items-center gap-1',
                              isTerminal ? 'text-[#8be9fd]/60' : 'text-cyan-500'
                            )}>
                              <Calendar className='h-3 w-3' />
                              {new Date(memo.t).toLocaleDateString()}
                            </p>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Related Thoughts */}
                  {relatedContent.thoughts.length > 0 && (
                    <div>
                      <h4 className={cn(
                        'flex items-center gap-2 text-sm font-medium mb-2',
                        isTerminal ? 'font-mono text-[#ffb86c]' : 'text-amber-600'
                      )}>
                        <Lightbulb className='h-3.5 w-3.5' />
                        Thoughts ({relatedContent.thoughts.length})
                      </h4>
                      <div className='space-y-2'>
                        {relatedContent.thoughts.slice(0, 5).map((thought, i) => (
                          <div
                            key={`thought-${i}`}
                            className={cn(
                              'p-2.5 rounded-lg text-sm',
                              isTerminal
                                ? 'bg-[#ffb86c]/10 border border-[#ffb86c]/20'
                                : 'bg-amber-50'
                            )}
                          >
                            <p className={cn(
                              'line-clamp-3',
                              isTerminal ? 'font-mono text-[#ffb86c]/80' : 'text-amber-700'
                            )}>
                              {thought.content || thought.label || 'Thought captured'}
                            </p>
                            <p className={cn(
                              'text-xs mt-1 flex items-center gap-1',
                              isTerminal ? 'text-[#ffb86c]/60' : 'text-amber-500'
                            )}>
                              <Calendar className='h-3 w-3' />
                              {new Date(thought.t).toLocaleDateString()}
                            </p>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* No related content message */}
                  {relatedContent.chats.length === 0 && 
                   relatedContent.memos.length === 0 && 
                   relatedContent.thoughts.length === 0 && (
                    <div className={cn(
                      'text-center py-6',
                      isTerminal ? 'text-[#50fa7b]/40' : 'text-muted-foreground'
                    )}>
                      <MessageSquare className='h-8 w-8 mx-auto mb-2 opacity-50' />
                      <p className={cn('text-sm', isTerminal && 'font-mono')}>
                        {isTerminal ? '// no related content yet' : 'No related content yet'}
                      </p>
                      <p className={cn('text-xs mt-1', isTerminal && 'font-mono')}>
                        {isTerminal 
                          ? '// use ai chat or memo pad on this post'
                          : 'Use AI Chat or Memo Pad while reading this post'}
                      </p>
                    </div>
                  )}
                </div>
                
                {/* Footer actions */}
                <div className={cn(
                  'p-4 border-t sticky bottom-0',
                  isTerminal 
                    ? 'border-[#50fa7b]/10 bg-[#0d0d14]' 
                    : 'border-gray-100 bg-white'
                )}>
                  <Button
                    className={cn(
                      'w-full gap-2',
                      isTerminal 
                        ? 'bg-[#50fa7b] text-[#052e16] hover:bg-[#50fa7b]/80 font-mono font-semibold' 
                        : 'bg-primary text-primary-foreground hover:bg-primary/90'
                    )}
                    onClick={() => {
                      if (node.type === 'post' && node.data) {
                        navigate(`/blog/${node.data.year}/${node.data.slug}`);
                      }
                    }}
                  >
                    <ExternalLink className='h-4 w-4' />
                    {isTerminal ? '> open_post' : 'Open Post'}
                  </Button>
                </div>
              </>
            );
          })()}
        </div>
      )}
    </div>
  );
};

export default Insight;

```

### NewPost.tsx

**Path:** `frontend/src/pages/NewPost.tsx`

```tsx
import { useEffect, useMemo, useRef, useState } from 'react';
import { useMutation } from '@tanstack/react-query';
import {
  adminLogin,
  createPostPR,
  type CreatePostPayload,
  uploadPostImages,
} from '@/services/admin';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { useToast } from '@/hooks/use-toast';
import MarkdownRenderer from '@/components/features/blog/MarkdownRenderer';

export default function NewPost() {
  const { toast } = useToast();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [token, setToken] = useState<string | null>(null);

  const [title, setTitle] = useState('');
  const [slug, setSlug] = useState('');
  const [year, setYear] = useState<string>(new Date().getFullYear().toString());
  const [category, setCategory] = useState('General');
  const [tags, setTags] = useState('');
  const [published, setPublished] = useState(true);
  const [coverImage, setCoverImage] = useState('');
  const [content, setContent] = useState('');

  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const [uploading, setUploading] = useState(false);
  const [uploaded, setUploaded] = useState<
    Array<{ url: string; variantWebp?: { url: string } | null }>
  >([]);

  // Restore token from localStorage on mount
  useEffect(() => {
    try {
      const saved = localStorage.getItem('admin.token');
      if (saved) setToken(saved);
    } catch {}
  }, []);

  const doLogin = useMutation({
    mutationFn: async () => {
      const t = await adminLogin(username, password);
      setToken(t);
      try {
        localStorage.setItem('admin.token', t);
        window.dispatchEvent(new Event('admin-auth-changed'));
      } catch {}
      return t;
    },
    onSuccess: () =>
      toast({ title: '로그인 성공', description: '관리자 인증 완료' }),
    onError: (e: any) =>
      toast({
        title: '로그인 실패',
        description: e?.message || '인증 실패',
        variant: 'destructive',
      }),
  });

  const logout = () => {
    setToken(null);
    try {
      localStorage.removeItem('admin.token');
      window.dispatchEvent(new Event('admin-auth-changed'));
    } catch {}
  };

  const createPr = useMutation({
    mutationFn: async () => {
      if (!token) throw new Error('먼저 로그인하세요');
      const payload: CreatePostPayload = {
        title: title.trim() || slug.trim() || 'New Post',
        slug: slug.trim() || undefined,
        year,
        content,
        frontmatter: {
          category: category || 'General',
          tags: tags
            .split(',')
            .map(s => s.trim())
            .filter(Boolean),
          coverImage: coverImage || undefined,
          published,
        },
      };
      return await createPostPR(payload, token);
    },
    onSuccess: data => {
      toast({ title: 'PR 생성됨', description: data.prUrl });
      try {
        window.open(data.prUrl, '_blank');
      } catch {}
    },
    onError: (e: any) =>
      toast({
        title: 'PR 생성 실패',
        description: e?.message || '오류',
        variant: 'destructive',
      }),
  });

  const doUpload = async () => {
    try {
      if (!token) throw new Error('먼저 로그인하세요');
      if (!year || !/^[0-9]{4}$/.test(year))
        throw new Error('연도(YYYY)를 입력하세요');
      if (!slug.trim()) throw new Error('슬러그를 입력하세요');
      const input = fileInputRef.current;
      if (!input || !input.files || input.files.length === 0)
        throw new Error('업로드할 파일을 선택하세요');
      setUploading(true);
      const files = Array.from(input.files);
      const res = await uploadPostImages(
        { year, slug: slug.trim() },
        files,
        token
      );
      setUploaded(prev => [...res.items, ...prev]);
      toast({
        title: '업로드 완료',
        description: `${res.items.length}개 업로드됨`,
      });
      // Clear selection
      input.value = '';
    } catch (e: any) {
      toast({
        title: '업로드 실패',
        description: e?.message || '오류',
        variant: 'destructive',
      });
    } finally {
      setUploading(false);
    }
  };

  const insertAtCursor = (text: string) => {
    setContent(prev =>
      prev
        ? prev + (prev.endsWith('\n') ? '' : '\n') + text + '\n'
        : text + '\n'
    );
  };

  const previewContent = useMemo(() => {
    const lines: string[] = [];
    if (title.trim()) lines.push(`# ${title.trim()}`);
    if (coverImage.trim()) lines.push(`![cover](${coverImage.trim()})`);
    if (tags.trim()) lines.push(`\n> 태그: ${tags}`);
    if (category.trim()) lines.push(`> 카테고리: ${category}`);
    if (!published) lines.push('> 상태: Draft');
    if (lines.length) lines.push('');
    return [lines.join('\n'), content].filter(Boolean).join('\n');
  }, [title, coverImage, tags, category, published, content]);

  return (
    <div className='container mx-auto px-4 py-8 max-w-5xl'>
      <Card>
        <CardHeader>
          <CardTitle>게시글 작성 (PR 생성)</CardTitle>
        </CardHeader>
        <CardContent className='space-y-6'>
          <div className='grid grid-cols-1 md:grid-cols-2 gap-4'>
            <div>
              <Label htmlFor='username'>관리자 아이디</Label>
              <Input
                id='username'
                value={username}
                onChange={e => setUsername(e.target.value)}
                placeholder='admin'
              />
            </div>
            <div>
              <Label htmlFor='password'>관리자 비밀번호</Label>
              <Input
                id='password'
                type='password'
                value={password}
                onChange={e => setPassword(e.target.value)}
                placeholder='••••••'
              />
            </div>
          </div>
          <div className='flex items-center gap-3'>
            <Button
              onClick={() => doLogin.mutate()}
              disabled={doLogin.isPending}
            >
              {doLogin.isPending
                ? '로그인 중…'
                : token
                  ? '다시 로그인'
                  : '로그인'}
            </Button>
            {token && (
              <>
                <span className='text-sm text-green-600'>로그인됨</span>
                <Button variant='secondary' onClick={logout}>
                  로그아웃
                </Button>
              </>
            )}
          </div>

          <hr className='my-4' />

          <div className='grid grid-cols-1 md:grid-cols-2 gap-4'>
            <div>
              <Label htmlFor='title'>제목</Label>
              <Input
                id='title'
                value={title}
                onChange={e => setTitle(e.target.value)}
                placeholder='글 제목'
              />
            </div>
            <div>
              <Label htmlFor='slug'>슬러그</Label>
              <Input
                id='slug'
                value={slug}
                onChange={e => setSlug(e.target.value)}
                placeholder='my-new-post'
              />
            </div>
            <div>
              <Label htmlFor='year'>연도</Label>
              <Input
                id='year'
                value={year}
                onChange={e => setYear(e.target.value)}
                placeholder='2025'
              />
            </div>
            <div>
              <Label htmlFor='category'>카테고리</Label>
              <Input
                id='category'
                value={category}
                onChange={e => setCategory(e.target.value)}
                placeholder='General'
              />
            </div>
            <div className='md:col-span-2'>
              <Label htmlFor='tags'>태그 (쉼표로 구분)</Label>
              <Input
                id='tags'
                value={tags}
                onChange={e => setTags(e.target.value)}
                placeholder='react, typescript'
              />
            </div>
            <div className='md:col-span-2'>
              <Label htmlFor='coverImage'>커버 이미지 URL (선택)</Label>
              <Input
                id='coverImage'
                value={coverImage}
                onChange={e => setCoverImage(e.target.value)}
                placeholder='/images/cover.jpg'
              />
            </div>
            <div>
              <label className='inline-flex items-center space-x-2'>
                <input
                  type='checkbox'
                  checked={published}
                  onChange={e => setPublished(e.target.checked)}
                />
                <span>공개</span>
              </label>
            </div>
          </div>

          <div className='grid grid-cols-1 md:grid-cols-2 gap-6'>
            <div>
              <Label htmlFor='content'>내용 (Markdown)</Label>
              <Textarea
                id='content'
                value={content}
                onChange={e => setContent(e.target.value)}
                className='min-h-[360px]'
                placeholder='# 새 글 시작...'
              />
            </div>
            <div>
              <Label>미리보기</Label>
              <div className='border rounded-md p-4 min-h-[360px] bg-background'>
                <MarkdownRenderer content={previewContent} />
              </div>
            </div>
          </div>

          <div className='space-y-3'>
            <div className='flex flex-col md:flex-row gap-3 md:items-end'>
              <div className='flex-1'>
                <Label>이미지 업로드</Label>
                <Input
                  ref={fileInputRef}
                  type='file'
                  accept='image/*'
                  multiple
                />
              </div>
              <Button onClick={doUpload} disabled={uploading || !token}>
                {uploading ? '업로드 중…' : '이미지 업로드'}
              </Button>
            </div>
            {uploaded.length > 0 && (
              <div className='border rounded-md p-3 space-y-2'>
                <div className='text-sm text-muted-foreground'>
                  업로드된 파일 (클릭하면 마크다운 삽입)
                </div>
                <ul className='space-y-1 text-sm'>
                  {uploaded.map((u, idx) => (
                    <li key={idx} className='flex items-center gap-2'>
                      <button
                        className='text-primary hover:underline'
                        onClick={() =>
                          insertAtCursor(
                            `![image](${u.variantWebp?.url || u.url})`
                          )
                        }
                        title='마크다운 삽입'
                      >
                        {u.variantWebp?.url || u.url}
                      </button>
                      <Button
                        size='sm'
                        variant='secondary'
                        onClick={() =>
                          navigator.clipboard.writeText(
                            u.variantWebp?.url || u.url
                          )
                        }
                      >
                        복사
                      </Button>
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>

          <div className='flex gap-3'>
            <Button
              onClick={() => createPr.mutate()}
              disabled={createPr.isPending || !token}
            >
              {createPr.isPending ? 'PR 생성 중…' : 'PR 생성하기'}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

```

### NotFound.tsx

**Path:** `frontend/src/pages/NotFound.tsx`

```tsx
import { Link } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Home, Search } from 'lucide-react';

const NotFound = () => {
  return (
    <div className='container mx-auto px-4 py-16 sm:py-24'>
      <div className='mx-auto max-w-2xl text-center'>
        <div className='mb-8'>
          <h1 className='text-9xl font-bold text-primary/20'>404</h1>
          <h2 className='mt-4 text-3xl font-bold tracking-tight sm:text-4xl'>
            Page not found
          </h2>
          <p className='mt-4 text-lg text-muted-foreground'>
            Sorry, we couldn't find the page you're looking for. The page might
            have been moved or deleted.
          </p>
        </div>

        <div className='flex flex-col sm:flex-row gap-4 justify-center'>
          <Button asChild size='lg'>
            <Link to='/'>
              <Home className='mr-2 h-4 w-4' />
              Go to Homepage
            </Link>
          </Button>
          <Button asChild variant='outline' size='lg'>
            <Link to='/blog'>
              <Search className='mr-2 h-4 w-4' />
              Browse Blog Posts
            </Link>
          </Button>
        </div>

        <div className='mt-12'>
          <h3 className='text-sm font-semibold text-muted-foreground'>
            Popular posts
          </h3>
          <div className='mt-4 space-y-2'>
            <Link
              to='/blog/2025/ai-models-for-coding'
              className='block text-sm text-primary hover:underline'
            >
              AI Models for Coding: A Comprehensive Guide
            </Link>
            <Link
              to='/blog/2025/docker-kubernetes-guide'
              className='block text-sm text-primary hover:underline'
            >
              Docker & Kubernetes: Modern Container Orchestration
            </Link>
            <Link
              to='/blog/2025/react-nextjs-modern-web-development'
              className='block text-sm text-primary hover:underline'
            >
              React & Next.js: Modern Web Development
            </Link>
          </div>
        </div>
      </div>
    </div>
  );
};

export default NotFound;

```

---

## frontend/src/services

### admin.ts

**Path:** `frontend/src/services/admin.ts`

```typescript
import { getApiBaseUrl } from '@/utils/apiBase';

export type CreatePostPayload = {
  title: string;
  slug?: string;
  year?: string | number;
  content: string;
  frontmatter?: Record<string, any>;
  draft?: boolean;
};

export async function adminLogin(
  username: string,
  password: string
): Promise<string> {
  const base = getApiBaseUrl();
  const res = await fetch(`${base}/api/v1/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, password }),
  });
  const json = await res.json().catch(() => ({}));
  if (!res.ok || !json?.ok) {
    throw new Error(json?.error || 'Login failed');
  }
  const token = json.data?.token as string;
  if (!token) throw new Error('No token returned');
  return token;
}

export async function createPostPR(
  payload: CreatePostPayload,
  token: string
): Promise<{ prUrl: string; branch: string; path: string }> {
  const base = getApiBaseUrl();
  const res = await fetch(`${base}/api/v1/admin/create-post-pr`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(payload),
  });
  const json = await res.json().catch(() => ({}));
  if (!res.ok || !json?.ok) {
    throw new Error(json?.error || 'Failed to create PR');
  }
  return json.data as { prUrl: string; branch: string; path: string };
}

export async function uploadPostImages(
  params: { year: string | number; slug: string },
  files: File[],
  token: string
): Promise<{
  dir: string;
  items: Array<{ url: string; variantWebp?: { url: string } | null }>;
}> {
  const base = getApiBaseUrl();
  const fd = new FormData();
  fd.append('year', String(params.year));
  fd.append('slug', params.slug);
  for (const f of files) fd.append('files', f, f.name);

  const res = await fetch(`${base}/api/v1/images/upload`, {
    method: 'POST',
    headers: { Authorization: `Bearer ${token}` },
    body: fd,
  });
  const json = await res.json().catch(() => ({}));
  if (!res.ok || !json?.ok) {
    throw new Error(json?.error || 'Failed to upload');
  }
  return json.data as {
    dir: string;
    items: Array<{ url: string; variantWebp?: { url: string } | null }>;
  };
}

```

### ai.ts

**Path:** `frontend/src/services/ai.ts`

```typescript
/**
 * AI Client for Inline Features
 * 
 * Thin Client 구조:
 * - 프론트엔드는 mode와 payload만 전송
 * - 프롬프트 생성 및 LLM 호출은 Workers에서 처리
 * - 에러 시 클라이언트 사이드 폴백 제공
 */
import { ensureSession } from '@/services/chat';
import { getApiBaseUrl } from '@/utils/apiBase';

// ============================================================================
// Types
// ============================================================================

export type SketchResult = {
  mood: string;
  bullets: string[];
};

export type PrismResult = {
  facets: Array<{
    title: string;
    points: string[];
  }>;
};

export type ChainResult = {
  questions: Array<{
    q: string;
    why: string;
  }>;
};

export type SummaryResult = {
  summary: string;
  keyPoints?: string[];
};

type TaskMode = 'sketch' | 'prism' | 'chain' | 'summary' | 'custom';

type TaskPayload = {
  paragraph?: string;
  postTitle?: string;
  persona?: string;
  [key: string]: unknown;
};

type TaskResponse<T> = {
  ok: boolean;
  data: T;
  mode: string;
  source?: 'ai-call' | 'gemini' | 'fallback';
  _fallback?: boolean;
};

// ============================================================================
// Utilities
// ============================================================================

/**
 * 객체인지 확인
 */
function isRecord(v: unknown): v is Record<string, unknown> {
  return v !== null && typeof v === 'object';
}

/**
 * JSON 파싱 (서버 응답이 문자열인 경우 대비)
 */
function tryParseJson<T = unknown>(text: string): T | null {
  if (!text || typeof text !== 'string') return null;

  // 직접 파싱
  try {
    return JSON.parse(text) as T;
  } catch {
    // continue
  }

  // 코드블록 추출
  const fence = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fence?.[1]) {
    try {
      return JSON.parse(fence[1].trim()) as T;
    } catch {
      // continue
    }
  }

  // { } 서브스트링
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start >= 0 && end > start) {
    try {
      return JSON.parse(text.slice(start, end + 1)) as T;
    } catch {
      // continue
    }
  }

  return null;
}

/**
 * 텍스트 안전 자르기 (폴백용)
 */
function safeTruncate(s: string, maxLength: number): string {
  if (!s) return '';
  return s.length > maxLength ? `${s.slice(0, maxLength - 1)}...` : s;
}

// ============================================================================
// Core API
// ============================================================================

/**
 * Workers API를 통해 AI Task 실행
 * 
 * 프론트엔드는 mode와 payload만 전송합니다.
 * 프롬프트 생성은 Workers에서 처리됩니다.
 */
async function invokeTask<T>(
  mode: TaskMode,
  payload: TaskPayload
): Promise<T> {
  const sessionId = await ensureSession();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/chat/session/${encodeURIComponent(sessionId)}/task`;

  const body = {
    mode,
    payload, // 프롬프트 없이 payload만 전송
    context: {
      url: typeof window !== 'undefined' ? window.location.href : undefined,
      title: typeof document !== 'undefined' ? document.title : undefined,
    },
  };

  const res = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`AI task error: ${res.status} ${text.slice(0, 180)}`);
  }

  const result = (await res.json()) as TaskResponse<T>;

  // data 추출 (다양한 응답 구조 대응)
  const data = result?.data ?? (result as unknown as { result?: T })?.result ?? result;

  if (!data) {
    throw new Error('Invalid AI task response: no data');
  }

  return data as T;
}

/**
 * 응답 데이터 검증 및 정규화
 */
function normalizeResponse<T>(
  raw: unknown,
  validator: (data: unknown) => data is T
): T | null {
  // 직접 검증
  if (validator(raw)) {
    return raw;
  }

  // nested data 구조 확인
  if (isRecord(raw) && 'data' in raw && validator(raw.data)) {
    return raw.data as T;
  }

  // _raw.text 구조 확인 (LLM 응답 파싱 실패 시)
  if (isRecord(raw) && '_raw' in raw) {
    const rawData = raw._raw;
    // _raw가 문자열인 경우
    if (typeof rawData === 'string') {
      const parsed = tryParseJson<T>(rawData);
      if (parsed && validator(parsed)) {
        return parsed;
      }
    }
    // _raw.text가 문자열인 경우
    if (isRecord(rawData) && typeof rawData.text === 'string') {
      const parsed = tryParseJson<T>(rawData.text);
      if (parsed && validator(parsed)) {
        return parsed;
      }
    }
  }

  // nested data._raw 구조 확인
  if (isRecord(raw) && 'data' in raw && isRecord(raw.data) && '_raw' in raw.data) {
    const rawData = (raw.data as Record<string, unknown>)._raw;
    if (typeof rawData === 'string') {
      const parsed = tryParseJson<T>(rawData);
      if (parsed && validator(parsed)) {
        return parsed;
      }
    }
    if (isRecord(rawData) && typeof rawData.text === 'string') {
      const parsed = tryParseJson<T>(rawData.text);
      if (parsed && validator(parsed)) {
        return parsed;
      }
    }
  }

  // 문자열인 경우 JSON 파싱 시도
  if (typeof raw === 'string') {
    const parsed = tryParseJson<T>(raw);
    if (parsed && validator(parsed)) {
      return parsed;
    }
  }

  return null;
}

// ============================================================================
// Validators
// ============================================================================

function isSketchResult(data: unknown): data is SketchResult {
  return (
    isRecord(data) &&
    typeof data.mood === 'string' &&
    Array.isArray(data.bullets)
  );
}

function isPrismResult(data: unknown): data is PrismResult {
  return isRecord(data) && Array.isArray(data.facets);
}

function isChainResult(data: unknown): data is ChainResult {
  return isRecord(data) && Array.isArray(data.questions);
}

// ============================================================================
// Fallback Generators
// ============================================================================

function createSketchFallback(paragraph: string): SketchResult {
  const sentences = (paragraph || '')
    .replace(/\n+/g, ' ')
    .split(/[.!?]\s+/)
    .map(s => s.trim())
    .filter(s => s.length > 10)
    .slice(0, 4);

  return {
    mood: 'reflective',
    bullets:
      sentences.length > 0
        ? sentences.map(s => safeTruncate(s, 100))
        : ['내용을 분석할 수 없습니다.'],
  };
}

function createPrismFallback(paragraph: string): PrismResult {
  return {
    facets: [
      {
        title: '핵심 요점',
        points: [safeTruncate(paragraph, 140) || '분석 중 오류 발생'],
      },
      {
        title: '생각해볼 점',
        points: ['다양한 관점에서 검토 필요', '추가 맥락 확인 권장'],
      },
    ],
  };
}

function createChainFallback(): ChainResult {
  return {
    questions: [
      { q: '이 주장의 핵심 근거는 무엇인가?', why: '논리적 기반 확인' },
      { q: '어떤 전제나 가정이 깔려 있는가?', why: '숨겨진 전제 파악' },
      { q: '실제로 어떻게 적용할 수 있는가?', why: '실용적 가치 탐색' },
    ],
  };
}

// ============================================================================
// Public API
// ============================================================================

/**
 * Sketch: 감정(mood)과 핵심 포인트(bullets) 추출
 */
export async function sketch(input: {
  paragraph: string;
  postTitle?: string;
  persona?: string;
}): Promise<SketchResult> {
  const { paragraph, postTitle, persona } = input;

  try {
    const response = await invokeTask<SketchResult>('sketch', {
      paragraph,
      postTitle,
      persona,
    });

    const normalized = normalizeResponse(response, isSketchResult);
    if (normalized) {
      return {
        mood: normalized.mood,
        bullets: normalized.bullets.slice(0, 10),
      };
    }

    throw new Error('Invalid sketch response format');
  } catch (err) {
    console.error('Sketch AI call failed:', err);
    return createSketchFallback(paragraph);
  }
}

/**
 * Prism: 다각도 분석 (facets)
 */
export async function prism(input: {
  paragraph: string;
  postTitle?: string;
}): Promise<PrismResult> {
  const { paragraph, postTitle } = input;

  try {
    const response = await invokeTask<PrismResult>('prism', {
      paragraph,
      postTitle,
    });

    const normalized = normalizeResponse(response, isPrismResult);
    if (normalized) {
      return {
        facets: normalized.facets.slice(0, 4),
      };
    }

    throw new Error('Invalid prism response format');
  } catch (err) {
    console.error('Prism AI call failed:', err);
    return createPrismFallback(paragraph);
  }
}

/**
 * Chain: 후속 질문 생성
 */
export async function chain(input: {
  paragraph: string;
  postTitle?: string;
}): Promise<ChainResult> {
  const { paragraph, postTitle } = input;

  try {
    const response = await invokeTask<ChainResult>('chain', {
      paragraph,
      postTitle,
    });

    const normalized = normalizeResponse(response, isChainResult);
    if (normalized) {
      return {
        questions: normalized.questions.slice(0, 6),
      };
    }

    throw new Error('Invalid chain response format');
  } catch (err) {
    console.error('Chain AI call failed:', err);
    return createChainFallback();
  }
}

/**
 * Summary: 요약 생성 (새로 추가)
 */
export async function summary(input: {
  paragraph: string;
  postTitle?: string;
}): Promise<SummaryResult> {
  const { paragraph, postTitle } = input;

  try {
    const response = await invokeTask<SummaryResult>('summary', {
      paragraph,
      postTitle,
    });

    if (isRecord(response) && typeof response.summary === 'string') {
      return {
        summary: response.summary,
        keyPoints: Array.isArray(response.keyPoints) ? response.keyPoints : undefined,
      };
    }

    throw new Error('Invalid summary response format');
  } catch (err) {
    console.error('Summary AI call failed:', err);
    return {
      summary: safeTruncate(paragraph, 200) || '요약을 생성할 수 없습니다.',
      keyPoints: ['원본 텍스트를 확인해주세요.'],
    };
  }
}

```

### analytics.ts

**Path:** `frontend/src/services/analytics.ts`

```typescript
/**
 * Analytics Service
 * Handles view tracking and editor picks from Cloudflare D1
 */
import { getApiBaseUrl } from '@/utils/apiBase';

// ============================================================================
// Types
// ============================================================================

export type PostStats = {
  total_views: number;
  views_7d: number;
  views_30d: number;
};

export type EditorPick = {
  post_slug: string;
  year: string;
  title: string;
  cover_image: string | null;
  category: string | null;
  rank: number;
  score: number;
  reason: string | null;
};

export type TrendingPost = {
  post_slug: string;
  year: string;
  recent_views: number;
  total_views: number;
};

// ============================================================================
// API Functions
// ============================================================================

/**
 * Record a view for a post
 */
export async function recordView(year: string, slug: string): Promise<boolean> {
  try {
    const baseUrl = getApiBaseUrl();
    const response = await fetch(`${baseUrl}/api/v1/analytics/view`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ year, slug }),
    });

    if (!response.ok) {
      console.warn('Failed to record view:', response.status);
      return false;
    }

    return true;
  } catch (err) {
    console.warn('Failed to record view:', err);
    return false;
  }
}

/**
 * Get stats for a specific post
 */
export async function getPostStats(year: string, slug: string): Promise<PostStats | null> {
  try {
    const baseUrl = getApiBaseUrl();
    const response = await fetch(`${baseUrl}/api/v1/analytics/stats/${year}/${slug}`);

    if (!response.ok) {
      return null;
    }

    const data = await response.json();
    return data.data?.stats || null;
  } catch (err) {
    console.warn('Failed to get post stats:', err);
    return null;
  }
}

/**
 * Get active editor picks from D1 database
 */
export async function getEditorPicks(limit: number = 3): Promise<EditorPick[]> {
  try {
    const baseUrl = getApiBaseUrl();
    const response = await fetch(`${baseUrl}/api/v1/analytics/editor-picks?limit=${limit}`);

    if (!response.ok) {
      return [];
    }

    const data = await response.json();
    return data.data?.picks || [];
  } catch (err) {
    console.warn('Failed to get editor picks:', err);
    return [];
  }
}

/**
 * Get trending posts based on recent views
 */
export async function getTrendingPosts(limit: number = 5, days: number = 7): Promise<TrendingPost[]> {
  try {
    const baseUrl = getApiBaseUrl();
    const response = await fetch(`${baseUrl}/api/v1/analytics/trending?limit=${limit}&days=${days}`);

    if (!response.ok) {
      return [];
    }

    const data = await response.json();
    return data.data?.trending || [];
  } catch (err) {
    console.warn('Failed to get trending posts:', err);
    return [];
  }
}

```

### chat.ts

**Path:** `frontend/src/services/chat.ts`

```typescript
/**
 * Chat Service - Legacy Compatibility Export
 *
 * 기존 import 경로 호환성을 위한 re-export
 * 새로운 코드는 '@/services/chat' 에서 직접 import 권장
 *
 * @deprecated Use '@/services/chat' instead
 */

export {
  // Types
  type ChatSession,
  type ChatTaskMode,
  type InvokeChatTaskInput,
  type InvokeChatTaskResult,
  type ChatStreamEvent,
  type StreamChatInput,
  type ChatImageUploadResult,
  // Config
  isUnifiedTasksEnabled,
  // Session
  ensureSession,
  // API
  invokeChatTask,
  streamChatEvents,
  streamChatMessage,
  uploadChatImage,
  invokeChatAggregate,
} from './chat/index';

```

### curiosity.ts

**Path:** `frontend/src/services/curiosity.ts`

```typescript
/**
 * Curiosity Event Tracking Service
 *
 * Web of Curiosity 기능을 위한 이벤트 트래킹 서비스
 * PRD 스키마 기반으로 의미 있는 사용자 행동만 추적
 *
 * @see docs/PRD-web-of-curiosity.md
 */

import { useCallback, useEffect, useState } from 'react';

// ─────────────────────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────────────────────

export type CuriosityEventType =
  | 'post_view'
  | 'memo_create'
  | 'tag_click'
  | 'category_filter'
  | 'search';

export interface CuriosityEventContext {
  postId?: string;
  path?: string;
  title?: string;
  tags?: string[];
  selectionHash?: string;
  snippet?: string;
  tag?: string;
  category?: string;
  queryHash?: string;
  queryText?: string; // Only stored if user opts in
}

export interface CuriosityEventMeta {
  version: number;
  ua?: string;
  ref?: 'search' | 'tag' | 'direct' | 'internal';
}

export interface CuriosityEvent {
  id: string;
  type: CuriosityEventType;
  ts: number;
  context: CuriosityEventContext;
  meta: CuriosityEventMeta;
}

export interface CuriositySettings {
  enabled: boolean;
  storeSearchText: boolean;
  maxEvents: number;
  retentionDays: number;
}

// ─────────────────────────────────────────────────────────────────────────────
// Constants
// ─────────────────────────────────────────────────────────────────────────────

const STORAGE_KEY = 'curiosity.events';
const SETTINGS_KEY = 'curiosity.settings';
const SCHEMA_VERSION = 1;

const DEFAULT_SETTINGS: CuriositySettings = {
  enabled: true,
  storeSearchText: false,
  maxEvents: 1500,
  retentionDays: 90,
};

// Events that should NOT be tracked (UI noise)
const NOISY_EVENTS = new Set([
  'panel_open',
  'panel_close',
  'scroll',
  'hover',
  'focus',
  'blur',
  'resize',
]);

// ─────────────────────────────────────────────────────────────────────────────
// Utility Functions
// ─────────────────────────────────────────────────────────────────────────────

function generateEventId(): string {
  return `evt_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}

function hashString(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return `hash:${Math.abs(hash).toString(16)}`;
}

function inferReferrer(): CuriosityEventMeta['ref'] {
  const referrer = document.referrer;
  if (!referrer) return 'direct';

  try {
    const url = new URL(referrer);
    const currentHost = window.location.host;

    if (url.host === currentHost) return 'internal';
    if (url.host.includes('google') || url.host.includes('bing') || url.host.includes('naver')) {
      return 'search';
    }
  } catch {
    // Invalid URL
  }

  return 'direct';
}

// ─────────────────────────────────────────────────────────────────────────────
// Storage Layer
// ─────────────────────────────────────────────────────────────────────────────

class CuriosityStorage {
  private events: CuriosityEvent[] = [];
  private settings: CuriositySettings = { ...DEFAULT_SETTINGS };
  private initialized = false;

  constructor() {
    this.loadFromStorage();
  }

  private loadFromStorage(): void {
    try {
      // Load settings
      const settingsRaw = localStorage.getItem(SETTINGS_KEY);
      if (settingsRaw) {
        this.settings = { ...DEFAULT_SETTINGS, ...JSON.parse(settingsRaw) };
      }

      // Load events
      const eventsRaw = localStorage.getItem(STORAGE_KEY);
      if (eventsRaw) {
        const parsed = JSON.parse(eventsRaw);
        if (Array.isArray(parsed)) {
          this.events = parsed.filter(
            (e): e is CuriosityEvent =>
              e && typeof e.id === 'string' && typeof e.ts === 'number'
          );
          this.cleanupOldEvents();
        }
      }

      this.initialized = true;
    } catch (err) {
      console.warn('[Curiosity] Failed to load from storage:', err);
      this.events = [];
    }
  }

  private saveToStorage(): void {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(this.events));
    } catch (err) {
      console.warn('[Curiosity] Failed to save to storage:', err);
    }
  }

  private cleanupOldEvents(): void {
    const now = Date.now();
    const maxAge = this.settings.retentionDays * 24 * 60 * 60 * 1000;
    const cutoff = now - maxAge;

    // Remove old events
    this.events = this.events.filter((e) => e.ts >= cutoff);

    // Enforce max events limit (keep newest)
    if (this.events.length > this.settings.maxEvents) {
      this.events = this.events
        .sort((a, b) => b.ts - a.ts)
        .slice(0, this.settings.maxEvents);
    }
  }

  addEvent(event: CuriosityEvent): void {
    if (!this.settings.enabled) return;

    this.events.push(event);
    this.cleanupOldEvents();
    this.saveToStorage();
  }

  getEvents(): CuriosityEvent[] {
    return [...this.events];
  }

  getSettings(): CuriositySettings {
    return { ...this.settings };
  }

  updateSettings(updates: Partial<CuriositySettings>): void {
    this.settings = { ...this.settings, ...updates };
    try {
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(this.settings));
    } catch {}
  }

  clearEvents(): void {
    this.events = [];
    this.saveToStorage();
  }

  exportEvents(): string {
    return JSON.stringify(this.events, null, 2);
  }

  importEvents(json: string): boolean {
    try {
      const parsed = JSON.parse(json);
      if (!Array.isArray(parsed)) return false;

      const valid = parsed.filter(
        (e): e is CuriosityEvent =>
          e && typeof e.id === 'string' && typeof e.ts === 'number'
      );

      this.events = [...this.events, ...valid];
      this.cleanupOldEvents();
      this.saveToStorage();
      return true;
    } catch {
      return false;
    }
  }

  getStats(): { total: number; byType: Record<CuriosityEventType, number> } {
    const byType: Record<CuriosityEventType, number> = {
      post_view: 0,
      memo_create: 0,
      tag_click: 0,
      category_filter: 0,
      search: 0,
    };

    for (const event of this.events) {
      if (byType[event.type] !== undefined) {
        byType[event.type]++;
      }
    }

    return { total: this.events.length, byType };
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Main Service
// ─────────────────────────────────────────────────────────────────────────────

class CuriosityTracker {
  private storage: CuriosityStorage;
  private lastPostView: { postId: string; ts: number } | null = null;

  constructor() {
    this.storage = new CuriosityStorage();
  }

  /**
   * Track a post view event
   */
  trackPostView(postId: string, path: string, title: string, tags: string[] = []): void {
    // Debounce: Don't track same post within 5 seconds
    if (
      this.lastPostView &&
      this.lastPostView.postId === postId &&
      Date.now() - this.lastPostView.ts < 5000
    ) {
      return;
    }

    const event: CuriosityEvent = {
      id: generateEventId(),
      type: 'post_view',
      ts: Date.now(),
      context: {
        postId,
        path,
        title,
        tags,
      },
      meta: {
        version: SCHEMA_VERSION,
        ref: inferReferrer(),
      },
    };

    this.storage.addEvent(event);
    this.lastPostView = { postId, ts: Date.now() };

    // Dispatch event for FAB/other components to listen
    window.dispatchEvent(
      new CustomEvent('curiosity:event', { detail: event })
    );
  }

  /**
   * Track memo creation
   */
  trackMemoCreate(
    postId: string,
    snippet?: string,
    selectionHash?: string
  ): void {
    const event: CuriosityEvent = {
      id: generateEventId(),
      type: 'memo_create',
      ts: Date.now(),
      context: {
        postId,
        snippet: snippet?.slice(0, 200), // Limit snippet length
        selectionHash,
      },
      meta: {
        version: SCHEMA_VERSION,
      },
    };

    this.storage.addEvent(event);
    window.dispatchEvent(
      new CustomEvent('curiosity:event', { detail: event })
    );
  }

  /**
   * Track tag click
   */
  trackTagClick(tag: string, fromPostId?: string): void {
    const event: CuriosityEvent = {
      id: generateEventId(),
      type: 'tag_click',
      ts: Date.now(),
      context: {
        tag,
        postId: fromPostId,
      },
      meta: {
        version: SCHEMA_VERSION,
      },
    };

    this.storage.addEvent(event);
    window.dispatchEvent(
      new CustomEvent('curiosity:event', { detail: event })
    );
  }

  /**
   * Track category filter
   */
  trackCategoryFilter(category: string): void {
    const event: CuriosityEvent = {
      id: generateEventId(),
      type: 'category_filter',
      ts: Date.now(),
      context: {
        category,
      },
      meta: {
        version: SCHEMA_VERSION,
      },
    };

    this.storage.addEvent(event);
    window.dispatchEvent(
      new CustomEvent('curiosity:event', { detail: event })
    );
  }

  /**
   * Track search execution
   */
  trackSearch(query: string): void {
    const settings = this.storage.getSettings();
    const event: CuriosityEvent = {
      id: generateEventId(),
      type: 'search',
      ts: Date.now(),
      context: {
        queryHash: hashString(query),
        queryText: settings.storeSearchText ? query : undefined,
      },
      meta: {
        version: SCHEMA_VERSION,
      },
    };

    this.storage.addEvent(event);
    window.dispatchEvent(
      new CustomEvent('curiosity:event', { detail: event })
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Data Access
  // ─────────────────────────────────────────────────────────────────────────

  getEvents(): CuriosityEvent[] {
    return this.storage.getEvents();
  }

  getEventsByType(type: CuriosityEventType): CuriosityEvent[] {
    return this.storage.getEvents().filter((e) => e.type === type);
  }

  getEventsByTimeRange(startTs: number, endTs: number): CuriosityEvent[] {
    return this.storage.getEvents().filter(
      (e) => e.ts >= startTs && e.ts <= endTs
    );
  }

  getRecentEvents(limit: number = 50): CuriosityEvent[] {
    return this.storage
      .getEvents()
      .sort((a, b) => b.ts - a.ts)
      .slice(0, limit);
  }

  getStats() {
    return this.storage.getStats();
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Settings
  // ─────────────────────────────────────────────────────────────────────────

  getSettings(): CuriositySettings {
    return this.storage.getSettings();
  }

  updateSettings(updates: Partial<CuriositySettings>): void {
    this.storage.updateSettings(updates);
  }

  setEnabled(enabled: boolean): void {
    this.storage.updateSettings({ enabled });
  }

  isEnabled(): boolean {
    return this.storage.getSettings().enabled;
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Data Management
  // ─────────────────────────────────────────────────────────────────────────

  clearAll(): void {
    this.storage.clearEvents();
  }

  exportData(): string {
    return this.storage.exportEvents();
  }

  importData(json: string): boolean {
    return this.storage.importEvents(json);
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Singleton Export
// ─────────────────────────────────────────────────────────────────────────────

export const curiosityTracker = new CuriosityTracker();

// ─────────────────────────────────────────────────────────────────────────────
// React Hook
// ─────────────────────────────────────────────────────────────────────────────

export function useCuriosityEvents(options?: {
  type?: CuriosityEventType;
  limit?: number;
  startTs?: number;
  endTs?: number;
}) {
  const [events, setEvents] = useState<CuriosityEvent[]>([]);
  const [stats, setStats] = useState(curiosityTracker.getStats());

  const refresh = useCallback(() => {
    let result: CuriosityEvent[];

    if (options?.startTs && options?.endTs) {
      result = curiosityTracker.getEventsByTimeRange(options.startTs, options.endTs);
    } else if (options?.type) {
      result = curiosityTracker.getEventsByType(options.type);
    } else if (options?.limit) {
      result = curiosityTracker.getRecentEvents(options.limit);
    } else {
      result = curiosityTracker.getEvents();
    }

    setEvents(result);
    setStats(curiosityTracker.getStats());
  }, [options?.type, options?.limit, options?.startTs, options?.endTs]);

  useEffect(() => {
    refresh();

    const handler = () => refresh();
    window.addEventListener('curiosity:event', handler);
    return () => window.removeEventListener('curiosity:event', handler);
  }, [refresh]);

  return { events, stats, refresh };
}

export function useCuriositySettings() {
  const [settings, setSettingsState] = useState(curiosityTracker.getSettings());

  const updateSettings = useCallback((updates: Partial<CuriositySettings>) => {
    curiosityTracker.updateSettings(updates);
    setSettingsState(curiosityTracker.getSettings());
  }, []);

  return { settings, updateSettings };
}

```

### memoVersions.ts

**Path:** `frontend/src/services/memoVersions.ts`

```typescript
/**
 * Memo Service - API client for memo versioning
 *
 * Handles communication with the /api/v1/memos endpoints
 * for memo content CRUD and version history management.
 */

import { getApiBaseUrl } from '@/utils/apiBase';

// ============================================================================
// Types
// ============================================================================

export interface Memo {
  id: string | null;
  userId: string;
  content: string;
  version: number;
  createdAt: string | null;
  updatedAt: string | null;
}

export interface MemoVersion {
  id: number;
  memoId: string;
  version: number;
  content?: string;
  contentLength: number;
  changeSummary: string | null;
  createdAt: string;
}

export interface MemoResponse {
  ok: boolean;
  data?: { memo: Memo };
  error?: { message: string };
}

export interface MemoSaveResponse {
  ok: boolean;
  data?: { id: string; version: number };
  error?: { message: string };
}

export interface MemoVersionsResponse {
  ok: boolean;
  data?: { versions: MemoVersion[]; total: number };
  error?: { message: string };
}

export interface MemoVersionResponse {
  ok: boolean;
  data?: { version: MemoVersion };
  error?: { message: string };
}

export interface MemoRestoreResponse {
  ok: boolean;
  data?: { id: string; version: number; restoredFrom: number };
  error?: { message: string };
}

// ============================================================================
// Helper
// ============================================================================

function buildUrl(path: string): string {
  const base = getApiBaseUrl();
  return `${base.replace(/\/$/, '')}/api/v1/memos${path}`;
}

// ============================================================================
// API Functions
// ============================================================================

/**
 * Get current memo content for a user
 */
export async function getMemo(userId: string): Promise<MemoResponse> {
  try {
    const res = await fetch(buildUrl(`/${encodeURIComponent(userId)}`), {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' },
    });

    const data = await res.json();
    return data as MemoResponse;
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to fetch memo';
    return { ok: false, error: { message } };
  }
}

/**
 * Save memo content
 *
 * @param userId - User ID
 * @param content - Memo content
 * @param createVersion - Whether to create a version snapshot
 * @param changeSummary - Optional description of changes
 */
export async function saveMemo(
  userId: string,
  content: string,
  createVersion = false,
  changeSummary?: string
): Promise<MemoSaveResponse> {
  try {
    const res = await fetch(buildUrl(`/${encodeURIComponent(userId)}`), {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content, createVersion, changeSummary }),
    });

    const data = await res.json();
    return data as MemoSaveResponse;
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to save memo';
    return { ok: false, error: { message } };
  }
}

/**
 * Get version history for a user's memo
 *
 * @param userId - User ID
 * @param limit - Max versions to return (default 20, max 50)
 * @param offset - Pagination offset
 */
export async function getMemoVersions(
  userId: string,
  limit = 20,
  offset = 0
): Promise<MemoVersionsResponse> {
  try {
    const params = new URLSearchParams({
      limit: String(limit),
      offset: String(offset),
    });

    const res = await fetch(
      buildUrl(`/${encodeURIComponent(userId)}/versions?${params}`),
      {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
      }
    );

    const data = await res.json();
    return data as MemoVersionsResponse;
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to fetch versions';
    return { ok: false, error: { message } };
  }
}

/**
 * Get specific version content
 *
 * @param userId - User ID
 * @param version - Version number
 */
export async function getMemoVersion(
  userId: string,
  version: number
): Promise<MemoVersionResponse> {
  try {
    const res = await fetch(
      buildUrl(`/${encodeURIComponent(userId)}/versions/${version}`),
      {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
      }
    );

    const data = await res.json();
    return data as MemoVersionResponse;
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to fetch version';
    return { ok: false, error: { message } };
  }
}

/**
 * Restore a specific version
 *
 * @param userId - User ID
 * @param version - Version number to restore
 */
export async function restoreMemoVersion(
  userId: string,
  version: number
): Promise<MemoRestoreResponse> {
  try {
    const res = await fetch(
      buildUrl(`/${encodeURIComponent(userId)}/restore/${version}`),
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      }
    );

    const data = await res.json();
    return data as MemoRestoreResponse;
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to restore version';
    return { ok: false, error: { message } };
  }
}

/**
 * Delete memo and all versions
 *
 * @param userId - User ID
 */
export async function deleteMemo(
  userId: string
): Promise<{ ok: boolean; error?: { message: string } }> {
  try {
    const res = await fetch(buildUrl(`/${encodeURIComponent(userId)}`), {
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
    });

    const data = await res.json();
    return data;
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to delete memo';
    return { ok: false, error: { message } };
  }
}

```

### memory.ts

**Path:** `frontend/src/services/memory.ts`

```typescript
/**
 * Memory Service
 *
 * 사용자 메모리 저장 및 RAG 기반 검색 서비스
 * - D1 데이터베이스에 메모리 저장 (Workers API)
 * - ChromaDB에 임베딩 저장 (Backend RAG API)
 * - 채팅 컨텍스트에 관련 메모리 주입
 */

import { getApiBaseUrl } from '@/utils/apiBase';

// ============================================================================
// Types
// ============================================================================

export interface UserMemory {
  id: string;
  userId: string;
  memoryType: 'fact' | 'preference' | 'context' | 'summary';
  category?: string;
  content: string;
  sourceType?: 'chat' | 'memo' | 'manual';
  sourceId?: string;
  importanceScore: number;
  accessCount: number;
  lastAccessedAt?: string;
  expiresAt?: string;
  createdAt: string;
  updatedAt: string;
}

export interface ChatSession {
  id: string;
  userId: string;
  title?: string;
  summary?: string;
  questionMode: 'general' | 'article';
  articleSlug?: string;
  messageCount: number;
  totalTokens: number;
  isArchived: boolean;
  lastMessageAt?: string;
  createdAt: string;
  updatedAt: string;
}

export interface ChatMessage {
  id: string;
  sessionId: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  contentType: 'text' | 'image' | 'code' | 'error';
  metadata?: Record<string, unknown>;
  createdAt: string;
}

export interface MemorySearchResult {
  id: string;
  document: string;
  metadata: {
    user_id: string;
    memory_type: string;
    category?: string;
    created_at: string;
  };
  distance: number;
  similarity: number;
}

// ============================================================================
// User ID Management
// ============================================================================

const USER_ID_KEY = 'memory.userId';

/**
 * 현재 사용자 ID 가져오기 (없으면 생성)
 */
export function getUserId(): string {
  let userId = localStorage.getItem(USER_ID_KEY);
  if (!userId) {
    userId = `user-${crypto.randomUUID()}`;
    localStorage.setItem(USER_ID_KEY, userId);
  }
  return userId;
}

/**
 * 사용자 ID 설정 (로그인 시)
 */
export function setUserId(id: string): void {
  localStorage.setItem(USER_ID_KEY, id);
}

// ============================================================================
// Memory CRUD API (Workers D1)
// ============================================================================

/**
 * 사용자 메모리 목록 조회
 */
export async function getMemories(options: {
  type?: string;
  category?: string;
  limit?: number;
  offset?: number;
  signal?: AbortSignal;
} = {}): Promise<{ memories: UserMemory[]; total: number }> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const params = new URLSearchParams();
  if (options.type) params.set('type', options.type);
  if (options.category) params.set('category', options.category);
  if (options.limit) params.set('limit', String(options.limit));
  if (options.offset) params.set('offset', String(options.offset));

  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}?${params}`;

  const res = await fetch(url, {
    method: 'GET',
    signal: options.signal,
  });

  if (!res.ok) {
    throw new Error(`Failed to get memories: ${res.status}`);
  }

  const data = await res.json();
  return data.data || { memories: [], total: 0 };
}

/**
 * 메모리 생성
 */
export async function createMemory(memory: {
  content: string;
  memoryType?: string;
  category?: string;
  sourceType?: string;
  sourceId?: string;
  importanceScore?: number;
}): Promise<{ id: string }> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}`;

  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(memory),
  });

  if (!res.ok) {
    throw new Error(`Failed to create memory: ${res.status}`);
  }

  const data = await res.json();
  const memoryId = data.data?.id;

  // 임베딩도 저장 (백그라운드)
  if (memoryId) {
    upsertMemoryEmbedding([{
      id: memoryId,
      content: memory.content,
      memoryType: memory.memoryType || 'fact',
      category: memory.category,
    }]).catch(console.error);
  }

  return data.data || { id: '' };
}

/**
 * 여러 메모리 일괄 생성
 */
export async function createMemoriesBatch(memories: Array<{
  content: string;
  memoryType?: string;
  category?: string;
  sourceType?: string;
  sourceId?: string;
  importanceScore?: number;
}>): Promise<{ ids: string[]; created: number }> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}/batch`;

  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ memories }),
  });

  if (!res.ok) {
    throw new Error(`Failed to create memories batch: ${res.status}`);
  }

  const data = await res.json();
  const result = data.data || { ids: [], created: 0 };

  // 임베딩도 저장 (백그라운드)
  if (result.ids.length > 0) {
    const memoriesToEmbed = memories.slice(0, result.ids.length).map((m, i) => ({
      id: result.ids[i],
      content: m.content,
      memoryType: m.memoryType || 'fact',
      category: m.category,
    }));
    upsertMemoryEmbedding(memoriesToEmbed).catch(console.error);
  }

  return result;
}

/**
 * 메모리 삭제
 */
export async function deleteMemory(memoryId: string): Promise<void> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}/${memoryId}`;

  const res = await fetch(url, { method: 'DELETE' });

  if (!res.ok) {
    throw new Error(`Failed to delete memory: ${res.status}`);
  }

  // 임베딩도 삭제 (백그라운드)
  deleteMemoryEmbedding(memoryId).catch(console.error);
}

// ============================================================================
// Memory RAG API (Backend ChromaDB)
// ============================================================================

/**
 * 메모리 임베딩 저장/업데이트
 */
export async function upsertMemoryEmbedding(memories: Array<{
  id: string;
  content: string;
  memoryType: string;
  category?: string;
}>): Promise<void> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/rag/memories/upsert`;

  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ userId, memories }),
  });

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    console.warn('Failed to upsert memory embedding:', res.status, text);
  }
}

/**
 * 메모리 임베딩 삭제
 */
export async function deleteMemoryEmbedding(memoryId: string): Promise<void> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/rag/memories/${userId}/${memoryId}`;

  const res = await fetch(url, { method: 'DELETE' });

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    console.warn('Failed to delete memory embedding:', res.status, text);
  }
}

/**
 * 메모리 시맨틱 검색 (RAG)
 */
export async function searchMemories(
  query: string,
  options: {
    n_results?: number;
    memoryType?: string;
    category?: string;
    signal?: AbortSignal;
  } = {}
): Promise<MemorySearchResult[]> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/rag/memories/search`;

  try {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId,
        query,
        n_results: options.n_results || 10,
        memoryType: options.memoryType,
        category: options.category,
      }),
      signal: options.signal,
    });

    if (!res.ok) {
      console.warn('Memory search failed:', res.status);
      return [];
    }

    const data = await res.json();
    return data.data?.results || [];
  } catch (err) {
    if (err instanceof Error && err.name === 'AbortError') return [];
    console.warn('Memory search error:', err);
    return [];
  }
}

// ============================================================================
// Chat Session API (Workers D1)
// ============================================================================

/**
 * 채팅 세션 목록 조회
 */
export async function getChatSessions(options: {
  limit?: number;
  offset?: number;
  includeArchived?: boolean;
  signal?: AbortSignal;
} = {}): Promise<{ sessions: ChatSession[] }> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const params = new URLSearchParams();
  if (options.limit) params.set('limit', String(options.limit));
  if (options.offset) params.set('offset', String(options.offset));
  if (options.includeArchived) params.set('includeArchived', 'true');

  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}/sessions?${params}`;

  const res = await fetch(url, {
    method: 'GET',
    signal: options.signal,
  });

  if (!res.ok) {
    throw new Error(`Failed to get chat sessions: ${res.status}`);
  }

  const data = await res.json();
  return data.data || { sessions: [] };
}

/**
 * 채팅 세션 생성
 */
export async function createChatSession(options: {
  title?: string;
  questionMode?: 'general' | 'article';
  articleSlug?: string;
}): Promise<{ id: string }> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}/sessions`;

  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(options),
  });

  if (!res.ok) {
    throw new Error(`Failed to create chat session: ${res.status}`);
  }

  const data = await res.json();
  return data.data || { id: '' };
}

/**
 * 채팅 세션 상세 조회 (메시지 포함)
 */
export async function getChatSession(sessionId: string, options: {
  limit?: number;
  signal?: AbortSignal;
} = {}): Promise<{ session: ChatSession; messages: ChatMessage[] }> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const params = new URLSearchParams();
  if (options.limit) params.set('limit', String(options.limit));

  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}/sessions/${sessionId}?${params}`;

  const res = await fetch(url, {
    method: 'GET',
    signal: options.signal,
  });

  if (!res.ok) {
    throw new Error(`Failed to get chat session: ${res.status}`);
  }

  const data = await res.json();
  return data.data || { session: null, messages: [] };
}

/**
 * 채팅 세션에 메시지 추가
 */
export async function addChatMessage(
  sessionId: string,
  message: {
    role: 'user' | 'assistant' | 'system';
    content: string;
    contentType?: string;
    metadata?: Record<string, unknown>;
  }
): Promise<{ id: string }> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}/sessions/${sessionId}/messages`;

  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(message),
  });

  if (!res.ok) {
    throw new Error(`Failed to add chat message: ${res.status}`);
  }

  const data = await res.json();
  return data.data || { id: '' };
}

/**
 * 여러 메시지 일괄 추가
 */
export async function addChatMessagesBatch(
  sessionId: string,
  messages: Array<{
    role: 'user' | 'assistant' | 'system';
    content: string;
    contentType?: string;
    metadata?: Record<string, unknown>;
  }>
): Promise<{ ids: string[]; created: number }> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}/sessions/${sessionId}/messages/batch`;

  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ messages }),
  });

  if (!res.ok) {
    throw new Error(`Failed to add chat messages batch: ${res.status}`);
  }

  const data = await res.json();
  return data.data || { ids: [], created: 0 };
}

/**
 * 채팅 세션 업데이트 (제목, 요약, 아카이브)
 */
export async function updateChatSession(
  sessionId: string,
  updates: {
    title?: string;
    summary?: string;
    isArchived?: boolean;
  }
): Promise<void> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}/sessions/${sessionId}`;

  const res = await fetch(url, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(updates),
  });

  if (!res.ok) {
    throw new Error(`Failed to update chat session: ${res.status}`);
  }
}

/**
 * 채팅 세션 삭제
 */
export async function deleteChatSession(sessionId: string): Promise<void> {
  const userId = getUserId();
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/memories/${userId}/sessions/${sessionId}`;

  const res = await fetch(url, { method: 'DELETE' });

  if (!res.ok) {
    throw new Error(`Failed to delete chat session: ${res.status}`);
  }
}

// ============================================================================
// Context Building for Chat
// ============================================================================

/**
 * 채팅 컨텍스트용 메모리 컨텍스트 가져오기
 *
 * @param userQuery - 사용자 질문
 * @param maxTokens - 대략적인 최대 토큰 수
 * @returns 챗봇에 주입할 메모리 컨텍스트 문자열
 */
export async function getMemoryContextForChat(
  userQuery: string,
  maxTokens = 1500
): Promise<string | null> {
  const results = await searchMemories(userQuery, { n_results: 10 });

  if (results.length === 0) return null;

  const contextParts: string[] = [];
  let currentLength = 0;
  const CHARS_PER_TOKEN = 4;

  for (const result of results) {
    // 유사도가 낮은 결과는 제외 (0.3 이하)
    if (result.similarity < 0.3) continue;

    const memType = result.metadata.memory_type || 'fact';
    const category = result.metadata.category ? `/${result.metadata.category}` : '';
    const entry = `[${memType}${category}] ${result.document}`;
    const entryTokens = Math.ceil(entry.length / CHARS_PER_TOKEN);

    if (currentLength + entryTokens > maxTokens) break;

    contextParts.push(entry);
    currentLength += entryTokens;
  }

  if (contextParts.length === 0) return null;

  return [
    '[사용자 기억 데이터]',
    '다음은 이 사용자에 대해 알고 있는 정보입니다. 답변 시 참고하세요:',
    '',
    ...contextParts,
    '',
  ].join('\n');
}

// ============================================================================
// Memory Extraction from Conversations
// ============================================================================

/**
 * 대화에서 메모리 추출 (AI 기반)
 * 챗봇 응답 후 호출하여 중요 정보를 메모리로 저장
 *
 * @param userMessage - 사용자 메시지
 * @param assistantResponse - AI 응답
 * @param sessionId - 채팅 세션 ID
 */
export async function extractAndSaveMemories(
  userMessage: string,
  assistantResponse: string,
  sessionId?: string
): Promise<void> {
  // 간단한 휴리스틱으로 메모리 추출
  // TODO: 실제로는 LLM을 사용하여 더 정교하게 추출
  
  const memories: Array<{
    content: string;
    memoryType: string;
    category?: string;
    importanceScore: number;
  }> = [];

  // 선호도 관련 키워드 감지
  const preferencePatterns = [
    /(?:좋아하|선호하|즐기|관심)/,
    /(?:싫어하|피하|불편)/,
  ];
  
  if (preferencePatterns.some(p => p.test(userMessage))) {
    memories.push({
      content: userMessage.slice(0, 500),
      memoryType: 'preference',
      category: 'interest',
      importanceScore: 0.7,
    });
  }

  // 개인정보 관련 (이름, 직업 등)
  const personalPatterns = [
    /(?:제 이름은|저는 .+(?:입니다|이에요|예요))/,
    /(?:직업|일|회사|학교)/,
    /(?:살고 있|거주)/,
  ];

  if (personalPatterns.some(p => p.test(userMessage))) {
    memories.push({
      content: userMessage.slice(0, 500),
      memoryType: 'fact',
      category: 'personal',
      importanceScore: 0.8,
    });
  }

  // 목표/계획 관련
  const goalPatterns = [
    /(?:목표|계획|하고 싶|배우고 싶|만들고 싶)/,
    /(?:도전|시도|프로젝트)/,
  ];

  if (goalPatterns.some(p => p.test(userMessage))) {
    memories.push({
      content: userMessage.slice(0, 500),
      memoryType: 'context',
      category: 'goal',
      importanceScore: 0.6,
    });
  }

  // 메모리가 있으면 저장
  if (memories.length > 0) {
    const memoriesWithSource = memories.map(m => ({
      ...m,
      sourceType: 'chat' as const,
      sourceId: sessionId,
    }));
    
    try {
      await createMemoriesBatch(memoriesWithSource);
    } catch (err) {
      console.warn('Failed to save extracted memories:', err);
    }
  }
}

```

### postService.ts

**Path:** `frontend/src/services/postService.ts`

```typescript
/// <reference types="vite/client" />
import matter from 'gray-matter';
import type {
  BlogPost,
  LocalizedPostFields,
  PostsPage,
  SupportedLanguage,
} from '../types/blog';

type ManifestItem = {
  path: string; // /posts/:lang/:year/:file.md or legacy /posts/:year/:file.md
  year: string;
  slug: string;
  title: string;
  description: string;
  snippet?: string;
  date: string;
  tags: string[];
  category: string;
  author?: string;
  readingTime?: string;
  published?: boolean;
  coverImage?: string;
  url?: string;
  language: SupportedLanguage;
};

type UnifiedManifest = {
  total: number;
  items: ManifestItem[];
  generatedAt: string;
  years: string[];
  format?: number;
};

export class PostService {
  private static postsCache: BlogPost[] | null = null; // metadata-only cache
  private static manifestCache: UnifiedManifest | null = null;
  private static contentCache: Map<string, string> = new Map(); // key: year/slug -> markdown content
  private static pageCache: Map<string, PostsPage<BlogPost>> = new Map();

  // Query for paginated metadata
  static readonly DEFAULT_PAGE_SIZE = 12;
  static readonly SORTS = ['date', 'title', 'readTime'] as const;

  private static getBasePath(): string {
    // Vite injects BASE_URL with a trailing slash (e.g., '/', '/blog/').
    // Normalize by removing the trailing slash so we can safely concatenate paths.
    const base = import.meta.env.BASE_URL ?? '/';
    return base.replace(/\/$/, '');
  }

  private static buildPageKey(q: {
    page: number;
    pageSize: number;
    category?: string;
    tags?: string[];
    search?: string;
    sort?: 'date' | 'title' | 'readTime';
  }): string {
    const normalized = {
      ...q,
      tags: (q.tags || []).slice().sort(),
      category: q.category || 'all',
      search: (q.search || '').trim().toLowerCase(),
      sort: q.sort || 'date',
    };
    return JSON.stringify(normalized);
  }

  private static applyFiltersAndSort(
    items: ManifestItem[],
    q: {
      category?: string;
      tags?: string[];
      search?: string;
      sort?: 'date' | 'title' | 'readTime';
    }
  ): ManifestItem[] {
    const search = (q.search || '').trim().toLowerCase();
    const category =
      q.category && q.category !== 'all' ? q.category : undefined;
    const requiredTags = (q.tags || []).filter(Boolean);

    let filtered = items.filter(it => it.published !== false);
    if (category) {
      filtered = filtered.filter(it => it.category === category);
    }
    if (requiredTags.length) {
      filtered = filtered.filter(it =>
        requiredTags.some(t => it.tags?.includes(t))
      );
    }
    if (search) {
      filtered = filtered.filter(
        it =>
          it.title.toLowerCase().includes(search) ||
          (it.description || '').toLowerCase().includes(search) ||
          (it.snippet || '').toLowerCase().includes(search) ||
          (it.category || '').toLowerCase().includes(search) ||
          (it.tags || []).some(t => t.toLowerCase().includes(search))
      );
    }

    const sortKey = q.sort || 'date';
    filtered.sort((a, b) => {
      if (sortKey === 'title') return a.title.localeCompare(b.title);
      if (sortKey === 'readTime') {
        // readingTime like "5 min read" -> parse leading int
        const parse = (s?: string) => (s ? parseInt(String(s), 10) || 0 : 0);
        return parse(a.readingTime) - parse(b.readingTime);
      }
      // default by date desc
      return new Date(b.date).getTime() - new Date(a.date).getTime();
    });

    return filtered;
  }

  static async getPostsPage(q: {
    page?: number;
    pageSize?: number;
    category?: string;
    tags?: string[];
    search?: string;
    sort?: 'date' | 'title' | 'readTime';
  }): Promise<PostsPage<BlogPost>> {
    const page = Math.max(1, q.page || 1);
    const pageSize = Math.max(1, q.pageSize || PostService.DEFAULT_PAGE_SIZE);
    const key = this.buildPageKey({ ...q, page, pageSize });
    const cached = this.pageCache.get(key);
    if (cached) return cached;

    const items = await this.getManifestItems();
    const filtered = this.applyFiltersAndSort(items, q);

    const total = filtered.length;
    const totalPages = Math.max(1, Math.ceil(total / pageSize));
    const start = (page - 1) * pageSize;
    const slice = filtered.slice(start, start + pageSize);

    const resultItems: BlogPost[] = slice.map(it => ({
      id: it.slug,
      title: it.title,
      description: it.description,
      excerpt: it.snippet || it.description,
      content: '',
      date: it.date,
      author: it.author || 'Admin',
      tags: it.tags || [],
      category: it.category,
      readingTime: it.readingTime,
      slug: it.slug,
      year: it.year,
      published: true,
      coverImage: it.coverImage,
      language: it.language,
    }));

    const pageResult: PostsPage<BlogPost> = {
      items: resultItems,
      page,
      pageSize,
      total,
      totalPages,
      hasMore: page < totalPages,
    };

    this.pageCache.set(key, pageResult);
    return pageResult;
  }

  static async prefetchPost(year: string, slug: string): Promise<void> {
    const items = await this.getManifestItems();
    const item = items.find(i => i.year === year && i.slug === slug);
    if (!item) return;
    const key = `${year}/${slug}`;
    if (this.contentCache.has(key)) return;
    try {
      const markdown = await this.loadMarkdownFile(item.path);
      this.contentCache.set(key, markdown);
    } catch {
      // ignore prefetch errors
    }
  }

  private static async loadPostsManifest(): Promise<
    UnifiedManifest | { posts: string[] } | null
  > {
    try {
      const base = this.getBasePath();
      const response = await fetch(`${base}/posts-manifest.json`, {
        // Favor fresh-ish metadata but allow cached when offline
        cache: 'force-cache',
      });
      if (!response.ok) {
        throw new Error('Failed to load posts manifest');
      }
      return await response.json();
    } catch (error) {
      console.error('Error loading posts manifest:', error);
      return null;
    }
  }

  private static async loadMarkdownFile(path: string): Promise<string> {
    try {
      const base = this.getBasePath();
      const normalizedPath = path.startsWith('/') ? path : `/${path}`;
      const url = `${base}${normalizedPath}`;
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to load ${path}`);
      }
      return await response.text();
    } catch (error) {
      console.error(`Error loading markdown file ${path}:`, error);
      throw error;
    }
  }

  private static parseMarkdownContent(
    content: string,
    filePath: string
  ): Partial<BlogPost> {
    const { data: frontMatter, content: markdownContent } = matter(content);
    // Simple reading time calculation: ~200 words per minute
    const wordCount = markdownContent
      .trim()
      .split(/\s+/)
      .filter(Boolean).length;
    const readingMinutes = Math.max(1, Math.ceil(wordCount / 200));
    const readingTimeText = `${readingMinutes} min read`;

    // Extract year and filename from /posts/:year/:slug.md
    const match = filePath.match(/\/posts\/(\d{4})\/(.+)\.md$/);
    const year = match?.[1] ?? new Date().getFullYear().toString();
    const filename =
      match?.[2] ?? filePath.split('/').pop()?.replace('.md', '') ?? 'post';

    const rawDefaultLanguage = frontMatter.defaultLanguage;
    const defaultLanguage: SupportedLanguage =
      rawDefaultLanguage === 'en' ? 'en' : 'ko';

    const parseLocalizedFields = (
      fields: unknown
    ): LocalizedPostFields | undefined => {
      if (!fields || typeof fields !== 'object') return undefined;
      const record = fields as Record<string, unknown>;
      const localized: LocalizedPostFields = {
        title: typeof record.title === 'string' ? record.title : '',
        description:
          typeof record.description === 'string' ? record.description : '',
      };
      if (!localized.title) delete localized.title;
      if (!localized.description) delete localized.description;
      if (typeof record.excerpt === 'string') localized.excerpt = record.excerpt;
      if (typeof record.content === 'string') localized.content = record.content;
      return Object.keys(localized).length ? localized : undefined;
    };

    const translationEntries: Partial<
      Record<SupportedLanguage, LocalizedPostFields>
    > = {};
    const rawTranslations = frontMatter.translations;
    if (rawTranslations && typeof rawTranslations === 'object') {
      Object.entries(rawTranslations as Record<string, unknown>).forEach(
        ([langKey, value]) => {
          const normalizedLang =
            langKey === 'en' ? 'en' : langKey === 'ko' ? 'ko' : null;
          if (!normalizedLang) return;
          const localized = parseLocalizedFields(value);
          if (localized) {
            translationEntries[normalizedLang] = localized;
          }
        }
      );
    }

    const availableLanguages = Array.from(
      new Set<SupportedLanguage>([
        defaultLanguage,
        ...Object.keys(translationEntries) as SupportedLanguage[],
      ])
    );

    return {
      id: filename,
      title:
        frontMatter.title ||
        filename.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
      description:
        frontMatter.description || `${markdownContent.substring(0, 150)}...`,
      excerpt:
        frontMatter.excerpt ||
        frontMatter.description ||
        `${markdownContent.substring(0, 150)}...`,
      content: markdownContent,
      date: frontMatter.date || `${year}-01-01`,
      author: frontMatter.author || 'Admin',
      tags: Array.isArray(frontMatter.tags) ? frontMatter.tags : [],
      category: frontMatter.category || 'General',
      readingTime: readingTimeText,
      slug: filename,
      year,
      published: frontMatter.published !== false,
      coverImage: frontMatter.coverImage,
      defaultLanguage,
      availableLanguages,
      translations: translationEntries,
    };
  }

  private static async getManifestItems(): Promise<ManifestItem[]> {
    if (this.manifestCache) return this.manifestCache.items;
    const manifest = await this.loadPostsManifest();
    if (!manifest) return [];

    // New format with items
    if ((manifest as UnifiedManifest).items) {
      this.manifestCache = manifest as UnifiedManifest;
      return this.manifestCache.items;
    }

    // Fallback: old format with posts array -> build items by reading each markdown frontmatter
    const old = manifest as { posts: string[] };
    if (!old.posts?.length) return [];

    const items: ManifestItem[] = [];
    for (const postPath of old.posts) {
      try {
        const content = await this.loadMarkdownFile(postPath);
        const parsed = this.parseMarkdownContent(content, postPath);
        if (parsed.published === false) continue;
        items.push({
          path: postPath,
          year: parsed.year!,
          slug: parsed.slug!,
          title: parsed.title!,
          description: parsed.description!,
          snippet: parsed.excerpt || parsed.description,
          date: parsed.date!,
          tags: parsed.tags || [],
          category: parsed.category!,
          author: parsed.author,
          readingTime: parsed.readingTime,
          published: true,
          coverImage: parsed.coverImage,
          url: `/blog/${parsed.year}/${parsed.slug}`,
        });
      } catch (e) {
        console.warn(`Failed to parse legacy post ${postPath}:`, e);
      }
    }
    // Sort desc by date
    items.sort(
      (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
    );
    this.manifestCache = {
      total: items.length,
      items,
      generatedAt: new Date().toISOString(),
      years: Array.from(new Set(items.map(i => i.year)))
        .sort()
        .reverse(),
      format: 1,
    };
    return items;
  }

  static async getAllPosts(): Promise<BlogPost[]> {
    if (this.postsCache) return this.postsCache;

    const items = await this.getManifestItems();
    // Map metadata to BlogPost shape with empty content to satisfy type
    const posts: BlogPost[] = items
      .filter(it => it.published !== false)
      .map(it => ({
        id: it.slug,
        title: it.title,
        description: it.description,
        excerpt: it.snippet || it.description,
        content: '', // lazy-loaded on demand
        date: it.date,
        author: it.author || 'Admin',
        tags: it.tags || [],
        category: it.category,
        readingTime: it.readingTime,
        slug: it.slug,
        year: it.year,
        published: true,
        coverImage: it.coverImage,
        defaultLanguage: it.defaultLanguage,
        availableLanguages: it.availableLanguages,
        translations: it.translations,
      }));

    this.postsCache = posts;
    return posts;
  }

  static async getPostBySlug(
    year: string,
    slug: string
  ): Promise<BlogPost | null> {
    const key = `${year}/${slug}`;
    const items = await this.getManifestItems();
    const item = items.find(i => i.year === year && i.slug === slug);
    if (!item) return null;

    // Try cache
    if (this.contentCache.has(key)) {
      const markdown = this.contentCache.get(key)!;
      const parsed = this.parseMarkdownContent(markdown, item.path);
      return {
        id: parsed.id!,
        title: parsed.title!,
        description: parsed.description!,
        excerpt: parsed.excerpt!,
        content: parsed.content!,
        date: parsed.date!,
        author: parsed.author!,
        tags: parsed.tags!,
        category: parsed.category!,
        readingTime: parsed.readingTime!,
        slug: parsed.slug!,
        year: parsed.year!,
        published: true,
        coverImage: parsed.coverImage,
        defaultLanguage: parsed.defaultLanguage,
        availableLanguages: parsed.availableLanguages,
        translations: parsed.translations,
      };
    }

    // Fetch only this post's markdown
    const markdown = await this.loadMarkdownFile(item.path);
    this.contentCache.set(key, markdown);
    const parsed = this.parseMarkdownContent(markdown, item.path);
    return {
      id: parsed.id!,
      title: parsed.title!,
      description: parsed.description!,
      excerpt: parsed.excerpt!,
      content: parsed.content!,
      date: parsed.date!,
      author: parsed.author!,
      tags: parsed.tags!,
      category: parsed.category!,
      readingTime: parsed.readingTime!,
      slug: parsed.slug!,
      year: parsed.year!,
      published: true,
      coverImage: parsed.coverImage,
      language: parsed.language!,
    };
  }

  static async getPostsByCategory(category: string): Promise<BlogPost[]> {
    const posts = await this.getAllPosts();
    return posts.filter(
      post => post.category.toLowerCase() === category.toLowerCase()
    );
  }

  static async getPostsByTag(tag: string): Promise<BlogPost[]> {
    const posts = await this.getAllPosts();
    return posts.filter(post =>
      post.tags.some(t => t.toLowerCase() === tag.toLowerCase())
    );
  }

  static async searchPosts(query: string): Promise<BlogPost[]> {
    const posts = await this.getAllPosts();
    const lowercaseQuery = query.toLowerCase();

    return posts.filter(
      post =>
        post.title.toLowerCase().includes(lowercaseQuery) ||
        post.description.toLowerCase().includes(lowercaseQuery) ||
        (post.excerpt && post.excerpt.toLowerCase().includes(lowercaseQuery)) ||
        post.tags.some(tag => tag.toLowerCase().includes(lowercaseQuery)) ||
        post.category.toLowerCase().includes(lowercaseQuery)
    );
  }

  static clearCache(): void {
    this.postsCache = null;
    this.manifestCache = null;
    this.contentCache.clear();
    this.pageCache.clear();
  }
}

```

### rag.ts

**Path:** `frontend/src/services/rag.ts`

```typescript
/**
 * RAG (Retrieval-Augmented Generation) Service
 *
 * ChromaDB 기반 시맨틱 검색 및 임베딩 생성 서비스
 * Backend의 /api/v1/rag 엔드포인트를 호출합니다.
 */

import { getApiBaseUrl } from '@/utils/apiBase';

// ============================================================================
// Types
// ============================================================================

export interface RAGSearchResult {
  id: string;
  content: string;
  document?: string; // Backend returns 'document' field
  metadata: {
    title?: string;
    slug?: string;
    year?: string;
    category?: string;
    tags?: string[];
    [key: string]: unknown;
  };
  score: number;
  distance?: number; // Backend returns 'distance' field
  snippet?: string;
}

export interface RAGSearchResponse {
  ok: boolean;
  data?: {
    results: RAGSearchResult[];
    query: string;
    total: number;
  };
  error?: { message: string; code?: string };
}

export interface RAGEmbedResponse {
  ok: boolean;
  data?: {
    embeddings: number[][];
    model: string;
  };
  error?: { message: string; code?: string };
}

export interface RAGHealthResponse {
  ok: boolean;
  data?: {
    status: 'ok' | 'error';
    chromadb: boolean;
    tei: boolean;
    timestamp: string;
  };
  error?: { message: string; code?: string };
}

// ============================================================================
// API Functions
// ============================================================================

/**
 * 시맨틱 검색 수행
 *
 * @param query - 검색 쿼리
 * @param options - 검색 옵션
 * @returns 검색 결과 (유사도 점수 포함)
 *
 * @example
 * const results = await semanticSearch('LLM 추론 최적화', { n_results: 10 });
 * results.data?.results.forEach(r => console.log(r.metadata.title, r.score));
 */
export async function semanticSearch(
  query: string,
  options: {
    n_results?: number;
    filter?: Record<string, unknown>;
    signal?: AbortSignal;
  } = {}
): Promise<RAGSearchResponse> {
  const { n_results = 5, filter, signal } = options;
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/rag/search`;

  try {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, n_results, filter }),
      signal,
    });

    const data = await res.json();

    if (!res.ok) {
      return {
        ok: false,
        error: data.error || { message: `HTTP ${res.status}` },
      };
    }

    // Normalize backend response format
    // Backend returns: { ok, data: { results: [{ document, metadata, distance }] } }
    // Frontend expects: { ok, data: { results: [{ content, metadata, score }] } }
    if (data.ok && data.data?.results) {
      data.data.results = data.data.results.map((r: any) => ({
        ...r,
        content: r.content || r.document || '',
        score: r.score ?? (r.distance != null ? Math.max(0, 1 - r.distance) : 0),
      }));
    }

    return data as RAGSearchResponse;
  } catch (err) {
    if (err instanceof Error && err.name === 'AbortError') {
      return { ok: false, error: { message: 'Search cancelled', code: 'ABORTED' } };
    }
    const message = err instanceof Error ? err.message : 'Search failed';
    return { ok: false, error: { message, code: 'NETWORK_ERROR' } };
  }
}

/**
 * 텍스트 임베딩 생성
 *
 * @param texts - 임베딩할 텍스트 배열
 * @param signal - AbortSignal
 * @returns 임베딩 벡터 배열
 *
 * @example
 * const embeddings = await generateEmbeddings(['Hello world', '안녕하세요']);
 */
export async function generateEmbeddings(
  texts: string[],
  signal?: AbortSignal
): Promise<RAGEmbedResponse> {
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/rag/embed`;

  try {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ texts }),
      signal,
    });

    const data = await res.json();

    if (!res.ok) {
      return {
        ok: false,
        error: data.error || { message: `HTTP ${res.status}` },
      };
    }

    return data as RAGEmbedResponse;
  } catch (err) {
    if (err instanceof Error && err.name === 'AbortError') {
      return { ok: false, error: { message: 'Embed cancelled', code: 'ABORTED' } };
    }
    const message = err instanceof Error ? err.message : 'Embed failed';
    return { ok: false, error: { message, code: 'NETWORK_ERROR' } };
  }
}

/**
 * RAG 서비스 상태 확인
 *
 * @returns 서비스 상태 (ChromaDB, TEI 연결 상태)
 */
export async function checkRAGHealth(): Promise<RAGHealthResponse> {
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/rag/health`;

  try {
    const res = await fetch(url, { method: 'GET' });
    const data = await res.json();

    if (!res.ok) {
      return {
        ok: false,
        error: data.error || { message: `HTTP ${res.status}` },
      };
    }

    return data as RAGHealthResponse;
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Health check failed';
    return { ok: false, error: { message, code: 'NETWORK_ERROR' } };
  }
}

// ============================================================================
// Hooks Helper
// ============================================================================

/**
 * 관련 포스트 검색 (현재 글 기반)
 *
 * @param currentPost - 현재 포스트 정보
 * @param limit - 반환할 개수
 * @returns 관련 포스트 목록
 */
export async function findRelatedPosts(
  currentPost: { title: string; content?: string; slug: string },
  limit = 5
): Promise<RAGSearchResult[]> {
  // 제목과 내용 일부를 쿼리로 사용
  const query = currentPost.content
    ? `${currentPost.title}\n\n${currentPost.content.slice(0, 500)}`
    : currentPost.title;

  const response = await semanticSearch(query, {
    n_results: limit + 1, // 자기 자신 제외를 위해 +1
  });

  if (!response.ok || !response.data) {
    return [];
  }

  // 현재 글 제외
  return response.data.results.filter(
    (r) => r.metadata.slug !== currentPost.slug
  ).slice(0, limit);
}

/**
 * AI 챗봇용 컨텍스트 검색
 *
 * @param userQuery - 사용자 질문
 * @param maxTokens - 대략적인 최대 토큰 수 (문자 기준 근사치)
 * @returns 챗봇에 주입할 컨텍스트 문자열
 */
export async function getRAGContextForChat(
  userQuery: string,
  maxTokens = 2000
): Promise<string | null> {
  const response = await semanticSearch(userQuery, { n_results: 3 });

  if (!response.ok || !response.data || response.data.results.length === 0) {
    return null;
  }

  const contextParts: string[] = [];
  let currentLength = 0;

  for (const result of response.data.results) {
    const entry = [
      `[${result.metadata.title || 'Untitled'}]`,
      result.content.slice(0, 800),
      `(관련도: ${(result.score * 100).toFixed(1)}%)`,
      '',
    ].join('\n');

    if (currentLength + entry.length > maxTokens * 4) break; // rough char estimate
    contextParts.push(entry);
    currentLength += entry.length;
  }

  if (contextParts.length === 0) return null;

  return [
    '[블로그 관련 문서]',
    '다음은 질문과 관련된 블로그 글입니다. 답변 시 참고하세요:',
    '',
    ...contextParts,
  ].join('\n');
}

```

### reactions.ts

**Path:** `frontend/src/services/reactions.ts`

```typescript
import { getApiBaseUrl } from '@/utils/apiBase';

// Available emoji reactions
export const ALLOWED_EMOJIS = ['👍', '❤️', '😂', '😮', '😢', '🔥', '🎉', '💡'] as const;
export type ReactionEmoji = typeof ALLOWED_EMOJIS[number];

export interface ReactionCount {
  emoji: string;
  count: number;
}

// Generate a simple fingerprint for anonymous reaction tracking
export function getFingerprint(): string {
  // Try to get existing fingerprint from localStorage
  const stored = localStorage.getItem('comment.fingerprint');
  if (stored) return stored;

  // Generate new fingerprint based on browser characteristics
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx?.fillText('fingerprint', 10, 10);
  const canvasData = canvas.toDataURL();

  const components = [
    navigator.userAgent,
    navigator.language,
    screen.width,
    screen.height,
    new Date().getTimezoneOffset(),
    canvasData.slice(-50),
  ];

  // Simple hash function
  const hash = components.join('|');
  let result = 0;
  for (let i = 0; i < hash.length; i++) {
    const char = hash.charCodeAt(i);
    result = ((result << 5) - result) + char;
    result = result & result;
  }
  const fingerprint = Math.abs(result).toString(36);

  localStorage.setItem('comment.fingerprint', fingerprint);
  return fingerprint;
}

// Fetch reactions for multiple comments
export async function fetchReactionsBatch(
  commentIds: string[]
): Promise<Record<string, ReactionCount[]>> {
  if (commentIds.length === 0) return {};

  const base = getApiBaseUrl().replace(/\/$/, '');
  const url = `${base}/api/v1/comments/reactions/batch?commentIds=${commentIds.join(',')}`;

  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    return data?.reactions || data?.data?.reactions || {};
  } catch (err) {
    console.warn('Failed to fetch reactions:', err);
    return {};
  }
}

// Add a reaction to a comment
export async function addReaction(
  commentId: string,
  emoji: ReactionEmoji
): Promise<{ added: boolean }> {
  const base = getApiBaseUrl().replace(/\/$/, '');
  const url = `${base}/api/v1/comments/${commentId}/reactions`;
  const fingerprint = getFingerprint();

  const resp = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ emoji, fingerprint }),
  });

  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
  const data = await resp.json();
  return data?.data || data;
}

// Remove a reaction from a comment
export async function removeReaction(
  commentId: string,
  emoji: ReactionEmoji
): Promise<{ removed: boolean }> {
  const base = getApiBaseUrl().replace(/\/$/, '');
  const url = `${base}/api/v1/comments/${commentId}/reactions`;
  const fingerprint = getFingerprint();

  const resp = await fetch(url, {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ emoji, fingerprint }),
  });

  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
  const data = await resp.json();
  return data?.data || data;
}

// Get user's reactions for a comment (from localStorage)
export function getUserReactions(commentId: string): Set<ReactionEmoji> {
  try {
    const stored = localStorage.getItem(`comment.reactions.${commentId}`);
    if (!stored) return new Set();
    return new Set(JSON.parse(stored));
  } catch {
    return new Set();
  }
}

// Save user's reactions for a comment (to localStorage)
export function setUserReactions(commentId: string, emojis: Set<ReactionEmoji>): void {
  try {
    localStorage.setItem(`comment.reactions.${commentId}`, JSON.stringify([...emojis]));
  } catch {}
}

```

### terminal.ts

**Path:** `frontend/src/services/terminal.ts`

```typescript
/**
 * Terminal Service
 *
 * WebSocket-based real Linux terminal connection via Workers gateway.
 *
 * Architecture:
 * Frontend -> Cloudflare Workers (terminal-gateway) -> Backend (terminal-server) -> Docker container
 */

import { useAuthStore } from '@/stores/useAuthStore';

// ============================================================================
// Types
// ============================================================================

export interface TerminalOptions {
  cols?: number;
  rows?: number;
  onOpen?: () => void;
  onData?: (data: string) => void;
  onClose?: (code: number, reason: string) => void;
  onError?: (error: Event) => void;
}

export interface TerminalConnection {
  send: (data: string) => void;
  resize: (cols: number, rows: number) => void;
  close: () => void;
  isConnected: () => boolean;
}

// ============================================================================
// Configuration
// ============================================================================

function getTerminalGatewayUrl(): string {
  // Check localStorage override first (for development)
  try {
    const override = localStorage.getItem('aiMemo.terminalGatewayUrl');
    if (override) {
      const parsed = JSON.parse(override);
      if (typeof parsed === 'string' && parsed) return parsed;
    }
  } catch {
    // ignore
  }

  // Environment variable
  if (import.meta.env.VITE_TERMINAL_GATEWAY_URL) {
    return import.meta.env.VITE_TERMINAL_GATEWAY_URL;
  }

  // Default production URL
  return 'wss://terminal.nodove.com';
}

function getAuthToken(): string | null {
  // Try Zustand store first
  const authToken = useAuthStore.getState().token;
  if (authToken && authToken.trim()) {
    return authToken.trim();
  }

  // Fallback to localStorage
  if (typeof window === 'undefined') return null;
  const candidates = [
    'aiMemo.authToken',
    'aiMemo.jwt',
    'auth.token',
    'aiMemoAuthToken',
  ];

  for (const key of candidates) {
    try {
      const raw = localStorage.getItem(key) ?? sessionStorage.getItem(key);
      if (raw) {
        const parsed = JSON.parse(raw);
        if (typeof parsed === 'string' && parsed.trim()) return parsed.trim();
        if (typeof raw === 'string' && raw.trim()) return raw.trim();
      }
    } catch {
      // ignore JSON parse errors
    }
  }

  return null;
}

// ============================================================================
// Terminal Connection
// ============================================================================

/**
 * Connect to real Linux terminal via WebSocket
 *
 * @param options - Terminal options (size, callbacks)
 * @returns TerminalConnection object with send/resize/close methods
 *
 * @example
 * const term = connectTerminal({
 *   cols: 80,
 *   rows: 24,
 *   onData: (data) => console.log(data),
 *   onClose: (code, reason) => console.log('Closed:', code, reason),
 * });
 *
 * term.send('ls -la\n');
 * term.resize(120, 30);
 * term.close();
 */
export function connectTerminal(options: TerminalOptions = {}): TerminalConnection | null {
  const token = getAuthToken();
  if (!token) {
    console.error('[terminal] No auth token available');
    return null;
  }

  const baseUrl = getTerminalGatewayUrl();
  const cols = options.cols || 80;
  const rows = options.rows || 24;

  // Build WebSocket URL with query params
  const url = new URL(`${baseUrl}/terminal`);
  url.searchParams.set('token', token);
  url.searchParams.set('cols', String(cols));
  url.searchParams.set('rows', String(rows));

  let ws: WebSocket | null = null;
  let connected = false;

  try {
    ws = new WebSocket(url.toString());
    ws.binaryType = 'arraybuffer';

    ws.onopen = () => {
      connected = true;
      console.log('[terminal] Connected');
      options.onOpen?.();
    };

    ws.onmessage = (event) => {
      let data: string;
      if (typeof event.data === 'string') {
        data = event.data;
      } else if (event.data instanceof ArrayBuffer) {
        data = new TextDecoder().decode(event.data);
      } else {
        return;
      }
      options.onData?.(data);
    };

    ws.onclose = (event) => {
      connected = false;
      console.log('[terminal] Disconnected:', event.code, event.reason);
      options.onClose?.(event.code, event.reason);
    };

    ws.onerror = (error) => {
      console.error('[terminal] Error:', error);
      options.onError?.(error);
    };
  } catch (err) {
    console.error('[terminal] Failed to connect:', err);
    return null;
  }

  return {
    send: (data: string) => {
      if (ws && connected && ws.readyState === WebSocket.OPEN) {
        ws.send(data);
      }
    },
    resize: (newCols: number, newRows: number) => {
      if (ws && connected && ws.readyState === WebSocket.OPEN) {
        // Send resize command (JSON protocol)
        ws.send(JSON.stringify({ type: 'resize', cols: newCols, rows: newRows }));
      }
    },
    close: () => {
      if (ws) {
        ws.close(1000, 'Client closed');
        ws = null;
        connected = false;
      }
    },
    isConnected: () => connected,
  };
}

/**
 * Check if terminal service is available
 */
export async function checkTerminalHealth(): Promise<boolean> {
  try {
    const baseUrl = getTerminalGatewayUrl().replace('wss://', 'https://').replace('ws://', 'http://');
    const response = await fetch(`${baseUrl}/health`, {
      method: 'GET',
      signal: AbortSignal.timeout(5000),
    });
    const data = await response.json();
    return data?.status === 'ok';
  } catch {
    return false;
  }
}

/**
 * Check if user has an active terminal session
 */
export function hasAuthToken(): boolean {
  return !!getAuthToken();
}

```

### translate.ts

**Path:** `frontend/src/services/translate.ts`

```typescript
/**
 * Translation Service
 * Handles AI-powered translations with caching
 */
import { getApiBaseUrl } from '@/utils/apiBase';

// ============================================================================
// Types
// ============================================================================

export type TranslationResult = {
  title: string;
  description: string;
  content: string;
  cached: boolean;
  isAiGenerated?: boolean;
};

export type TranslationRequest = {
  year: string;
  slug: string;
  targetLang: string;
  sourceLang?: string;
  title: string;
  description?: string;
  content: string;
  forceRefresh?: boolean;
};

// ============================================================================
// API Functions
// ============================================================================

/**
 * Translate a blog post to target language
 * First checks cache, then uses AI if not cached
 */
export async function translatePost(request: TranslationRequest): Promise<TranslationResult> {
  const baseUrl = getApiBaseUrl();
  
  console.log('[translate] Requesting translation:', request.year, request.slug, request.targetLang);
  
  const response = await fetch(`${baseUrl}/api/v1/translate`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    const message = (errorData as any)?.error?.message || `Translation failed: ${response.status}`;
    console.error('[translate] API error:', response.status, message);
    throw new Error(message);
  }

  const data = await response.json();
  console.log('[translate] Success, cached:', (data as any).data?.cached);
  return (data as any).data as TranslationResult;
}

/**
 * Get cached translation for a post (if exists)
 */
export async function getCachedTranslation(
  year: string,
  slug: string,
  targetLang: string
): Promise<TranslationResult | null> {
  try {
    const baseUrl = getApiBaseUrl();
    const response = await fetch(`${baseUrl}/api/v1/translate/${year}/${slug}/${targetLang}`);

    if (!response.ok) {
      if (response.status === 404) return null;
      return null;
    }

    const data = await response.json();
    return (data as any).data as TranslationResult;
  } catch {
    return null;
  }
}

/**
 * Delete cached translation
 */
export async function deleteCachedTranslation(
  year: string,
  slug: string,
  targetLang: string
): Promise<boolean> {
  try {
    const baseUrl = getApiBaseUrl();
    const response = await fetch(`${baseUrl}/api/v1/translate/${year}/${slug}/${targetLang}`, {
      method: 'DELETE',
    });

    return response.ok;
  } catch {
    return false;
  }
}

```

### userContent.ts

**Path:** `frontend/src/services/userContent.ts`

```typescript
import { getApiBaseUrl } from '@/utils/apiBase';
import { useAuthStore } from '@/stores/useAuthStore';

export type Persona = {
  id: string;
  name: string;
  prompt: string;
  tags: string[];
  createdAt: string;
  updatedAt?: string;
  etag?: string | null;
};

export type MemoSource = {
  conversationId?: string;
  conversationTitle?: string;
  messageId?: string;
};

export type MemoNote = {
  id: string;
  originalContent: string;
  userNote: string;
  tags: string[];
  createdAt: string;
  updatedAt?: string;
  source?: MemoSource;
  etag?: string | null;
};

export type ApiEnvelope<T> = {
  ok: boolean;
  data?: T;
  error?: {
    message: string;
    code?: string;
  };
  cursor?: string | null;
  hasMore?: boolean;
};

export type ListResponse<T> = {
  items: T[];
  cursor: string | null;
  hasMore: boolean;
};

export type PersonaPayload = {
  id?: string;
  name: string;
  prompt: string;
  tags?: string[];
};

export type MemoPayload = {
  id?: string;
  originalContent: string;
  userNote?: string;
  tags?: string[];
  source?: MemoSource;
};

export type CreatePersonaInput = Omit<PersonaPayload, 'id'>;
export type UpdatePersonaInput = Omit<PersonaPayload, 'id'>;
export type CreateMemoInput = Omit<MemoPayload, 'id'>;
export type UpdateMemoInput = Omit<MemoPayload, 'id'>;

function getAuthToken(): string | null {
  const authToken = useAuthStore.getState().token;
  if (authToken && authToken.trim()) {
    return authToken.trim();
  }
  if (typeof window === 'undefined') return null;
  const candidates = [
    'aiMemo.authToken',
    'aiMemo.jwt',
    'auth.token',
    'aiMemoAuthToken',
  ];
  for (const key of candidates) {
    try {
      const raw = localStorage.getItem(key) ?? sessionStorage.getItem(key);
      if (raw) {
        const parsed = JSON.parse(raw);
        if (typeof parsed === 'string' && parsed.trim()) return parsed.trim();
        if (typeof raw === 'string' && raw.trim()) return raw.trim();
      }
    } catch {
      // ignore JSON parse errors
    }
  }
  return null;
}

async function request<T>(
  path: string,
  init?: RequestInit,
  expectJson = true
): Promise<ApiEnvelope<T>> {
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}${path}`;

  const headers = new Headers(init?.headers);
  if (!headers.has('Content-Type') && init?.body) {
    headers.set('Content-Type', 'application/json');
  }
  const token = getAuthToken();
  if (token) headers.set('Authorization', `Bearer ${token}`);
  if (!headers.has('Accept')) headers.set('Accept', 'application/json');

  const res = await fetch(url, {
    ...init,
    headers,
  });

  if (!res.ok) {
    let message = `HTTP ${res.status}`;
    try {
      const data = await res.json();
      message = (data?.error?.message as string) ?? message;
    } catch {
      // ignore body parse errors
    }
    throw new Error(message);
  }

  if (!expectJson) {
    return { ok: true } as ApiEnvelope<T>;
  }

  const body = (await res.json()) as ApiEnvelope<T>;
  if (!body?.ok) {
    throw new Error(body?.error?.message || 'Request failed');
  }
  return body;
}

function normalisePersona(raw: any): Persona {
  return {
    id: String(raw.id),
    name: String(raw.name ?? ''),
    prompt: String(raw.prompt ?? ''),
    tags: Array.isArray(raw.tags) ? raw.tags.map(String) : [],
    createdAt: String(raw.createdAt ?? new Date().toISOString()),
    updatedAt: raw.updatedAt ? String(raw.updatedAt) : undefined,
    etag: raw.etag ? String(raw.etag) : null,
  };
}

function normaliseMemo(raw: any): MemoNote {
  return {
    id: String(raw.id),
    originalContent: String(raw.originalContent ?? ''),
    userNote: String(raw.userNote ?? ''),
    tags: Array.isArray(raw.tags) ? raw.tags.map(String) : [],
    createdAt: String(raw.createdAt ?? new Date().toISOString()),
    updatedAt: raw.updatedAt ? String(raw.updatedAt) : undefined,
    source: raw.source ? { ...raw.source } : undefined,
    etag: raw.etag ? String(raw.etag) : null,
  };
}

export async function listPersonas(cursor?: string | null): Promise<ListResponse<Persona>> {
  const params = cursor ? `?cursor=${encodeURIComponent(cursor)}` : '';
  const res = await request<any[]>(`/api/v1/personas${params}`);
  const payload = Array.isArray(res.data) ? res.data : [];
  const personas = payload.map(normalisePersona);
  const cursorValue = (res.cursor ?? null) as string | null;
  const hasMore = Boolean(res.hasMore);
  return { items: personas, cursor: cursorValue, hasMore };
}

export async function createPersona(input: PersonaPayload): Promise<Persona> {
  const body = JSON.stringify(input);
  const res = await request<any>('/api/v1/personas', {
    method: 'POST',
    body,
  });
  return normalisePersona(res.data ?? {});
}

export async function updatePersona(
  id: string,
  input: PersonaPayload,
  etag?: string | null
): Promise<Persona> {
  const headers: Record<string, string> = {};
  if (etag) headers['If-Match'] = etag;
  const res = await request<any>(`/api/v1/personas/${encodeURIComponent(id)}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(input),
  });
  return normalisePersona(res.data ?? {});
}

export async function deletePersona(id: string, etag?: string | null): Promise<void> {
  const headers: Record<string, string> = {};
  if (etag) headers['If-Match'] = etag;
  await request(`/api/v1/personas/${encodeURIComponent(id)}`, {
    method: 'DELETE',
    headers,
  }, false);
}

export async function listMemos(cursor?: string | null): Promise<ListResponse<MemoNote>> {
  const params = cursor ? `?cursor=${encodeURIComponent(cursor)}` : '';
  const res = await request<any[]>(`/api/v1/memos${params}`);
  const payload = Array.isArray(res.data) ? res.data : [];
  const memos = payload.map(normaliseMemo);
  const cursorValue = (res.cursor ?? null) as string | null;
  const hasMore = Boolean(res.hasMore);
  return { items: memos, cursor: cursorValue, hasMore };
}

export async function createMemo(input: MemoPayload): Promise<MemoNote> {
  const res = await request<any>('/api/v1/memos', {
    method: 'POST',
    body: JSON.stringify(input),
  });
  return normaliseMemo(res.data ?? {});
}

export async function updateMemo(
  id: string,
  input: MemoPayload,
  etag?: string | null
): Promise<MemoNote> {
  const headers: Record<string, string> = {};
  if (etag) headers['If-Match'] = etag;
  const res = await request<any>(`/api/v1/memos/${encodeURIComponent(id)}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(input),
  });
  return normaliseMemo(res.data ?? {});
}

export async function deleteMemo(id: string, etag?: string | null): Promise<void> {
  const headers: Record<string, string> = {};
  if (etag) headers['If-Match'] = etag;
  await request(`/api/v1/memos/${encodeURIComponent(id)}`, {
    method: 'DELETE',
    headers,
  }, false);
}

export const UserContentService = {
  listPersonas,
  createPersona,
  updatePersona,
  deletePersona,
  listMemos,
  createMemo,
  updateMemo,
  deleteMemo,
};

```

---

## frontend/src/services/chat

### api.ts

**Path:** `frontend/src/services/chat/api.ts`

```typescript
/**
 * Chat Service - API Functions
 *
 * 채팅 관련 API 호출 함수들
 */

import { getApiBaseUrl } from '@/utils/apiBase';
import { buildChatUrl, buildChatHeaders, isUnifiedTasksEnabled } from './config';
import { ensureSession } from './session';
import {
  getPageContext,
  getArticleTextSnippet,
  CHAT_STYLE_PROMPT,
  buildContextPrompt,
  buildImageContext,
  buildRAGContextPrompt,
  buildMemoryContextPrompt,
} from './context';
import {
  getParserForContentType,
  createFirstTokenTracker,
} from './stream';
import type {
  ChatStreamEvent,
  StreamChatInput,
  InvokeChatTaskInput,
  InvokeChatTaskResult,
  ChatImageUploadResult,
  ContentPart,
} from './types';

// ============================================================================
// Chat Task API
// ============================================================================

/**
 * AI 태스크 실행 (sketch, prism, chain 등)
 */
export async function invokeChatTask<T = unknown>(
  input: InvokeChatTaskInput
): Promise<InvokeChatTaskResult<T>> {
  if (!isUnifiedTasksEnabled()) {
    throw new Error('Unified chat task API is disabled');
  }

  const sessionID = await ensureSession();
  const url = buildChatUrl('/task', sessionID);
  const headers = buildChatHeaders('json');

  if (input.headers) Object.assign(headers, input.headers);

  const body = {
    mode: input.mode,
    prompt: input.prompt ?? '',
    payload: input.payload ?? {},
    context: input.context ?? getPageContext(),
  };

  const res = await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify(body),
    signal: input.signal,
  });

  const text = await res.text().catch(() => '');
  let parsed: unknown = null;
  if (text) {
    try {
      parsed = JSON.parse(text);
    } catch {
      parsed = text;
    }
  }

  if (!res.ok) {
    const errorMessage =
      typeof parsed === 'object' && parsed !== null && 'error' in (parsed as any)
        ? String((parsed as any).error)
        : text.slice(0, 180) || `status ${res.status}`;
    const error = new Error(`Chat task error: ${errorMessage}`);
    (error as any).status = res.status;
    (error as any).response = parsed;
    throw error;
  }

  const dataCandidate =
    parsed && typeof parsed === 'object'
      ? (parsed as any).data ??
        (parsed as any).result ??
        (parsed as any).output ??
        (parsed as any).payload ??
        parsed
      : parsed;

  return {
    ok: true,
    status: res.status,
    data: (dataCandidate as T) ?? null,
    raw: parsed,
  };
}

// ============================================================================
// Chat Streaming API
// ============================================================================

/**
 * 채팅 메시지 스트리밍
 */
export async function* streamChatEvents(
  input: StreamChatInput
): AsyncGenerator<ChatStreamEvent, void, void> {
  const sessionID = await ensureSession();
  const url = buildChatUrl('/message', sessionID);
  const headers = buildChatHeaders('stream');

  // 페이지 컨텍스트
  const page = input.page || getPageContext();

  // 아티클 컨텍스트
  const shouldUseArticleContext =
    input.useArticleContext !== undefined ? input.useArticleContext : true;
  const articleSnippet = shouldUseArticleContext
    ? getArticleTextSnippet(4000)
    : null;

  // 콘텐츠 파트 구성
  const parts: ContentPart[] = [{ type: 'text', text: CHAT_STYLE_PROMPT }];

  // RAG 컨텍스트 추가
  if (input.ragContext) {
    const ragPrompt = buildRAGContextPrompt(input.ragContext);
    if (ragPrompt) parts.push({ type: 'text', text: ragPrompt });
  }

  // 사용자 메모리 컨텍스트 추가
  if (input.memoryContext) {
    const memoryPrompt = buildMemoryContextPrompt(input.memoryContext);
    if (memoryPrompt) parts.push({ type: 'text', text: memoryPrompt });
  }

  // 아티클 컨텍스트 추가
  const contextPrompt = buildContextPrompt(articleSnippet);
  if (contextPrompt) parts.push({ type: 'text', text: contextPrompt });

  // 사용자 입력 (이미지 포함 여부에 따라)
  if (input.imageUrl) {
    const imageContext = buildImageContext(
      input.imageUrl,
      input.imageAnalysis,
      input.text
    );
    parts.push({ type: 'text', text: imageContext });
  } else {
    parts.push({ type: 'text', text: input.text });
  }

  // 요청 전송
  const res = await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      parts,
      context: { page },
      model: input.model, // AI 모델 선택
    }),
    signal: input.signal,
  });

  if (!res.ok || !res.body) {
    const t = await res.text().catch(() => '');
    throw new Error(`Chat error: ${res.status} ${t.slice(0, 180)}`);
  }

  // 스트림 파싱
  const contentType = res.headers.get('content-type') || '';
  const parser = getParserForContentType(contentType);
  const markFirst = createFirstTokenTracker(input.onFirstToken);

  const reader = res.body.getReader();
  const decoder = new TextDecoder();

  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      if (!chunk) continue;

      const events = parser.processChunk(chunk);
      for (const event of events) {
        if (event.type === 'text') markFirst();
        yield event;
      }
    }

    // 남은 버퍼 처리
    const finalEvents = parser.flush();
    for (const event of finalEvents) {
      if (event.type === 'text') markFirst();
      yield event;
    }
  } finally {
    reader.releaseLock();
  }
}

/**
 * 간단한 텍스트 전용 스트리밍
 */
export async function* streamChatMessage(input: {
  text: string;
}): AsyncGenerator<string, void, void> {
  for await (const ev of streamChatEvents({ text: input.text })) {
    if (ev.type === 'text') yield ev.text;
  }
}

// ============================================================================
// Image Upload API
// ============================================================================

/**
 * 채팅용 이미지 업로드
 */
export async function uploadChatImage(
  file: File,
  signal?: AbortSignal
): Promise<ChatImageUploadResult> {
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/images/chat-upload`;
  const formData = new FormData();
  formData.append('file', file);

  if (process.env.NODE_ENV === 'development') {
    console.log('[ChatImage] Uploading to:', url);
  }

  const res = await fetch(url, {
    method: 'POST',
    body: formData,
    signal,
  });

  const text = await res.text().catch(() => '');
  let parsed: any = null;
  if (text) {
    try {
      parsed = JSON.parse(text);
    } catch {
      parsed = null;
    }
  }

  if (!res.ok || !parsed?.ok) {
    const message =
      (parsed && parsed.error && parsed.error.message) ||
      text.slice(0, 180) ||
      `status ${res.status}`;
    throw new Error(`Chat image upload error: ${message}`);
  }

  const data = parsed.data;
  if (!data || typeof data.url !== 'string') {
    throw new Error('Invalid chat image upload response');
  }

  if (process.env.NODE_ENV === 'development') {
    console.log('[ChatImage] Upload success, analysis:', data.imageAnalysis ? 'OK' : 'NULL');
  }

  return data as ChatImageUploadResult;
}

// ============================================================================
// Aggregate API
// ============================================================================

/**
 * 여러 세션 통합 요약
 */
export async function invokeChatAggregate(input: {
  prompt: string;
  signal?: AbortSignal;
}): Promise<string> {
  const base = getApiBaseUrl();
  const url = `${base.replace(/\/$/, '')}/api/v1/chat/aggregate`;

  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ prompt: input.prompt }),
    signal: input.signal,
  });

  const text = await res.text().catch(() => '');
  let parsed: any = null;
  if (text) {
    try {
      parsed = JSON.parse(text);
    } catch {
      parsed = null;
    }
  }

  if (!res.ok || !parsed?.ok) {
    const message =
      (parsed && parsed.error && parsed.error.message) ||
      text.slice(0, 180) ||
      `status ${res.status}`;
    throw new Error(`Chat aggregate error: ${message}`);
  }

  const data = parsed.data;
  const value =
    (data && typeof data.text === 'string' && data.text) ||
    (typeof data === 'string' ? data : null);

  if (!value) {
    throw new Error('Invalid chat aggregate response');
  }
  return value;
}

```

### config.ts

**Path:** `frontend/src/services/chat/config.ts`

```typescript
/**
 * Chat Service Configuration
 *
 * 런타임/환경 설정 관련 유틸리티
 */

import { getApiBaseUrl } from '@/utils/apiBase';

/**
 * Chat 서버 베이스 URL 가져오기
 * 우선순위: runtime config > env > API base URL
 */
export function getChatBaseUrl(): string {
  const w = typeof window !== 'undefined' ? (window as any) : null;
  const fromRuntime =
    w?.APP_CONFIG?.chatBaseUrl || w?.__APP_CONFIG?.chatBaseUrl;
  if (typeof fromRuntime === 'string' && fromRuntime) return fromRuntime;

  const fromEnv = (import.meta as any)?.env?.VITE_CHAT_BASE_URL as
    | string
    | undefined;
  if (typeof fromEnv === 'string' && fromEnv) return fromEnv;

  return '';
}

/**
 * Chat API 키 가져오기
 */
export function getChatApiKey(): string {
  const w = typeof window !== 'undefined' ? (window as any) : null;
  const fromRuntime = w?.APP_CONFIG?.chatApiKey || w?.__APP_CONFIG?.chatApiKey;
  if (typeof fromRuntime === 'string' && fromRuntime) return fromRuntime;

  const fromEnv = (import.meta as any)?.env?.VITE_CHAT_API_KEY as
    | string
    | undefined;
  if (typeof fromEnv === 'string' && fromEnv) return fromEnv;

  return '';
}

/**
 * 불리언 값 파싱 유틸리티
 */
export function getBooleanFromUnknown(value: unknown): boolean {
  if (typeof value === 'boolean') return value;
  if (typeof value === 'number') return value !== 0;
  if (typeof value === 'string') {
    const lowered = value.trim().toLowerCase();
    return lowered === '1' || lowered === 'true' || lowered === 'yes' || lowered === 'on';
  }
  return false;
}

/**
 * 통합 태스크 API 활성화 여부
 */
export function isUnifiedTasksEnabled(): boolean {
  const w = typeof window !== 'undefined' ? (window as any) : null;
  const runtimeFlag =
    w?.APP_CONFIG?.aiUnified ?? w?.__APP_CONFIG?.aiUnified ?? undefined;
  if (runtimeFlag !== undefined) return getBooleanFromUnknown(runtimeFlag);

  const envFlag = (import.meta as any)?.env?.VITE_AI_UNIFIED as
    | string
    | boolean
    | undefined;
  return getBooleanFromUnknown(envFlag);
}

/**
 * Chat 엔드포인트 URL 생성 헬퍼
 */
export function buildChatUrl(path: string, sessionId?: string): string {
  const chatBase = getChatBaseUrl();

  if (chatBase) {
    const base = chatBase.replace(/\/$/, '');
    return sessionId
      ? `${base}/session/${encodeURIComponent(sessionId)}${path}`
      : `${base}${path}`;
  }

  const apiBase = getApiBaseUrl().replace(/\/$/, '');
  return sessionId
    ? `${apiBase}/api/v1/chat/session/${encodeURIComponent(sessionId)}${path}`
    : `${apiBase}/api/v1/chat${path}`;
}

/**
 * Chat 요청 헤더 생성
 */
export function buildChatHeaders(
  contentType: 'json' | 'stream' = 'json'
): Record<string, string> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  if (contentType === 'stream') {
    headers['Accept'] = 'text/event-stream, application/x-ndjson, text/plain';
  } else {
    headers['Accept'] = 'application/json, text/plain';
  }

  const apiKey = getChatApiKey();
  if (apiKey && getChatBaseUrl()) {
    headers['X-API-KEY'] = apiKey;
  }

  return headers;
}

```

### context.ts

**Path:** `frontend/src/services/chat/context.ts`

```typescript
/**
 * Chat Service - Context Utilities
 *
 * 페이지 컨텍스트 및 아티클 텍스트 추출 유틸리티
 */

import type { PageContext } from './types';

/**
 * 현재 페이지 컨텍스트 가져오기
 */
export function getPageContext(): PageContext {
  const w = typeof window !== 'undefined' ? (window as any) : null;
  const url = w?.location?.href as string | undefined;
  const title = w?.document?.title as string | undefined;
  return { url, title };
}

/**
 * 현재 페이지의 아티클 텍스트 스니펫 추출
 *
 * @param maxChars - 최대 문자 수
 * @returns 아티클 텍스트 또는 null
 */
export function getArticleTextSnippet(maxChars = 4000): string | null {
  if (typeof document === 'undefined') return null;

  try {
    const pick = (selector: string): string | null => {
      const el = document.querySelector(selector) as HTMLElement | null;
      if (!el) return null;
      const text = (el.innerText || '').trim();
      return text && text.length > 40 ? text : null;
    };

    // 우선순위에 따라 셀렉터 시도
    const candidates = [
      'article',
      'main article',
      'article.prose',
      '.prose article',
      '.prose',
      '#content',
    ];

    for (const sel of candidates) {
      const v = pick(sel);
      if (v) {
        if (v.length <= maxChars) return v;
        return `${v.slice(0, maxChars)}\n…(truncated)`;
      }
    }

    // 폴백: body 전체
    const bodyText = (document.body?.innerText || '').trim();
    if (!bodyText) return null;
    if (bodyText.length <= maxChars) return bodyText;
    return `${bodyText.slice(0, maxChars)}\n…(truncated)`;
  } catch {
    return null;
  }
}

/**
 * 챗봇 스타일 프롬프트
 */
export const CHAT_STYLE_PROMPT =
  '다음 지침을 따르세요: 말투는 귀엽고 상냥한 애니메이션 여캐릭터(botchi)처럼, 존댓말을 유지하고 과하지 않게 가벼운 말끝(예: ~에요, ~일까요?)과 가끔 이모지(^_^, ✨)를 섞습니다. 응답은 간결하고 핵심만 전합니다.';

/**
 * 컨텍스트 프롬프트 생성
 */
export function buildContextPrompt(articleSnippet: string | null): string {
  if (!articleSnippet) return '';

  return [
    '현재 보고 있는 페이지의 본문 일부를 함께 전달할게요.',
    '이 내용을 참고해서 사용자의 질문에 더 정확하게 답변해 주세요.',
    '',
    '[페이지 본문]',
    articleSnippet,
    '',
    '---',
    '',
  ].join('\n');
}

/**
 * 이미지 컨텍스트 생성
 */
export function buildImageContext(
  imageUrl: string,
  imageAnalysis: string | null | undefined,
  userText: string
): string {
  let imageContext = '';

  if (imageAnalysis) {
    imageContext += `[첨부된 이미지 분석 결과]\n${imageAnalysis}\n\n`;
  }

  imageContext += `[이미지 링크: ${imageUrl}]\n\n`;
  imageContext += userText || '이 이미지에 대해 설명해 주세요.';

  return imageContext;
}

/**
 * RAG 컨텍스트 프롬프트 생성
 */
export function buildRAGContextPrompt(ragContext: string | null): string {
  if (!ragContext) return '';

  return [
    '[관련 블로그 문서]',
    '다음은 질문과 관련된 블로그 글입니다. 답변 시 참고하세요:',
    '',
    ragContext,
    '',
    '---',
    '',
  ].join('\n');
}

/**
 * 사용자 메모리 컨텍스트 프롬프트 생성
 */
export function buildMemoryContextPrompt(memoryContext: string | null): string {
  if (!memoryContext) return '';

  return [
    '[사용자 정보]',
    '다음은 이전 대화에서 파악한 사용자에 대한 정보입니다.',
    '답변 시 이 정보를 자연스럽게 활용하되, 명시적으로 언급하지는 마세요:',
    '',
    memoryContext,
    '',
    '---',
    '',
  ].join('\n');
}

```

### index.ts

**Path:** `frontend/src/services/chat/index.ts`

```typescript
/**
 * Chat Service - Main Export
 *
 * 모듈화된 채팅 서비스의 통합 export
 */

// Types
export type {
  ChatSession,
  ChatTaskMode,
  InvokeChatTaskInput,
  InvokeChatTaskResult,
  ChatStreamEvent,
  StreamChatInput,
  ChatImageUploadResult,
  PageContext,
  ContentPart,
} from './types';

// Config
export {
  getChatBaseUrl,
  getChatApiKey,
  isUnifiedTasksEnabled,
  buildChatUrl,
  buildChatHeaders,
} from './config';

// Session
export {
  ensureSession,
  getStoredSessionId,
  storeSessionId,
  clearStoredSessionId,
} from './session';

// Context
export {
  getPageContext,
  getArticleTextSnippet,
  CHAT_STYLE_PROMPT,
  buildContextPrompt,
  buildImageContext,
  buildRAGContextPrompt,
  buildMemoryContextPrompt,
} from './context';

// Stream parsing
export {
  extractTexts,
  parseStreamObject,
  parseSSEFrame,
  createFirstTokenTracker,
  createSSEParser,
  createNDJSONParser,
  createJSONParser,
  createPlainTextParser,
  getParserForContentType,
} from './stream';
export type { StreamParser } from './stream';

// API functions
export {
  invokeChatTask,
  streamChatEvents,
  streamChatMessage,
  uploadChatImage,
  invokeChatAggregate,
} from './api';

```

### session.ts

**Path:** `frontend/src/services/chat/session.ts`

```typescript
/**
 * Chat Service - Session Management
 *
 * 세션 생성 및 관리
 */

import { buildChatUrl, buildChatHeaders } from './config';

const SESSION_STORAGE_KEY = 'nodove_chat_session_id';

/**
 * 기존 세션 ID 가져오기
 */
export function getStoredSessionId(): string | null {
  try {
    const existing = localStorage.getItem(SESSION_STORAGE_KEY);
    if (existing && typeof existing === 'string' && existing.trim()) {
      return existing;
    }
  } catch {
    // localStorage 접근 실패
  }
  return null;
}

/**
 * 세션 ID 저장
 */
export function storeSessionId(sessionId: string): void {
  try {
    localStorage.setItem(SESSION_STORAGE_KEY, sessionId);
  } catch {
    // localStorage 접근 실패
  }
}

/**
 * 세션 ID 삭제 (재생성 필요 시)
 */
export function clearStoredSessionId(): void {
  try {
    localStorage.removeItem(SESSION_STORAGE_KEY);
  } catch {
    // localStorage 접근 실패
  }
}

/**
 * 세션 확보 (기존 세션 또는 새 세션 생성)
 *
 * @returns 세션 ID
 * @throws 세션 생성 실패 시
 */
export async function ensureSession(): Promise<string> {
  // 기존 세션 확인
  const existing = getStoredSessionId();
  if (existing) {
    return existing;
  }

  // 새 세션 생성
  const url = buildChatUrl('/session');
  const headers = buildChatHeaders('json');

  const res = await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify({ title: 'Nodove Blog Visitor Session' }),
  });

  if (!res.ok) {
    const t = await res.text().catch(() => '');
    throw new Error(`Failed to create session: ${res.status} ${t.slice(0, 180)}`);
  }

  const data = (await res.json().catch(() => ({}))) as any;
  const id =
    data?.sessionID || data?.id || data?.data?.sessionID || data?.data?.id;

  if (!id || typeof id !== 'string') {
    throw new Error('Invalid session response');
  }

  storeSessionId(id);
  return id;
}

```

### stream.ts

**Path:** `frontend/src/services/chat/stream.ts`

```typescript
/**
 * Chat Service - Stream Parser
 *
 * SSE/NDJSON 스트림 파싱 유틸리티
 */

import type { ChatStreamEvent } from './types';

/**
 * 응답 객체에서 텍스트 추출
 */
export function extractTexts(obj: any): string[] {
  const out: string[] = [];
  if (!obj || typeof obj !== 'object') return out;

  // 직접 content
  if (typeof obj.content === 'string') out.push(obj.content);

  // parts 배열
  if (Array.isArray(obj.parts)) {
    for (const p of obj.parts) {
      if (p) {
        if (typeof (p as any).text === 'string') out.push((p as any).text);
        else if (typeof (p as any).content === 'string')
          out.push((p as any).content);
      }
    }
  }

  // message.content
  if (obj.message && typeof obj.message.content === 'string') {
    out.push(obj.message.content);
  }

  // OpenAI 스타일 choices
  if (Array.isArray(obj.choices)) {
    for (const c of obj.choices) {
      const delta = c?.delta?.content ?? c?.message?.content;
      if (typeof delta === 'string') out.push(delta);
    }
  }

  // delta 필드
  if (typeof obj.delta === 'string') out.push(obj.delta);

  return out;
}

/**
 * JSON 객체를 ChatStreamEvent로 변환
 */
export function parseStreamObject(obj: any): ChatStreamEvent[] {
  const events: ChatStreamEvent[] = [];

  // 텍스트 추출
  const texts = extractTexts(obj);
  for (const t of texts) {
    if (t) events.push({ type: 'text', text: t });
  }

  // 소스
  const srcs = obj?.sources;
  if (Array.isArray(srcs)) {
    events.push({ type: 'sources', sources: srcs });
  }

  // 후속 질문
  const fups = obj?.followups || obj?.suggestions;
  if (Array.isArray(fups)) {
    events.push({ type: 'followups', questions: fups });
  }

  // 컨텍스트
  const ctx = obj?.context;
  if (ctx && typeof ctx === 'object') {
    events.push({ type: 'context', page: ctx.page || ctx });
  }

  return events;
}

/**
 * SSE 프레임 파싱
 */
export function parseSSEFrame(frame: string): {
  data: string;
  event?: string;
} | null {
  const lines = frame.split('\n');
  const datas: string[] = [];
  let evt: string | undefined;

  for (const ln of lines) {
    if (ln.startsWith('data:')) datas.push(ln.slice(5).trim());
    else if (ln.startsWith('event:')) evt = ln.slice(6).trim();
  }

  const data = datas.join('\n');
  if (!data) return null;

  return { data, event: evt };
}

/**
 * First Token 타이밍 트래커
 */
export function createFirstTokenTracker(
  onFirstToken?: (ms: number) => void
): () => void {
  const started =
    typeof performance !== 'undefined' && performance.now
      ? performance.now()
      : Date.now();
  let firstEmitted = false;

  return () => {
    if (!firstEmitted) {
      firstEmitted = true;
      const now =
        typeof performance !== 'undefined' && performance.now
          ? performance.now()
          : Date.now();
      if (typeof onFirstToken === 'function') {
        onFirstToken(Math.max(0, Math.round(now - started)));
      }
    }
  };
}

/**
 * 스트림 타입별 파서
 */
export type StreamParser = {
  processChunk: (chunk: string) => ChatStreamEvent[];
  flush: () => ChatStreamEvent[];
};

export function createSSEParser(): StreamParser {
  let buffer = '';

  return {
    processChunk(chunk: string): ChatStreamEvent[] {
      buffer += chunk;
      const events: ChatStreamEvent[] = [];

      while (true) {
        const sep = buffer.indexOf('\n\n');
        if (sep < 0) break;

        const frame = buffer.slice(0, sep);
        buffer = buffer.slice(sep + 2);

        const parsed = parseSSEFrame(frame);
        if (!parsed) continue;

        const { data, event } = parsed;

        if (data === '[DONE]' || event === 'done') {
          events.push({ type: 'done' });
          continue;
        }

        try {
          const obj = JSON.parse(data);
          events.push(...parseStreamObject(obj));
        } catch {
          // JSON 파싱 실패 시 텍스트로 처리
          events.push({ type: 'text', text: data });
        }
      }

      return events;
    },
    flush(): ChatStreamEvent[] {
      return [];
    },
  };
}

export function createNDJSONParser(): StreamParser {
  let buffer = '';

  return {
    processChunk(chunk: string): ChatStreamEvent[] {
      buffer += chunk;
      const events: ChatStreamEvent[] = [];

      while (true) {
        const nl = buffer.indexOf('\n');
        if (nl < 0) break;

        const line = buffer.slice(0, nl).trim();
        buffer = buffer.slice(nl + 1);

        if (!line) continue;

        if (line === '[DONE]') {
          events.push({ type: 'done' });
          continue;
        }

        try {
          const obj = JSON.parse(line);
          events.push(...parseStreamObject(obj));
        } catch {
          events.push({ type: 'text', text: line });
        }
      }

      return events;
    },
    flush(): ChatStreamEvent[] {
      const events: ChatStreamEvent[] = [];
      const lines = buffer.split('\n');

      for (const s of lines) {
        const line = s.trim();
        if (!line) continue;

        if (line === '[DONE]') {
          events.push({ type: 'done' });
          continue;
        }

        try {
          const obj = JSON.parse(line);
          events.push(...parseStreamObject(obj));
        } catch {
          events.push({ type: 'text', text: line });
        }
      }

      buffer = '';
      return events;
    },
  };
}

export function createJSONParser(): StreamParser {
  let buffer = '';

  return {
    processChunk(chunk: string): ChatStreamEvent[] {
      buffer += chunk;
      return []; // JSON은 끝까지 모아서 파싱
    },
    flush(): ChatStreamEvent[] {
      if (!buffer) return [];

      try {
        const obj = JSON.parse(buffer);
        return parseStreamObject(obj);
      } catch {
        return [{ type: 'text', text: buffer }];
      }
    },
  };
}

export function createPlainTextParser(): StreamParser {
  return {
    processChunk(chunk: string): ChatStreamEvent[] {
      return [{ type: 'text', text: chunk }];
    },
    flush(): ChatStreamEvent[] {
      return [];
    },
  };
}

/**
 * Content-Type에 따른 파서 선택
 */
export function getParserForContentType(contentType: string): StreamParser {
  const ct = contentType.toLowerCase();

  if (ct.includes('text/event-stream')) {
    return createSSEParser();
  }
  if (ct.includes('ndjson') || ct.includes('jsonl')) {
    return createNDJSONParser();
  }
  if (ct.includes('application/json')) {
    return createJSONParser();
  }
  if (ct.includes('text/plain')) {
    return createPlainTextParser();
  }

  // 기본값: SSE
  return createSSEParser();
}

```

### types.ts

**Path:** `frontend/src/services/chat/types.ts`

```typescript
/**
 * Chat Service Types
 *
 * 타입 정의 모음
 */

// ============================================================================
// Session Types
// ============================================================================

export type ChatSession = {
  sessionID: string;
};

// ============================================================================
// Task Types
// ============================================================================

export type ChatTaskMode =
  | 'catalyst'
  | 'sketch'
  | 'prism'
  | 'chain'
  | 'summary'
  | 'custom';

export type InvokeChatTaskInput = {
  mode: ChatTaskMode;
  prompt?: string;
  payload?: Record<string, unknown>;
  context?: { url?: string; title?: string };
  signal?: AbortSignal;
  headers?: Record<string, string>;
};

export type InvokeChatTaskResult<T = unknown> = {
  ok: boolean;
  status: number;
  data: T | null;
  raw: unknown;
};

// ============================================================================
// Stream Types
// ============================================================================

export type ChatStreamEvent =
  | { type: 'text'; text: string }
  | {
      type: 'sources';
      sources: Array<{
        title?: string;
        url?: string;
        score?: number;
        snippet?: string;
      }>;
    }
  | { type: 'followups'; questions: string[] }
  | { type: 'context'; page?: { url?: string; title?: string } }
  | { type: 'done' };

export type StreamChatInput = {
  text: string;
  page?: { url?: string; title?: string };
  signal?: AbortSignal;
  onFirstToken?: (ms: number) => void;
  useArticleContext?: boolean;
  imageUrl?: string;
  imageAnalysis?: string | null;
  ragContext?: string | null; // RAG 검색 컨텍스트 (블로그 포스트)
  memoryContext?: string | null; // 사용자 메모리 컨텍스트
  model?: string; // AI 모델 선택
};

// ============================================================================
// Image Upload Types
// ============================================================================

export type ChatImageUploadResult = {
  url: string;
  key: string;
  size: number;
  contentType: string;
  imageAnalysis?: string | null;
};

// ============================================================================
// Context Types
// ============================================================================

export type PageContext = {
  url?: string;
  title?: string;
};

export type ContentPart = {
  type: 'text';
  text: string;
};

```

---

## frontend/src/stores

### useAuthStore.ts

**Path:** `frontend/src/stores/useAuthStore.ts`

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export type AuthState = {
  token: string | null;
  setToken: (token: string | null) => void;
  clearToken: () => void;
};

const STORAGE_KEY = 'aiMemo.auth';

export const useAuthStore = create<AuthState>()(
  persist(
    set => ({
      token: null,
      setToken: token => set({ token: token?.trim() || null }),
      clearToken: () => set({ token: null }),
    }),
    {
      name: STORAGE_KEY,
      partialize: state => ({ token: state.token }),
    }
  )
);

export function bootstrapAuthTokenFromLegacyStorage(): void {
  try {
    const legacyKeys = ['aiMemo.authToken', 'aiMemo.jwt', 'auth.token', 'aiMemoAuthToken'];
    for (const key of legacyKeys) {
      const raw = localStorage.getItem(key) ?? sessionStorage.getItem(key);
      if (!raw) continue;
      try {
        const parsed = JSON.parse(raw);
        if (typeof parsed === 'string' && parsed.trim()) {
          useAuthStore.getState().setToken(parsed.trim());
          return;
        }
      } catch {
        if (raw.trim()) {
          useAuthStore.getState().setToken(raw.trim());
          return;
        }
      }
    }
  } catch {
    // ignore storage access errors
  }
}

```

### useMemoStore.ts

**Path:** `frontend/src/stores/useMemoStore.ts`

```typescript
import { create } from 'zustand';
import { produce } from 'immer';
import { toast } from '@/hooks/use-toast';
import {
  CreateMemoInput,
  MemoNote,
  UpdateMemoInput,
  UserContentService,
} from '@/services/userContent';

export type MemoStoreState = {
  memos: MemoNote[];
  isLoading: boolean;
  fetchMemos: () => Promise<void>;
  createMemo: (input: CreateMemoInput) => Promise<MemoNote | undefined>;
  updateMemo: (id: string, input: UpdateMemoInput) => Promise<MemoNote | undefined>;
  deleteMemo: (id: string) => Promise<boolean>;
  isMessageSaved: (messageId: string) => boolean;
  replaceAll: (memos: MemoNote[]) => void;
};

type OptimisticMemo = MemoNote & { __optimistic?: boolean };

export const useMemoStore = create<MemoStoreState>((set, get) => ({
  memos: [],
  isLoading: false,

  replaceAll: memos => set({ memos }),

  fetchMemos: async () => {
    set({ isLoading: true });
    try {
      const { items } = await UserContentService.listMemos();
      set({ memos: items, isLoading: false });
    } catch (error) {
      console.error('[useMemoStore] fetchMemos error', error);
      toast({ title: '메모 불러오기 실패', description: '네트워크 상태를 확인하고 다시 시도해주세요.' });
      set({ isLoading: false });
    }
  },

  createMemo: async input => {
    const tempId = `temp-${Date.now()}`;
    const createdAt = new Date().toISOString();
    const optimistic: OptimisticMemo = {
      id: tempId,
      originalContent: input.originalContent,
      userNote: input.userNote ?? '',
      tags: input.tags ?? [],
      source: input.source,
      createdAt,
      updatedAt: createdAt,
      etag: null,
      __optimistic: true,
    };

    set(state => ({ memos: [optimistic, ...state.memos] }));
    toast({ title: '저장 중…', description: '메모를 저장하고 있어요.' });

    try {
      const memo = await UserContentService.createMemo(input);
      set(state =>
        produce(state, draft => {
          const target = draft.memos.find(m => m.id === tempId);
          if (!target) return;
          Object.assign(target, memo);
          delete (target as OptimisticMemo).__optimistic;
        })
      );
      toast({ title: '메모에 저장됨', description: 'AI 응답이 메모장에 추가되었어요.' });
      return memo;
    } catch (error) {
      console.error('[useMemoStore] createMemo error', error);
      set(state => ({ memos: state.memos.filter(m => m.id !== tempId) }));
      toast({ title: '메모 저장 실패', description: '잠시 후 다시 시도해주세요.' });
      return undefined;
    }
  },

  updateMemo: async (id, input) => {
    const original = get().memos;
    const target = original.find(m => m.id === id);
    if (!target) return undefined;

    const optimistic = produce(original, draft => {
      const memo = draft.find(m => m.id === id);
      if (!memo) return;
      memo.userNote = input.userNote ?? memo.userNote;
      memo.tags = input.tags ?? memo.tags;
      if (input.originalContent) memo.originalContent = input.originalContent;
      if (input.source) memo.source = input.source;
      memo.updatedAt = new Date().toISOString();
    });
    set({ memos: optimistic });

    try {
      const updated = await UserContentService.updateMemo(id, input, target.etag);
      set(state =>
        produce(state, draft => {
          const memo = draft.memos.find(m => m.id === id);
          if (!memo) return;
          Object.assign(memo, updated);
        })
      );
      toast({ title: '메모가 업데이트되었습니다.' });
      return updated;
    } catch (error: any) {
      console.error('[useMemoStore] updateMemo error', error);
      set({ memos: original });
      const status = error?.message?.includes?.('412') ? '동일한 메모가 이미 수정되었어요.' : '잠시 후 다시 시도해주세요.';
      toast({ title: '메모 수정 실패', description: status });
      return undefined;
    }
  },

  deleteMemo: async id => {
    const original = get().memos;
    const target = original.find(m => m.id === id);
    if (!target) return false;

    set({ memos: original.filter(m => m.id !== id) });
    try {
      await UserContentService.deleteMemo(id, target.etag);
      toast({ title: '메모가 삭제되었습니다.' });
      return true;
    } catch (error: any) {
      console.error('[useMemoStore] deleteMemo error', error);
      set({ memos: original });
      const message = error?.message?.includes?.('412')
        ? '다른 곳에서 수정된 메모예요. 새로고침 후 다시 시도해주세요.'
        : '메모 삭제에 실패했습니다. 다시 시도해주세요.';
      toast({ title: '삭제 실패', description: message });
      return false;
    }
  },

  isMessageSaved: messageId => {
    return get().memos.some(memo => memo.source?.messageId === messageId);
  },
}));

```

---

## frontend/src/test

### BlogCard.prefetch.test.tsx

**Path:** `frontend/src/test/BlogCard.prefetch.test.tsx`

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ThemeProvider } from '../contexts/ThemeContext';
import { BrowserRouter } from 'react-router-dom';
import { BlogCard } from '../components/features/blog';

vi.mock('@/data/posts', () => {
  return {
    prefetchPost: vi.fn(() => Promise.resolve()),
  };
});

// Use ESM import so alias resolution works under Vitest
import { prefetchPost } from '@/data/posts';

const renderWithProviders = (ui: React.ReactElement) => {
  return render(
    <BrowserRouter>
      <ThemeProvider>{ui}</ThemeProvider>
    </BrowserRouter>
  );
};

const mockPost = {
  id: '1',
  title: 'Test Blog Post',
  description: 'Description',
  excerpt: 'Description',
  date: '2025-01-01',
  year: '2025',
  category: 'Tech',
  tags: ['React'],
  content: '',
  slug: 'test-blog-post',
  readTime: 5,
  readingTime: '5 min read',
  author: 'Me',
  published: true,
};

describe('BlogCard prefetch triggers', () => {
  beforeEach(() => {
    vi.mocked(prefetchPost).mockClear();
  });

  it('calls prefetchPost on hover and focus for title link', async () => {
    const user = userEvent.setup();
    renderWithProviders(<BlogCard post={mockPost} />);

    const titleLink = screen.getByRole('link', { name: /test blog post/i });

    await user.hover(titleLink);
    expect(vi.mocked(prefetchPost)).toHaveBeenCalledWith(
      '2025',
      'test-blog-post'
    );

    await user.unhover(titleLink);

    await user.tab(); // focus first focusable element (likely the link)
    expect(vi.mocked(prefetchPost)).toHaveBeenCalledWith(
      '2025',
      'test-blog-post'
    );
  });

  it('calls prefetchPost on hover and focus for Read more link', async () => {
    const user = userEvent.setup();
    renderWithProviders(<BlogCard post={mockPost} />);

    const readMore = screen.getByRole('link', { name: /read more/i });

    await user.hover(readMore);
    expect(vi.mocked(prefetchPost)).toHaveBeenCalledWith(
      '2025',
      'test-blog-post'
    );

    await user.unhover(readMore);

    readMore.focus();
    expect(vi.mocked(prefetchPost)).toHaveBeenCalledTimes(2);
    expect(vi.mocked(prefetchPost)).toHaveBeenNthCalledWith(
      1,
      '2025',
      'test-blog-post'
    );
    expect(vi.mocked(prefetchPost)).toHaveBeenNthCalledWith(
      2,
      '2025',
      'test-blog-post'
    );
  });
});

```

### BlogCard.test.tsx

**Path:** `frontend/src/test/BlogCard.test.tsx`

```tsx
import { render, screen } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import { ThemeProvider } from '../contexts/ThemeContext';
import { BrowserRouter } from 'react-router-dom';
import { BlogCard } from '../components/features/blog';

// Mock blog post data
const mockPost = {
  id: '1',
  title: 'Test Blog Post',
  description: 'This is a test blog post description',
  excerpt: 'This is a test blog post description',
  date: '2024-01-01',
  year: '2024',
  category: 'Tech',
  tags: ['React', 'TypeScript'],
  content: 'Test content',
  slug: 'test-blog-post',
  readTime: 5,
  readingTime: '5분 읽기',
  author: 'Test Author',
  published: true,
};

const renderWithProviders = (ui: React.ReactElement) => {
  return render(
    <BrowserRouter>
      <ThemeProvider>{ui}</ThemeProvider>
    </BrowserRouter>
  );
};

describe('BlogCard Component', () => {
  it('renders blog post information correctly', () => {
    renderWithProviders(<BlogCard post={mockPost} />);

    expect(screen.getByText('Test Blog Post')).toBeInTheDocument();
    expect(
      screen.getByText('This is a test blog post description')
    ).toBeInTheDocument();
    expect(screen.getByText('Tech')).toBeInTheDocument();
    expect(screen.getByText('React')).toBeInTheDocument();
    expect(screen.getByText('TypeScript')).toBeInTheDocument();
  });

  it('displays read time when provided', () => {
    renderWithProviders(<BlogCard post={mockPost} />);

    expect(screen.getByText('5분 읽기')).toBeInTheDocument();
  });
});

```

### BlogPost.integration.test.tsx

**Path:** `frontend/src/test/BlogPost.integration.test.tsx`

```tsx
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import {
  render,
  screen,
  waitForElementToBeRemoved,
} from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { MemoryRouter, Route, Routes } from 'react-router-dom';
import { ThemeProvider } from '@/contexts/ThemeContext';
import BlogPost from '@/pages/BlogPost';

// Mock data layer
vi.mock('@/data/posts', () => {
  return {
    getPostBySlug: vi.fn(async () => ({
      id: 'test',
      title: 'Test Blog Post',
      description: 'Desc',
      excerpt: 'Desc',
      content: '# Hello\n\nWorld',
      date: '2025-01-01',
      author: 'Me',
      tags: ['tag1'],
      category: 'Tech',
      readingTime: '1 min read',
      slug: 'test',
      year: '2025',
      published: true,
    })),
    getPostsPage: vi.fn(async () => ({
      items: [
        {
          id: 'rel-1',
          title: 'Related One',
          description: 'Rel1',
          excerpt: 'Rel1',
          content: '',
          date: '2025-01-02',
          author: 'Me',
          tags: ['tag1'],
          category: 'Tech',
          readingTime: '2 min read',
          slug: 'rel-one',
          year: '2025',
          published: true,
        },
        {
          id: 'rel-2',
          title: 'Related Two',
          description: 'Rel2',
          excerpt: 'Rel2',
          content: '',
          date: '2025-01-03',
          author: 'Me',
          tags: ['tag2'],
          category: 'Tech',
          readingTime: '3 min read',
          slug: 'rel-two',
          year: '2025',
          published: true,
        },
      ],
      page: 1,
      pageSize: 6,
      total: 2,
      totalPages: 1,
      hasMore: false,
    })),
    prefetchPost: vi.fn(() => Promise.resolve()),
  };
});

// Mock MarkdownRenderer to force Suspense fallback first, then resolve
vi.mock('@/components/features/blog/MarkdownRenderer', () => {
  let resolved = false;
  let doResolve: () => void;
  const p = new Promise<void>(r => {
    doResolve = () => {
      resolved = true;
      r();
    };
  });
  const Comp = () => {
    if (!resolved) {
      throw p; // trigger Suspense fallback
    }
    return <div data-testid='markdown'>Rendered Markdown</div>;
  };
  // expose a handle so tests can resolve when needed
  return { default: Comp, __resolve: () => doResolve!() } as any;
});

// Import mocked modules (vi.mock hoists above)
import { prefetchPost } from '@/data/posts';
// @ts-expect-error - __resolve is a test-only export from the mock
import { __resolve as resolveMarkdown } from '@/components/features/blog/MarkdownRenderer';

const renderWithProviders = (initialEntries: string[]) => {
  return render(
    <MemoryRouter initialEntries={initialEntries}>
      <ThemeProvider>
        <Routes>
          <Route path='/blog/:year/:slug' element={<BlogPost />} />
          <Route path='*' element={<div>Fallback</div>} />
        </Routes>
      </ThemeProvider>
    </MemoryRouter>
  );
};

describe('BlogPost integration', () => {
  beforeEach(() => {
    vi.restoreAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('shows Suspense fallback while MarkdownRenderer is loading, then renders content', async () => {
    renderWithProviders(['/blog/2025/test']);

    // Wait for page to leave initial loading state (title visible)
    await screen.findByText('Test Blog Post');

    // Suspense fallback should be visible initially
    const fallback = screen.getByLabelText(/Loading article content/i);
    expect(fallback).toBeInTheDocument();

    // Now resolve the mocked MarkdownRenderer and wait for fallback to disappear
    resolveMarkdown();
    await waitForElementToBeRemoved(() =>
      screen.queryByLabelText(/Loading article content/i)
    );

    // Content rendered
    expect(screen.getByTestId('markdown')).toBeInTheDocument();
  });

  it('prefetches related post markdown on hover and focus', async () => {
    const user = userEvent.setup();
    renderWithProviders(['/blog/2025/test']);

    // Resolve markdown so the page is stable
    resolveMarkdown();
    await screen.findByTestId('markdown');

    // Related links should appear
    const rel1 = await screen.findByRole('link', { name: /related one/i });
    const rel2 = await screen.findByRole('link', { name: /related two/i });

    await user.hover(rel1);
    expect(vi.mocked(prefetchPost)).toHaveBeenCalledWith('2025', 'rel-one');
    await user.unhover(rel1);

    rel2.focus();
    expect(vi.mocked(prefetchPost)).toHaveBeenCalledWith('2025', 'rel-two');
  });
});

```

### BlogPost.scroll-top.test.tsx

**Path:** `frontend/src/test/BlogPost.scroll-top.test.tsx`

```tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, act } from '@testing-library/react';
import { MemoryRouter, Route, Routes } from 'react-router-dom';
import { ThemeProvider } from '@/contexts/ThemeContext';
import BlogPost from '@/pages/BlogPost';

vi.mock('@/data/posts', () => {
  const post = {
    id: 'test',
    title: 'Test Blog Post',
    description: 'Desc',
    excerpt: 'Desc',
    content: '# Hello',
    date: '2025-01-01',
    author: 'Me',
    tags: ['tag1'],
    category: 'Tech',
    readingTime: '1 min read',
    slug: 'test',
    year: '2025',
    published: true,
  };
  return {
    getPostBySlug: vi.fn(async (_year: string, slug: string) => ({
      ...post,
      slug,
    })),
    getPostsPage: vi.fn(async () => ({
      items: [],
      page: 1,
      pageSize: 6,
      total: 0,
      totalPages: 0,
      hasMore: false,
    })),
    prefetchPost: vi.fn(() => Promise.resolve()),
  };
});

vi.mock('@/components/features/blog/MarkdownRenderer', () => ({
  default: () => <div data-testid='markdown'>Rendered Markdown</div>,
}));

const renderRoute = (initialEntries: string[]) =>
  render(
    <MemoryRouter initialEntries={initialEntries}>
      <ThemeProvider>
        <Routes>
          <Route path='/blog/:year/:slug' element={<BlogPost />} />
        </Routes>
      </ThemeProvider>
    </MemoryRouter>
  );

describe('BlogPost scroll-to-top', () => {
  const origScrollTo = window.scrollTo;

  beforeEach(() => {
    // jsdom doesn't implement scrollTo; mock and track calls
    // @ts-expect-error - allow spying on scrollTo
    window.scrollTo = vi.fn();
  });

  it('scrolls to top when navigating to a different post', async () => {
    renderRoute(['/blog/2025/foo']);
    // Wait for initial post title
    await screen.findByText(/Test Blog Post/i);

    // Navigate to new entry by pushing a new location
    renderRoute(['/blog/2025/bar']);
    await screen.findByText(/Test Blog Post/i);

    expect(window.scrollTo).toHaveBeenCalledWith({
      top: 0,
      left: 0,
      behavior: 'auto',
    });
  });

  it('records visited posts to localStorage on load', async () => {
    localStorage.clear();
    renderRoute(['/blog/2025/abc']);
    await screen.findByText(/Test Blog Post/i);
    const raw = localStorage.getItem('visited.posts');
    expect(raw).toBeTruthy();
    const arr = JSON.parse(raw || '[]');
    expect(arr[0].path).toBe('/blog/2025/abc');
  });

  // restore scrollTo for any other tests
  afterAll(() => {
    window.scrollTo = origScrollTo;
  });
});

```

### FloatingActionBar.feature-flag.test.tsx

**Path:** `frontend/src/test/FloatingActionBar.feature-flag.test.tsx`

```tsx
import { render, screen, cleanup, waitFor } from '@testing-library/react';
import { describe, it, expect, afterEach, beforeEach, vi } from 'vitest';
import { act } from 'react';
import App from '../App';

const seedVisited = () => {
  const items = [
    { path: '/blog/2025/foo', title: 'Foo', year: '2025', slug: 'foo' },
    { path: '/blog/2025/bar', title: 'Bar', year: '2025', slug: 'bar' },
  ];
  window.localStorage.setItem('visited.posts', JSON.stringify(items));
};

const withFab = async (enabled: boolean) => {
  window.localStorage.setItem('aiMemo.fab.enabled', JSON.stringify(enabled));
  await act(async () => {
    render(<App />);
  });
};

beforeEach(() => {
  localStorage.clear();
});

afterEach(() => {
  // Ensure any stubbed ai-memo-pad elements are removed between tests
  document.querySelectorAll('ai-memo-pad').forEach(el => el.remove());
  cleanup();
});

describe('FloatingActionBar feature flag', () => {
  it('hides VisitedPostsMinimap when FAB enabled', async () => {
    seedVisited();
    await withFab(true);
    const historyTriggers = screen.queryAllByLabelText(
      'Open visited posts history'
    );
    expect(historyTriggers.length).toBe(0);
  });

  it('shows VisitedPostsMinimap when FAB disabled', async () => {
    seedVisited();
    await withFab(false);
    const historyTriggers = screen.queryAllByLabelText(
      'Open visited posts history'
    );
    expect(historyTriggers.length).toBeGreaterThan(0);
  });

  it('renders FAB toolbar when enabled', async () => {
    await withFab(true);
    const toolbar = screen.queryByRole('toolbar', { name: 'Floating actions' });
    expect(toolbar).not.toBeNull();
    // Insight button label should be visible
    expect(screen.queryByRole('button', { name: 'Insight' })).not.toBeNull();
  });

  it('falls back to visited-posts minimap when ai-memo is absent', async () => {
    // Enable FAB with no ai-memo element present
    seedVisited();
    await withFab(true);

    // FAB toolbar should be present
    await waitFor(() => {
      expect(
        screen.queryByRole('toolbar', { name: 'Floating actions' })
      ).not.toBeNull();
    });

    // Spy on window.dispatchEvent to capture fallback event
    const dispatchSpy = vi.spyOn(window, 'dispatchEvent');

    // Click Insight and expect a visitedposts:open fallback event
    const insightBtn = screen.getByRole('button', { name: 'Insight' });
    await act(async () => {
      insightBtn.click();
    });

    await waitFor(() => {
      const calls = (dispatchSpy.mock?.calls || []) as unknown[] as any[];
      const hasVisitedOpen = calls.some(args => args?.[0]?.type === 'visitedposts:open');
      expect(hasVisitedOpen).toBe(true);
    });

    dispatchSpy.mockRestore();
  });

  it('shows global actions when memo is open under FAB', async () => {
    // Enable FAB
    window.localStorage.setItem('aiMemo.fab.enabled', 'true');

    // Stub ai-memo web component with a shadow root and an open panel
    const aiMemo = document.createElement('ai-memo-pad') as any;
    const shadow = aiMemo.attachShadow
      ? aiMemo.attachShadow({ mode: 'open' })
      : (aiMemo as any).shadowRoot;
    const panel = document.createElement('div');
    panel.id = 'panel';
    panel.className = 'open';
    shadow.appendChild(panel);
    document.body.appendChild(aiMemo);

    // Render app
    await act(async () => {
      render(<App />);
    });

    // Wait for FAB toolbar
    await waitFor(() => {
      expect(
        screen.queryByRole('toolbar', { name: 'Floating actions' })
      ).not.toBeNull();
    });

    // Expect global action buttons are present
    expect(screen.queryByRole('button', { name: 'AI Chat' })).not.toBeNull();
    expect(screen.queryByRole('button', { name: 'Insight' })).not.toBeNull();

    // And legacy contextual memo actions are not present in FAB anymore
    expect(screen.queryByRole('button', { name: '선택 추가' })).toBeNull();
    expect(screen.queryByRole('button', { name: '그래프에 추가' })).toBeNull();
    expect(screen.queryByRole('button', { name: 'AI 요약' })).toBeNull();
    expect(screen.queryByRole('button', { name: 'Catalyst' })).toBeNull();
    expect(screen.queryByRole('button', { name: '메모 다운로드' })).toBeNull();
  });

  it('hides FAB while legacy history overlay is open and shows after close', async () => {
    // Enable FAB
    window.localStorage.setItem('aiMemo.fab.enabled', 'true');

    // Stub ai-memo web component with a shadow root and a visible history overlay
    const aiMemo = document.createElement('ai-memo-pad') as any;
    const shadow = aiMemo.attachShadow
      ? aiMemo.attachShadow({ mode: 'open' })
      : (aiMemo as any).shadowRoot;
    const overlay = document.createElement('div');
    overlay.id = 'historyOverlay';
    overlay.style.display = 'block'; // simulate overlay open
    shadow.appendChild(overlay);
    document.body.appendChild(aiMemo);

    // Render app
    await act(async () => {
      render(<App />);
    });

    // FAB should be hidden while overlay is open
    await waitFor(() => {
      const toolbar = screen.queryByRole('toolbar', {
        name: 'Floating actions',
      });
      expect(toolbar).toBeNull();
    });

    // Close overlay and expect FAB to appear
    overlay.style.display = 'none';
    await waitFor(() => {
      const toolbar = screen.queryByRole('toolbar', {
        name: 'Floating actions',
      });
      expect(toolbar).not.toBeNull();
    });

    // Clicking Insight should call history open on the component
    const openHistorySpy = vi.fn();
    (aiMemo as any).openHistory = openHistorySpy;
    const insightBtn = screen.getByRole('button', { name: 'Insight' });
    insightBtn.click();
    expect(openHistorySpy).toHaveBeenCalled();
  });
});

```

### PostService.prefetch.test.ts

**Path:** `frontend/src/test/PostService.prefetch.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { PostService } from '@/services/postService';

// Utility to create a minimal fetch Response
const jsonResponse = (data: unknown, init: ResponseInit = { status: 200 }) =>
  new Response(JSON.stringify(data), {
    headers: { 'Content-Type': 'application/json' },
    ...init,
  });

const textResponse = (data: string, init: ResponseInit = { status: 200 }) =>
  new Response(data, init);

describe('PostService.prefetchPost', () => {
  const manifest = {
    total: 1,
    items: [
      {
        path: '/posts/2025/test.md',
        year: '2025',
        slug: 'test',
        title: 'Test',
        description: 'Desc',
        snippet: 'Desc',
        date: '2025-01-01',
        tags: ['a'],
        category: 'Cat',
        author: 'Admin',
        readingTime: '1 min read',
        published: true,
      },
    ],
    generatedAt: new Date().toISOString(),
    years: ['2025'],
  };

  const markdown = '# Test\n\nHello';

  beforeEach(() => {
    PostService.clearCache();
    vi.restoreAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('caches markdown and avoids duplicate markdown fetches on subsequent prefetch', async () => {
    const fetchMock = vi
      .spyOn(global, 'fetch' as any)
      .mockImplementation((url: RequestInfo | URL) => {
        const href = String(url);
        if (href.endsWith('/posts-manifest.json'))
          return Promise.resolve(jsonResponse(manifest));
        if (href.endsWith('/posts/2025/test.md'))
          return Promise.resolve(textResponse(markdown));
        return Promise.resolve(new Response('', { status: 404 }));
      });

    await PostService.prefetchPost('2025', 'test');

    // Expected: 1 manifest + 1 markdown fetch
    const firstMarkdownCalls = fetchMock.mock.calls.filter(c =>
      String(c[0]).endsWith('/posts/2025/test.md')
    ).length;
    expect(firstMarkdownCalls).toBe(1);

    // Second prefetch should be a no-op for markdown
    await PostService.prefetchPost('2025', 'test');

    const markdownCalls = fetchMock.mock.calls.filter(c =>
      String(c[0]).endsWith('/posts/2025/test.md')
    ).length;
    expect(markdownCalls).toBe(1);

    // Manifest should be fetched only once due to manifestCache
    const manifestCalls = fetchMock.mock.calls.filter(c =>
      String(c[0]).endsWith('/posts-manifest.json')
    ).length;
    expect(manifestCalls).toBe(1);
  });

  it('uses cached markdown when getPostBySlug is called after prefetch', async () => {
    const fetchMock = vi
      .spyOn(global, 'fetch' as any)
      .mockImplementation((url: RequestInfo | URL) => {
        const href = String(url);
        if (href.endsWith('/posts-manifest.json'))
          return Promise.resolve(jsonResponse(manifest));
        if (href.endsWith('/posts/2025/test.md'))
          return Promise.resolve(textResponse(markdown));
        return Promise.resolve(new Response('', { status: 404 }));
      });

    await PostService.prefetchPost('2025', 'test');

    // markdown fetched once during prefetch
    expect(
      fetchMock.mock.calls.filter(c =>
        String(c[0]).endsWith('/posts/2025/test.md')
      ).length
    ).toBe(1);

    // now getPostBySlug should not fetch markdown again (still only 1 markdown fetch)
    const post = await PostService.getPostBySlug('2025', 'test');
    expect(post?.slug).toBe('test');

    expect(
      fetchMock.mock.calls.filter(c =>
        String(c[0]).endsWith('/posts/2025/test.md')
      ).length
    ).toBe(1);
  });
});

```

### Smoke.test.tsx

**Path:** `frontend/src/test/Smoke.test.tsx`

```tsx
import { render, screen, cleanup } from '@testing-library/react';
import { describe, it, expect, afterEach } from 'vitest';
import { act } from 'react';
import App from '../App';

const renderApp = async () => {
  await act(async () => {
    render(<App />);
  });
};

afterEach(() => {
  cleanup();
});

describe('Smoke: App routes render', () => {
  it('renders app without crashing', async () => {
    await renderApp();
    expect(
      screen.getAllByText(/Home|Latest Posts|블로그|Blog|Nodove/i).length
    ).toBeGreaterThan(0);
  });
});

```

### VisitedPostsMinimap.test.tsx

**Path:** `frontend/src/test/VisitedPostsMinimap.test.tsx`

```tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { MemoryRouter, Route, Routes } from 'react-router-dom';
import { VisitedPostsMinimap } from '@/components/features/navigation/VisitedPostsMinimap';
import { ThemeProvider } from '@/contexts/ThemeContext';

const wrap = (ui: React.ReactNode, initialEntries: string[] = ['/']) =>
  render(
    <MemoryRouter initialEntries={initialEntries}>
      <ThemeProvider>
        <Routes>
          <Route path='/' element={<>{ui}</>} />
          <Route path='/blog/:year/:slug' element={<div>Post Page</div>} />
        </Routes>
      </ThemeProvider>
    </MemoryRouter>
  );

describe('VisitedPostsMinimap', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  it('does not render when there are no visited posts', () => {
    wrap(<VisitedPostsMinimap />);
    // Should not be present when there are no visited posts
    expect(
      screen.queryByLabelText(/open visited posts history/i)
    ).not.toBeInTheDocument();
  });

  it('renders when visited posts exist and toggles open state', () => {
    localStorage.setItem(
      'visited.posts',
      JSON.stringify([
        { path: '/blog/2025/foo', title: 'Foo', year: '2025', slug: 'foo' },
        { path: '/blog/2025/bar', title: 'Bar', year: '2025', slug: 'bar' },
      ])
    );
    wrap(<VisitedPostsMinimap />);

    const btn = screen.getByRole('button', {
      name: /open visited posts history/i,
    });
    expect(btn).toBeInTheDocument();

    // Initially collapsed, clicking opens list
    fireEvent.click(btn);
    expect(screen.getByText(/Recently visited/i)).toBeInTheDocument();

    // Close via Close button
    fireEvent.click(screen.getByRole('button', { name: /close history/i }));
    expect(screen.queryByText(/Recently visited/i)).not.toBeInTheDocument();
  });

  it('reacts to visitedposts:update and storage events', async () => {
    localStorage.setItem('visited.posts', JSON.stringify([]));
    wrap(<VisitedPostsMinimap />);

    // Update storage directly
    localStorage.setItem(
      'visited.posts',
      JSON.stringify([
        { path: '/blog/2025/foo', title: 'Foo', year: '2025', slug: 'foo' },
      ])
    );
    // Dispatch custom event to trigger refresh and wait for update
    await act(async () => {
      window.dispatchEvent(new CustomEvent('visitedposts:update'));
    });

    // Now the minimap should appear
    const btn = await screen.findByRole('button', {
      name: /open visited posts history/i,
    });
    expect(btn).toBeInTheDocument();
  });

  it('navigates to selected post when clicking an item', () => {
    localStorage.setItem(
      'visited.posts',
      JSON.stringify([
        { path: '/blog/2025/foo', title: 'Foo', year: '2025', slug: 'foo' },
      ])
    );
    wrap(<VisitedPostsMinimap />);

    fireEvent.click(
      screen.getByRole('button', { name: /open visited posts history/i })
    );

    // Click the list item button which has text Foo
    fireEvent.click(screen.getByRole('button', { name: /foo/i }));

    // The router renders Post Page at the target route
    expect(screen.getByText('Post Page')).toBeInTheDocument();
  });
});

```

### setup.ts

**Path:** `frontend/src/test/setup.ts`

```typescript
import '@testing-library/jest-dom';

// Provide a stable in-memory localStorage/sessionStorage for tests
(function ensureStorage() {
  const makeStorage = () => {
    const store = new Map<string, string>();
    return {
      get length() {
        return store.size;
      },
      clear() {
        store.clear();
      },
      getItem(key: string) {
        return store.has(key) ? store.get(key)! : null;
      },
      key(index: number) {
        return Array.from(store.keys())[index] ?? null;
      },
      removeItem(key: string) {
        store.delete(key);
      },
      setItem(key: string, value: string) {
        store.set(String(key), String(value));
      },
    } as Storage;
  };
  try {
    // If jsdom provided storages are missing or broken, replace them
    if (!('localStorage' in window) || typeof window.localStorage?.getItem !== 'function') {
      Object.defineProperty(window, 'localStorage', {
        value: makeStorage(),
        configurable: true,
        writable: true,
      });
    }
    if (!('sessionStorage' in window) || typeof window.sessionStorage?.getItem !== 'function') {
      Object.defineProperty(window, 'sessionStorage', {
        value: makeStorage(),
        configurable: true,
        writable: true,
      });
    }
  } catch {
    // As a fallback, force-define
    Object.defineProperty(window, 'localStorage', {
      value: makeStorage(),
      configurable: true,
      writable: true,
    });
    Object.defineProperty(window, 'sessionStorage', {
      value: makeStorage(),
      configurable: true,
      writable: true,
    });
  }
})();

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: (query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: () => {},
    removeListener: () => {},
    addEventListener: () => {},
    removeEventListener: () => {},
    dispatchEvent: () => {},
  }),
});

// Mock IntersectionObserver
global.IntersectionObserver = class {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
} as unknown as typeof IntersectionObserver;

// Mock ResizeObserver
global.ResizeObserver = class {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
} as unknown as typeof ResizeObserver;

// Mock window.scrollTo to avoid jsdom not-implemented errors
// eslint-disable-next-line @typescript-eslint/no-empty-function
window.scrollTo = (() => {}) as any;

// Stub fetch for posts-manifest.json in tests that render the app shell
const originalFetch = global.fetch;
// Provide a minimal, valid manifest shape used by tests
const stubManifest = {
  total: 1,
  generatedAt: new Date().toISOString(),
  years: ['2025'],
  items: [
    {
      path: '/posts/2025/foo.md',
      year: '2025',
      slug: 'foo',
      title: 'Foo',
      description: 'Test post',
      snippet: 'Test post',
      date: '2025-01-01',
      tags: [],
      category: 'General',
      author: 'Admin',
      readingTime: '1 min read',
      published: true,
      coverImage: undefined,
      url: '/blog/2025/foo',
    },
  ],
};

global.fetch = (input: any, init?: any): Promise<Response> => {
  const url =
    typeof input === 'string'
      ? input
      : input instanceof URL
        ? input.toString()
        : (input as Request).url;
  if (url.endsWith('/posts-manifest.json')) {
    return Promise.resolve(
      new Response(JSON.stringify(stubManifest), {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      })
    );
  }
  return originalFetch(input as any, init);
};

```

---

## frontend/src/types

### blog.ts

**Path:** `frontend/src/types/blog.ts`

```typescript
export type SupportedLanguage = 'ko' | 'en';

export interface LocalizedPostFields {
  title: string;
  description: string;
  excerpt?: string;
  content?: string;
}

export interface BlogPost {
  id: string;
  title: string;
  description: string;
  excerpt?: string;
  date: string;
  year: string;
  category: string;
  tags: string[];
  content: string;
  slug: string;
  language: SupportedLanguage;
  readTime?: number;
  readingTime?: string;
  author?: string;
  published?: boolean;
  coverImage?: string;
  defaultLanguage?: SupportedLanguage;
  availableLanguages?: SupportedLanguage[];
  translations?: Partial<Record<SupportedLanguage, LocalizedPostFields>>;
}

export interface BlogCategory {
  name: string;
  count: number;
  slug: string;
}

export interface BlogTag {
  name: string;
  count: number;
  slug: string;
}

// Generic page result for paginated queries
export interface PostsPage<T = BlogPost> {
  items: T[];
  page: number;
  pageSize: number;
  total: number;
  totalPages: number;
  hasMore: boolean;
}

```

---

## frontend/src/utils

### apiBase.ts

**Path:** `frontend/src/utils/apiBase.ts`

```typescript
// Default API URL for production
const DEFAULT_API_URL = 'https://api.nodove.com';

export function getApiBaseUrl(): string {
  // 1) runtime injected config
  const w = typeof window !== 'undefined' ? (window as any) : null;
  const fromRuntime = w?.APP_CONFIG?.apiBaseUrl || w?.__APP_CONFIG?.apiBaseUrl;
  if (typeof fromRuntime === 'string' && fromRuntime) return fromRuntime;

  // 2) Vite env
  const fromEnv = import.meta?.env?.VITE_API_BASE_URL as string | undefined;
  if (typeof fromEnv === 'string' && fromEnv) return fromEnv;

  // 3) AI Memo localStorage (developer convenience)
  try {
    const v = localStorage.getItem('aiMemo.backendUrl');
    if (v) {
      const parsed = JSON.parse(v);
      if (typeof parsed === 'string' && parsed) return parsed;
    }
  } catch {
    void 0;
  }

  // 4) Default production URL
  return DEFAULT_API_URL;
}

```

### blog.ts

**Path:** `frontend/src/utils/blog.ts`

```typescript
import { type BlogPost, type SupportedLanguage } from '@/types/blog';

export interface FrontmatterData {
  title?: string;
  excerpt?: string;
  date?: string;
  category?: string;
  tags?: string[];
  readTime?: string | number;
}

export interface ParsedMarkdown {
  frontmatter: FrontmatterData;
  content: string;
}

export const formatDate = (
  dateString: string,
  language: SupportedLanguage = 'ko'
): string => {
  const date = new Date(dateString);
  const locale = language === 'en' ? 'en-US' : 'ko-KR';
  return date.toLocaleDateString(locale, {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
};

export const calculateReadTime = (content: string): number => {
  const WORDS_PER_MINUTE = 200;
  const words = content.trim().split(/\s+/).length;
  return Math.ceil(words / WORDS_PER_MINUTE);
};

export const createSlug = (title: string): string => {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9가-힣]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
};

export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return `${text.slice(0, maxLength).trim()}...`;
};

export interface LocalizedPostContent {
  title: string;
  description: string;
  excerpt?: string;
  content: string;
}

const getFallbackLanguage = (post: BlogPost): SupportedLanguage =>
  post.defaultLanguage ?? 'ko';

export const getAvailableLanguages = (
  post: BlogPost
): SupportedLanguage[] => {
  const fallback = getFallbackLanguage(post);
  const available = (post.availableLanguages ?? []).filter(
    (lang): lang is SupportedLanguage => lang === 'ko' || lang === 'en'
  );
  return Array.from(new Set<SupportedLanguage>([fallback, ...available]));
};

export const resolveLocalizedPost = (
  post: BlogPost,
  language: SupportedLanguage
): LocalizedPostContent => {
  const fallbackLang = getFallbackLanguage(post);
  const base: LocalizedPostContent = {
    title: post.title,
    description: post.description,
    excerpt: post.excerpt,
    content: post.content,
  };

  if (language === fallbackLang) {
    return base;
  }

  const translation = post.translations?.[language];
  if (!translation) {
    return base;
  }

  return {
    title: translation.title || base.title,
    description: translation.description || base.description,
    excerpt: translation.excerpt || base.excerpt,
    content: translation.content || base.content,
  };
};

const parseMarkdownValue = (value: string): unknown => {
  // Remove quotes if present
  if (
    (value.startsWith('"') && value.endsWith('"')) ||
    (value.startsWith("'") && value.endsWith("'"))
  ) {
    return value.slice(1, -1);
  }

  // Parse arrays
  if (value.startsWith('[') && value.endsWith(']')) {
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }

  return value;
};

export const parseMarkdownFrontmatter = (content: string): ParsedMarkdown => {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
  const match = content.match(frontmatterRegex);

  if (!match) {
    return { frontmatter: {}, content };
  }

  const frontmatterText = match[1];
  const bodyContent = match[2];

  const frontmatter: FrontmatterData = {};
  frontmatterText.split('\n').forEach(line => {
    const colonIndex = line.indexOf(':');
    if (colonIndex > 0) {
      const key = line.substring(0, colonIndex).trim();
      const rawValue = line.substring(colonIndex + 1).trim();
      const value = parseMarkdownValue(rawValue);

      (frontmatter as Record<string, unknown>)[key] = value;
    }
  });

  return { frontmatter, content: bodyContent };
};

export const loadPostBySlug = async (
  slug: string
): Promise<BlogPost | null> => {
  try {
    const baseUrl = import.meta.env.BASE_URL || '/';
    const response = await fetch(`${baseUrl}posts/${slug}.md`);

    if (!response.ok) {
      return null;
    }

    const content = await response.text();
    const { frontmatter, content: bodyContent } =
      parseMarkdownFrontmatter(content);

    if (!frontmatter.title) {
      return null;
    }

    const readTime = frontmatter.readTime
      ? typeof frontmatter.readTime === 'string'
        ? parseInt(frontmatter.readTime, 10)
        : frontmatter.readTime
      : calculateReadTime(bodyContent);

    const year = frontmatter.date
      ? new Date(frontmatter.date).getFullYear().toString()
      : new Date().getFullYear().toString();

    return {
      id: slug.replace('/', '-'),
      title: frontmatter.title,
      description: frontmatter.excerpt || truncateText(bodyContent, 200),
      date: frontmatter.date || '',
      year,
      category: frontmatter.category || '기술',
      tags: Array.isArray(frontmatter.tags) ? frontmatter.tags : [],
      slug,
      content: bodyContent,
      readTime,
    };
  } catch (error) {
    console.error(`Failed to load post ${slug}:`, error);
    return null;
  }
};

```

### common.ts

**Path:** `frontend/src/utils/common.ts`

```typescript
export const cn = (
  ...classes: (string | undefined | null | boolean)[]
): string => {
  return classes.filter(Boolean).join(' ');
};

export const debounce = <T extends (...args: unknown[]) => void>(
  func: T,
  delay: number
): ((...args: Parameters<T>) => void) => {
  let timeoutId: NodeJS.Timeout;

  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func(...args), delay);
  };
};

export const throttle = <T extends (...args: unknown[]) => void>(
  func: T,
  limit: number
): ((...args: Parameters<T>) => void) => {
  let inThrottle: boolean;

  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
};

export const copyToClipboard = async (text: string): Promise<boolean> => {
  try {
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      return true;
    } else {
      // Fallback for older browsers or non-secure contexts
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      // Use deprecated execCommand as fallback
      const success = document.execCommand('copy');
      document.body.removeChild(textArea);
      return success;
    }
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
};

export const formatFileSize = (bytes: number): string => {
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  if (bytes === 0) return '0 B';

  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  return `${Math.round((bytes / Math.pow(1024, i)) * 100) / 100} ${sizes[i]}`;
};

export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

export const isValidUrl = (url: string): boolean => {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
};

export const generateId = (): string => {
  return Math.random().toString(36).substring(2, 9);
};

/**
 * Strips markdown syntax from text for clean display in previews.
 * Removes images, links, code blocks, bold/italic, headers, etc.
 */
export const stripMarkdown = (text: string, maxLength = 150): string => {
  if (!text) return '';

  let cleaned = text
    // Remove images: ![alt](url) or ![alt][ref]
    .replace(/!\[.*?\]\(.*?\)/g, '')
    .replace(/!\[.*?\]\[.*?\]/g, '')
    // Remove inline links but keep text: [text](url) -> text
    .replace(/\[([^\]]*)\]\([^)]*\)/g, '$1')
    // Remove reference-style links: [text][ref] -> text
    .replace(/\[([^\]]*)\]\[[^\]]*\]/g, '$1')
    // Remove code blocks (fenced)
    .replace(/```[\s\S]*?```/g, '')
    // Remove inline code
    .replace(/`([^`]+)`/g, '$1')
    // Remove headers
    .replace(/^#{1,6}\s+/gm, '')
    // Remove bold/italic (order matters)
    .replace(/\*\*\*(.+?)\*\*\*/g, '$1')
    .replace(/\*\*(.+?)\*\*/g, '$1')
    .replace(/\*(.+?)\*/g, '$1')
    .replace(/___(.+?)___/g, '$1')
    .replace(/__(.+?)__/g, '$1')
    .replace(/_(.+?)_/g, '$1')
    // Remove strikethrough
    .replace(/~~(.+?)~~/g, '$1')
    // Remove blockquotes
    .replace(/^>\s?/gm, '')
    // Remove horizontal rules
    .replace(/^[-*_]{3,}\s*$/gm, '')
    // Remove list markers
    .replace(/^[\s]*[-*+]\s+/gm, '')
    .replace(/^[\s]*\d+\.\s+/gm, '')
    // Remove HTML tags
    .replace(/<[^>]*>/g, '')
    // Remove extra whitespace and newlines
    .replace(/\n+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  // Truncate to maxLength with ellipsis
  if (cleaned.length > maxLength) {
    cleaned = cleaned.slice(0, maxLength).trim() + '...';
  }

  return cleaned;
};


```

---

## frontend/src/utils/seo

### seo.ts

**Path:** `frontend/src/utils/seo/seo.ts`

```typescript
import { BlogPost } from '../../types/blog';
import { getApiBaseUrl } from '@/utils/apiBase';

export interface SEOData {
  title: string;
  description: string;
  keywords: string[];
  canonicalUrl?: string;
  ogImage?: string;
  ogType?: string;
  publishedTime?: string;
  modifiedTime?: string;
  author?: string;
  section?: string;
  tags?: string[];
}

export type SEOPageType = 'home' | 'blog' | 'post' | 'about' | 'contact';

export interface GenerateSEOOptions {
  category?: string | null;
  ogImageOverride?: string;
}

const slugifyCategory = (value: string): string =>
  value
    .trim()
    .replace(/[&/]+/g, ' and ')
    .toLowerCase()
    .replace(/[^0-9a-z\uac00-\ud7a3]+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');

const normalizeCategory = (category?: string | null): string | undefined => {
  if (!category) return undefined;
  const trimmed = category.trim();
  if (!trimmed || trimmed.toLowerCase() === 'all') return undefined;
  return trimmed;
};

const buildCategoryImagePath = (
  basePath: string,
  category?: string
): string => {
  if (!category) return `${basePath}/default/seo.png`;
  const slug = slugifyCategory(category);
  return slug ? `${basePath}/${slug}/seo.png` : `${basePath}/default/seo.png`;
};

export const generateSEOData = (
  post?: BlogPost,
  pageType: SEOPageType = 'home',
  options: GenerateSEOOptions = {}
): SEOData => {
  const baseUrl = import.meta.env.VITE_SITE_BASE_URL || 'http://localhost:3000';
  const apiBase = getApiBaseUrl();
  const siteName = 'nodove-blog'; 
  const seoImageBase = `${baseUrl}/images/seo`;
  const defaultOgImage = `${seoImageBase}/default/seo.png`;
  const category = normalizeCategory(options.category);
  const categoryOgImage = options.ogImageOverride
    ? options.ogImageOverride
    : category
      ? buildCategoryImagePath(seoImageBase, category)
      : defaultOgImage;

  switch (pageType) {
    case 'post':
      if (!post) throw new Error('Post data required for post page');
      return {
        title: `${post.title} | ${siteName}`,
        description: post.description,
        keywords: [...post.tags, post.category],
        canonicalUrl: `${baseUrl}/blog/${post.year}/${post.slug}`,
        ogImage: `${(apiBase || baseUrl).replace(/\/$/, '')}/api/${apiBase ? 'v1/og' : 'og'}?title=${encodeURIComponent(post.title)}`,
        ogType: 'article',
        publishedTime: post.date,
        modifiedTime: post.date,
        author: post.author,
        section: post.category,
        tags: post.tags,
      };

    case 'blog':
      return {
        title: `${category ? `${category} Posts` : 'Blog'} | ${siteName}`,
        description: category
          ? `Latest blog posts and curated resources about ${category}.`
          : 'Latest blog posts about technology, programming, and web development',
        keywords: [
          'blog',
          'technology',
          'programming',
          'web development',
          ...(category ? [category] : []),
        ],
        canonicalUrl: category
          ? `${baseUrl}/blog?category=${encodeURIComponent(category)}`
          : `${baseUrl}/blog`,
        ogImage: categoryOgImage,
        ogType: 'website',
      };

    case 'about':
      return {
        title: `About | ${siteName}`,
        description: 'Learn more about the author and the purpose of this blog',
        keywords: ['about', 'author', 'biography'],
        canonicalUrl: `${baseUrl}/about`,
        ogImage: categoryOgImage,
        ogType: 'website',
      };

    case 'contact':
      return {
        title: `Contact | ${siteName}`,
        description: 'Get in touch with the blog author',
        keywords: ['contact', 'email', 'reach out'],
        canonicalUrl: `${baseUrl}/contact`,
        ogImage: categoryOgImage,
        ogType: 'website',
      };

    default:
      return {
        title: siteName,
        description:
          'A blog about technology, programming, and web development',
        keywords: [
          'blog',
          'technology',
          'programming',
          'web development',
          'tutorials',
        ],
        canonicalUrl: baseUrl,
        ogImage: categoryOgImage,
        ogType: 'website',
      };
  }
};

export const generateStructuredData = (
  post?: BlogPost,
  pageType: string = 'home'
) => {
  const baseUrl = import.meta.env.VITE_SITE_BASE_URL || 'http://localhost:3000';
  const apiBase = getApiBaseUrl();
  const siteName = 'nodove-blog'; // TODO: set your actual site name
  const authorName = 'nodove'; // TODO: set your actual name

  if (pageType === 'post' && post) {
    return {
      '@context': 'https://schema.org',
      '@type': 'BlogPosting',
      headline: post.title,
      description: post.description,
      image: `${(apiBase || baseUrl).replace(/\/$/, '')}/api/${apiBase ? 'v1/og' : 'og'}?title=${encodeURIComponent(
        post.title
      )}`,
      author: {
        '@type': 'Person',
        name: authorName,
      },
      publisher: {
        '@type': 'Organization',
        name: siteName,
        logo: {
          '@type': 'ImageObject',
          url: `${baseUrl}/logo.png`,
        },
      },
      datePublished: post.date,
      dateModified: post.date,
      mainEntityOfPage: {
        '@type': 'WebPage',
        '@id': `${baseUrl}/blog/${post.year}/${post.slug}`,
      },
      keywords: post.tags.join(', '),
      articleSection: post.category,
    };
  }

  if (pageType === 'blog') {
    return {
      '@context': 'https://schema.org',
      '@type': 'Blog',
      name: `${siteName} Blog`,
      description: 'A blog about technology, programming, and web development',
      url: `${baseUrl}/blog`,
      author: {
        '@type': 'Person',
        name: authorName,
      },
    };
  }

  return {
    '@context': 'https://schema.org',
    '@type': 'WebSite',
    name: siteName,
    description: 'A blog about technology, programming, and web development',
    url: baseUrl,
    author: {
      '@type': 'Person',
      name: authorName,
    },
  };
};

```

### sitemap.ts

**Path:** `frontend/src/utils/seo/sitemap.ts`

```typescript
import { BlogPost } from '@/types/blog';
import { getPosts } from '@/data/posts';

export interface SitemapEntry {
  url: string;
  lastModified: string;
  changeFreq:
    | 'always'
    | 'hourly'
    | 'daily'
    | 'weekly'
    | 'monthly'
    | 'yearly'
    | 'never';
  priority: number;
}

export const generateSitemap = async (): Promise<string> => {
  const baseUrl = import.meta.env.VITE_SITE_BASE_URL || 'http://localhost:3000';
  const posts = await getPosts();

  const entries: SitemapEntry[] = [
    // Static pages
    {
      url: baseUrl,
      lastModified: new Date().toISOString(),
      changeFreq: 'weekly',
      priority: 1.0,
    },
    {
      url: `${baseUrl}/blog`,
      lastModified: new Date().toISOString(),
      changeFreq: 'daily',
      priority: 0.9,
    },
    {
      url: `${baseUrl}/about`,
      lastModified: new Date().toISOString(),
      changeFreq: 'monthly',
      priority: 0.7,
    },
    {
      url: `${baseUrl}/contact`,
      lastModified: new Date().toISOString(),
      changeFreq: 'monthly',
      priority: 0.6,
    },

    // Blog posts
    ...posts.map((post: BlogPost) => ({
      url: `${baseUrl}/blog/${post.year}/${post.slug}`,
      lastModified: new Date(post.date).toISOString(),
      changeFreq: 'monthly' as const,
      priority: 0.8,
    })),
  ];

  const xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${entries
  .map(
    entry => `  <url>
    <loc>${entry.url}</loc>
    <lastmod>${entry.lastModified}</lastmod>
    <changefreq>${entry.changeFreq}</changefreq>
    <priority>${entry.priority}</priority>
  </url>`
  )
  .join('\n')}
</urlset>`;

  return xmlContent;
};

export const generateRobotsTxt = (): string => {
  const baseUrl = import.meta.env.VITE_SITE_BASE_URL || 'http://localhost:3000';

  return `User-agent: *
Allow: /

Sitemap: ${baseUrl}/sitemap.xml`;
};

// Generate RSS feed
export const generateRSSFeed = async (): Promise<string> => {
  const baseUrl = import.meta.env.VITE_SITE_BASE_URL || 'http://localhost:3000';
  const siteName = 'Your Blog Name';
  const siteDescription =
    'A blog about technology, programming, and web development';
  const posts = await getPosts();

  const rssContent = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>${siteName}</title>
    <description>${siteDescription}</description>
    <link>${baseUrl}</link>
    <atom:link href="${baseUrl}/rss.xml" rel="self" type="application/rss+xml"/>
    <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>
    <language>ko-KR</language>
    
${posts
  .slice(0, 20)
  .map(
    (post: BlogPost) => `    <item>
      <title>${post.title}</title>
      <description>${post.description}</description>
      <link>${baseUrl}/blog/${post.year}/${post.slug}</link>
      <guid isPermaLink="true">${baseUrl}/blog/${post.year}/${post.slug}</guid>
      <pubDate>${new Date(post.date).toUTCString()}</pubDate>
      <category>${post.category}</category>
${post.tags.map(tag => `      <category>${tag}</category>`).join('\n')}
    </item>`
  )
  .join('\n')}
  </channel>
</rss>`;

  return rssContent;
};

```

---

## my-app/alembic

### env.py

**Path:** `my-app/alembic/env.py`

```python
from sqlmodel import SQLModel
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = SQLModel.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

```

---

## my-app/alembic/versions

### 8869a941367b_initial_schema.py

**Path:** `my-app/alembic/versions/8869a941367b_initial_schema.py`

```python
"""Initial schema

Revision ID: 8869a941367b
Revises: 
Create Date: 2025-09-20 23:41:41.859727

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
import sqlmodel


# revision identifiers, used by Alembic.
revision: str = '8869a941367b'
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###

```

---

## scripts

### e2e-workers.sh

**Path:** `scripts/e2e-workers.sh`

```bash
#!/usr/bin/env bash
# E2E Test Script for Cloudflare Workers API
# Usage: bash scripts/e2e-workers.sh [API_BASE_URL]

set -euo pipefail

API_BASE="${1:-http://localhost:8787}/api/v1"
ADMIN_USERNAME="${ADMIN_USERNAME:-admin}"
ADMIN_PASSWORD="${ADMIN_PASSWORD:-admin}"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "🧪 E2E Tests for Workers API"
echo "API: $API_BASE"
echo ""

# Test health check
echo -n "Testing health check... "
HEALTH=$(curl -s "$API_BASE/../healthz")
if echo "$HEALTH" | grep -q '"ok":true'; then
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $HEALTH"
  exit 1
fi

# Test login
echo -n "Testing login... "
LOGIN_RESPONSE=$(curl -s -X POST "$API_BASE/auth/login" \
  -H "Content-Type: application/json" \
  -d "{\"username\":\"$ADMIN_USERNAME\",\"password\":\"$ADMIN_PASSWORD\"}")

if echo "$LOGIN_RESPONSE" | grep -q '"ok":true'; then
  TOKEN=$(echo "$LOGIN_RESPONSE" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $LOGIN_RESPONSE"
  exit 1
fi

# Test /auth/me
echo -n "Testing /auth/me... "
ME_RESPONSE=$(curl -s "$API_BASE/auth/me" \
  -H "Authorization: Bearer $TOKEN")

if echo "$ME_RESPONSE" | grep -q '"ok":true'; then
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $ME_RESPONSE"
  exit 1
fi

# Test create post
echo -n "Testing create post... "
SLUG="test-post-$(date +%s)"
POST_RESPONSE=$(curl -s -X POST "$API_BASE/posts" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d "{\"title\":\"Test Post\",\"slug\":\"$SLUG\",\"content\":\"# Test\\nThis is a test post.\",\"tags\":[\"test\",\"e2e\"]}")

if echo "$POST_RESPONSE" | grep -q '"ok":true'; then
  POST_ID=$(echo "$POST_RESPONSE" | grep -o '"id":"[^"]*"' | cut -d'"' -f4)
  echo -e "${GREEN}✓${NC} (ID: $POST_ID)"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $POST_RESPONSE"
  exit 1
fi

# Test get posts
echo -n "Testing get posts... "
POSTS_RESPONSE=$(curl -s "$API_BASE/posts")
if echo "$POSTS_RESPONSE" | grep -q '"ok":true'; then
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $POSTS_RESPONSE"
  exit 1
fi

# Test get single post
echo -n "Testing get post by slug... "
SINGLE_POST=$(curl -s "$API_BASE/posts/$SLUG")
if echo "$SINGLE_POST" | grep -q '"ok":true'; then
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $SINGLE_POST"
  exit 1
fi

# Test update post
echo -n "Testing update post... "
UPDATE_RESPONSE=$(curl -s -X PUT "$API_BASE/posts/$SLUG" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d "{\"title\":\"Updated Test Post\"}")

if echo "$UPDATE_RESPONSE" | grep -q '"ok":true'; then
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $UPDATE_RESPONSE"
  exit 1
fi

# Test create comment
echo -n "Testing create comment... "
COMMENT_RESPONSE=$(curl -s -X POST "$API_BASE/comments" \
  -H "Content-Type: application/json" \
  -d "{\"postId\":\"$POST_ID\",\"author\":\"Test User\",\"content\":\"Great post!\"}")

if echo "$COMMENT_RESPONSE" | grep -q '"ok":true'; then
  COMMENT_ID=$(echo "$COMMENT_RESPONSE" | grep -o '"id":"[^"]*"' | cut -d'"' -f4)
  echo -e "${GREEN}✓${NC} (ID: $COMMENT_ID)"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $COMMENT_RESPONSE"
  exit 1
fi

# Test get comments
echo -n "Testing get comments... "
COMMENTS_RESPONSE=$(curl -s "$API_BASE/comments?postId=$POST_ID")
if echo "$COMMENTS_RESPONSE" | grep -q '"ok":true'; then
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $COMMENTS_RESPONSE"
  exit 1
fi

# Test AI sketch
echo -n "Testing AI sketch... "
AI_RESPONSE=$(curl -s -X POST "$API_BASE/ai/sketch" \
  -H "Content-Type: application/json" \
  -d "{\"paragraph\":\"This is a test paragraph for AI processing.\",\"postTitle\":\"Test\"}")

if echo "$AI_RESPONSE" | grep -q '"ok":true'; then
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${YELLOW}⚠${NC} (may require GEMINI_API_KEY)"
fi

# Test OG image
echo -n "Testing OG image generation... "
OG_RESPONSE=$(curl -s "$API_BASE/og?title=Test+Post")
if echo "$OG_RESPONSE" | grep -q '<svg'; then
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $OG_RESPONSE"
  exit 1
fi

# Test CORS preflight
echo -n "Testing CORS preflight... "
CORS_RESPONSE=$(curl -s -X OPTIONS "$API_BASE/posts" \
  -H "Origin: https://blog.nodove.com" \
  -H "Access-Control-Request-Method: GET")
# Check for 204 or Access-Control headers
if [ "$(echo "$CORS_RESPONSE" | wc -c)" -lt 10 ]; then
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${YELLOW}⚠${NC} (unexpected response)"
fi

# Cleanup: delete test post
echo -n "Cleanup: deleting test post... "
DELETE_RESPONSE=$(curl -s -X DELETE "$API_BASE/posts/$SLUG" \
  -H "Authorization: Bearer $TOKEN")

if echo "$DELETE_RESPONSE" | grep -q '"ok":true'; then
  echo -e "${GREEN}✓${NC}"
else
  echo -e "${RED}✗${NC}"
  echo "Response: $DELETE_RESPONSE"
fi

echo ""
echo -e "${GREEN}✅ All tests passed!${NC}"

```

---

## scripts/rag

### index_posts.py

**Path:** `scripts/rag/index_posts.py`

```python
import os
import json
import hashlib
import logging
from datetime import datetime
from urllib.parse import urlparse
from pathlib import Path
from typing import Any, Dict, List, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed

import requests
import chromadb
from chromadb.config import Settings
from bs4 import BeautifulSoup
import markdown as md
try:
    import tiktoken  # type: ignore
except Exception:  # pragma: no cover
    tiktoken = None
import time
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry


logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


def read_manifest(manifest_path: Path) -> List[Dict[str, Any]]:
    with manifest_path.open('r', encoding='utf-8') as f:
        data = json.load(f)
    items = data.get('items') or []
    out = []
    for it in items:
        if not isinstance(it, dict):
            continue
        if it.get('published') is False:
            continue
        p = it.get('path')
        if not isinstance(p, str):
            continue
        out.append(it)
    return out


def markdown_to_text(markdown_str: str) -> str:
    html = md.markdown(markdown_str)
    soup = BeautifulSoup(html, 'html.parser')
    text = soup.get_text('\n')
    text = '\n'.join([ln.strip() for ln in text.splitlines()])
    text = '\n'.join([ln for ln in text.splitlines() if ln])
    return text


def chunk_text(text: str, chunk_size: int = 1000, overlap: int = 150) -> List[str]:
    if chunk_size <= 0:
        return [text]
    if overlap < 0:
        overlap = 0
    out: List[str] = []
    n = len(text)
    i = 0
    while i < n:
        j = min(i + chunk_size, n)
        out.append(text[i:j])
        if j >= n:
            break
        i = max(j - overlap, 0)
    return out


def get_tokenizer():
    if tiktoken is None:
        return None
    try:
        # cl100k_base is commonly used (GPT-4/3.5). Serves as a reasonable proxy.
        return tiktoken.get_encoding('cl100k_base')
    except Exception:
        return None


def chunk_by_tokens(text: str, tokens_per_chunk: int = 512, overlap_tokens: int = 80) -> List[str]:
    enc = get_tokenizer()
    if enc is None or tokens_per_chunk <= 0:
        # Fallback to char-based
        approx_char = max(200, tokens_per_chunk * 2)
        approx_overlap = max(0, overlap_tokens * 2)
        return chunk_text(text, chunk_size=approx_char, overlap=approx_overlap)
    toks = enc.encode(text, disallowed_special=())
    out: List[str] = []
    step = max(1, tokens_per_chunk - max(0, overlap_tokens))
    i = 0
    n = len(toks)
    while i < n:
        j = min(i + tokens_per_chunk, n)
        chunk_tokens = toks[i:j]
        out.append(enc.decode(chunk_tokens))
        if j >= n:
            break
        i = max(j - overlap_tokens, i + step)
    return out


def stable_chunk_id(base: str, idx: int, content: str) -> str:
    h = hashlib.sha1()
    h.update(base.encode('utf-8'))
    h.update(b'\n')
    h.update(str(idx).encode('utf-8'))
    h.update(b'\n')
    h.update(content.encode('utf-8'))
    return h.hexdigest()


def get_cf_access_headers() -> Dict[str, str]:
    client_id = os.environ.get('CF_ACCESS_CLIENT_ID', '').strip()
    client_secret = os.environ.get('CF_ACCESS_CLIENT_SECRET', '').strip()
    headers: Dict[str, str] = {}
    if client_id:
        headers['CF-Access-Client-Id'] = client_id
    if client_secret:
        headers['CF-Access-Client-Secret'] = client_secret
    return headers


def create_session(total_retries: int = 5, backoff_factor: float = 1.0, status_forcelist: List[int] | None = None) -> requests.Session:
    if status_forcelist is None:
        status_forcelist = [429, 500, 502, 503, 504]
    retry = Retry(
        total=total_retries,
        read=total_retries,
        connect=total_retries,
        status=total_retries,
        backoff_factor=backoff_factor,
        status_forcelist=status_forcelist,
        allowed_methods=["GET", "POST", "PUT", "DELETE"],
        raise_on_status=False,
    )
    adapter = HTTPAdapter(max_retries=retry)
    sess = requests.Session()
    sess.mount("http://", adapter)
    sess.mount("https://", adapter)
    return sess


def embed_texts(session: requests.Session, tei_url: str, inputs: List[str], batch_size: int = 32, timeout: int = 120) -> List[List[float]]:
    out: List[List[float]] = []
    for i in range(0, len(inputs), batch_size):
        batch = inputs[i:i + batch_size]
        resp = session.post(tei_url, json={"inputs": batch}, timeout=timeout)
        resp.raise_for_status()
        data = resp.json()
        embs = data.get('embeddings')
        if not isinstance(embs, list):
            raise RuntimeError('Invalid TEI response')
        if len(embs) != len(batch):
            raise RuntimeError('Mismatched embedding count')
        out.extend(embs)
    return out


def connect_chroma(chroma_url: str, cf_headers: Dict[str, str] | None = None) -> chromadb.Client:
    u = urlparse(chroma_url)
    host = u.hostname or 'localhost'
    port = u.port or (443 if u.scheme == 'https' else 8000)
    ssl_enabled = (u.scheme == 'https')
    settings_kwargs: Dict[str, Any] = {
        'chroma_server_host': host,
        'chroma_server_http_port': port,
        'chroma_server_ssl_enabled': ssl_enabled,
        'anonymized_telemetry': False,
    }
    if cf_headers:
        settings_kwargs['chroma_server_headers'] = cf_headers
    try:
        settings = Settings(**settings_kwargs)
    except TypeError:
        settings_kwargs.pop('chroma_server_headers', None)
        settings = Settings(**settings_kwargs)
    # chromadb 0.6 moved the public HTTP client to chromadb.HttpClient.
    http_client_cls = getattr(chromadb, "HttpClient", None)
    if http_client_cls is not None:
        client_kwargs: Dict[str, Any] = {
            'host': host,
            'port': port,
            'ssl': ssl_enabled,
            'settings': settings,
        }
        if cf_headers:
            client_kwargs['headers'] = cf_headers
        try:
            return http_client_cls(**client_kwargs)
        except TypeError:
            client_kwargs.pop('headers', None)
            try:
                return http_client_cls(**client_kwargs)
            except TypeError:
                # In case the installed chromadb expects different kwargs (older versions), fall back.
                pass
    return chromadb.Client(settings)


def get_collection(client: chromadb.Client, name: str):
    return client.get_or_create_collection(name=name, metadata={"hnsw:space": "cosine"})


def chroma_delete_with_retry(collection, where: Dict[str, Any], attempts: int = 4, backoff_s: float = 1.5) -> None:
    last_err: Exception | None = None
    for k in range(attempts):
        try:
            collection.delete(where=where)
            return
        except Exception as e:  # pragma: no cover
            last_err = e
            time.sleep(backoff_s * (2 ** k))
    if last_err:
        raise last_err


def chroma_upsert_with_retry(collection, ids: List[str], embeddings: List[List[float]], metadatas: List[Dict[str, Any]], documents: List[str], attempts: int = 4, backoff_s: float = 1.5) -> None:
    last_err: Exception | None = None
    for k in range(attempts):
        try:
            collection.upsert(ids=ids, embeddings=embeddings, metadatas=metadatas, documents=documents)
            return
        except Exception as e:  # pragma: no cover
            last_err = e
            time.sleep(backoff_s * (2 ** k))
    if last_err:
        raise last_err


def process_document(
    file_path: Path,
    item: Dict[str, Any],
    tei_url: str,
    total_retries: int,
    retry_backoff: float,
    tokens_per_chunk: int,
    overlap_tokens: int,
    embed_batch: int,
    embed_timeout: int,
    cf_headers: Dict[str, str] | None,
) -> Tuple[str, List[str], List[List[float]], List[Dict[str, Any]], List[str]]:
    """
    Worker function to process a single markdown file into chunks and embeddings.
    Returns a tuple of (doc_id, ids, embeddings, metadatas, documents).
    """
    # read file
    content = file_path.read_text(encoding='utf-8', errors='ignore')
    text = markdown_to_text(content)
    chunks = chunk_by_tokens(text, tokens_per_chunk=tokens_per_chunk, overlap_tokens=overlap_tokens)
    if not chunks:
        return ("", [], [], [], [])

    doc_id = str(item.get('url') or item.get('path') or file_path.as_posix())

    # Per-worker session to avoid cross-thread Session usage
    session = create_session(total_retries=total_retries, backoff_factor=retry_backoff)
    if cf_headers:
        session.headers.update(cf_headers)
    try:
        embeddings = embed_texts(session, tei_url, chunks, batch_size=embed_batch, timeout=embed_timeout)
    finally:
        session.close()

    base_id = doc_id
    ids = [stable_chunk_id(base_id, i, ch) for i, ch in enumerate(chunks)]
    metadatas: List[Dict[str, Any]] = []
    indexed_at = datetime.utcnow().isoformat() + 'Z'
    source_path = str(file_path)

    for i, ch in enumerate(chunks):
        metadatas.append({
            "doc_id": doc_id,
            "url": item.get('url'),
            "title": item.get('title'),
            "path": item.get('path'),
            "slug": item.get('slug'),
            "year": item.get('year'),
            "tags": item.get('tags'),
            "category": item.get('category'),
            "date": item.get('date'),
            "chunk_index": i,
            "chunk_count": len(chunks),
            "source": source_path,
            "chunk_text": ch,
            "created_at": indexed_at,
        })
    documents = chunks
    return (doc_id, ids, embeddings, metadatas, documents)


def main() -> None:
    repo_root = Path(__file__).resolve().parents[2]
    manifest_rel = os.environ.get('POSTS_MANIFEST', 'frontend/public/posts-manifest.json')
    manifest_path = (repo_root / manifest_rel).resolve()
    public_dir = (repo_root / 'frontend/public').resolve()

    items = read_manifest(manifest_path)

    tei_url = os.environ.get('TEI_URL', '').strip()
    if not tei_url:
        raise SystemExit('Missing TEI_URL')
    chroma_url = os.environ.get('CHROMA_URL', '').strip()
    if not chroma_url:
        raise SystemExit('Missing CHROMA_URL')
    # Dynamic collection naming: prefer explicit CHROMA_COLLECTION, else base + model
    base_collection = os.environ.get('BASE_COLLECTION_NAME', 'blog-posts').strip() or 'blog-posts'
    tei_model_name = os.environ.get('TEI_MODEL_NAME', os.environ.get('TEI_MODEL', 'all-MiniLM-L6-v2')).strip() or 'all-MiniLM-L6-v2'
    explicit_collection = os.environ.get('CHROMA_COLLECTION', '').strip()
    collection_name = explicit_collection if explicit_collection else f"{base_collection}__{tei_model_name}"

    cf_headers = get_cf_access_headers()

    client = connect_chroma(chroma_url, cf_headers=cf_headers if cf_headers else None)
    collection = get_collection(client, collection_name)
    # Configure retries/timeouts from env
    total_retries = int(os.environ.get('RETRIES_TOTAL', '5'))
    retry_backoff = float(os.environ.get('RETRY_BACKOFF_S', '1.0'))
    chroma_attempts = int(os.environ.get('CHROMA_RETRIES', '4'))
    chroma_backoff = float(os.environ.get('CHROMA_BACKOFF_S', '1.5'))
    embed_timeout = int(os.environ.get('EMBED_TIMEOUT_S', '120'))
    embed_batch = int(os.environ.get('EMBED_BATCH', '32'))
    # token chunking params
    tokens_per_chunk = int(os.environ.get('CHUNK_TOKENS', '512'))
    overlap_tokens = int(os.environ.get('CHUNK_OVERLAP_TOKENS', '80'))
    # Concurrency
    max_workers = int(os.environ.get('MAX_WORKERS', '6'))
    # Prepare jobs (and perform doc-level deletes up-front in main thread)
    jobs: List[Tuple[str, Path, Dict[str, Any]]] = []
    for it in items:
        rel_path = str(it.get('path', '')).lstrip('/')
        file_path = (public_dir / rel_path).resolve()
        if not file_path.is_file():
            continue
        doc_id = str(it.get('url') or it.get('path') or file_path.as_posix())
        # Idempotent delete for this doc (and legacy keys) before re-insert
        try:
            chroma_delete_with_retry(collection, {"doc_id": doc_id}, attempts=chroma_attempts, backoff_s=chroma_backoff)
        except Exception:
            pass
        try:
            if it.get('url'):
                chroma_delete_with_retry(collection, {"url": it.get('url')}, attempts=chroma_attempts, backoff_s=chroma_backoff)
        except Exception:
            pass
        try:
            if it.get('path'):
                chroma_delete_with_retry(collection, {"path": it.get('path')}, attempts=chroma_attempts, backoff_s=chroma_backoff)
        except Exception:
            pass
        jobs.append((doc_id, file_path, it))

    # Run embeddings in parallel; upsert results serially to avoid client thread-safety concerns
    with ThreadPoolExecutor(max_workers=max_workers) as ex:
        futures = {
            ex.submit(
                process_document,
                file_path,
                it,
                tei_url,
                total_retries,
                retry_backoff,
                tokens_per_chunk,
                overlap_tokens,
                embed_batch,
                embed_timeout,
                cf_headers,
            ): (doc_id, file_path, it)
            for doc_id, file_path, it in jobs
        }
        for fut in as_completed(futures):
            ctx_doc_id, ctx_file_path, ctx_item = futures[fut]
            try:
                doc_id, ids, embeddings, metadatas, documents = fut.result()
                if ids and embeddings and metadatas and documents:
                    chroma_upsert_with_retry(
                        collection,
                        ids=ids,
                        embeddings=embeddings,
                        metadatas=metadatas,
                        documents=documents,
                        attempts=chroma_attempts,
                        backoff_s=chroma_backoff,
                    )
            except Exception as exc:
                logger.exception(
                    "Failed to process document %s (path=%s): %s",
                    ctx_doc_id,
                    ctx_item.get('path'),
                    exc,
                )
                continue


if __name__ == '__main__':
    main()

```

---

## shared

### index.ts

**Path:** `shared/index.ts`

```typescript
/**
 * Shared AI Module
 * 
 * 모든 AI 관련 타입, 설정, 유틸리티를 내보냅니다.
 */

// Types
export * from './types/ai';

// Configuration
export { 
  getAIConfig, 
  setAIConfig, 
  getProvider, 
  getEnabledProviders,
  isModelAvailable,
  PROVIDERS,
  DEFAULT_AI_CONFIG,
  AI_URLS,
  TIMEOUTS,
} from './ai/config';

// Client
export {
  type IAIClient,
  type ITaskClient,
  BaseAIClient,
  tryParseJson,
  safeTruncate,
  AIError,
  CircuitOpenError,
  TimeoutError,
} from './ai/client';

// Logger
export {
  aiLogger,
  generateRequestId,
} from './ai/logger';

```

### package.json

**Path:** `shared/package.json`

```json
{
  "name": "@blog/shared",
  "version": "1.0.0",
  "description": "Shared types and utilities for blog AI services",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./types/*": {
      "types": "./dist/types/*.d.ts",
      "import": "./dist/types/*.js"
    },
    "./ai/*": {
      "types": "./dist/ai/*.d.ts",
      "import": "./dist/ai/*.js"
    }
  },
  "scripts": {
    "build": "tsc",
    "watch": "tsc --watch",
    "clean": "rm -rf dist"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "typescript": "^5.3.0"
  }
}

```

### services.ts

**Path:** `shared/services.ts`

```typescript
/**
 * Centralized Service Configuration
 * 
 * 모든 서비스 엔드포인트, 포트, 명칭을 중앙에서 관리합니다.
 * 하드코딩된 연결 정보를 제거하고 환경변수로 오버라이드 가능하게 합니다.
 * 
 * 원칙:
 * 1. 모든 서비스 주소는 이 파일에서만 정의
 * 2. 환경변수로 오버라이드 가능
 * 3. 서비스 이름은 통일된 명명 규칙 사용
 */

// ============================================================================
// Environment Variable Helpers
// ============================================================================

function getEnv(key: string, defaultValue: string): string {
  if (typeof process !== 'undefined' && process.env) {
    return process.env[key] || defaultValue;
  }
  return defaultValue;
}

function getEnvNumber(key: string, defaultValue: number): number {
  const value = getEnv(key, String(defaultValue));
  const parsed = parseInt(value, 10);
  return isNaN(parsed) ? defaultValue : parsed;
}

// ============================================================================
// Service Names (통일된 명명 규칙)
// ============================================================================
// 기존: vas-core, opencode, opencode-serve 등 혼용
// 통일: 모든 서비스는 단일 명칭 사용

export const SERVICE_NAMES = {
  // AI Services
  AI_GATEWAY: 'litellm',        // LiteLLM AI Gateway (Primary)
  AI_ENGINE: 'ai-engine',       // VAS Core (GitHub Copilot Auth) - 기존 vas-core/opencode 통일
  AI_ADMIN: 'ai-admin',         // VAS Admin UI - 기존 vas-admin
  
  // Backend Services  
  API: 'api',                   // Backend API Server
  
  // Infrastructure
  EMBEDDING: 'embedding',       // TEI Embedding Server
  VECTOR_DB: 'vector-db',       // ChromaDB
  TERMINAL: 'terminal',         // Terminal WebSocket Server
  
  // External
  NGINX: 'nginx',               // Reverse Proxy
} as const;

// ============================================================================
// Port Definitions (중앙 관리)
// ============================================================================

export const PORTS = {
  // AI Services
  AI_GATEWAY: getEnvNumber('PORT_AI_GATEWAY', 4000),
  AI_ENGINE: getEnvNumber('PORT_AI_ENGINE', 7012),
  AI_ADMIN: getEnvNumber('PORT_AI_ADMIN', 7080),
  
  // Backend Services
  API: getEnvNumber('PORT_API', 5080),
  
  // Infrastructure
  EMBEDDING: getEnvNumber('PORT_EMBEDDING', 80),
  VECTOR_DB: getEnvNumber('PORT_VECTOR_DB', 8000),
  TERMINAL: getEnvNumber('PORT_TERMINAL', 8080),
  
  // External
  NGINX: getEnvNumber('PORT_NGINX', 80),
  
  // Local Development (localhost binding)
  LOCAL_AI_GATEWAY: getEnvNumber('PORT_LOCAL_AI_GATEWAY', 4000),
  LOCAL_AI_ENGINE: getEnvNumber('PORT_LOCAL_AI_ENGINE', 7012),
  LOCAL_EMBEDDING: getEnvNumber('PORT_LOCAL_EMBEDDING', 8180),
  LOCAL_VECTOR_DB: getEnvNumber('PORT_LOCAL_VECTOR_DB', 8100),
} as const;

// ============================================================================
// Service URLs (환경별 자동 구성)
// ============================================================================

export interface ServiceEndpoint {
  name: string;
  host: string;
  port: number;
  url: string;
  healthPath: string;
}

function createEndpoint(
  name: string,
  envKey: string,
  defaultHost: string,
  port: number,
  healthPath = '/health'
): ServiceEndpoint {
  const host = getEnv(envKey, defaultHost);
  return {
    name,
    host,
    port,
    url: `http://${host}:${port}`,
    healthPath,
  };
}

// Docker 내부 서비스 엔드포인트
export const SERVICES = {
  // AI Gateway (LiteLLM) - Primary AI endpoint
  AI_GATEWAY: createEndpoint(
    SERVICE_NAMES.AI_GATEWAY,
    'SERVICE_AI_GATEWAY_HOST',
    'litellm',
    PORTS.AI_GATEWAY,
    '/health'
  ),
  
  // AI Engine (VAS Core) - GitHub Copilot authentication
  AI_ENGINE: createEndpoint(
    SERVICE_NAMES.AI_ENGINE,
    'SERVICE_AI_ENGINE_HOST',
    'ai-engine',  // 통일된 이름 (docker-compose에서 alias 사용)
    PORTS.AI_ENGINE,
    '/app'
  ),
  
  // AI Admin (VAS Admin)
  AI_ADMIN: createEndpoint(
    SERVICE_NAMES.AI_ADMIN,
    'SERVICE_AI_ADMIN_HOST',
    'ai-admin',
    PORTS.AI_ADMIN,
    '/health'
  ),
  
  // Backend API
  API: createEndpoint(
    SERVICE_NAMES.API,
    'SERVICE_API_HOST',
    'api',
    PORTS.API,
    '/api/v1/healthz'
  ),
  
  // Embedding Server (TEI)
  EMBEDDING: createEndpoint(
    SERVICE_NAMES.EMBEDDING,
    'SERVICE_EMBEDDING_HOST',
    'embedding-server',
    PORTS.EMBEDDING,
    '/health'
  ),
  
  // Vector Database (ChromaDB)
  VECTOR_DB: createEndpoint(
    SERVICE_NAMES.VECTOR_DB,
    'SERVICE_VECTOR_DB_HOST',
    'chromadb',
    PORTS.VECTOR_DB,
    '/api/v1/heartbeat'
  ),
  
  // Terminal Server
  TERMINAL: createEndpoint(
    SERVICE_NAMES.TERMINAL,
    'SERVICE_TERMINAL_HOST',
    'terminal-server',
    PORTS.TERMINAL,
    '/health'
  ),
} as const;

// ============================================================================
// URL Builders (OpenAI 호환 API 경로 등)
// ============================================================================

export const URLS = {
  // LiteLLM Gateway (OpenAI-compatible)
  litellm: {
    base: getEnv('LITELLM_BASE_URL', SERVICES.AI_GATEWAY.url),
    chat: () => `${URLS.litellm.base}/v1/chat/completions`,
    models: () => `${URLS.litellm.base}/v1/models`,
    embeddings: () => `${URLS.litellm.base}/v1/embeddings`,
    health: () => `${URLS.litellm.base}/health`,
  },
  
  // AI Engine (for auth only)
  aiEngine: {
    base: getEnv('AI_ENGINE_URL', SERVICES.AI_ENGINE.url),
    providers: () => `${URLS.aiEngine.base}/config/providers`,
    auth: () => `${URLS.aiEngine.base}/auth`,
  },
  
  // Backend API
  api: {
    base: getEnv('API_BASE_URL', SERVICES.API.url),
    health: () => `${URLS.api.base}/api/v1/healthz`,
  },
  
  // RAG Services
  rag: {
    embedding: getEnv('TEI_URL', SERVICES.EMBEDDING.url),
    vectorDb: getEnv('CHROMA_URL', SERVICES.VECTOR_DB.url),
  },
  
  // Public URLs (Cloudflare Tunnel)
  public: {
    api: getEnv('PUBLIC_API_URL', 'https://api.nodove.com'),
    site: getEnv('PUBLIC_SITE_URL', 'https://noblog.nodove.com'),
  },
} as const;

// ============================================================================
// Legacy Compatibility (점진적 마이그레이션 지원)
// ============================================================================
// 기존 코드에서 사용하던 변수명을 새 시스템으로 매핑

export const LEGACY_MAPPINGS = {
  // 기존 → 새 시스템
  'AI_SERVE_BASE_URL': URLS.litellm.base,
  'VAS_CORE_URL': URLS.aiEngine.base,
  'VAS_PROXY_URL': URLS.litellm.base, // vas-proxy는 litellm으로 대체됨
  'TEI_URL': URLS.rag.embedding,
  'CHROMA_URL': URLS.rag.vectorDb,
} as const;

// ============================================================================
// Service Discovery Helpers
// ============================================================================

/**
 * Get service URL by name (for dynamic service discovery)
 */
export function getServiceUrl(serviceName: keyof typeof SERVICES): string {
  return SERVICES[serviceName].url;
}

/**
 * Check if running in Docker environment
 */
export function isDockerEnvironment(): boolean {
  return getEnv('DOCKER_ENV', 'false') === 'true' || 
         getEnv('KUBERNETES_SERVICE_HOST', '') !== '';
}

/**
 * Get appropriate URL based on environment
 * - In Docker: use internal service names
 * - Locally: use localhost with mapped ports
 */
export function getEnvironmentAwareUrl(
  serviceName: keyof typeof SERVICES,
  localPort?: number
): string {
  if (isDockerEnvironment()) {
    return SERVICES[serviceName].url;
  }
  
  const port = localPort || SERVICES[serviceName].port;
  return `http://localhost:${port}`;
}

// ============================================================================
// Validation & Health Check
// ============================================================================

export interface HealthCheckResult {
  service: string;
  url: string;
  healthy: boolean;
  latencyMs?: number;
  error?: string;
}

/**
 * Check health of a service
 */
export async function checkServiceHealth(
  service: ServiceEndpoint,
  timeoutMs = 5000
): Promise<HealthCheckResult> {
  const url = `${service.url}${service.healthPath}`;
  const startTime = Date.now();
  
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    
    const response = await fetch(url, { 
      signal: controller.signal,
      method: 'GET',
    });
    
    clearTimeout(timeoutId);
    
    return {
      service: service.name,
      url,
      healthy: response.ok,
      latencyMs: Date.now() - startTime,
    };
  } catch (error) {
    return {
      service: service.name,
      url,
      healthy: false,
      latencyMs: Date.now() - startTime,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Check health of all services
 */
export async function checkAllServicesHealth(): Promise<HealthCheckResult[]> {
  const checks = Object.values(SERVICES).map(service => 
    checkServiceHealth(service)
  );
  return Promise.all(checks);
}

// ============================================================================
// Export Type Definitions
// ============================================================================

export type ServiceName = keyof typeof SERVICES;
export type PortName = keyof typeof PORTS;

```

### tsconfig.json

**Path:** `shared/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ES2020", "DOM"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist",
    "rootDir": "./",
    "resolveJsonModule": true
  },
  "include": ["**/*.ts"],
  "exclude": ["node_modules", "dist"]
}

```

---

## shared/ai

### adapters.ts

**Path:** `shared/ai/adapters.ts`

```typescript
/**
 * AI Provider Adapters
 * 
 * Provider별 응답 형식 차이를 추상화하여 통일된 인터페이스를 제공합니다.
 * 하드코딩된 MESSAGE_PATHS 배열 대신 Adapter Pattern을 사용합니다.
 * 
 * 원칙:
 * 1. 새 Provider 추가 시 Adapter만 구현하면 됨
 * 2. 기존 코드 수정 없이 Provider 확장 가능
 * 3. Provider별 특수 처리 로직 캡슐화
 */

// ============================================================================
// Types
// ============================================================================

export interface AIMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

export interface AIRequest {
  messages: AIMessage[];
  model?: string;
  temperature?: number;
  maxTokens?: number;
  stream?: boolean;
}

export interface AIResponse {
  content: string;
  model: string;
  finishReason?: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  raw?: unknown; // Original response for debugging
}

export interface ProviderAdapter {
  name: string;
  
  /** Transform request to provider-specific format */
  formatRequest(request: AIRequest): unknown;
  
  /** Parse provider response to unified format */
  parseResponse(response: unknown): AIResponse;
  
  /** Parse streaming chunk */
  parseStreamChunk(chunk: unknown): string | null;
  
  /** Extract error message from provider error response */
  parseError(error: unknown): string;
}

// ============================================================================
// OpenAI Adapter (also works for LiteLLM, Azure OpenAI)
// ============================================================================

export const OpenAIAdapter: ProviderAdapter = {
  name: 'openai',
  
  formatRequest(request: AIRequest) {
    return {
      model: request.model || 'gpt-4',
      messages: request.messages,
      temperature: request.temperature ?? 0.7,
      max_tokens: request.maxTokens,
      stream: request.stream ?? false,
    };
  },
  
  parseResponse(response: unknown): AIResponse {
    const r = response as {
      choices?: Array<{
        message?: { content?: string };
        finish_reason?: string;
      }>;
      model?: string;
      usage?: {
        prompt_tokens?: number;
        completion_tokens?: number;
        total_tokens?: number;
      };
    };
    
    return {
      content: r.choices?.[0]?.message?.content || '',
      model: r.model || 'unknown',
      finishReason: r.choices?.[0]?.finish_reason,
      usage: r.usage ? {
        promptTokens: r.usage.prompt_tokens || 0,
        completionTokens: r.usage.completion_tokens || 0,
        totalTokens: r.usage.total_tokens || 0,
      } : undefined,
      raw: response,
    };
  },
  
  parseStreamChunk(chunk: unknown): string | null {
    const c = chunk as {
      choices?: Array<{
        delta?: { content?: string };
      }>;
    };
    return c.choices?.[0]?.delta?.content || null;
  },
  
  parseError(error: unknown): string {
    const e = error as { error?: { message?: string }; message?: string };
    return e.error?.message || e.message || 'Unknown OpenAI error';
  },
};

// ============================================================================
// Anthropic (Claude) Adapter
// ============================================================================

export const AnthropicAdapter: ProviderAdapter = {
  name: 'anthropic',
  
  formatRequest(request: AIRequest) {
    // Anthropic uses different message format
    const systemMessage = request.messages.find(m => m.role === 'system');
    const otherMessages = request.messages.filter(m => m.role !== 'system');
    
    return {
      model: request.model || 'claude-3-sonnet-20240229',
      max_tokens: request.maxTokens || 4096,
      system: systemMessage?.content,
      messages: otherMessages.map(m => ({
        role: m.role,
        content: m.content,
      })),
    };
  },
  
  parseResponse(response: unknown): AIResponse {
    const r = response as {
      content?: Array<{ type?: string; text?: string }>;
      model?: string;
      stop_reason?: string;
      usage?: {
        input_tokens?: number;
        output_tokens?: number;
      };
    };
    
    // Anthropic returns content as array of blocks
    const textContent = r.content
      ?.filter(c => c.type === 'text')
      .map(c => c.text)
      .join('') || '';
    
    return {
      content: textContent,
      model: r.model || 'unknown',
      finishReason: r.stop_reason,
      usage: r.usage ? {
        promptTokens: r.usage.input_tokens || 0,
        completionTokens: r.usage.output_tokens || 0,
        totalTokens: (r.usage.input_tokens || 0) + (r.usage.output_tokens || 0),
      } : undefined,
      raw: response,
    };
  },
  
  parseStreamChunk(chunk: unknown): string | null {
    const c = chunk as {
      type?: string;
      delta?: { type?: string; text?: string };
    };
    if (c.type === 'content_block_delta' && c.delta?.type === 'text_delta') {
      return c.delta.text || null;
    }
    return null;
  },
  
  parseError(error: unknown): string {
    const e = error as { error?: { message?: string }; message?: string };
    return e.error?.message || e.message || 'Unknown Anthropic error';
  },
};

// ============================================================================
// Google Gemini Adapter
// ============================================================================

export const GeminiAdapter: ProviderAdapter = {
  name: 'gemini',
  
  formatRequest(request: AIRequest) {
    return {
      contents: request.messages.map(m => ({
        role: m.role === 'assistant' ? 'model' : 'user',
        parts: [{ text: m.content }],
      })),
      generationConfig: {
        temperature: request.temperature ?? 0.7,
        maxOutputTokens: request.maxTokens,
      },
    };
  },
  
  parseResponse(response: unknown): AIResponse {
    const r = response as {
      candidates?: Array<{
        content?: { parts?: Array<{ text?: string }> };
        finishReason?: string;
      }>;
      usageMetadata?: {
        promptTokenCount?: number;
        candidatesTokenCount?: number;
        totalTokenCount?: number;
      };
    };
    
    const content = r.candidates?.[0]?.content?.parts
      ?.map(p => p.text)
      .join('') || '';
    
    return {
      content,
      model: 'gemini',
      finishReason: r.candidates?.[0]?.finishReason,
      usage: r.usageMetadata ? {
        promptTokens: r.usageMetadata.promptTokenCount || 0,
        completionTokens: r.usageMetadata.candidatesTokenCount || 0,
        totalTokens: r.usageMetadata.totalTokenCount || 0,
      } : undefined,
      raw: response,
    };
  },
  
  parseStreamChunk(chunk: unknown): string | null {
    const c = chunk as {
      candidates?: Array<{
        content?: { parts?: Array<{ text?: string }> };
      }>;
    };
    return c.candidates?.[0]?.content?.parts?.[0]?.text || null;
  },
  
  parseError(error: unknown): string {
    const e = error as { error?: { message?: string }; message?: string };
    return e.error?.message || e.message || 'Unknown Gemini error';
  },
};

// ============================================================================
// VAS (OpenCode) Adapter - Legacy format support
// ============================================================================

export const VASAdapter: ProviderAdapter = {
  name: 'vas',
  
  formatRequest(request: AIRequest) {
    // VAS uses a simplified format
    const lastUserMessage = request.messages
      .filter(m => m.role === 'user')
      .pop();
    
    return {
      message: lastUserMessage?.content || '',
      providerID: 'github-copilot',
      modelID: request.model || 'gpt-4.1',
      title: `api-${Date.now()}`,
    };
  },
  
  parseResponse(response: unknown): AIResponse {
    // VAS can return in multiple formats - handle all of them
    const r = response as Record<string, unknown>;
    
    // Try different response paths (replacing hardcoded MESSAGE_PATHS)
    const content = extractContent(r, [
      ['response', 'text'],
      ['response', 'content'],
      ['data', 'response', 'text'],
      ['data', 'message'],
      ['message'],
      ['content'],
      ['text'],
      ['result'],
    ]);
    
    return {
      content: content || '',
      model: (r.model as string) || 'vas',
      raw: response,
    };
  },
  
  parseStreamChunk(chunk: unknown): string | null {
    const c = chunk as { text?: string; content?: string; delta?: string };
    return c.text || c.content || c.delta || null;
  },
  
  parseError(error: unknown): string {
    const e = error as { error?: string; message?: string };
    return e.error || e.message || 'Unknown VAS error';
  },
};

// ============================================================================
// Universal Response Extractor
// ============================================================================

/**
 * Extract content from nested object using multiple possible paths
 * This replaces the hardcoded MESSAGE_PATHS array
 */
function extractContent(
  obj: Record<string, unknown>,
  paths: string[][]
): string | null {
  for (const path of paths) {
    let current: unknown = obj;
    
    for (const key of path) {
      if (current && typeof current === 'object' && key in current) {
        current = (current as Record<string, unknown>)[key];
      } else {
        current = undefined;
        break;
      }
    }
    
    if (typeof current === 'string' && current.length > 0) {
      return current;
    }
  }
  
  return null;
}

// ============================================================================
// Provider Registry
// ============================================================================

const adapters: Map<string, ProviderAdapter> = new Map([
  ['openai', OpenAIAdapter],
  ['litellm', OpenAIAdapter], // LiteLLM uses OpenAI format
  ['azure', OpenAIAdapter],   // Azure OpenAI uses same format
  ['anthropic', AnthropicAdapter],
  ['claude', AnthropicAdapter],
  ['gemini', GeminiAdapter],
  ['google', GeminiAdapter],
  ['vas', VASAdapter],
  ['github-copilot', VASAdapter],
]);

/**
 * Get adapter for a provider
 */
export function getAdapter(provider: string): ProviderAdapter {
  const adapter = adapters.get(provider.toLowerCase());
  if (!adapter) {
    // Default to OpenAI adapter (most common format)
    console.warn(`Unknown provider "${provider}", using OpenAI adapter`);
    return OpenAIAdapter;
  }
  return adapter;
}

/**
 * Register a custom adapter
 */
export function registerAdapter(name: string, adapter: ProviderAdapter): void {
  adapters.set(name.toLowerCase(), adapter);
}

/**
 * List all registered adapters
 */
export function listAdapters(): string[] {
  return Array.from(adapters.keys());
}

// ============================================================================
// Unified AI Client using Adapters
// ============================================================================

export interface UnifiedAIClientOptions {
  baseUrl: string;
  apiKey: string;
  provider?: string;
  defaultModel?: string;
}

export class UnifiedAIClient {
  private baseUrl: string;
  private apiKey: string;
  private adapter: ProviderAdapter;
  private defaultModel: string;
  
  constructor(options: UnifiedAIClientOptions) {
    this.baseUrl = options.baseUrl;
    this.apiKey = options.apiKey;
    this.adapter = getAdapter(options.provider || 'openai');
    this.defaultModel = options.defaultModel || 'gpt-4';
  }
  
  async chat(request: AIRequest): Promise<AIResponse> {
    const formattedRequest = this.adapter.formatRequest({
      ...request,
      model: request.model || this.defaultModel,
    });
    
    const response = await fetch(`${this.baseUrl}/v1/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`,
      },
      body: JSON.stringify(formattedRequest),
    });
    
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(this.adapter.parseError(error));
    }
    
    const data = await response.json();
    return this.adapter.parseResponse(data);
  }
  
  async *stream(request: AIRequest): AsyncGenerator<string, void, unknown> {
    const formattedRequest = this.adapter.formatRequest({
      ...request,
      model: request.model || this.defaultModel,
      stream: true,
    });
    
    const response = await fetch(`${this.baseUrl}/v1/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`,
      },
      body: JSON.stringify(formattedRequest),
    });
    
    if (!response.ok || !response.body) {
      const error = await response.json().catch(() => ({}));
      throw new Error(this.adapter.parseError(error));
    }
    
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data === '[DONE]') return;
            
            try {
              const parsed = JSON.parse(data);
              const content = this.adapter.parseStreamChunk(parsed);
              if (content) yield content;
            } catch {
              // Skip invalid JSON
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }
}

```

### client.ts

**Path:** `shared/ai/client.ts`

```typescript
/**
 * Unified AI Client Interface
 * 
 * 모든 AI 클라이언트가 구현해야 하는 인터페이스 정의
 */

import type {
  Message,
  ImageInput,
  ChatRequest,
  ChatResponse,
  GenerateRequest,
  GenerateResponse,
  HealthStatus,
  CircuitBreakerState,
  ProviderId,
  TaskMode,
  TaskPayload,
  TaskResult,
} from '../types/ai';

// ============================================================================
// Client Interface
// ============================================================================

/**
 * AI 클라이언트 인터페이스
 * Backend, Workers에서 각각 구현합니다.
 */
export interface IAIClient {
  /**
   * Chat completion with message history
   */
  chat(request: ChatRequest): Promise<ChatResponse>;

  /**
   * Simple text generation
   */
  generate(request: GenerateRequest): Promise<GenerateResponse>;

  /**
   * Vision analysis with image
   */
  vision(image: ImageInput, prompt: string, options?: Partial<GenerateRequest>): Promise<GenerateResponse>;

  /**
   * Health check
   */
  health(force?: boolean): Promise<HealthStatus>;

  /**
   * Get circuit breaker state
   */
  getCircuitState(): CircuitBreakerState;
}

/**
 * Task 처리 클라이언트 인터페이스
 * Sketch, Prism, Chain 등 구조화된 태스크용
 */
export interface ITaskClient {
  /**
   * Execute a structured task
   */
  executeTask<T extends TaskResult>(mode: TaskMode, payload: TaskPayload): Promise<T>;
}

// ============================================================================
// Abstract Base Client
// ============================================================================

/**
 * 공통 기능을 제공하는 추상 베이스 클래스
 */
export abstract class BaseAIClient implements IAIClient {
  protected circuitState: CircuitBreakerState = {
    isOpen: false,
    failures: 0,
    lastFailure: 0,
    threshold: 5,
    resetTimeMs: 30000,
  };

  constructor(circuitBreakerConfig?: Partial<CircuitBreakerState>) {
    if (circuitBreakerConfig) {
      this.circuitState = { ...this.circuitState, ...circuitBreakerConfig };
    }
  }

  // ============================================================================
  // Circuit Breaker Logic
  // ============================================================================

  protected isCircuitOpen(): boolean {
    if (!this.circuitState.isOpen) return false;

    const now = Date.now();
    if (now - this.circuitState.lastFailure > this.circuitState.resetTimeMs) {
      this.circuitState.isOpen = false;
      this.circuitState.failures = 0;
      return false;
    }

    return true;
  }

  protected recordFailure(): void {
    this.circuitState.failures++;
    this.circuitState.lastFailure = Date.now();

    if (this.circuitState.failures >= this.circuitState.threshold) {
      this.circuitState.isOpen = true;
    }
  }

  protected recordSuccess(): void {
    this.circuitState.failures = 0;
    this.circuitState.isOpen = false;
  }

  getCircuitState(): CircuitBreakerState {
    return { ...this.circuitState };
  }

  // ============================================================================
  // Abstract Methods (to be implemented by subclasses)
  // ============================================================================

  abstract chat(request: ChatRequest): Promise<ChatResponse>;
  abstract generate(request: GenerateRequest): Promise<GenerateResponse>;
  abstract vision(image: ImageInput, prompt: string, options?: Partial<GenerateRequest>): Promise<GenerateResponse>;
  abstract health(force?: boolean): Promise<HealthStatus>;
}

// ============================================================================
// Response Utilities
// ============================================================================

/**
 * JSON 파싱 유틸리티
 * AI 응답에서 JSON을 추출합니다.
 */
export function tryParseJson<T = unknown>(text: string | null | undefined): T | null {
  if (!text || typeof text !== 'string') return null;

  // Direct parse
  try {
    return JSON.parse(text) as T;
  } catch {
    // continue
  }

  // Extract from code fence
  const fence = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fence?.[1]) {
    try {
      return JSON.parse(fence[1].trim()) as T;
    } catch {
      // continue
    }
  }

  // Extract { } substring
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start >= 0 && end > start) {
    try {
      return JSON.parse(text.slice(start, end + 1)) as T;
    } catch {
      // continue
    }
  }

  return null;
}

/**
 * 텍스트 안전 자르기
 */
export function safeTruncate(text: string | null | undefined, maxLength: number): string {
  if (!text) return '';
  if (text.length <= maxLength) return text;
  return `${text.slice(0, maxLength - 3)}...`;
}

// ============================================================================
// Error Types
// ============================================================================

export class AIError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly provider?: ProviderId,
    public readonly statusCode?: number,
  ) {
    super(message);
    this.name = 'AIError';
  }
}

export class CircuitOpenError extends AIError {
  constructor(provider?: ProviderId) {
    super('AI service temporarily unavailable (circuit breaker open)', 'CIRCUIT_OPEN', provider);
    this.name = 'CircuitOpenError';
  }
}

export class TimeoutError extends AIError {
  constructor(timeoutMs: number, provider?: ProviderId) {
    super(`Request timeout after ${timeoutMs}ms`, 'TIMEOUT', provider);
    this.name = 'TimeoutError';
  }
}

```

### config.ts

**Path:** `shared/ai/config.ts`

```typescript
/**
 * Centralized AI Configuration
 * 
 * 모든 AI 서비스 설정을 중앙에서 관리합니다.
 * LiteLLM Gateway를 통해 모든 Provider에 접근합니다.
 * 환경변수로 오버라이드 가능합니다.
 */

import type { AIConfig, ProviderId, ProviderConfig } from '../types/ai';

// ============================================================================
// Environment Variable Helpers
// ============================================================================

function getEnv(key: string, defaultValue: string): string {
  if (typeof process !== 'undefined' && process.env) {
    return process.env[key] || defaultValue;
  }
  return defaultValue;
}

function getEnvNumber(key: string, defaultValue: number): number {
  const value = getEnv(key, String(defaultValue));
  const parsed = parseInt(value, 10);
  return isNaN(parsed) ? defaultValue : parsed;
}

function getEnvBoolean(key: string, defaultValue: boolean): boolean {
  const value = getEnv(key, String(defaultValue));
  return value === 'true' || value === '1';
}

// ============================================================================
// LiteLLM Gateway Configuration (Primary)
// ============================================================================

export const LITELLM_CONFIG = {
  // Base URL for LiteLLM proxy (OpenAI-compatible)
  baseUrl: getEnv('LITELLM_BASE_URL', 'http://litellm:4000'),
  
  // Master API key for authentication
  apiKey: getEnv('LITELLM_MASTER_KEY', 'sk-litellm-master-key'),
  
  // Default model (will be routed by LiteLLM)
  defaultModel: getEnv('AI_DEFAULT_MODEL', 'gpt-4.1'),
  
  // Timeout settings
  timeout: getEnvNumber('AI_TIMEOUT_MS', 120000),
  longTimeout: getEnvNumber('AI_LONG_TIMEOUT_MS', 300000),
  
  // Retry settings (LiteLLM handles fallbacks automatically)
  retryAttempts: getEnvNumber('AI_RETRY_ATTEMPTS', 2),
};

// ============================================================================
// Provider Definitions (Reference - actual routing handled by LiteLLM)
// ============================================================================

export const PROVIDERS: Record<ProviderId, ProviderConfig> = {
  'github-copilot': {
    id: 'github-copilot',
    name: 'GitHub Copilot',
    baseUrl: 'auto', // Routed through LiteLLM → vas-core
    models: ['gpt-4.1', 'gpt-4o', 'gpt-4-turbo', 'o1-mini', 'claude-sonnet-4'],
    features: {
      chat: true,
      streaming: true,
      vision: true,
      functionCalling: true,
    },
    enabled: true,
  },
  openai: {
    id: 'openai',
    name: 'OpenAI',
    baseUrl: 'https://api.openai.com/v1', // Routed through LiteLLM
    models: ['gpt-4o', 'gpt-4-turbo', 'gpt-3.5-turbo'],
    features: {
      chat: true,
      streaming: true,
      vision: true,
      functionCalling: true,
    },
    enabled: getEnvBoolean('AI_OPENAI_ENABLED', false),
  },
  gemini: {
    id: 'gemini',
    name: 'Google Gemini',
    baseUrl: 'https://generativelanguage.googleapis.com/v1beta', // Routed through LiteLLM
    models: ['gemini-1.5-flash', 'gemini-1.5-pro', 'gemini-2.0-flash-exp'],
    features: {
      chat: true,
      streaming: true,
      vision: true,
      functionCalling: true,
    },
    enabled: true,
  },
  anthropic: {
    id: 'anthropic',
    name: 'Anthropic Claude',
    baseUrl: 'https://api.anthropic.com/v1', // Routed through LiteLLM
    models: ['claude-3-5-sonnet', 'claude-3-opus', 'claude-3-haiku'],
    features: {
      chat: true,
      streaming: true,
      vision: true,
      functionCalling: false,
    },
    enabled: getEnvBoolean('AI_ANTHROPIC_ENABLED', false),
  },
  local: {
    id: 'local',
    name: 'Local LLM',
    baseUrl: getEnv('AI_LOCAL_URL', 'http://localhost:11434'), // Routed through LiteLLM
    models: ['llama3', 'codellama', 'mistral'],
    features: {
      chat: true,
      streaming: true,
      vision: false,
      functionCalling: false,
    },
    enabled: getEnvBoolean('AI_LOCAL_ENABLED', false),
  },
};

// ============================================================================
// Default Configuration
// ============================================================================

export const DEFAULT_AI_CONFIG: AIConfig = {
  providers: Object.values(PROVIDERS),
  routing: {
    defaultProvider: getEnv('AI_DEFAULT_PROVIDER', 'github-copilot') as ProviderId,
    defaultModel: getEnv('AI_DEFAULT_MODEL', 'gpt-4.1'),
    fallbackProviders: ['gemini'], // LiteLLM handles fallbacks automatically
    timeout: getEnvNumber('AI_TIMEOUT_MS', 120000),
    retryAttempts: getEnvNumber('AI_RETRY_ATTEMPTS', 2),
  },
  circuitBreaker: {
    threshold: getEnvNumber('AI_CB_THRESHOLD', 5),
    resetTimeMs: getEnvNumber('AI_CB_RESET_MS', 30000),
  },
  logging: {
    enabled: getEnvBoolean('AI_LOGGING_ENABLED', true),
    level: getEnv('AI_LOG_LEVEL', 'info') as 'debug' | 'info' | 'warn' | 'error',
    includeMetrics: getEnvBoolean('AI_LOG_METRICS', true),
  },
};

// ============================================================================
// Configuration Accessors
// ============================================================================

let _config: AIConfig = DEFAULT_AI_CONFIG;

/**
 * Get the current AI configuration
 */
export function getAIConfig(): AIConfig {
  return _config;
}

/**
 * Update the AI configuration (for runtime changes)
 */
export function setAIConfig(config: Partial<AIConfig>): void {
  _config = { ..._config, ...config };
}

/**
 * Get a specific provider configuration
 */
export function getProvider(id: ProviderId): ProviderConfig | undefined {
  return _config.providers.find(p => p.id === id);
}

/**
 * Get all enabled providers
 */
export function getEnabledProviders(): ProviderConfig[] {
  return _config.providers.filter(p => p.enabled);
}

/**
 * Check if a model is available for a provider
 */
export function isModelAvailable(providerId: ProviderId, model: string): boolean {
  const provider = getProvider(providerId);
  return provider?.enabled === true && provider.models.includes(model);
}

// ============================================================================
// URL Configuration
// ============================================================================

export const AI_URLS = {
  // LiteLLM Gateway (Primary - use this for all AI calls)
  litellm: LITELLM_CONFIG.baseUrl,
  litellmApi: `${LITELLM_CONFIG.baseUrl}/v1`,
  
  // Legacy VAS endpoints (for GitHub Copilot auth only)
  vasCore: getEnv('VAS_CORE_URL', 'http://vas-core:7012'),
  vasAdmin: getEnv('VAS_ADMIN_URL', 'http://vas-admin:7080'),
  
  // Workers API
  workersApi: getEnv('WORKERS_API_URL', 'https://api.nodove.com'),
};

// ============================================================================
// Timeout Configuration
// ============================================================================

export const TIMEOUTS = {
  default: LITELLM_CONFIG.timeout,
  long: LITELLM_CONFIG.longTimeout,
  health: getEnvNumber('AI_HEALTH_TIMEOUT_MS', 5000),
  stream: getEnvNumber('AI_STREAM_TIMEOUT_MS', 180000),
};

// ============================================================================
// Model Aliases (for convenience)
// ============================================================================
// Use these in your code instead of provider-specific names
// LiteLLM will route to the correct provider automatically

export const MODELS = {
  // Default models
  default: LITELLM_CONFIG.defaultModel,
  
  // Fast models (for quick responses)
  fast: 'gemini-1.5-flash',
  
  // Smart models (for complex tasks)
  smart: 'gpt-4.1',
  smartVision: 'gpt-4o',
  
  // Coding models
  code: 'gpt-4.1',
  
  // Long context models
  longContext: 'gemini-1.5-pro',
  
  // Cost-effective models
  cheap: 'gemini-1.5-flash',
};

```

### logger.ts

**Path:** `shared/ai/logger.ts`

```typescript
/**
 * Centralized AI Logger
 * 
 * 모든 AI 서비스에서 사용하는 통합 로깅 시스템
 */

import type { AILogEntry, LogLevel, ProviderId, CircuitBreakerState } from '../types/ai';
import { getAIConfig } from './config';

// ============================================================================
// Logger Implementation
// ============================================================================

class AILogger {
  private static instance: AILogger;
  
  private constructor() {}
  
  static getInstance(): AILogger {
    if (!AILogger.instance) {
      AILogger.instance = new AILogger();
    }
    return AILogger.instance;
  }

  private shouldLog(level: LogLevel): boolean {
    const config = getAIConfig();
    if (!config.logging.enabled) return false;
    
    const levels: LogLevel[] = ['debug', 'info', 'warn', 'error'];
    const configLevelIndex = levels.indexOf(config.logging.level);
    const msgLevelIndex = levels.indexOf(level);
    
    return msgLevelIndex >= configLevelIndex;
  }

  private formatEntry(entry: AILogEntry): string {
    return JSON.stringify(entry);
  }

  private log(level: LogLevel, entry: Omit<AILogEntry, 'timestamp' | 'level'>): void {
    if (!this.shouldLog(level)) return;

    const fullEntry: AILogEntry = {
      ...entry,
      timestamp: new Date().toISOString(),
      level,
    };

    const formatted = this.formatEntry(fullEntry);

    switch (level) {
      case 'debug':
        console.debug(formatted);
        break;
      case 'info':
        console.log(formatted);
        break;
      case 'warn':
        console.warn(formatted);
        break;
      case 'error':
        console.error(formatted);
        break;
    }
  }

  // ============================================================================
  // Public API
  // ============================================================================

  debug(service: string, operation: string, metadata?: Record<string, unknown>): void {
    this.log('debug', { service, operation, metadata });
  }

  info(service: string, operation: string, metadata?: Record<string, unknown>): void {
    this.log('info', { service, operation, metadata });
  }

  warn(service: string, operation: string, metadata?: Record<string, unknown>): void {
    this.log('warn', { service, operation, metadata });
  }

  error(service: string, operation: string, error: Error | string, metadata?: Record<string, unknown>): void {
    this.log('error', {
      service,
      operation,
      error: error instanceof Error ? error.message : error,
      metadata,
    });
  }

  // ============================================================================
  // Specialized Logging Methods
  // ============================================================================

  /**
   * Log an AI request
   */
  logRequest(params: {
    service: string;
    operation: string;
    requestId: string;
    provider: ProviderId;
    model: string;
    metadata?: Record<string, unknown>;
  }): void {
    this.log('info', {
      service: params.service,
      operation: params.operation,
      requestId: params.requestId,
      provider: params.provider,
      model: params.model,
      metadata: params.metadata,
    });
  }

  /**
   * Log an AI response
   */
  logResponse(params: {
    service: string;
    operation: string;
    requestId: string;
    provider: ProviderId;
    model: string;
    duration: number;
    success: boolean;
    error?: string;
    metadata?: Record<string, unknown>;
  }): void {
    const level: LogLevel = params.success ? 'info' : 'error';
    this.log(level, {
      service: params.service,
      operation: params.operation,
      requestId: params.requestId,
      provider: params.provider,
      model: params.model,
      duration: params.duration,
      error: params.error,
      metadata: params.metadata,
    });
  }

  /**
   * Log circuit breaker state changes
   */
  logCircuitBreaker(service: string, state: CircuitBreakerState, event: 'opened' | 'closed' | 'half-open'): void {
    const level: LogLevel = event === 'opened' ? 'warn' : 'info';
    this.log(level, {
      service,
      operation: 'circuit_breaker',
      metadata: {
        event,
        ...state,
      },
    });
  }

  /**
   * Log health check results
   */
  logHealthCheck(service: string, healthy: boolean, details?: Record<string, unknown>): void {
    const level: LogLevel = healthy ? 'debug' : 'warn';
    this.log(level, {
      service,
      operation: 'health_check',
      metadata: {
        healthy,
        ...details,
      },
    });
  }
}

// ============================================================================
// Export Singleton
// ============================================================================

export const aiLogger = AILogger.getInstance();

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Generate a unique request ID
 */
export function generateRequestId(prefix = 'req'): string {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).slice(2, 8);
  return `${prefix}-${timestamp}-${random}`;
}

```

---

## shared/types

### ai.ts

**Path:** `shared/types/ai.ts`

```typescript
/**
 * Shared AI Types
 * 
 * 모든 AI 관련 타입을 중앙에서 정의합니다.
 * Backend, Workers, Frontend에서 공유합니다.
 */

// ============================================================================
// Provider & Model Types
// ============================================================================

export type ProviderId = 'github-copilot' | 'openai' | 'gemini' | 'anthropic' | 'local';

export interface ProviderConfig {
  id: ProviderId;
  name: string;
  baseUrl: string;
  models: string[];
  features: ProviderFeatures;
  enabled: boolean;
}

export interface ProviderFeatures {
  chat: boolean;
  streaming: boolean;
  vision: boolean;
  functionCalling: boolean;
}

// ============================================================================
// Message Types
// ============================================================================

export type MessageRole = 'system' | 'user' | 'assistant';

export interface Message {
  role: MessageRole;
  content: string;
  name?: string;
  timestamp?: number;
}

export interface ImageInput {
  base64: string;
  mimeType: string;
}

// ============================================================================
// Request/Response Types
// ============================================================================

export interface ChatRequest {
  messages: Message[];
  provider?: ProviderId;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  stream?: boolean;
}

export interface ChatResponse {
  content: string;
  model: string;
  provider: ProviderId;
  usage?: TokenUsage;
  finishReason?: string;
}

export interface TokenUsage {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
}

export interface GenerateRequest {
  prompt: string;
  provider?: ProviderId;
  model?: string;
  temperature?: number;
  maxTokens?: number;
}

export interface GenerateResponse {
  text: string;
  model: string;
  provider: ProviderId;
  usage?: TokenUsage;
}

// ============================================================================
// Task Types (Sketch, Prism, Chain, Summary)
// ============================================================================

export type TaskMode = 'sketch' | 'prism' | 'chain' | 'catalyst' | 'summary' | 'custom';

export interface TaskPayload {
  paragraph?: string;
  content?: string;
  postTitle?: string;
  title?: string;
  persona?: string;
  prompt?: string;
  [key: string]: unknown;
}

export interface SketchResult {
  mood: string;
  bullets: string[];
}

export interface PrismFacet {
  title: string;
  points: string[];
}

export interface PrismResult {
  facets: PrismFacet[];
}

export interface ChainQuestion {
  q: string;
  why: string;
}

export interface ChainResult {
  questions: ChainQuestion[];
}

export interface SummaryResult {
  summary: string;
  keyPoints?: string[];
}

export type TaskResult = SketchResult | PrismResult | ChainResult | SummaryResult;

// ============================================================================
// Health & Status Types
// ============================================================================

export interface HealthStatus {
  ok: boolean;
  status?: string;
  tokenReady?: boolean;
  error?: string;
  cached?: boolean;
  timestamp: number;
}

export interface CircuitBreakerState {
  isOpen: boolean;
  failures: number;
  lastFailure: number;
  threshold: number;
  resetTimeMs: number;
}

// ============================================================================
// Logging Types
// ============================================================================

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface AILogEntry {
  timestamp: string;
  level: LogLevel;
  service: string;
  operation: string;
  requestId?: string;
  provider?: ProviderId;
  model?: string;
  duration?: number;
  error?: string;
  metadata?: Record<string, unknown>;
}

// ============================================================================
// Configuration Types
// ============================================================================

export interface AIRoutingConfig {
  defaultProvider: ProviderId;
  defaultModel: string;
  fallbackProviders: ProviderId[];
  timeout: number;
  retryAttempts: number;
}

export interface AIConfig {
  providers: ProviderConfig[];
  routing: AIRoutingConfig;
  circuitBreaker: {
    threshold: number;
    resetTimeMs: number;
  };
  logging: {
    enabled: boolean;
    level: LogLevel;
    includeMetrics: boolean;
  };
}

```

---

## workers

### .gitignore

**Path:** `workers/.gitignore`

```gitignore
node_modules/
dist/
.wrangler/
.dev.vars
*.log
.DS_Store
.env
.env.local

```

### .prettierrc.json

**Path:** `workers/.prettierrc.json`

```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "arrowParens": "always"
}

```

### package.json

**Path:** `workers/package.json`

```json
{
  "name": "blog-api-workers",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy",
    "deploy:prod": "wrangler deploy --env production",
    "migrations:apply": "wrangler d1 migrations apply blog-db --local",
    "migrations:apply:prod": "wrangler d1 migrations apply blog-db-prod --env production --remote",
    "migrations:create": "wrangler d1 migrations create blog-db",
    "d1:shell": "wrangler d1 execute blog-db --local --command 'SELECT 1'",
    "typecheck": "tsc --noEmit",
    "format": "prettier --write \"src/**/*.ts\""
  },
  "dependencies": {
    "@blog/shared": "file:../shared",
    "hono": "^4.6.14",
    "jose": "^6.1.2"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20241127.0",
    "@types/node": "^22.10.2",
    "prettier": "^3.4.2",
    "typescript": "^5.7.2",
    "wrangler": "^3.94.0"
  }
}

```

### test-endpoints.sh

**Path:** `workers/test-endpoints.sh`

```bash
#!/bin/bash
# Test all API endpoints

API_URL="${1:-https://blog-api-prod.immuddelo.workers.dev}"
echo "Testing API endpoints at: $API_URL"
echo "================================================"

# Health check
echo -e "\n[1] Testing /healthz"
curl -s "$API_URL/healthz" | jq .

# Public config
echo -e "\n[2] Testing /public/config"
curl -s "$API_URL/public/config" | jq .

# Posts list
echo -e "\n[3] Testing /api/v1/posts"
curl -s "$API_URL/api/v1/posts?page=1&limit=5" | jq .

# Comments list
echo -e "\n[4] Testing /api/v1/comments"
curl -s "$API_URL/api/v1/comments?postId=test" | jq .

# AI Sketch
echo -e "\n[5] Testing /api/v1/ai/sketch"
curl -s -X POST "$API_URL/api/v1/ai/sketch" \
  -H "Content-Type: application/json" \
  -d '{"paragraph":"테스트 문단입니다.","postTitle":"테스트"}' \
  | jq .

# AI Summarize
echo -e "\n[6] Testing /api/v1/ai/summarize"
curl -s -X POST "$API_URL/api/v1/ai/summarize" \
  -H "Content-Type: application/json" \
  -d '{"input":"AI 요약 테스트","instructions":"요약해주세요"}' \
  | jq .

echo -e "\n================================================"
echo "All tests completed!"

```

### tsconfig.json

**Path:** `workers/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "WebWorker"],
    "module": "ES2022",
    "moduleResolution": "bundler",
    "types": ["@cloudflare/workers-types"],
    "resolveJsonModule": true,
    "allowJs": true,
    "checkJs": false,
    "jsx": "react",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noUncheckedIndexedAccess": true,
    "noEmit": true,
    "isolatedModules": true,
    "allowSyntheticDefaultImports": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist", ".wrangler"]
}

```

### worker-configuration.d.ts

**Path:** `workers/worker-configuration.d.ts`

```typescript
// Generated by Wrangler by running `wrangler types`

interface Env {
	KV: KVNamespace;
	ENV: "development" | "production";
	ALLOWED_ORIGINS: "http://localhost:5173,http://localhost:4173,http://localhost:8080,http://localhost:8081,https://noblog.nodove.com,https://blog.nodove.com,https://blog-test.nodove.com" | "https://noblog.nodove.com,https://blog.nodove.com,https://blog-test.nodove.com";
	ASSETS_BASE_URL: "https://assets-b.nodove.com";
	API_BASE_URL: "https://api.nodove.com";
	R2: R2Bucket;
	DB: D1Database;
}

```

### wrangler.toml

**Path:** `workers/wrangler.toml`

```toml
#:schema node_modules/wrangler/config-schema.json
name = "blog-api"
main = "src/index.ts"
compatibility_date = "2024-09-01"
compatibility_flags = ["nodejs_compat"]
account_id = "f6f11e2a4e5178d2f37476785018f761"

# Secrets (set via wrangler secret put):
# - GEMINI_API_KEY: Google Gemini API key for AI features
# - JWT_SECRET: Secret key for JWT token signing
# - ADMIN_USERNAME: Admin username (optional)
# - ADMIN_PASSWORD: Admin password hash (optional)
# - OPENROUTER_API_KEY: OpenRouter API key for vision fallback (optional)
# - AI_SERVE_API_KEY: Internal API key for self-hosted AI server (optional)
#
# Set secrets with: npx wrangler secret put <SECRET_NAME> [--env production]

# Development environment variables
[vars]
ENV = "development"
ALLOWED_ORIGINS = "http://localhost:5173,http://localhost:4173,http://localhost:8080,http://localhost:8081,https://noblog.nodove.com,https://blog.nodove.com,https://blog-test.nodove.com"
ASSETS_BASE_URL = "https://assets-b.nodove.com"
# Backend API via Cloudflare Tunnel
API_BASE_URL = "https://api.nodove.com"
# AI Agent Configuration for gateway routes
# Mode: 'backend' (self-hosted), 'external' (direct API), 'auto' (backend first with fallback)
# These can be overridden at runtime via KV: config:ai_agent_mode, config:ai_agent_backend_url
# AI_AGENT_MODE = "backend"
# AI_AGENT_BACKEND_URL = "https://api.nodove.com"

# D1 Database binding (development)
[[d1_databases]]
binding = "DB"
database_name = "blog-db"
database_id = "65661464-f6e2-4cdf-8da8-dd63a482fd29"

# R2 Storage binding (development)
# [[r2_buckets]]
# binding = "R2"
# bucket_name = "blog-assets-dev"
# preview_bucket_name = "blog-assets-dev"

[[r2_buckets]]
binding = "R2"
bucket_name = "blog"

# KV namespace binding (development)
[[kv_namespaces]]
binding = "KV"
id = "8bb28b36c3cb42da8ed7aca89f8cf0fe"

# Cron triggers for scheduled tasks (daily at 6 AM UTC)
[triggers]
crons = ["0 6 * * *"]

# Production environment
[env.production]
name = "blog-api-prod"

[env.production.vars]
ENV = "production"
ALLOWED_ORIGINS = "https://noblog.nodove.com,https://blog.nodove.com,https://blog-test.nodove.com"
# Backend API via Cloudflare Tunnel
API_BASE_URL = "https://api.nodove.com"

[[env.production.d1_databases]]
binding = "DB"
database_name = "blog-db-prod"
database_id = "e547f944-71a0-42b6-8af1-abc50f29df80"

# [[env.production.r2_buckets]]
# binding = "R2"
# bucket_name = "blog-assets-prod"

[[env.production.r2_buckets]]
binding = "R2"
bucket_name = "blog"

[[env.production.kv_namespaces]]
binding = "KV"
id = "3d45140577d94404bc5f4bf000b07488"

# Observability (optional)
[observability]
enabled = true

```

---

## workers/ai-check-gateway

### .gitignore

**Path:** `workers/ai-check-gateway/.gitignore`

```gitignore
./ai-serve.nodove.com
```

### package.json

**Path:** `workers/ai-check-gateway/package.json`

```json
{
  "name": "ai-check-gateway",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "jose": "^5.9.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20241127.0",
    "typescript": "^5.7.2",
    "wrangler": "^3.94.0"
  }
}

```

### tsconfig.json

**Path:** `workers/ai-check-gateway/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "types": ["@cloudflare/workers-types"],
    "skipLibCheck": true,
    "noEmit": true
  },
  "include": ["src/**/*"]
}

```

### wrangler.toml

**Path:** `workers/ai-check-gateway/wrangler.toml`

```toml
name = "ai-check-gateway"
main = "src/index.ts"
compatibility_date = "2025-10-22"
compatibility_flags = ["nodejs_compat"]
account_id = "f6f11e2a4e5178d2f37476785018f761"

# Service binding to dedicated R2 gateway worker
services = [
  { binding = "R2_GATEWAY", service = "r2-gateway" }
]

# Optional runtime configuration for authentication
[vars]
AUTH_JWKS_URL = ""
AUTH_AUDIENCE = ""
AUTH_ISSUER = ""
AUTH_JWT_SECRET = ""
AUTH_CACHE_TTL_SECONDS = "300"
# Allowed origins for local development
ALLOWED_ORIGINS = "http://localhost:5173,http://localhost:4173,http://localhost:8080,http://localhost:8081"

# Secrets (set via Wrangler):
# wrangler secret put SECRET_API_KEY
# wrangler secret put SECRET_INTERNAL_KEY

[env.production]
name = "ai-check-gateway"
services = [
  { binding = "R2_GATEWAY", service = "r2-gateway", environment = "production" }
]

[env.production.vars]
# Comma-separated list of allowed origins
ALLOWED_ORIGINS = "https://noblog.nodove.com,https://blog.nodove.com,http://localhost:5173,http://localhost:4173,http://localhost:8080,http://localhost:8081"
# Backend host to forward to
REAL_BACKEND_HOST = "ai-serve.nodove.com"
AUTH_JWKS_URL = ""
AUTH_AUDIENCE = ""
AUTH_ISSUER = ""
AUTH_JWT_SECRET = ""
AUTH_CACHE_TTL_SECONDS = "300"

[[env.production.routes]]
pattern = "ai-check.nodove.com/*"
zone_name = "nodove.com"

```

---

## workers/ai-check-gateway/src

### index.ts

**Path:** `workers/ai-check-gateway/src/index.ts`

```typescript
// workers/ai-check-gateway/src/index.ts

import { createRemoteJWKSet, jwtVerify } from 'jose';
import { z } from 'zod';

type Env = {
  ALLOWED_ORIGINS?: string;
  REAL_BACKEND_HOST: string;
  SECRET_INTERNAL_KEY: string;
  SECRET_CALLER_KEY?: string;
  GITHUB_TOKEN?: string;
  R2_GATEWAY: Fetcher;
  AUTH_JWT_SECRET?: string;
  AUTH_JWKS_URL?: string;
  AUTH_AUDIENCE?: string;
  AUTH_ISSUER?: string;
  AUTH_CACHE_TTL_SECONDS?: string;
};

const JSON_CONTENT_TYPE = { 'Content-Type': 'application/json' } as const;
const MAX_PAGE_SIZE = 100;
const DEFAULT_CACHE_TTL_SECONDS = 300;
const INTERNAL_CALLER_HEADER = 'X-Gateway-Caller-Key';

type R2GatewayListResponse = {
  ok: boolean;
  cursor: string | null;
  truncated: boolean;
  objects: Array<{
    key: string;
    size: number;
    httpEtag: string | null;
    uploaded: string | null;
  }>;
  delimitedPrefixes: string[];
};

type GatewayFetchOptions = {
  method?: string;
  headers?: HeadersInit;
  body?: BodyInit | null;
  searchParams?: Record<string, string | undefined>;
};

function normalizeEtag(value?: string | null) {
  return value?.replace(/"/g, '') ?? null;
}

/**
 * Build a relative URL for Service Binding fetch.
 * Service Bindings ignore the host, so we use a dummy base URL
 * and extract the pathname + search params.
 */
function buildGatewayPath(path: string, searchParams?: Record<string, string | undefined>): string {
  // Ensure path starts with /
  const normalizedPath = path.startsWith('/') ? path : `/${path}`;
  
  if (!searchParams) {
    return normalizedPath;
  }
  
  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(searchParams)) {
    if (value !== undefined && value !== null) {
      params.set(key, value);
    }
  }
  
  const queryString = params.toString();
  return queryString ? `${normalizedPath}?${queryString}` : normalizedPath;
}

async function gatewayFetch(env: Env, path: string, options: GatewayFetchOptions = {}) {
  const { method = 'GET', headers: initHeaders, body, searchParams } = options;
  const headers = new Headers(initHeaders);
  if (!env.SECRET_CALLER_KEY) {
    throw new Error('SECRET_CALLER_KEY is required for R2 gateway access');
  }
  headers.set(INTERNAL_CALLER_HEADER, env.SECRET_CALLER_KEY);

  // Build path with query params for Service Binding
  const requestPath = buildGatewayPath(path, searchParams);
  
  // Service Binding fetch - use Request object with relative-like URL
  // The host is ignored, only pathname matters
  const request = new Request(`https://r2-gateway.workers.dev${requestPath}`, {
    method,
    headers,
    body,
  });
  
  return env.R2_GATEWAY.fetch(request);
}

async function parseJsonSafe<T>(response: Response): Promise<T | null> {
  try {
    return (await response.json()) as T;
  } catch {
    return null;
  }
}

async function gatewayErrorResponse(response: Response, fallbackMessage: string, fallbackCode = 'STORAGE_ERROR') {
  const payload = await parseJsonSafe<{ error?: string; code?: string }>(response);
  const message = payload?.error || fallbackMessage;
  const code = payload?.code || fallbackCode;
  const error = code ? { message, code } : { message };
  return makeResponse({ ok: false, error }, { status: response.status });
}

function internalPath(kind: 'memos' | 'personas', userId: string, id?: string) {
  const segments = ['internal', kind, encodeURIComponent(userId)];
  if (id) segments.push(encodeURIComponent(id));
  return segments.join('/');
}

async function fetchGatewayObject<T = Record<string, unknown>>(
  env: Env,
  kind: 'memos' | 'personas',
  userId: string,
  id: string
): Promise<{ data: T; etag: string | null } | null> {
  const response = await gatewayFetch(env, internalPath(kind, userId, id), {
    method: 'GET',
    headers: { Accept: 'application/json' },
  });
  if (response.status === 404) {
    return null;
  }
  if (!response.ok) {
    throw new Error(`Failed to fetch object: ${response.status}`);
  }
  const data = await parseJsonSafe<T>(response);
  if (!data) {
    throw new Error('Invalid JSON payload from R2 gateway');
  }
  return {
    data,
    etag: normalizeEtag(response.headers.get('ETag')),
  };
}

const memoSchema = z.object({
  id: z.string().optional(),
  userNote: z.string().optional().default(''),
  originalContent: z.string().min(1),
  tags: z.array(z.string()).optional().default([]),
  source: z
    .object({
      conversationId: z.string().min(1),
      messageId: z.string().min(1),
      conversationTitle: z.string().optional(),
    })
    .optional(),
});

const personaSchema = z.object({
  id: z.string().optional(),
  name: z.string().min(1).max(120),
  prompt: z.string().min(10).max(4000),
  tags: z.array(z.string()).optional().default([]),
});

type ApiEnvelope<T> = {
  ok: boolean;
  data?: T;
  error?: { message: string; code?: string };
  cursor?: string | null;
  hasMore?: boolean;
};

function makeResponse<T>(body: ApiEnvelope<T>, init?: ResponseInit) {
  return new Response(JSON.stringify(body), {
    status: init?.status ?? 200,
    headers: { ...JSON_CONTENT_TYPE, ...(init?.headers || {}) },
  });
}

function applyCors(headers: Headers, origin: string, requestHeaders?: string | null) {
  headers.set('Access-Control-Allow-Origin', origin);
  headers.set('Vary', 'Origin, Access-Control-Request-Headers, Access-Control-Request-Method');
  headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  const incoming = (requestHeaders || '')
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);
  const base = ['Content-Type', 'Authorization', 'If-Match'];
  const merged = Array.from(new Set([...base, ...incoming])).join(', ');
  headers.set('Access-Control-Allow-Headers', merged);
  headers.set('Access-Control-Max-Age', '600');
}

async function verifyAuth(request: Request, env: Env): Promise<{ userId: string } | null> {
  const authHeader = request.headers.get('Authorization');
  if (!authHeader?.startsWith('Bearer ')) return null;
  const token = authHeader.substring('Bearer '.length).trim();
  if (!token) return null;

  const audience = env.AUTH_AUDIENCE?.split(',').map((v) => v.trim()).filter(Boolean);
  const issuer = env.AUTH_ISSUER;

  try {
    if (env.AUTH_JWKS_URL) {
      const cacheTtl = parseInt(env.AUTH_CACHE_TTL_SECONDS || '', 10);
      const ttl = Number.isFinite(cacheTtl) && cacheTtl > 0 ? cacheTtl : DEFAULT_CACHE_TTL_SECONDS;
      const JWKS = createRemoteJWKSet(new URL(env.AUTH_JWKS_URL), {
        cacheMaxAge: ttl * 1000,
      });
      const { payload } = await jwtVerify(token, JWKS, {
        audience,
        issuer,
      });
      const sub = payload.sub;
      if (typeof sub !== 'string' || !sub) return null;
      return { userId: sub };
    }

    if (env.AUTH_JWT_SECRET) {
      const encoder = new TextEncoder();
      const { payload } = await jwtVerify(token, encoder.encode(env.AUTH_JWT_SECRET), {
        audience,
        issuer,
      });
      const sub = payload.sub;
      if (typeof sub !== 'string' || !sub) return null;
      return { userId: sub };
    }
  } catch (err) {
    console.warn('JWT verification failed', err instanceof Error ? err.message : err);
    return null;
  }

  return null;
}

function extractIfMatch(request: Request) {
  const header = request.headers.get('If-Match');
  return header ? header.replace(/^"|"$/g, '') : undefined;
}

async function handleList(env: Env, userId: string, kind: 'memos' | 'personas', cursor?: string | null) {
  const response = await gatewayFetch(env, internalPath(kind, userId), {
    searchParams: {
      cursor: cursor || undefined,
      limit: String(MAX_PAGE_SIZE),
    },
    headers: { Accept: 'application/json' },
  });

  if (!response.ok) {
    return gatewayErrorResponse(response, 'Failed to list objects');
  }

  const payload = await parseJsonSafe<R2GatewayListResponse>(response);
  if (!payload?.ok) {
    return makeResponse({ ok: false, error: { message: 'Invalid gateway response' } }, { status: 502 });
  }

  const items = await Promise.all(
    payload.objects.map(async (obj) => {
      const objectId = obj.key.split('/').pop()?.replace(/\.json$/i, '');
      if (!objectId) return null;
      try {
        const gatewayObject = await fetchGatewayObject<Record<string, unknown>>(env, kind, userId, objectId);
        if (!gatewayObject) return null;
        const data = gatewayObject.data;
        return {
          ...data,
          id: typeof data.id === 'string' ? data.id : objectId,
          etag: gatewayObject.etag,
          createdAt:
            typeof data.createdAt === 'string'
              ? data.createdAt
              : obj.uploaded ?? new Date().toISOString(),
          updatedAt: typeof data.updatedAt === 'string' ? data.updatedAt : undefined,
        };
      } catch (err) {
        console.error('Failed to fetch object from gateway', err);
        return null;
      }
    })
  );

  return makeResponse({
    ok: true,
    data: items.filter(Boolean),
    cursor: payload.cursor,
    hasMore: !!payload.cursor,
  });
}

async function handleGet(env: Env, userId: string, kind: 'memos' | 'personas', id: string) {
  const gatewayObject = await fetchGatewayObject<Record<string, unknown>>(env, kind, userId, id);
  if (!gatewayObject) {
    return makeResponse({ ok: false, error: { message: 'Not found', code: 'NOT_FOUND' } }, { status: 404 });
  }
  const payload = gatewayObject.data;
  return makeResponse({
    ok: true,
    data: {
      ...payload,
      id,
      etag: gatewayObject.etag,
    },
  });
}

async function handlePut(
  env: Env,
  userId: string,
  kind: 'memos' | 'personas',
  id: string,
  payload: z.infer<typeof memoSchema> | z.infer<typeof personaSchema>,
  ifMatch?: string
) {
  const now = new Date().toISOString();

  let createdAt = now;
  let existingEtag: string | null = null;
  let existingData: Record<string, unknown> | null = null;
  try {
    const existing = await fetchGatewayObject<Record<string, unknown>>(env, kind, userId, id);
    if (existing) {
      existingEtag = existing.etag;
      existingData = existing.data;
      if (typeof existing.data?.createdAt === 'string') {
        createdAt = existing.data.createdAt;
      }
    }
  } catch (err) {
    console.error('Failed to read existing object from gateway', err);
    return makeResponse({ ok: false, error: { message: 'Storage error' } }, { status: 502 });
  }

  if (ifMatch && existingEtag && existingEtag !== ifMatch) {
    return makeResponse(
      { ok: false, error: { message: 'ETag mismatch', code: 'PRECONDITION_FAILED' } },
      { status: 412 }
    );
  }
  if (ifMatch && !existingEtag) {
    return makeResponse(
      { ok: false, error: { message: 'Resource not found for provided ETag', code: 'PRECONDITION_FAILED' } },
      { status: 412 }
    );
  }

  const record: Record<string, unknown> = {
    ...payload,
    id,
    userId,
    createdAt,
    updatedAt: now,
  };

  try {
    const response = await gatewayFetch(env, internalPath(kind, userId, id), {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...(ifMatch ? { 'If-Match': ifMatch } : {}),
      },
      body: JSON.stringify(record),
    });

    if (!response.ok) {
      return gatewayErrorResponse(response, 'Failed to write object');
    }

    const writeResult = await parseJsonSafe<{ ok?: boolean; etag?: string | null }>(response);
    const etag = normalizeEtag(writeResult?.etag ?? response.headers.get('ETag'));
    return makeResponse(
      {
        ok: true,
        data: {
          ...record,
          etag,
        },
      },
      { status: existingData ? 200 : 201 }
    );
  } catch (err) {
    console.error('R2 put failed', err);
    return makeResponse({ ok: false, error: { message: 'Storage error' } }, { status: 502 });
  }
}

async function handleDelete(env: Env, userId: string, kind: 'memos' | 'personas', id: string, ifMatch?: string) {
  try {
    const response = await gatewayFetch(env, internalPath(kind, userId, id), {
      method: 'DELETE',
      headers: ifMatch ? { 'If-Match': ifMatch } : undefined,
    });

    if (response.status === 204) {
      return new Response(null, { status: 204 });
    }

    if (!response.ok) {
      return gatewayErrorResponse(response, 'Failed to delete object');
    }

    return new Response(await response.text(), { status: response.status, headers: response.headers });
  } catch (err) {
    console.error('R2 delete failed', err);
    return makeResponse({ ok: false, error: { message: 'Storage error' } }, { status: 502 });
  }
}

async function routeApi(request: Request, env: Env, userId: string) {
  const url = new URL(request.url);
  const path = url.pathname.replace(/^\/+/, ''); // remove leading slash
  const [, resource, id] = path.split('/'); // api/<resource>/<id?>
  const cursor = url.searchParams.get('cursor');

  if (resource === 'memos') {
    if (request.method === 'GET' && !id) return handleList(env, userId, 'memos', cursor);
    if (request.method === 'GET' && id) return handleGet(env, userId, 'memos', id);
    if (request.method === 'POST') {
      const parsed = memoSchema.parse(await request.json());
      const memoId = parsed.id || crypto.randomUUID();
      return handlePut(env, userId, 'memos', memoId, parsed);
    }
    if (request.method === 'PUT' && id) {
      const parsed = memoSchema.parse(await request.json());
      return handlePut(env, userId, 'memos', id, parsed, extractIfMatch(request));
    }
    if (request.method === 'DELETE' && id) {
      return handleDelete(env, userId, 'memos', id, extractIfMatch(request));
    }
  }

  if (resource === 'personas') {
    if (request.method === 'GET' && !id) return handleList(env, userId, 'personas', cursor);
    if (request.method === 'GET' && id) return handleGet(env, userId, 'personas', id);
    if (request.method === 'POST') {
      const parsed = personaSchema.parse(await request.json());
      const personaId = parsed.id || crypto.randomUUID();
      return handlePut(env, userId, 'personas', personaId, parsed);
    }
    if (request.method === 'PUT' && id) {
      const parsed = personaSchema.parse(await request.json());
      return handlePut(env, userId, 'personas', id, parsed, extractIfMatch(request));
    }
    if (request.method === 'DELETE' && id) {
      return handleDelete(env, userId, 'personas', id, extractIfMatch(request));
    }
  }

  return makeResponse({ ok: false, error: { message: 'Not Found', code: 'NOT_FOUND' } }, { status: 404 });
}

async function proxyToBackend(request: Request, env: Env) {
  const url = new URL(request.url);
  url.hostname = env.REAL_BACKEND_HOST;
  url.protocol = 'https:';

  const headers = new Headers(request.headers);
  headers.set('Host', env.REAL_BACKEND_HOST);
  headers.delete('X-API-KEY');
  headers.delete('X-Gateway-Caller-Key');
  headers.delete('X-Internal-Gateway-Key');
  headers.delete('Authorization');

  headers.set('X-Internal-Gateway-Key', env.SECRET_INTERNAL_KEY);
  headers.set('Authorization', `Bearer ${env.GITHUB_TOKEN}`);
  headers.set('X-Forwarded-Authorization', `Bearer ${env.GITHUB_TOKEN}`);

  const forwarded = new Request(url.toString(), {
    method: request.method,
    headers,
    body: ['GET', 'HEAD'].includes(request.method) ? undefined : await request.blob(),
    redirect: 'manual',
  });

  return fetch(forwarded);
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const origin = request.headers.get('Origin') || '';
    const callerKey = request.headers.get('X-Gateway-Caller-Key') || '';
    const allowed = (env.ALLOWED_ORIGINS || '')
      .split(',')
      .map((s) => s.trim())
      .filter(Boolean);
    const isBrowserAllowed = !!origin && (allowed.includes('*') || allowed.includes(origin));
    const isWorkerAllowed = !origin && !!env.SECRET_CALLER_KEY && callerKey === env.SECRET_CALLER_KEY;

    if (request.method === 'OPTIONS') {
      if (!isBrowserAllowed) {
        return makeResponse({ ok: false, error: { message: 'Forbidden: Invalid origin' } }, { status: 403 });
      }
      const res = new Response(null, { status: 204 });
      applyCors(res.headers, origin, request.headers.get('Access-Control-Request-Headers'));
      return res;
    }

    if (!(isBrowserAllowed || isWorkerAllowed)) {
      return makeResponse({ ok: false, error: { message: 'Forbidden: Invalid origin' } }, { status: 403 });
    }

    if (!env.SECRET_INTERNAL_KEY || !env.GITHUB_TOKEN) {
      const res = makeResponse({
        ok: false,
        error: { message: 'Server misconfiguration: missing required secrets', code: 'MISCONFIGURED' },
      }, { status: 500 });
      if (isBrowserAllowed && origin) {
        applyCors(res.headers, origin, request.headers.get('Access-Control-Request-Headers'));
      }
      return res;
    }

    const isApiRoute = request.url.includes('/api/memos') || request.url.includes('/api/personas');

    if (isApiRoute) {
      // Check R2 gateway configuration
      if (!env.SECRET_CALLER_KEY) {
        const res = makeResponse({
          ok: false,
          error: { message: 'Server misconfiguration: SECRET_CALLER_KEY not set for R2 gateway', code: 'MISCONFIGURED' },
        }, { status: 500 });
        if (isBrowserAllowed && origin) {
          applyCors(res.headers, origin, request.headers.get('Access-Control-Request-Headers'));
        }
        return res;
      }

      const auth = await verifyAuth(request, env);
      if (!auth?.userId) {
        const res = makeResponse({ ok: false, error: { message: 'Unauthorized' } }, { status: 401 });
        if (isBrowserAllowed && origin) {
          applyCors(res.headers, origin, request.headers.get('Access-Control-Request-Headers'));
        }
        return res;
      }

      try {
        const response = await routeApi(request, env, auth.userId);
        if (isBrowserAllowed && origin) {
          applyCors(response.headers, origin, request.headers.get('Access-Control-Request-Headers'));
        }
        return response;
      } catch (err) {
        console.error('API route error', err);
        const res = makeResponse({ ok: false, error: { message: 'Internal error' } }, { status: 500 });
        if (isBrowserAllowed && origin) {
          applyCors(res.headers, origin, request.headers.get('Access-Control-Request-Headers'));
        }
        return res;
      }
    }

    try {
      const backendRes = await proxyToBackend(request, env);
      const headers = new Headers(backendRes.headers);
      if (isBrowserAllowed && origin) {
        applyCors(headers, origin);
      }
      return new Response(backendRes.body, { status: backendRes.status, headers });
    } catch (err) {
      console.error('Proxy request failed', err);
      const res = makeResponse({ ok: false, error: { message: 'Upstream fetch failed' } }, { status: 502 });
      if (isBrowserAllowed && origin) {
        applyCors(res.headers, origin, request.headers.get('Access-Control-Request-Headers'));
      }
      return res;
    }
  },
};

```

---

## workers/db-api

### package.json

**Path:** `workers/db-api/package.json`

```json
{
  "name": "db-api",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "wrangler dev",
    "start": "wrangler dev --remote",
    "deploy": "wrangler deploy --env production"
  },
  "dependencies": {
    "hono": "^4.6.8"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20240925.0",
    "typescript": "^5.6.3",
    "wrangler": "^3.78.7"
  }
}

```

### tsconfig.json

**Path:** `workers/db-api/tsconfig.json`

```json
{
  "compilerOptions": {
    "types": ["@cloudflare/workers-types"],
    "module": "esnext",
    "target": "es2022",
    "moduleResolution": "bundler",
    "strict": true,
    "outDir": "dist"
  },
  "include": ["src/**/*"]
}

```

---

## workers/db-api/src

### index.ts

**Path:** `workers/db-api/src/index.ts`

```typescript
import { Hono } from 'hono'
import { cors } from 'hono/cors'

export type Bindings = {
  DB: D1Database
}

const app = new Hono<{ Bindings: Bindings }>()

app.use('*', cors())

app.get('/api/v1/healthz', (c) => {
  return c.json({ ok: true, env: 'production', ts: Date.now() })
})

app.get('/api/v1/posts', async (c) => {
  try {
    const { results } = await c.env.DB
      .prepare(
        `SELECT slug, title, description, date, year, tags, category
         FROM posts
         WHERE published = 1
         ORDER BY date DESC
         LIMIT 50`
      )
      .all()
    return c.json({ ok: true, items: results ?? [] })
  } catch (e) {
    const msg = (e as Error)?.message || 'Query failed'
    return c.json({ ok: false, error: msg }, 500)
  }
})

app.get('/api/v1/posts/:slug', async (c) => {
  const slug = c.req.param('slug')
  try {
    const { results } = await c.env.DB
      .prepare(
        `SELECT slug, title, description, date, year, tags, category, content
         FROM posts WHERE slug = ? LIMIT 1`
      )
      .bind(slug)
      .all()
    const item = results?.[0]
    if (!item) return c.json({ ok: false, error: 'Not Found' }, 404)
    return c.json({ ok: true, item })
  } catch (e) {
    const msg = (e as Error)?.message || 'Query failed'
    return c.json({ ok: false, error: msg }, 500)
  }
})

export default app

```

---

## workers/migrations

### 0001_init.sql

**Path:** `workers/migrations/0001_init.sql`

```sql
-- Initial schema for blog database
-- Enable foreign keys
PRAGMA foreign_keys = ON;

-- Users table (admin accounts)
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  username TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Posts table
CREATE TABLE IF NOT EXISTS posts (
  id TEXT PRIMARY KEY,
  slug TEXT NOT NULL UNIQUE,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  excerpt TEXT,
  cover_image_url TEXT,
  status TEXT NOT NULL DEFAULT 'published' CHECK(status IN ('draft', 'published')),
  author_id TEXT NOT NULL,
  published_at TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY(author_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Tags table
CREATE TABLE IF NOT EXISTS tags (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL UNIQUE
);

-- Post-Tags junction table (many-to-many)
CREATE TABLE IF NOT EXISTS post_tags (
  post_id TEXT NOT NULL,
  tag_id INTEGER NOT NULL,
  PRIMARY KEY (post_id, tag_id),
  FOREIGN KEY(post_id) REFERENCES posts(id) ON DELETE CASCADE,
  FOREIGN KEY(tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

-- Comments table
CREATE TABLE IF NOT EXISTS comments (
  id TEXT PRIMARY KEY,
  post_id TEXT NOT NULL,
  author TEXT NOT NULL,
  email TEXT,
  content TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'visible' CHECK(status IN ('visible', 'hidden', 'pending')),
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY(post_id) REFERENCES posts(id) ON DELETE CASCADE
);

-- Attachments table (R2 file metadata)
CREATE TABLE IF NOT EXISTS attachments (
  id TEXT PRIMARY KEY,
  post_id TEXT NOT NULL,
  url TEXT NOT NULL,
  r2_key TEXT NOT NULL,
  content_type TEXT,
  size_bytes INTEGER,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY(post_id) REFERENCES posts(id) ON DELETE CASCADE
);

-- Settings table (key-value store for config)
CREATE TABLE IF NOT EXISTS settings (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_posts_status ON posts(status);
CREATE INDEX IF NOT EXISTS idx_posts_slug ON posts(slug);
CREATE INDEX IF NOT EXISTS idx_comments_post_id ON comments(post_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_comments_status ON comments(status);
CREATE INDEX IF NOT EXISTS idx_post_tags_post_id ON post_tags(post_id);
CREATE INDEX IF NOT EXISTS idx_post_tags_tag_id ON post_tags(tag_id);

```

### 0002_seed_admin.sql

**Path:** `workers/migrations/0002_seed_admin.sql`

```sql
-- Seed initial admin user
-- Note: Password hash should be updated with actual bcrypt/argon2 hash in production
-- This is just a placeholder for the migration structure

-- INSERT INTO users(id, username, password_hash, created_at, updated_at)
-- VALUES (
--   'admin-' || lower(hex(randomblob(8))),
--   'admin',
--   '$2a$10$placeholder.hash.will.be.replaced',
--   datetime('now'),
--   datetime('now')
-- );

-- To be populated via admin setup script or manual insert

```

### 0003_comments_drop_fk.sql

**Path:** `workers/migrations/0003_comments_drop_fk.sql`

```sql
-- Drop foreign key on comments.post_id by recreating table without FK
-- This migration preserves data and indexes

PRAGMA foreign_keys = OFF;

-- Create new table without FK constraint
CREATE TABLE IF NOT EXISTS comments_new (
  id TEXT PRIMARY KEY,
  post_id TEXT NOT NULL,
  author TEXT NOT NULL,
  email TEXT,
  content TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'visible' CHECK(status IN ('visible', 'hidden', 'pending')),
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Copy data from old table
INSERT INTO comments_new (id, post_id, author, email, content, status, created_at, updated_at)
SELECT id, post_id, author, email, content, status, created_at, updated_at FROM comments;

-- Replace old table
DROP TABLE comments;
ALTER TABLE comments_new RENAME TO comments;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_comments_post_id ON comments(post_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_comments_status ON comments(status);

PRAGMA foreign_keys = ON;

```

### 0004_post_analytics.sql

**Path:** `workers/migrations/0004_post_analytics.sql`

```sql
-- Post analytics and editor picks tables
-- Tracks view counts and manages automatically curated editor picks

-- Post views tracking table
CREATE TABLE IF NOT EXISTS post_views (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  post_slug TEXT NOT NULL,
  year TEXT NOT NULL,
  view_date TEXT NOT NULL DEFAULT (date('now')),
  view_count INTEGER NOT NULL DEFAULT 1,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  UNIQUE(post_slug, year, view_date)
);

-- Aggregated post stats for quick lookups
CREATE TABLE IF NOT EXISTS post_stats (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  post_slug TEXT NOT NULL,
  year TEXT NOT NULL,
  total_views INTEGER NOT NULL DEFAULT 0,
  views_7d INTEGER NOT NULL DEFAULT 0,
  views_30d INTEGER NOT NULL DEFAULT 0,
  last_viewed_at TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  UNIQUE(post_slug, year)
);

-- Editor picks table (auto-updated daily)
CREATE TABLE IF NOT EXISTS editor_picks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  post_slug TEXT NOT NULL,
  year TEXT NOT NULL,
  title TEXT NOT NULL,
  cover_image TEXT,
  category TEXT,
  rank INTEGER NOT NULL DEFAULT 0,
  score REAL NOT NULL DEFAULT 0,
  reason TEXT,
  picked_at TEXT NOT NULL DEFAULT (datetime('now')),
  expires_at TEXT,
  is_active INTEGER NOT NULL DEFAULT 1,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  UNIQUE(post_slug, year)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_post_views_slug_year ON post_views(post_slug, year);
CREATE INDEX IF NOT EXISTS idx_post_views_date ON post_views(view_date DESC);
CREATE INDEX IF NOT EXISTS idx_post_stats_slug_year ON post_stats(post_slug, year);
CREATE INDEX IF NOT EXISTS idx_post_stats_total_views ON post_stats(total_views DESC);
CREATE INDEX IF NOT EXISTS idx_post_stats_views_7d ON post_stats(views_7d DESC);
CREATE INDEX IF NOT EXISTS idx_editor_picks_active ON editor_picks(is_active, rank);
CREATE INDEX IF NOT EXISTS idx_editor_picks_expires ON editor_picks(expires_at);

```

### 0005_translation_cache.sql

**Path:** `workers/migrations/0005_translation_cache.sql`

```sql
-- AI Translation cache table
-- Stores cached translations to avoid repeated API calls

CREATE TABLE IF NOT EXISTS post_translations_cache (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  post_slug TEXT NOT NULL,
  year TEXT NOT NULL,
  source_lang TEXT NOT NULL,
  target_lang TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  content TEXT NOT NULL,
  content_hash TEXT NOT NULL,
  is_ai_generated INTEGER NOT NULL DEFAULT 1,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  UNIQUE(post_slug, year, target_lang)
);

-- Indexes for quick lookups
CREATE INDEX IF NOT EXISTS idx_translations_cache_lookup 
  ON post_translations_cache(post_slug, year, target_lang);
CREATE INDEX IF NOT EXISTS idx_translations_cache_hash 
  ON post_translations_cache(content_hash);

```

### 0006_user_content.sql

**Path:** `workers/migrations/0006_user_content.sql`

```sql
-- User content tables: Personas and Memos
-- Stores user-created personas for AI interactions and saved memos

-- Personas table
CREATE TABLE IF NOT EXISTS personas (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  name TEXT NOT NULL,
  prompt TEXT NOT NULL,
  tags TEXT, -- JSON array of tags
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Memos table
CREATE TABLE IF NOT EXISTS memos (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  original_content TEXT NOT NULL,
  user_note TEXT,
  tags TEXT, -- JSON array of tags
  source TEXT, -- JSON object with url, title, postId, etc.
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_personas_user_id ON personas(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_memos_user_id ON memos(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_memos_created_at ON memos(created_at DESC);

```

### 0007_comment_reactions.sql

**Path:** `workers/migrations/0007_comment_reactions.sql`

```sql
-- Comment reactions/stickers table
-- Allows users to react to comments with emoji stickers

CREATE TABLE IF NOT EXISTS comment_reactions (
  id TEXT PRIMARY KEY,
  comment_id TEXT NOT NULL,
  emoji TEXT NOT NULL,
  user_fingerprint TEXT NOT NULL, -- Browser fingerprint for anonymous reaction tracking
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (comment_id) REFERENCES comments(id) ON DELETE CASCADE
);

-- Ensure one reaction type per user per comment
CREATE UNIQUE INDEX IF NOT EXISTS idx_comment_reactions_unique 
  ON comment_reactions(comment_id, emoji, user_fingerprint);

-- Index for fast reaction counts per comment
CREATE INDEX IF NOT EXISTS idx_comment_reactions_comment 
  ON comment_reactions(comment_id);

-- Index for cleanup queries
CREATE INDEX IF NOT EXISTS idx_comment_reactions_created 
  ON comment_reactions(created_at);

```

### 0008_memo_versions.sql

**Path:** `workers/migrations/0008_memo_versions.sql`

```sql
-- Memo versioning for history/restore functionality
-- Stores versions of memo content for undo/restore capabilities

-- Main memo content table (updated to track current version)
-- The existing 'memos' table stores individual clips/selections
-- This new table stores the full memo editor content with versioning
CREATE TABLE IF NOT EXISTS memo_content (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  content TEXT NOT NULL DEFAULT '',
  version INTEGER NOT NULL DEFAULT 1,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Memo version history table
CREATE TABLE IF NOT EXISTS memo_versions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  memo_id TEXT NOT NULL,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  version INTEGER NOT NULL,
  content TEXT NOT NULL,
  content_length INTEGER NOT NULL DEFAULT 0,
  change_summary TEXT, -- Brief description of what changed
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (memo_id) REFERENCES memo_content(id) ON DELETE CASCADE
);

-- Indexes for efficient queries
CREATE INDEX IF NOT EXISTS idx_memo_content_user_id ON memo_content(user_id);
CREATE INDEX IF NOT EXISTS idx_memo_versions_memo_id ON memo_versions(memo_id, version DESC);
CREATE INDEX IF NOT EXISTS idx_memo_versions_user_id ON memo_versions(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_memo_versions_created_at ON memo_versions(created_at DESC);

```

### 0009_user_memories.sql

**Path:** `workers/migrations/0009_user_memories.sql`

```sql
-- Migration: 0009_user_memories.sql
-- Purpose: User memory storage for AI chatbot context + chat session persistence

-- ========================================
-- User Memories Table
-- Stores extracted facts, preferences, and context from conversations
-- ========================================
CREATE TABLE IF NOT EXISTS user_memories (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  memory_type TEXT NOT NULL DEFAULT 'fact',  -- 'fact', 'preference', 'context', 'summary'
  category TEXT,  -- 'personal', 'technical', 'interest', 'goal', etc.
  content TEXT NOT NULL,
  source_type TEXT,  -- 'chat', 'memo', 'manual'
  source_id TEXT,  -- reference to chat_sessions.id or memos.id
  importance_score REAL DEFAULT 0.5,  -- 0.0 ~ 1.0, for retrieval ranking
  access_count INTEGER DEFAULT 0,
  last_accessed_at TEXT,
  expires_at TEXT,  -- optional TTL for temporary memories
  is_active INTEGER DEFAULT 1,  -- soft delete flag
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_user_memories_user_id ON user_memories(user_id, is_active, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_user_memories_type ON user_memories(user_id, memory_type, is_active);
CREATE INDEX IF NOT EXISTS idx_user_memories_category ON user_memories(user_id, category, is_active);
CREATE INDEX IF NOT EXISTS idx_user_memories_importance ON user_memories(user_id, importance_score DESC);
CREATE INDEX IF NOT EXISTS idx_user_memories_source ON user_memories(source_type, source_id);

-- ========================================
-- Chat Sessions Table
-- Stores persistent chat sessions for logged-in users
-- ========================================
CREATE TABLE IF NOT EXISTS chat_sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  title TEXT,  -- auto-generated or user-defined
  summary TEXT,  -- AI-generated summary of the conversation
  question_mode TEXT DEFAULT 'general',  -- 'general', 'article'
  article_slug TEXT,  -- if question_mode is 'article'
  message_count INTEGER DEFAULT 0,
  total_tokens INTEGER DEFAULT 0,
  is_archived INTEGER DEFAULT 0,
  is_deleted INTEGER DEFAULT 0,
  last_message_at TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_chat_sessions_user_id ON chat_sessions(user_id, is_deleted, last_message_at DESC);
CREATE INDEX IF NOT EXISTS idx_chat_sessions_article ON chat_sessions(article_slug, is_deleted);

-- ========================================
-- Chat Messages Table
-- Stores individual messages in chat sessions
-- ========================================
CREATE TABLE IF NOT EXISTS chat_messages (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  role TEXT NOT NULL,  -- 'user', 'assistant', 'system'
  content TEXT NOT NULL,
  content_type TEXT DEFAULT 'text',  -- 'text', 'image', 'code', 'error'
  metadata TEXT,  -- JSON: { sources, followups, images, tokens, etc. }
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY (session_id) REFERENCES chat_sessions(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_chat_messages_session ON chat_messages(session_id, created_at ASC);
CREATE INDEX IF NOT EXISTS idx_chat_messages_user ON chat_messages(user_id, created_at DESC);

-- ========================================
-- Memory Embeddings Table (optional, for local vector search)
-- Stores pre-computed embeddings for faster similarity search
-- ========================================
CREATE TABLE IF NOT EXISTS memory_embeddings (
  id TEXT PRIMARY KEY,
  memory_id TEXT NOT NULL UNIQUE,
  embedding_model TEXT NOT NULL DEFAULT 'all-MiniLM-L6-v2',
  embedding_dim INTEGER NOT NULL DEFAULT 384,
  embedding_blob BLOB,  -- serialized float32 array
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY (memory_id) REFERENCES user_memories(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_memory_embeddings_memory ON memory_embeddings(memory_id);

```

### 0010_config_management.sql

**Path:** `workers/migrations/0010_config_management.sql`

```sql
-- Config management schema for web-based environment variable UI
-- Uses existing settings table pattern with enhanced structure

-- Config categories for grouping variables
CREATE TABLE IF NOT EXISTS config_categories (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  display_order INTEGER NOT NULL DEFAULT 0,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Config variables with type information and validation
CREATE TABLE IF NOT EXISTS config_variables (
  id TEXT PRIMARY KEY,
  category_id TEXT NOT NULL,
  key TEXT NOT NULL UNIQUE,
  value TEXT,
  default_value TEXT,
  type TEXT NOT NULL DEFAULT 'text' CHECK(type IN ('text', 'number', 'boolean', 'select', 'password', 'url', 'textarea')),
  options TEXT, -- JSON array for select type
  is_secret INTEGER NOT NULL DEFAULT 0,
  is_required INTEGER NOT NULL DEFAULT 0,
  validation_regex TEXT,
  description TEXT,
  display_order INTEGER NOT NULL DEFAULT 0,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY(category_id) REFERENCES config_categories(id) ON DELETE CASCADE
);

-- Config change audit log
CREATE TABLE IF NOT EXISTS config_audit_log (
  id TEXT PRIMARY KEY,
  variable_key TEXT NOT NULL,
  old_value TEXT,
  new_value TEXT,
  changed_by TEXT,
  changed_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_config_variables_category ON config_variables(category_id);
CREATE INDEX IF NOT EXISTS idx_config_variables_key ON config_variables(key);
CREATE INDEX IF NOT EXISTS idx_config_audit_log_key ON config_audit_log(variable_key, changed_at DESC);

-- Seed default categories
INSERT OR IGNORE INTO config_categories (id, name, description, display_order) VALUES
  ('app', 'Application', '서버 기본 설정', 1),
  ('cors', 'CORS & URLs', 'CORS 허용 도메인 및 URL 설정', 2),
  ('ai', 'AI Services', 'AI 모델 및 VAS 서비스 설정', 3),
  ('cloudflare', 'Cloudflare', 'D1, R2, Workers 설정', 4),
  ('github', 'GitHub', 'GitHub 통합 설정', 5),
  ('rag', 'RAG Services', 'TEI, ChromaDB 설정', 6),
  ('auth', 'Authentication', '인증 및 보안 설정', 7);

-- Seed default variables (without values - populated from current env)
INSERT OR IGNORE INTO config_variables (id, category_id, key, type, default_value, is_secret, description, display_order) VALUES
  -- App category
  ('v_app_env', 'app', 'APP_ENV', 'select', 'development', 0, '실행 환경', 1),
  ('v_host', 'app', 'HOST', 'text', '0.0.0.0', 0, '서버 호스트', 2),
  ('v_port', 'app', 'PORT', 'number', '5080', 0, '서버 포트', 3),
  ('v_log_level', 'app', 'LOG_LEVEL', 'select', 'info', 0, '로그 레벨', 4),
  ('v_trust_proxy', 'app', 'TRUST_PROXY', 'number', '1', 0, 'Proxy 신뢰 레벨', 5),
  
  -- CORS category
  ('v_allowed_origins', 'cors', 'ALLOWED_ORIGINS', 'textarea', 'http://localhost:5173', 0, 'CORS 허용 도메인 (쉼표 구분)', 1),
  ('v_api_base_url', 'cors', 'API_BASE_URL', 'url', 'http://localhost:5080', 0, 'API 기본 URL', 2),
  ('v_site_base_url', 'cors', 'SITE_BASE_URL', 'url', 'https://noblog.nodove.com', 0, '사이트 기본 URL', 3),
  
  -- AI category
  ('v_ai_serve_base_url', 'ai', 'AI_SERVE_BASE_URL', 'url', 'http://vas-proxy:7016', 0, 'VAS Proxy URL', 1),
  ('v_vas_core_url', 'ai', 'VAS_CORE_URL', 'url', 'http://vas-core:7012', 0, 'VAS Core URL', 2),
  ('v_ai_default_provider', 'ai', 'AI_SERVE_DEFAULT_PROVIDER', 'select', 'github-copilot', 0, '기본 AI 제공자', 3),
  ('v_ai_default_model', 'ai', 'AI_SERVE_DEFAULT_MODEL', 'text', 'gpt-4.1', 0, '기본 AI 모델', 4),
  ('v_gemini_api_key', 'ai', 'GEMINI_API_KEY', 'password', NULL, 1, 'Gemini API Key', 5),
  ('v_openrouter_api_key', 'ai', 'OPENROUTER_API_KEY', 'password', NULL, 1, 'OpenRouter API Key', 6),
  
  -- Cloudflare category
  ('v_cf_account_id', 'cloudflare', 'CF_ACCOUNT_ID', 'text', NULL, 0, 'Cloudflare Account ID', 1),
  ('v_cf_api_token', 'cloudflare', 'CF_API_TOKEN', 'password', NULL, 1, 'Cloudflare API Token', 2),
  ('v_d1_database_id', 'cloudflare', 'D1_DATABASE_ID', 'text', NULL, 0, 'D1 Database ID', 3),
  ('v_r2_bucket_name', 'cloudflare', 'R2_BUCKET_NAME', 'text', 'blog', 0, 'R2 Bucket 이름', 4),
  ('v_r2_assets_base_url', 'cloudflare', 'R2_ASSETS_BASE_URL', 'url', 'https://assets-b.nodove.com', 0, 'R2 Assets URL', 5),
  
  -- GitHub category
  ('v_github_token', 'github', 'GITHUB_TOKEN', 'password', NULL, 1, 'GitHub Personal Access Token', 1),
  ('v_github_owner', 'github', 'GITHUB_REPO_OWNER', 'text', NULL, 0, 'GitHub Repo Owner', 2),
  ('v_github_repo', 'github', 'GITHUB_REPO_NAME', 'text', NULL, 0, 'GitHub Repo Name', 3),
  ('v_git_user_name', 'github', 'GIT_USER_NAME', 'text', NULL, 0, 'Git User Name', 4),
  ('v_git_user_email', 'github', 'GIT_USER_EMAIL', 'text', NULL, 0, 'Git User Email', 5),
  
  -- RAG category
  ('v_tei_url', 'rag', 'TEI_URL', 'url', 'http://embedding-server:80', 0, 'TEI Embedding Server URL', 1),
  ('v_chroma_url', 'rag', 'CHROMA_URL', 'url', 'http://chromadb:8000', 0, 'ChromaDB URL', 2),
  ('v_chroma_collection', 'rag', 'CHROMA_COLLECTION', 'text', 'blog-posts-all-MiniLM-L6-v2', 0, 'ChromaDB Collection', 3),
  
  -- Auth category
  ('v_admin_bearer_token', 'auth', 'ADMIN_BEARER_TOKEN', 'password', NULL, 1, 'Admin Bearer Token', 1),
  ('v_jwt_secret', 'auth', 'JWT_SECRET', 'password', NULL, 1, 'JWT Secret', 2),
  ('v_admin_username', 'auth', 'ADMIN_USERNAME', 'text', NULL, 0, 'Admin Username', 3),
  ('v_admin_password', 'auth', 'ADMIN_PASSWORD', 'password', NULL, 1, 'Admin Password', 4);

-- Update options for select types
UPDATE config_variables SET options = '["development","staging","production","test"]' WHERE key = 'APP_ENV';
UPDATE config_variables SET options = '["fatal","error","warn","info","debug","trace"]' WHERE key = 'LOG_LEVEL';
UPDATE config_variables SET options = '["github-copilot","gemini","openai","anthropic","local"]' WHERE key = 'AI_SERVE_DEFAULT_PROVIDER';

```

### 0011_ai_model_management.sql

**Path:** `workers/migrations/0011_ai_model_management.sql`

```sql
-- =============================================================================
-- AI Model Management System
-- Migration: 0011_ai_model_management.sql
-- =============================================================================

-- AI Provider 관리
CREATE TABLE IF NOT EXISTS ai_providers (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,              -- 'openai', 'anthropic', 'gemini', 'vas', 'ollama'
  display_name TEXT NOT NULL,             -- 'OpenAI', 'Anthropic Claude'
  api_base_url TEXT,                      -- Provider API URL (optional)
  api_key_env TEXT,                       -- 환경변수 이름 (보안: 실제 키 저장 안함)
  is_enabled INTEGER DEFAULT 1,
  health_status TEXT DEFAULT 'unknown',   -- 'healthy', 'degraded', 'down', 'unknown'
  last_health_check TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- AI 모델 관리
CREATE TABLE IF NOT EXISTS ai_models (
  id TEXT PRIMARY KEY,
  provider_id TEXT NOT NULL,
  model_name TEXT NOT NULL UNIQUE,        -- 'gpt-4.1' (LiteLLM에서 사용하는 이름)
  display_name TEXT NOT NULL,             -- 'GPT-4.1 (GitHub Copilot)'
  litellm_model TEXT NOT NULL,            -- 'openai/gpt-4.1' (실제 LiteLLM 모델명)
  description TEXT,
  context_window INTEGER,                 -- 128000
  max_tokens INTEGER,                     -- 4096
  input_cost_per_1k REAL,                 -- $0.01
  output_cost_per_1k REAL,                -- $0.03
  supports_vision INTEGER DEFAULT 0,
  supports_streaming INTEGER DEFAULT 1,
  supports_function_calling INTEGER DEFAULT 0,
  is_enabled INTEGER DEFAULT 1,
  priority INTEGER DEFAULT 0,             -- 높을수록 우선 사용
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (provider_id) REFERENCES ai_providers(id) ON DELETE CASCADE
);

-- 라우팅 규칙
CREATE TABLE IF NOT EXISTS ai_routes (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,              -- 'default', 'high-context', 'fast'
  description TEXT,
  routing_strategy TEXT DEFAULT 'latency-based-routing', -- 'simple', 'latency-based-routing', 'cost-based-routing'
  primary_model_id TEXT,
  fallback_model_ids TEXT,                -- JSON array of model IDs
  context_window_fallback_ids TEXT,       -- JSON array for long context
  num_retries INTEGER DEFAULT 3,
  timeout_seconds INTEGER DEFAULT 120,
  is_default INTEGER DEFAULT 0,
  is_enabled INTEGER DEFAULT 1,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (primary_model_id) REFERENCES ai_models(id) ON DELETE SET NULL
);

-- 사용량 로그 (개별 요청)
CREATE TABLE IF NOT EXISTS ai_usage_logs (
  id TEXT PRIMARY KEY,
  model_id TEXT,
  route_id TEXT,
  request_type TEXT,                      -- 'chat', 'completion', 'embedding', 'vision'
  prompt_tokens INTEGER,
  completion_tokens INTEGER,
  total_tokens INTEGER,
  estimated_cost REAL,
  latency_ms INTEGER,
  status TEXT,                            -- 'success', 'error', 'timeout'
  error_message TEXT,
  user_id TEXT,
  metadata TEXT,                          -- JSON for additional info
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (model_id) REFERENCES ai_models(id) ON DELETE SET NULL,
  FOREIGN KEY (route_id) REFERENCES ai_routes(id) ON DELETE SET NULL
);

-- 일별 사용량 집계
CREATE TABLE IF NOT EXISTS ai_usage_daily (
  date TEXT NOT NULL,
  model_id TEXT NOT NULL,
  total_requests INTEGER DEFAULT 0,
  total_prompt_tokens INTEGER DEFAULT 0,
  total_completion_tokens INTEGER DEFAULT 0,
  total_tokens INTEGER DEFAULT 0,
  total_cost REAL DEFAULT 0,
  success_count INTEGER DEFAULT 0,
  error_count INTEGER DEFAULT 0,
  avg_latency_ms REAL,
  PRIMARY KEY (date, model_id),
  FOREIGN KEY (model_id) REFERENCES ai_models(id) ON DELETE CASCADE
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_ai_models_provider ON ai_models(provider_id);
CREATE INDEX IF NOT EXISTS idx_ai_models_enabled ON ai_models(is_enabled);
CREATE INDEX IF NOT EXISTS idx_ai_usage_logs_created ON ai_usage_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_ai_usage_logs_model ON ai_usage_logs(model_id);
CREATE INDEX IF NOT EXISTS idx_ai_usage_daily_date ON ai_usage_daily(date);

```

### 0012_ai_model_seed.sql

**Path:** `workers/migrations/0012_ai_model_seed.sql`

```sql
-- =============================================================================
-- AI Model Management - Seed Data
-- Migration: 0012_ai_model_seed.sql
-- Based on: backend/litellm_config.yaml
-- =============================================================================

-- -----------------------------------------------------------------------------
-- Providers
-- -----------------------------------------------------------------------------
INSERT OR IGNORE INTO ai_providers (id, name, display_name, api_base_url, api_key_env) VALUES
  ('prov_vas', 'vas', 'GitHub Copilot (VAS)', 'http://vas-core:7012/v1', 'VAS_API_KEY'),
  ('prov_openai', 'openai', 'OpenAI', 'https://api.openai.com/v1', 'OPENAI_API_KEY'),
  ('prov_gemini', 'gemini', 'Google Gemini', NULL, 'GOOGLE_API_KEY'),
  ('prov_anthropic', 'anthropic', 'Anthropic Claude', 'https://api.anthropic.com', 'ANTHROPIC_API_KEY'),
  ('prov_ollama', 'ollama', 'Ollama (Local)', 'http://host.docker.internal:11434', NULL);

-- -----------------------------------------------------------------------------
-- Models - GitHub Copilot (VAS)
-- -----------------------------------------------------------------------------
INSERT OR IGNORE INTO ai_models (
  id, provider_id, model_name, display_name, litellm_model, description,
  context_window, max_tokens, input_cost_per_1k, output_cost_per_1k,
  supports_vision, supports_streaming, supports_function_calling, priority
) VALUES
  ('model_vas_gpt41', 'prov_vas', 'gpt-4.1', 'GPT-4.1 (GitHub Copilot)', 'openai/gpt-4.1',
   'GitHub Copilot GPT-4.1 via VAS - Primary model', 128000, 4096, 0.01, 0.03, 1, 1, 1, 100),

  ('model_vas_gpt4o', 'prov_vas', 'gpt-4o', 'GPT-4o (GitHub Copilot)', 'openai/gpt-4o',
   'GitHub Copilot GPT-4o via VAS', 128000, 4096, 0.005, 0.015, 1, 1, 1, 90),

  ('model_vas_claude', 'prov_vas', 'claude-sonnet-4', 'Claude Sonnet 4 (GitHub Copilot)', 'openai/claude-sonnet-4',
   'GitHub Copilot Claude Sonnet 4 via VAS', 200000, 4096, 0.003, 0.015, 1, 1, 1, 85);

-- -----------------------------------------------------------------------------
-- Models - OpenAI Direct
-- -----------------------------------------------------------------------------
INSERT OR IGNORE INTO ai_models (
  id, provider_id, model_name, display_name, litellm_model, description,
  context_window, max_tokens, input_cost_per_1k, output_cost_per_1k,
  supports_vision, supports_streaming, supports_function_calling, priority
) VALUES
  ('model_oai_gpt4o', 'prov_openai', 'openai/gpt-4o', 'GPT-4o (Direct)', 'gpt-4o',
   'OpenAI GPT-4o Direct', 128000, 4096, 0.005, 0.015, 1, 1, 1, 70),

  ('model_oai_gpt4t', 'prov_openai', 'openai/gpt-4-turbo', 'GPT-4 Turbo (Direct)', 'gpt-4-turbo',
   'OpenAI GPT-4 Turbo Direct', 128000, 4096, 0.01, 0.03, 1, 1, 1, 60),

  ('model_oai_gpt35', 'prov_openai', 'openai/gpt-3.5-turbo', 'GPT-3.5 Turbo (Direct)', 'gpt-3.5-turbo',
   'OpenAI GPT-3.5 Turbo Direct - Fast and cheap', 16385, 4096, 0.0005, 0.0015, 0, 1, 1, 50);

-- -----------------------------------------------------------------------------
-- Models - Google Gemini
-- -----------------------------------------------------------------------------
INSERT OR IGNORE INTO ai_models (
  id, provider_id, model_name, display_name, litellm_model, description,
  context_window, max_tokens, input_cost_per_1k, output_cost_per_1k,
  supports_vision, supports_streaming, supports_function_calling, priority
) VALUES
  ('model_gem_flash', 'prov_gemini', 'gemini-1.5-flash', 'Gemini 1.5 Flash', 'gemini/gemini-1.5-flash',
   'Google Gemini 1.5 Flash - Fast and cheap fallback', 1000000, 8192, 0.00035, 0.0014, 1, 1, 1, 80),

  ('model_gem_pro', 'prov_gemini', 'gemini-1.5-pro', 'Gemini 1.5 Pro', 'gemini/gemini-1.5-pro',
   'Google Gemini 1.5 Pro - Long context specialist', 1000000, 8192, 0.00125, 0.005, 1, 1, 1, 75),

  ('model_gem_flash2', 'prov_gemini', 'gemini-2.0-flash', 'Gemini 2.0 Flash', 'gemini/gemini-2.0-flash-exp',
   'Google Gemini 2.0 Flash Experimental', 1000000, 8192, 0.00035, 0.0014, 1, 1, 1, 78);

-- -----------------------------------------------------------------------------
-- Models - Anthropic Claude
-- -----------------------------------------------------------------------------
INSERT OR IGNORE INTO ai_models (
  id, provider_id, model_name, display_name, litellm_model, description,
  context_window, max_tokens, input_cost_per_1k, output_cost_per_1k,
  supports_vision, supports_streaming, supports_function_calling, priority
) VALUES
  ('model_ant_sonnet', 'prov_anthropic', 'claude-3.5-sonnet', 'Claude 3.5 Sonnet', 'claude-3-5-sonnet-20241022',
   'Anthropic Claude 3.5 Sonnet - Best balance', 200000, 4096, 0.003, 0.015, 1, 1, 1, 65),

  ('model_ant_opus', 'prov_anthropic', 'claude-3-opus', 'Claude 3 Opus', 'claude-3-opus-20240229',
   'Anthropic Claude 3 Opus - Most capable', 200000, 4096, 0.015, 0.075, 1, 1, 1, 55),

  ('model_ant_haiku', 'prov_anthropic', 'claude-3-haiku', 'Claude 3 Haiku', 'claude-3-haiku-20240307',
   'Anthropic Claude 3 Haiku - Fast and cheap', 200000, 4096, 0.00025, 0.00125, 1, 1, 1, 60);

-- -----------------------------------------------------------------------------
-- Models - Local (Ollama)
-- -----------------------------------------------------------------------------
INSERT OR IGNORE INTO ai_models (
  id, provider_id, model_name, display_name, litellm_model, description,
  context_window, max_tokens, input_cost_per_1k, output_cost_per_1k,
  supports_vision, supports_streaming, supports_function_calling, is_enabled, priority
) VALUES
  ('model_local_llama', 'prov_ollama', 'local/llama3', 'Llama 3 (Local)', 'ollama/llama3',
   'Local Llama 3 via Ollama - Development/testing', 8192, 2048, 0, 0, 0, 1, 0, 0, 10),

  ('model_local_code', 'prov_ollama', 'local/codellama', 'CodeLlama (Local)', 'ollama/codellama',
   'Local CodeLlama via Ollama - Code tasks', 16384, 2048, 0, 0, 0, 1, 0, 0, 10);

-- -----------------------------------------------------------------------------
-- Routes - Default routing configuration
-- -----------------------------------------------------------------------------
INSERT OR IGNORE INTO ai_routes (
  id, name, description, routing_strategy, primary_model_id,
  fallback_model_ids, context_window_fallback_ids, num_retries, timeout_seconds, is_default
) VALUES
  ('route_default', 'default', 'Default routing - GPT-4.1 primary with Gemini/Claude fallback',
   'latency-based-routing', 'model_vas_gpt41',
   '["model_gem_flash", "model_ant_haiku"]',
   '["model_gem_pro"]',
   3, 120, 1),

  ('route_fast', 'fast', 'Fast routing - Optimized for speed',
   'latency-based-routing', 'model_gem_flash',
   '["model_ant_haiku", "model_oai_gpt35"]',
   NULL,
   2, 60, 0),

  ('route_quality', 'quality', 'Quality routing - Best models first',
   'simple', 'model_vas_gpt4o',
   '["model_gem_pro", "model_ant_sonnet"]',
   '["model_gem_pro"]',
   3, 180, 0),

  ('route_long_context', 'long-context', 'Long context routing - For large documents',
   'simple', 'model_gem_pro',
   '["model_ant_sonnet", "model_vas_claude"]',
   NULL,
   2, 180, 0);

```

### 0013_agent_orchestration.sql

**Path:** `workers/migrations/0013_agent_orchestration.sql`

```sql
-- Migration: 0013_agent_orchestration.sql
-- Purpose: Agent orchestration layer tables for multi-turn conversations,
--          tool execution history, and enhanced memory management

-- ========================================
-- Agent Sessions Table
-- Stores agent conversation sessions with tool execution context
-- ========================================
CREATE TABLE IF NOT EXISTS agent_sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  title TEXT,                           -- Auto-generated or user-defined title
  mode TEXT DEFAULT 'default',          -- Agent mode: default, research, coding, blog, article, terminal
  article_slug TEXT,                    -- If mode is 'article'
  system_prompt_hash TEXT,              -- Hash of system prompt for cache invalidation
  message_count INTEGER DEFAULT 0,
  tool_call_count INTEGER DEFAULT 0,
  total_tokens INTEGER DEFAULT 0,
  total_cost REAL DEFAULT 0,
  last_model TEXT,                      -- Last model used
  status TEXT DEFAULT 'active',         -- active, archived, deleted
  last_message_at TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_agent_sessions_user ON agent_sessions(user_id, status, last_message_at DESC);
CREATE INDEX IF NOT EXISTS idx_agent_sessions_mode ON agent_sessions(user_id, mode, status);

-- ========================================
-- Agent Messages Table
-- Stores individual messages in agent sessions
-- ========================================
CREATE TABLE IF NOT EXISTS agent_messages (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  role TEXT NOT NULL,                   -- 'user', 'assistant', 'system', 'tool'
  content TEXT NOT NULL,
  content_type TEXT DEFAULT 'text',     -- 'text', 'tool_call', 'tool_result', 'error'
  
  -- Tool call specific fields
  tool_name TEXT,                       -- Name of tool called (if role='tool')
  tool_call_id TEXT,                    -- Unique ID for tool call
  tool_args TEXT,                       -- JSON: Tool arguments
  tool_result TEXT,                     -- JSON: Tool execution result
  tool_duration_ms INTEGER,             -- Tool execution time
  
  -- Token tracking
  prompt_tokens INTEGER,
  completion_tokens INTEGER,
  
  -- Metadata
  model TEXT,                           -- Model used for this message
  metadata TEXT,                        -- JSON: Additional metadata
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (session_id) REFERENCES agent_sessions(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_agent_messages_session ON agent_messages(session_id, created_at ASC);
CREATE INDEX IF NOT EXISTS idx_agent_messages_tool ON agent_messages(session_id, role, tool_name);

-- ========================================
-- Agent Tool Executions Table
-- Detailed log of all tool executions for debugging and analytics
-- ========================================
CREATE TABLE IF NOT EXISTS agent_tool_executions (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  message_id TEXT,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  tool_name TEXT NOT NULL,
  tool_version TEXT,
  
  -- Execution details
  input_args TEXT NOT NULL,             -- JSON: Input arguments
  output_result TEXT,                   -- JSON: Output result
  error_message TEXT,                   -- Error message if failed
  status TEXT NOT NULL,                 -- 'pending', 'running', 'success', 'error', 'timeout'
  
  -- Timing
  started_at TEXT NOT NULL DEFAULT (datetime('now')),
  completed_at TEXT,
  duration_ms INTEGER,
  
  -- Context
  retry_count INTEGER DEFAULT 0,
  parent_execution_id TEXT,             -- For nested tool calls
  
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (session_id) REFERENCES agent_sessions(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_agent_tool_executions_session ON agent_tool_executions(session_id, started_at DESC);
CREATE INDEX IF NOT EXISTS idx_agent_tool_executions_tool ON agent_tool_executions(tool_name, status, started_at DESC);
CREATE INDEX IF NOT EXISTS idx_agent_tool_executions_user ON agent_tool_executions(user_id, started_at DESC);

-- ========================================
-- Agent User Preferences Table
-- Stores user-specific agent configuration
-- ========================================
CREATE TABLE IF NOT EXISTS agent_user_preferences (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL UNIQUE,
  
  -- Default settings
  default_mode TEXT DEFAULT 'default',
  default_model TEXT,
  default_temperature REAL DEFAULT 0.7,
  
  -- Tool preferences
  enabled_tools TEXT,                   -- JSON: Array of enabled tool names
  disabled_tools TEXT,                  -- JSON: Array of disabled tool names
  
  -- Memory preferences
  memory_enabled INTEGER DEFAULT 1,
  memory_retention_days INTEGER DEFAULT 90,
  auto_summarize INTEGER DEFAULT 1,
  
  -- UI preferences
  stream_responses INTEGER DEFAULT 1,
  show_tool_calls INTEGER DEFAULT 1,
  
  -- Custom instructions
  custom_instructions TEXT,
  persona TEXT,
  
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_agent_user_preferences_user ON agent_user_preferences(user_id);

-- ========================================
-- Agent Knowledge Base Table
-- Stores indexed knowledge for RAG retrieval
-- ========================================
CREATE TABLE IF NOT EXISTS agent_knowledge (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL DEFAULT 'system',
  source_type TEXT NOT NULL,            -- 'blog_post', 'memo', 'manual', 'web', 'file'
  source_id TEXT,                       -- Reference to source (e.g., post slug, memo id)
  source_url TEXT,
  
  -- Content
  title TEXT,
  content TEXT NOT NULL,
  content_hash TEXT NOT NULL,           -- For deduplication
  
  -- Chunking info
  chunk_index INTEGER DEFAULT 0,        -- For multi-chunk documents
  total_chunks INTEGER DEFAULT 1,
  
  -- Metadata
  category TEXT,
  tags TEXT,                            -- JSON: Array of tags
  language TEXT DEFAULT 'ko',
  
  -- Embedding status
  embedding_status TEXT DEFAULT 'pending',  -- 'pending', 'indexed', 'failed'
  embedding_model TEXT,
  last_indexed_at TEXT,
  
  -- Visibility
  is_public INTEGER DEFAULT 1,
  
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_agent_knowledge_source ON agent_knowledge(source_type, source_id);
CREATE INDEX IF NOT EXISTS idx_agent_knowledge_user ON agent_knowledge(user_id, is_public, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_agent_knowledge_embedding ON agent_knowledge(embedding_status, updated_at);
CREATE INDEX IF NOT EXISTS idx_agent_knowledge_hash ON agent_knowledge(content_hash);

-- ========================================
-- Agent Feedback Table
-- Stores user feedback on agent responses for improvement
-- ========================================
CREATE TABLE IF NOT EXISTS agent_feedback (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  message_id TEXT NOT NULL,
  user_id TEXT NOT NULL DEFAULT 'default-user',
  
  -- Feedback
  rating INTEGER,                       -- 1-5 star rating
  feedback_type TEXT,                   -- 'helpful', 'not_helpful', 'incorrect', 'offensive'
  comment TEXT,
  
  -- Context
  query TEXT,                           -- Original user query
  response TEXT,                        -- Agent response
  tools_used TEXT,                      -- JSON: Tools used in response
  
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  
  FOREIGN KEY (session_id) REFERENCES agent_sessions(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_agent_feedback_session ON agent_feedback(session_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_agent_feedback_rating ON agent_feedback(rating, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_agent_feedback_type ON agent_feedback(feedback_type, created_at DESC);

-- ========================================
-- Views for Analytics
-- ========================================

-- Daily agent usage summary
CREATE VIEW IF NOT EXISTS v_agent_daily_usage AS
SELECT 
  date(created_at) as date,
  user_id,
  COUNT(DISTINCT id) as session_count,
  SUM(message_count) as total_messages,
  SUM(tool_call_count) as total_tool_calls,
  SUM(total_tokens) as total_tokens,
  SUM(total_cost) as total_cost
FROM agent_sessions
WHERE status != 'deleted'
GROUP BY date(created_at), user_id;

-- Tool usage summary
CREATE VIEW IF NOT EXISTS v_agent_tool_usage AS
SELECT 
  tool_name,
  COUNT(*) as execution_count,
  SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END) as success_count,
  SUM(CASE WHEN status = 'error' THEN 1 ELSE 0 END) as error_count,
  AVG(duration_ms) as avg_duration_ms,
  MAX(duration_ms) as max_duration_ms
FROM agent_tool_executions
GROUP BY tool_name;

```

---

## workers/r2-gateway

### README.md

**Path:** `workers/r2-gateway/README.md`

```markdown
# r2-gateway Worker

R2 access-control gateway to reduce R2 reads by fronting with Cloudflare cache and enforcing request policies.

## Setup

1) Edit `wrangler.toml`:
- Set `bucket_name` in `r2_buckets` to your actual R2 bucket
- Choose a routing method: `routes` or custom domain

2) Deploy

```
npm i
npm run deploy
```

## Access control

Default policy allows requests only with `Referer` starting `https://mydomain.com/`. Adjust logic in `src/index.ts` as needed.

```

### package.json

**Path:** `workers/r2-gateway/package.json`

```json
{
  "name": "r2-gateway",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy",
    "typecheck": "tsc --noEmit"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20241127.0",
    "typescript": "^5.7.2",
    "wrangler": "^3.94.0"
  }
}

```

### tsconfig.json

**Path:** `workers/r2-gateway/tsconfig.json`

```json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "jsx": "react-jsx",
    "types": ["@cloudflare/workers-types"],
    "skipLibCheck": true,
    "noEmit": true
  },
  "include": ["src/**/*"]
}

```

### wrangler.toml

**Path:** `workers/r2-gateway/wrangler.toml`

```toml
name = "r2-gateway"
main = "src/index.ts"
compatibility_date = "2025-10-21"
account_id = "f6f11e2a4e5178d2f37476785018f761"

# R2 bucket binding
[[r2_buckets]]
binding = "MY_BUCKET"
bucket_name = "blog"

# Environment variables
[vars]
ALLOWED_ORIGINS = "*"

# Custom domain for public access
# Uncomment and configure if you have a custom domain set up in Cloudflare
# routes = [
#   { pattern = "assets-b.nodove.com/*", zone_name = "nodove.com" }
# ]

# workers.dev subdomain is automatically enabled

```

---

## workers/r2-gateway/src

### index.ts

**Path:** `workers/r2-gateway/src/index.ts`

```typescript
type Env = {
  MY_BUCKET: R2Bucket;
  INTERNAL_CALLER_KEY?: string;
  ALLOWED_INTERNAL_ORIGINS?: string;
  ALLOWED_ORIGINS?: string;
};

const JSON_HEADERS = { "Content-Type": "application/json" } as const;
const ALLOWED_METHODS = ["GET", "HEAD", "OPTIONS"];
const MAX_LIST_PAGE_SIZE = 100;

// Public prefixes - these paths are publicly accessible without authentication
const PUBLIC_PREFIXES = ["ai-chat/", "images/", "posts/", "assets/"];

function isPublicPath(pathname: string): boolean {
  return PUBLIC_PREFIXES.some((prefix) => pathname.startsWith(prefix));
}

function sanitizeEtag(etag?: string | null) {
  return etag?.replace(/"/g, "") ?? null;
}

function buildJsonResponse(body: unknown, init?: ResponseInit) {
  return new Response(JSON.stringify(body), {
    status: init?.status ?? 200,
    headers: { ...JSON_HEADERS, ...(init?.headers || {}) },
  });
}

function applyCorsHeaders(headers: Headers, origin: string, env: Env) {
  const allowedOrigins = (env.ALLOWED_ORIGINS || "*").split(",").map((o) => o.trim());
  
  if (allowedOrigins.includes("*") || allowedOrigins.includes(origin)) {
    headers.set("Access-Control-Allow-Origin", allowedOrigins.includes("*") ? "*" : origin);
    headers.set("Access-Control-Allow-Methods", "GET, HEAD, OPTIONS");
    headers.set("Access-Control-Allow-Headers", "Content-Type, If-None-Match");
    headers.set("Access-Control-Max-Age", "86400");
  }
}

async function handleAssetRequest(request: Request, env: Env, key: string) {
  const origin = request.headers.get("Origin") || "*";

  // Handle CORS preflight
  if (request.method === "OPTIONS") {
    const response = new Response(null, { status: 204 });
    applyCorsHeaders(response.headers, origin, env);
    return response;
  }

  if (!["GET", "HEAD"].includes(request.method)) {
    return new Response("Method Not Allowed", { status: 405 });
  }

  const object = await env.MY_BUCKET.get(key);
  if (!object) {
    const notFoundResponse = new Response("Object not found", { status: 404 });
    applyCorsHeaders(notFoundResponse.headers, origin, env);
    return notFoundResponse;
  }

  const etag = object.httpEtag;
  const ifNoneMatch = request.headers.get("If-None-Match");
  if (ifNoneMatch && etag && ifNoneMatch.replace(/W\//, "") === etag.replace(/W\//, "")) {
    const cachedResponse = new Response(null, {
      status: 304,
      headers: {
        ETag: etag,
        "Cache-Control": "public, max-age=31536000, immutable",
      },
    });
    applyCorsHeaders(cachedResponse.headers, origin, env);
    return cachedResponse;
  }

  const headers = new Headers();
  object.writeHttpMetadata(headers);
  headers.set("ETag", etag ?? "");
  // Long cache for immutable assets
  headers.set("Cache-Control", "public, max-age=31536000, immutable");
  headers.set("Accept-Ranges", "bytes");
  applyCorsHeaders(headers, origin, env);

  if (request.method === "HEAD") {
    return new Response(null, { headers });
  }

  return new Response(object.body, { headers });
}

function isInternalCall(request: Request, env: Env): boolean {
  const key = request.headers.get("X-Gateway-Caller-Key") || "";
  if (env.INTERNAL_CALLER_KEY && key === env.INTERNAL_CALLER_KEY) {
    return true;
  }
  const referer = request.headers.get("Referer") || "";
  if (!referer) return false;
  if (!env.ALLOWED_INTERNAL_ORIGINS) return false;
  return env.ALLOWED_INTERNAL_ORIGINS.split(",")
    .map((o) => o.trim())
    .filter(Boolean)
    .some((allowed) => referer.startsWith(allowed));
}

async function handleInternalRequest(
  request: Request,
  env: Env,
  resource: string,
  userId: string,
  id?: string
) {
  if (!isInternalCall(request, env)) {
    return buildJsonResponse({ ok: false, error: "Forbidden" }, { status: 403 });
  }

  const url = new URL(request.url);
  const cursor = url.searchParams.get("cursor") || undefined;
  const limitParam = url.searchParams.get("limit");
  const limit = limitParam ? Math.min(MAX_LIST_PAGE_SIZE, Math.max(parseInt(limitParam, 10) || 0, 1)) : MAX_LIST_PAGE_SIZE;
  const sanitizedId = id?.replace(/\.json$/i, "");
  const objectKey = sanitizedId ? `${resource}/${userId}/${sanitizedId}.json` : `${resource}/${userId}/`;

  if (request.method === "GET" && !sanitizedId) {
    const result = await env.MY_BUCKET.list({
      prefix: `${resource}/${userId}/`,
      cursor,
      limit,
    });

    const responseBody = {
      ok: true,
      cursor: (result as { cursor?: string }).cursor ?? null,
      truncated: result.truncated ?? false,
      objects: result.objects.map((obj) => ({
        key: obj.key,
        size: obj.size,
        httpEtag: sanitizeEtag(obj.httpEtag),
        uploaded: obj.uploaded?.toISOString?.() ?? null,
      })),
      delimitedPrefixes: result.delimitedPrefixes ?? [],
    };

    return buildJsonResponse(responseBody);
  }

  if (!sanitizedId) {
    return buildJsonResponse({ ok: false, error: "Invalid request" }, { status: 400 });
  }

  switch (request.method) {
    case "GET": {
      const object = await env.MY_BUCKET.get(objectKey);
      if (!object) {
        return buildJsonResponse({ ok: false, error: "Not found" }, { status: 404 });
      }

      const headers = new Headers(JSON_HEADERS);
      object.writeHttpMetadata(headers);
      headers.set("ETag", sanitizeEtag(object.httpEtag) ?? "");

      return new Response(object.body, { status: 200, headers });
    }
    case "HEAD": {
      const object = await env.MY_BUCKET.get(objectKey);
      if (!object) {
        return buildJsonResponse({ ok: false, error: "Not found" }, { status: 404 });
      }

      const headers = new Headers();
      object.writeHttpMetadata(headers);
      headers.set("ETag", sanitizeEtag(object.httpEtag) ?? "");
      return new Response(null, { status: 200, headers });
    }
    case "PUT": {
      const ifMatch = request.headers.get("If-Match")?.replace(/^"|"$/g, "");
      const existing = await env.MY_BUCKET.get(objectKey);
      const existingEtag = sanitizeEtag(existing?.httpEtag);
      if (ifMatch && existingEtag && ifMatch !== existingEtag) {
        return buildJsonResponse({ ok: false, error: "ETag mismatch" }, { status: 412 });
      }
      if (ifMatch && !existing) {
        return buildJsonResponse({ ok: false, error: "Missing resource" }, { status: 412 });
      }

      const text = await request.text();
      const result = await env.MY_BUCKET.put(objectKey, text, {
        httpMetadata: { contentType: "application/json" },
      });
      return buildJsonResponse({ ok: true, etag: sanitizeEtag(result.httpEtag) }, {
        status: existing ? 200 : 201,
      });
    }
    case "DELETE": {
      const ifMatch = request.headers.get("If-Match")?.replace(/^"|"$/g, "");
      if (ifMatch) {
        const existing = await env.MY_BUCKET.get(objectKey);
        const existingEtag = sanitizeEtag(existing?.httpEtag);
        if (!existing) {
          return buildJsonResponse({ ok: false, error: "Missing resource" }, { status: 412 });
        }
        if (existingEtag && existingEtag !== ifMatch) {
          return buildJsonResponse({ ok: false, error: "ETag mismatch" }, { status: 412 });
        }
      }
      await env.MY_BUCKET.delete(objectKey);
      return new Response(null, { status: 204 });
    }
    default:
      return buildJsonResponse({ ok: false, error: "Method not allowed" }, { status: 405 });
  }
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const pathname = url.pathname.replace(/^\/+/, "");
    const origin = request.headers.get("Origin") || "*";

    // Handle CORS preflight for any path
    if (request.method === "OPTIONS") {
      const response = new Response(null, { status: 204 });
      applyCorsHeaders(response.headers, origin, env);
      return response;
    }
    
    // Root path - return simple status
    if (!pathname) {
      const statusResponse = buildJsonResponse({ ok: true, service: "r2-gateway" });
      applyCorsHeaders(statusResponse.headers, origin, env);
      return statusResponse;
    }

    // Legacy /assets/* path - strip prefix and serve
    if (pathname.startsWith("assets/")) {
      return handleAssetRequest(request, env, pathname.replace(/^assets\//, ""));
    }

    // Public paths - serve directly without /assets/ prefix
    // This allows URLs like /ai-chat/2025/image.png to work
    if (isPublicPath(pathname)) {
      return handleAssetRequest(request, env, pathname);
    }

    // Internal API paths - require authentication
    if (pathname.startsWith("internal/")) {
      const [, resource, userId, ...rest] = pathname.split("/");
      if (!resource || !userId) {
        return buildJsonResponse({ ok: false, error: "Invalid path" }, { status: 400 });
      }
      const id = rest.length > 0 ? rest.join("/") : undefined;
      return handleInternalRequest(request, env, resource, userId, id);
    }

    const notFoundResponse = new Response(JSON.stringify({ ok: false, error: "Not Found" }), {
      status: 404,
      headers: JSON_HEADERS,
    });
    applyCorsHeaders(notFoundResponse.headers, origin, env);
    return notFoundResponse;
  },
};

```

---

## workers/scripts

### migrate-firestore-to-d1.ts

**Path:** `workers/scripts/migrate-firestore-to-d1.ts`

```typescript
/**
 * Firestore to D1 Migration Script
 * 
 * This script exports data from Firestore and generates SQL INSERT statements
 * for importing into D1.
 * 
 * Usage:
 *   1. Set FIREBASE_SERVICE_ACCOUNT_JSON env var to path of service account JSON
 *   2. Run: npx tsx scripts/migrate-firestore-to-d1.ts > migrations/0003_seed_data.sql
 *   3. Apply: wrangler d1 execute blog-db --file=migrations/0003_seed_data.sql --local
 */

import * as admin from 'firebase-admin';
import * as fs from 'fs';

// Initialize Firebase Admin
const serviceAccountPath = process.env.FIREBASE_SERVICE_ACCOUNT_JSON;
if (!serviceAccountPath) {
  console.error('Error: FIREBASE_SERVICE_ACCOUNT_JSON environment variable not set');
  process.exit(1);
}

if (!fs.existsSync(serviceAccountPath)) {
  console.error(`Error: Service account file not found: ${serviceAccountPath}`);
  process.exit(1);
}

const serviceAccount = JSON.parse(fs.readFileSync(serviceAccountPath, 'utf8'));

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

const db = admin.firestore();

function sqlEscape(value: unknown): string {
  if (value === null || value === undefined) return 'NULL';
  if (typeof value === 'number') return String(value);
  if (typeof value === 'boolean') return value ? '1' : '0';
  if (value instanceof Date) return `'${value.toISOString()}'`;
  // Escape single quotes
  return `'${String(value).replace(/'/g, "''")}'`;
}

async function exportComments() {
  console.error('Exporting comments...');
  const snapshot = await db.collection('comments').get();
  
  for (const doc of snapshot.docs) {
    const data = doc.data();
    const createdAt = data.createdAt?.toDate?.()?.toISOString() || new Date().toISOString();
    const updatedAt = data.updatedAt?.toDate?.()?.toISOString() || createdAt;
    
    console.log(
      `INSERT INTO comments(id, post_id, author, email, content, status, created_at, updated_at) VALUES (` +
      `${sqlEscape(doc.id)}, ` +
      `${sqlEscape(data.postId)}, ` +
      `${sqlEscape(data.author)}, ` +
      `${sqlEscape(data.email || null)}, ` +
      `${sqlEscape(data.content)}, ` +
      `${sqlEscape(data.archived ? 'hidden' : 'visible')}, ` +
      `${sqlEscape(createdAt)}, ` +
      `${sqlEscape(updatedAt)}` +
      `);`
    );
  }
  
  console.error(`Exported ${snapshot.size} comments`);
}

async function exportSettings() {
  console.error('Exporting settings...');
  const snapshot = await db.collection('settings').get();
  
  for (const doc of snapshot.docs) {
    const data = doc.data();
    const updatedAt = data.updatedAt?.toDate?.()?.toISOString() || new Date().toISOString();
    
    console.log(
      `INSERT INTO settings(key, value, updated_at) VALUES (` +
      `${sqlEscape(doc.id)}, ` +
      `${sqlEscape(JSON.stringify(data.value || data))}, ` +
      `${sqlEscape(updatedAt)}` +
      `);`
    );
  }
  
  console.error(`Exported ${snapshot.size} settings`);
}

async function main() {
  console.log('-- Firestore to D1 Migration');
  console.log('-- Generated at: ' + new Date().toISOString());
  console.log('');
  console.log('BEGIN TRANSACTION;');
  console.log('');
  
  try {
    await exportComments();
    console.log('');
    await exportSettings();
    console.log('');
    console.log('COMMIT;');
    console.error('\n✅ Migration SQL generated successfully');
    console.error('📝 Review the output and apply with: wrangler d1 execute blog-db --file=migrations/0003_seed_data.sql');
  } catch (error) {
    console.error('❌ Migration failed:', error);
    console.log('ROLLBACK;');
    process.exit(1);
  }
}

main();

```

### setup-admin.ts

**Path:** `workers/scripts/setup-admin.ts`

```typescript
/**
 * Setup Admin User Script
 * 
 * Creates an admin user in D1 database with hashed password.
 * 
 * Usage:
 *   npx tsx scripts/setup-admin.ts
 * 
 * Note: This script uses a simple hash. For production, use bcrypt or argon2.
 */

async function hashPassword(password: string): Promise<string> {
  // Simple SHA-256 hash (not secure for production)
  // TODO: Replace with bcrypt or argon2 when available in Workers
  const encoder = new TextEncoder();
  const data = encoder.encode(password);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
  return `sha256:${hashHex}`;
}

async function main() {
  const username = process.argv[2] || process.env.ADMIN_USERNAME || 'admin';
  const password = process.argv[3] || process.env.ADMIN_PASSWORD;

  if (!password) {
    console.error('Error: Password required');
    console.error('Usage: npx tsx scripts/setup-admin.ts [username] <password>');
    process.exit(1);
  }

  const passwordHash = await hashPassword(password);
  const userId = `admin-${crypto.randomUUID()}`;
  const now = new Date().toISOString();

  console.log('-- Setup Admin User');
  console.log('-- Generated at: ' + now);
  console.log('');
  console.log(
    `INSERT INTO users(id, username, password_hash, created_at, updated_at) VALUES ` +
    `('${userId}', '${username}', '${passwordHash}', '${now}', '${now}');`
  );
  console.log('');
  console.error(`✅ Admin user SQL generated`);
  console.error(`Username: ${username}`);
  console.error(`User ID: ${userId}`);
  console.error('');
  console.error('📝 Apply with: wrangler d1 execute blog-db --file=migrations/0002_seed_admin.sql --local');
}

main();

```

---

## workers/src

### index.ts

**Path:** `workers/src/index.ts`

```typescript
import { Hono } from 'hono';
import type { Env } from './types';
import { corsMiddleware } from './middleware/cors';
import { loggerMiddleware } from './middleware/logger';
import { errorHandler } from './middleware/error';
import { success } from './lib/response';

// Import routes
import auth from './routes/auth';
import posts from './routes/posts';
import comments from './routes/comments';
import ai from './routes/ai';
import chat from './routes/chat';
import images from './routes/images';
import og from './routes/og';
import analytics from './routes/analytics';
import translate from './routes/translate';
import config from './routes/config';
import rag from './routes/rag';
import gateway from './routes/gateway';
import memos from './routes/memos';
import memories from './routes/memories';

const app = new Hono<{ Bindings: Env }>();

// Global middlewares
app.use('*', corsMiddleware);
app.use('*', loggerMiddleware);

// Health check
app.get('/healthz', (c) => {
  return success(c, {
    status: 'ok',
    env: c.env.ENV,
    timestamp: new Date().toISOString(),
  });
});

// Public config
app.get('/public/config', (c) => {
  return success(c, {
    env: c.env.ENV,
    features: {
      aiInline: true,
      comments: true,
    },
  });
});

// Mount API routes under /api/v1
const api = new Hono<{ Bindings: Env }>();
api.route('/auth', auth);
api.route('/posts', posts);
api.route('/comments', comments);
api.route('/ai', ai);
api.route('/chat', chat);
api.route('/images', images);
api.route('/og', og);
api.route('/analytics', analytics);
api.route('/translate', translate);
api.route('/config', config);
api.route('/rag', rag);
api.route('/gateway', gateway);
api.route('/memos', memos);
api.route('/memories', memories);

app.route('/api/v1', api);

// 404 handler
app.notFound((c) => {
  return c.json({ ok: false, error: { message: 'Not Found' } }, 404);
});

// Error handler
app.onError(errorHandler);

// Scheduled handler for cron triggers
async function scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {
  console.log(`Cron triggered at ${new Date().toISOString()}`);

  try {
    const db = env.DB;

    // 1. Refresh post stats (7d, 30d views)
    const now = new Date();
    const date7d = new Date(now);
    date7d.setDate(date7d.getDate() - 7);
    const date30d = new Date(now);
    date30d.setDate(date30d.getDate() - 30);
    const date7dStr = date7d.toISOString().split('T')[0];
    const date30dStr = date30d.toISOString().split('T')[0];

    const allPosts = await db
      .prepare(`SELECT DISTINCT post_slug, year FROM post_stats`)
      .all<{ post_slug: string; year: string }>();

    for (const post of allPosts.results || []) {
      const views7d = await db
        .prepare(
          `SELECT COALESCE(SUM(view_count), 0) as cnt FROM post_views WHERE post_slug = ? AND year = ? AND view_date >= ?`
        )
        .bind(post.post_slug, post.year, date7dStr)
        .first<{ cnt: number }>();

      const views30d = await db
        .prepare(
          `SELECT COALESCE(SUM(view_count), 0) as cnt FROM post_views WHERE post_slug = ? AND year = ? AND view_date >= ?`
        )
        .bind(post.post_slug, post.year, date30dStr)
        .first<{ cnt: number }>();

      await db
        .prepare(
          `UPDATE post_stats SET views_7d = ?, views_30d = ?, updated_at = datetime('now') WHERE post_slug = ? AND year = ?`
        )
        .bind(views7d?.cnt || 0, views30d?.cnt || 0, post.post_slug, post.year)
        .run();
    }

    console.log(`Refreshed stats for ${allPosts.results?.length || 0} posts`);

    // 2. Update editor picks
    const topPosts = await db
      .prepare(
        `SELECT *, (views_7d * 0.5 + views_30d * 0.3 + total_views * 0.2) as score
         FROM post_stats WHERE total_views > 0 ORDER BY score DESC LIMIT 10`
      )
      .all<{ post_slug: string; year: string; views_7d: number; views_30d: number; total_views: number }>();

    if (topPosts.results && topPosts.results.length > 0) {
      // Deactivate all current picks
      await db.prepare(`UPDATE editor_picks SET is_active = 0, updated_at = datetime('now')`).run();

      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 1);
      expiresAt.setHours(6, 0, 0, 0);
      const expiresAtStr = expiresAt.toISOString();

      const topPicks = topPosts.results.slice(0, 3);
      for (let i = 0; i < topPicks.length; i++) {
        const postItem = topPicks[i];
        if (!postItem) continue;
        const score = postItem.views_7d * 0.5 + postItem.views_30d * 0.3 + postItem.total_views * 0.2;
        let reason = 'Popular post';
        if (postItem.views_7d > postItem.views_30d * 0.5) {
          reason = 'Trending this week';
        } else if (postItem.total_views > 100) {
          reason = 'Evergreen favorite';
        }

        await db
          .prepare(
            `INSERT INTO editor_picks (post_slug, year, title, rank, score, reason, expires_at, is_active)
             VALUES (?, ?, ?, ?, ?, ?, ?, 1)
             ON CONFLICT(post_slug, year)
             DO UPDATE SET rank = ?, score = ?, reason = ?, expires_at = ?, is_active = 1, picked_at = datetime('now'), updated_at = datetime('now')`
          )
          .bind(postItem.post_slug, postItem.year, '', i + 1, score, reason, expiresAtStr, i + 1, score, reason, expiresAtStr)
          .run();
      }

      console.log(`Updated ${topPicks.length} editor picks`);
    }

    // 3. Clean up old view records (older than 90 days)
    const date90d = new Date(now);
    date90d.setDate(date90d.getDate() - 90);
    const date90dStr = date90d.toISOString().split('T')[0];

    await db.prepare(`DELETE FROM post_views WHERE view_date < ?`).bind(date90dStr).run();

    console.log('Cron job completed successfully');
  } catch (err) {
    console.error('Cron job failed:', err);
  }
}

export default {
  fetch: app.fetch,
  scheduled,
};

```

### types.ts

**Path:** `workers/src/types.ts`

```typescript
// Cloudflare Workers Environment Bindings
export type Env = {
  // Bindings
  DB: D1Database;
  R2: R2Bucket;
  KV: KVNamespace;

  // Secrets
  JWT_SECRET: string;
  ADMIN_USERNAME?: string;
  ADMIN_PASSWORD?: string;

  // Backend AI Server (via Cloudflare Tunnel)
  // 모든 AI 호출은 이 서버를 통해 처리됩니다
  AI_SERVE_BASE_URL?: string; // e.g., https://ai-check.nodove.com
  AI_SERVE_API_KEY?: string;
  AI_GATEWAY_CALLER_KEY?: string;
  API_BASE_URL?: string; // e.g., https://api.nodove.com

  // Legacy: GEMINI_API_KEY는 더 이상 Workers에서 직접 사용하지 않음
  // 백엔드 서버에서 관리됩니다
  GEMINI_API_KEY?: string;

  // Email + site notification
  RESEND_API_KEY?: string;
  NOTIFY_FROM_EMAIL?: string;
  NOTIFY_TO_EMAILS?: string;
  PUBLIC_SITE_URL?: string;
  ASSETS_BASE_URL?: string;
  OPENCODE_AUTH_TOKEN?: string;
  GITHUB_TOKEN?: string;

  // Variables
  ENV: 'development' | 'production';
  ALLOWED_ORIGINS: string;
};

// Context extending Hono's context with our Env
export type Context = {
  env: Env;
  executionCtx: ExecutionContext;
};

// Standard API response
export type ApiResponse<T = unknown> = {
  ok: boolean;
  data?: T;
  error?: {
    code?: string;
    message: string;
  };
};

// Database Models
export type User = {
  id: string;
  username: string;
  password_hash: string;
  created_at: string;
  updated_at: string;
};

export type Post = {
  id: string;
  slug: string;
  title: string;
  content: string;
  excerpt: string | null;
  cover_image_url: string | null;
  status: 'draft' | 'published';
  author_id: string;
  published_at: string | null;
  created_at: string;
  updated_at: string;
};

export type Tag = {
  id: number;
  name: string;
};

export type Comment = {
  id: string;
  post_id: string;
  author: string;
  email: string | null;
  content: string;
  status: 'visible' | 'hidden' | 'pending';
  created_at: string;
  updated_at: string;
};

export type Attachment = {
  id: string;
  post_id: string;
  url: string;
  r2_key: string;
  content_type: string | null;
  size_bytes: number | null;
  created_at: string;
};

// JWT Payload
export type JwtPayload = {
  sub: string;
  role: string;
  username: string;
  iat?: number;
  exp?: number;
};

// Post Analytics Models
export type PostView = {
  id: number;
  post_slug: string;
  year: string;
  view_date: string;
  view_count: number;
  created_at: string;
  updated_at: string;
};

export type PostStats = {
  id: number;
  post_slug: string;
  year: string;
  total_views: number;
  views_7d: number;
  views_30d: number;
  last_viewed_at: string | null;
  created_at: string;
  updated_at: string;
};

export type EditorPick = {
  id: number;
  post_slug: string;
  year: string;
  title: string;
  cover_image: string | null;
  category: string | null;
  rank: number;
  score: number;
  reason: string | null;
  picked_at: string;
  expires_at: string | null;
  is_active: number;
  created_at: string;
  updated_at: string;
};

```

---

## workers/src/lib

### ai-service.ts

**Path:** `workers/src/lib/ai-service.ts`

```typescript
/**
 * Unified AI Service for Cloudflare Workers
 *
 * 모든 AI 호출은 자체 백엔드 서버(api.nodove.com)를 통해 처리됩니다.
 * 이 모듈은 백엔드의 ai-service.js와 동일한 인터페이스를 제공합니다.
 *
 * Architecture:
 *   Workers Route -> AIService -> Backend API -> Provider (LiteLLM/VAS/Gemini)
 *
 * Features:
 *   - Provider-agnostic interface (backend handles provider selection)
 *   - KV-based dynamic configuration
 *   - Automatic fallback data on failure
 *   - Structured task support (sketch, prism, chain, summary)
 */

import type { Env } from '../types';
import { getAiServeUrl, getAiServeApiKey, getAiGatewayCallerKey } from './config';
import { buildTaskPrompt, getFallbackData, type TaskMode, type TaskPayload } from './prompts';

// ============================================================================
// Types
// ============================================================================

export type GenerateOptions = {
  temperature?: number;
  maxTokens?: number;
  model?: string;
  systemPrompt?: string;
  timeout?: number;
};

export type ChatMessage = {
  role: 'system' | 'user' | 'assistant';
  content: string;
};

export type ChatOptions = {
  temperature?: number;
  maxTokens?: number;
  model?: string;
  timeout?: number;
};

export type ChatResult = {
  content: string;
  model: string;
  provider: string;
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
};

export type VisionOptions = {
  mimeType?: string;
  model?: string;
  timeout?: number;
};

export type TaskOptions = {
  temperature?: number;
};

export type TaskResult<T = unknown> = {
  ok: boolean;
  data: T;
  error?: string;
};

// ============================================================================
// AIService Class
// ============================================================================

export class AIService {
  private env: Env;
  private baseUrl: string | null = null;

  constructor(env: Env) {
    this.env = env;
  }

  /**
   * Get the backend API URL (cached)
   */
  private async getBaseUrl(): Promise<string> {
    if (!this.baseUrl) {
      this.baseUrl = await getAiServeUrl(this.env);
    }
    return this.baseUrl;
  }

  /**
   * Build request headers with authentication
   */
  private async buildHeaders(): Promise<Record<string, string>> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'User-Agent': 'Blog-Workers/1.0',
      Accept: 'application/json',
    };

    const apiKey = await getAiServeApiKey(this.env);
    if (apiKey) {
      headers['X-API-KEY'] = apiKey;
    }

    const gatewayCallerKey = await getAiGatewayCallerKey(this.env);
    if (gatewayCallerKey) {
      headers['X-Gateway-Caller-Key'] = gatewayCallerKey;
    }

    return headers;
  }

  /**
   * Make a request to the backend API
   */
  private async request<T>(
    endpoint: string,
    body: unknown,
    options: { timeout?: number } = {}
  ): Promise<T> {
    const baseUrl = await this.getBaseUrl();
    const url = `${baseUrl.replace(/\/$/, '')}/api/v1/ai${endpoint}`;
    const headers = await this.buildHeaders();

    const controller = new AbortController();
    const timeoutId = options.timeout
      ? setTimeout(() => controller.abort(), options.timeout)
      : undefined;

    try {
      const res = await fetch(url, {
        method: 'POST',
        headers,
        body: JSON.stringify(body),
        signal: controller.signal,
      });

      if (!res.ok) {
        const txt = await res.text().catch(() => '');
        throw new Error(`Backend AI error: ${res.status} ${txt.slice(0, 200)}`);
      }

      const payload = (await res.json()) as { ok?: boolean; data?: T; error?: string };

      if (payload.ok === false) {
        throw new Error(payload.error || 'Backend returned error');
      }

      return (payload.data ?? payload) as T;
    } finally {
      if (timeoutId) clearTimeout(timeoutId);
    }
  }

  /**
   * Generate text from a prompt
   */
  async generate(prompt: string, options: GenerateOptions = {}): Promise<string> {
    const result = await this.request<{ text: string }>('/generate', {
      prompt,
      temperature: options.temperature ?? 0.2,
      maxTokens: options.maxTokens,
      model: options.model,
      systemPrompt: options.systemPrompt,
    }, { timeout: options.timeout });

    return result.text;
  }

  /**
   * Chat completion with message history
   */
  async chat(messages: ChatMessage[], options: ChatOptions = {}): Promise<ChatResult> {
    return this.request<ChatResult>('/auto-chat', {
      messages,
      temperature: options.temperature,
      maxTokens: options.maxTokens,
      model: options.model,
    }, { timeout: options.timeout });
  }

  /**
   * Vision analysis with image
   */
  async vision(
    imageData: string,
    prompt: string,
    options: VisionOptions = {}
  ): Promise<string> {
    const result = await this.request<{ description: string }>('/vision/analyze', {
      imageBase64: imageData,
      mimeType: options.mimeType || 'image/jpeg',
      prompt,
      model: options.model,
    }, { timeout: options.timeout });

    return result.description;
  }

  /**
   * Execute a structured AI task (sketch, prism, chain, summary)
   */
  async task<T = unknown>(
    mode: TaskMode,
    payload: TaskPayload,
    options: TaskOptions = {}
  ): Promise<TaskResult<T>> {
    const config = buildTaskPrompt(mode, payload);
    const fullPrompt = `${config.system}\n\n${config.user}`;

    try {
      const text = await this.generate(fullPrompt, {
        temperature: options.temperature ?? config.temperature,
        maxTokens: config.maxTokens,
      });

      const json = tryParseJson<T>(text);
      if (json && typeof json === 'object') {
        return { ok: true, data: json };
      }

      // Fallback if JSON parsing fails
      return { ok: true, data: getFallbackData(mode, payload) as T };
    } catch (err) {
      console.error(`[AIService:${mode}] Error:`, err instanceof Error ? err.message : err);
      return { ok: true, data: getFallbackData(mode, payload) as T };
    }
  }

  /**
   * Summarize content
   */
  async summarize(
    content: string,
    options: { instructions?: string; temperature?: number } = {}
  ): Promise<{ summary: string; keyPoints?: string[] }> {
    const result = await this.task<{ summary: string; keyPoints?: string[] }>(
      'summary',
      { content, prompt: options.instructions },
      { temperature: options.temperature }
    );
    return result.data;
  }

  /**
   * Health check
   */
  async health(): Promise<{ ok: boolean; provider?: string; status?: string }> {
    try {
      const baseUrl = await this.getBaseUrl();
      const url = `${baseUrl.replace(/\/$/, '')}/api/v1/ai/health`;
      const headers = await this.buildHeaders();

      const res = await fetch(url, {
        method: 'GET',
        headers,
      });

      if (!res.ok) {
        return { ok: false, status: `HTTP ${res.status}` };
      }

      const data = (await res.json()) as {
        ok: boolean;
        data?: { status: string; provider?: string };
      };

      return {
        ok: data.ok ?? true,
        provider: data.data?.provider,
        status: data.data?.status || 'ok',
      };
    } catch (err) {
      return {
        ok: false,
        status: err instanceof Error ? err.message : 'unknown error',
      };
    }
  }

  /**
   * Get provider info from backend
   */
  async getProviderInfo(): Promise<{
    provider: string;
    features: Record<string, boolean>;
  }> {
    try {
      const baseUrl = await this.getBaseUrl();
      const url = `${baseUrl.replace(/\/$/, '')}/api/v1/ai/status`;
      const headers = await this.buildHeaders();

      const res = await fetch(url, { method: 'GET', headers });
      if (!res.ok) {
        return { provider: 'unknown', features: {} };
      }

      const data = (await res.json()) as {
        ok: boolean;
        data?: { provider?: string; features?: Record<string, boolean> };
      };

      return {
        provider: data.data?.provider || 'unknown',
        features: data.data?.features || {},
      };
    } catch {
      return { provider: 'unknown', features: {} };
    }
  }
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * JSON 파싱 유틸리티
 * LLM 응답에서 JSON을 추출합니다.
 */
export function tryParseJson<T = unknown>(text: string): T | null {
  if (!text || typeof text !== 'string') return null;

  // 1. 직접 파싱 시도
  try {
    return JSON.parse(text) as T;
  } catch {
    // continue
  }

  // 2. ```json 코드블록 추출
  const fenceMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fenceMatch?.[1]) {
    try {
      return JSON.parse(fenceMatch[1].trim()) as T;
    } catch {
      // continue
    }
  }

  // 3. 첫 { ~ 마지막 } 서브스트링
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start >= 0 && end > start) {
    try {
      return JSON.parse(text.slice(start, end + 1)) as T;
    } catch {
      // continue
    }
  }

  return null;
}

// ============================================================================
// Factory Function
// ============================================================================

/**
 * Create an AIService instance for the given environment
 */
export function createAIService(env: Env): AIService {
  return new AIService(env);
}

// ============================================================================
// Legacy Exports (for backward compatibility with gemini.ts)
// ============================================================================

export type { GenerateOptions as GenerateContentOptions };

/**
 * Legacy generateContent function
 * @deprecated Use createAIService(env).generate() instead
 */
export async function generateContent(
  prompt: string,
  env: Env,
  options?: GenerateOptions
): Promise<string> {
  const service = createAIService(env);
  return service.generate(prompt, options);
}

```

### config.ts

**Path:** `workers/src/lib/config.ts`

```typescript
/**
 * Dynamic configuration via KV
 *
 * 모든 AI 호출은 자체 백엔드 서버(api.nodove.com)를 통해 처리됩니다.
 * 이 모듈은 KV 스토리지를 통해 런타임에 서버 URL을 변경할 수 있게 합니다.
 *
 * KV Keys:
 * - config:ai_serve_url     - AI 서버 URL (api.nodove.com)
 * - config:ai_serve_api_key - AI 서버 API 키
 * - config:api_base_url     - 백엔드 API URL (api.nodove.com)
 * - config:ai_gateway_caller_key - 게이트웨이 호출자 키
 *
 * Priority:
 * 1. KV value (if set)
 * 2. Environment variable
 * 3. Hardcoded default
 */

import type { Env } from '../types';

// KV key constants
export const CONFIG_KEYS = {
  AI_SERVE_URL: 'config:ai_serve_url',
  AI_SERVE_API_KEY: 'config:ai_serve_api_key',
  AI_GATEWAY_CALLER_KEY: 'config:ai_gateway_caller_key',
  API_BASE_URL: 'config:api_base_url',
} as const;

// Default fallback URLs (used if both KV and env are empty)
const DEFAULTS = {
  AI_SERVE_URL: 'https://api.nodove.com',
  API_BASE_URL: 'https://api.nodove.com',
} as const;

// In-memory cache to reduce KV reads (TTL: 60 seconds)
type CacheEntry = { value: string | null; timestamp: number };
const cache = new Map<string, CacheEntry>();
const CACHE_TTL_MS = 60_000; // 60 seconds

function getCached(key: string): string | null | undefined {
  const entry = cache.get(key);
  if (!entry) return undefined;
  if (Date.now() - entry.timestamp > CACHE_TTL_MS) {
    cache.delete(key);
    return undefined;
  }
  return entry.value;
}

function setCache(key: string, value: string | null): void {
  cache.set(key, { value, timestamp: Date.now() });
}

/**
 * Get a config value with priority: KV > env > default
 */
async function getConfig(
  kv: KVNamespace,
  kvKey: string,
  envValue: string | undefined,
  defaultValue: string
): Promise<string> {
  // Check cache first
  const cached = getCached(kvKey);
  if (cached !== undefined) {
    return cached || envValue || defaultValue;
  }

  try {
    const kvValue = await kv.get(kvKey);
    setCache(kvKey, kvValue);
    if (kvValue) return kvValue;
  } catch (err) {
    console.error(`Failed to read KV config ${kvKey}:`, err);
  }

  return envValue || defaultValue;
}

/**
 * Get optional config value (no default)
 */
async function getOptionalConfig(
  kv: KVNamespace,
  kvKey: string,
  envValue: string | undefined
): Promise<string | undefined> {
  const cached = getCached(kvKey);
  if (cached !== undefined) {
    return cached || envValue || undefined;
  }

  try {
    const kvValue = await kv.get(kvKey);
    setCache(kvKey, kvValue);
    if (kvValue) return kvValue;
  } catch (err) {
    console.error(`Failed to read KV config ${kvKey}:`, err);
  }

  return envValue;
}

/**
 * Get AI Serve URL (for AI server like ai-check.nodove.com)
 */
export async function getAiServeUrl(env: Env): Promise<string> {
  return getConfig(
    env.KV,
    CONFIG_KEYS.AI_SERVE_URL,
    env.AI_SERVE_BASE_URL,
    DEFAULTS.AI_SERVE_URL
  );
}

/**
 * Get AI Serve API Key (optional)
 */
export async function getAiServeApiKey(env: Env): Promise<string | undefined> {
  return getOptionalConfig(env.KV, CONFIG_KEYS.AI_SERVE_API_KEY, env.AI_SERVE_API_KEY);
}

/**
 * Get AI Gateway Caller Key (optional)
 */
export async function getAiGatewayCallerKey(env: Env): Promise<string | undefined> {
  return getOptionalConfig(
    env.KV,
    CONFIG_KEYS.AI_GATEWAY_CALLER_KEY,
    env.AI_GATEWAY_CALLER_KEY
  );
}

/**
 * Get Backend API Base URL (via Cloudflare Tunnel)
 */
export async function getApiBaseUrl(env: Env): Promise<string> {
  return getConfig(
    env.KV,
    CONFIG_KEYS.API_BASE_URL,
    env.API_BASE_URL,
    DEFAULTS.API_BASE_URL
  );
}

/**
 * Set a config value in KV
 */
export async function setConfigValue(
  kv: KVNamespace,
  key: keyof typeof CONFIG_KEYS,
  value: string
): Promise<void> {
  const kvKey = CONFIG_KEYS[key];
  await kv.put(kvKey, value);
  setCache(kvKey, value);
}

/**
 * Delete a config value from KV (will fall back to env/default)
 */
export async function deleteConfigValue(
  kv: KVNamespace,
  key: keyof typeof CONFIG_KEYS
): Promise<void> {
  const kvKey = CONFIG_KEYS[key];
  await kv.delete(kvKey);
  cache.delete(kvKey);
}

/**
 * Get all current config values (for debugging/admin)
 */
export async function getAllConfig(env: Env): Promise<{
  aiServeUrl: { value: string; source: 'kv' | 'env' | 'default' };
  apiBaseUrl: { value: string; source: 'kv' | 'env' | 'default' };
  aiServeApiKey: { value: string; source: 'kv' | 'env' | 'none' } | null;
  aiGatewayCallerKey: { value: string; source: 'kv' | 'env' | 'none' } | null;
}> {
  const kv = env.KV;

  // AI Serve URL
  const aiServeKv = await kv.get(CONFIG_KEYS.AI_SERVE_URL);
  const aiServeUrl = aiServeKv
    ? { value: aiServeKv, source: 'kv' as const }
    : env.AI_SERVE_BASE_URL
      ? { value: env.AI_SERVE_BASE_URL, source: 'env' as const }
      : { value: DEFAULTS.AI_SERVE_URL, source: 'default' as const };

  // API Base URL (Cloudflare Tunnel)
  const apiBaseKv = await kv.get(CONFIG_KEYS.API_BASE_URL);
  const apiBaseUrl = apiBaseKv
    ? { value: apiBaseKv, source: 'kv' as const }
    : env.API_BASE_URL
      ? { value: env.API_BASE_URL, source: 'env' as const }
      : { value: DEFAULTS.API_BASE_URL, source: 'default' as const };

  // AI Serve API Key
  const aiServeApiKeyKv = await kv.get(CONFIG_KEYS.AI_SERVE_API_KEY);
  const aiServeApiKey = aiServeApiKeyKv
    ? { value: '***' + aiServeApiKeyKv.slice(-4), source: 'kv' as const }
    : env.AI_SERVE_API_KEY
      ? { value: '***' + env.AI_SERVE_API_KEY.slice(-4), source: 'env' as const }
      : null;

  // AI Gateway Caller Key
  const aiGatewayKeyKv = await kv.get(CONFIG_KEYS.AI_GATEWAY_CALLER_KEY);
  const aiGatewayCallerKey = aiGatewayKeyKv
    ? { value: '***' + aiGatewayKeyKv.slice(-4), source: 'kv' as const }
    : env.AI_GATEWAY_CALLER_KEY
      ? { value: '***' + env.AI_GATEWAY_CALLER_KEY.slice(-4), source: 'env' as const }
      : null;

  return {
    aiServeUrl,
    apiBaseUrl,
    aiServeApiKey,
    aiGatewayCallerKey,
  };
}

/**
 * Clear the in-memory cache (useful for testing or force refresh)
 */
export function clearConfigCache(): void {
  cache.clear();
}

```

### cors.ts

**Path:** `workers/src/lib/cors.ts`

```typescript
import { Context } from 'hono';
import type { Env } from '../types';

export function getAllowedOrigins(env: Env): string[] {
  return (env.ALLOWED_ORIGINS || '')
    .split(',')
    .map((o) => o.trim())
    .filter(Boolean);
}

export function isOriginAllowed(origin: string | undefined, env: Env): boolean {
  if (!origin) return false;
  const allowed = getAllowedOrigins(env);
  return allowed.includes(origin);
}

export function setCorsHeaders(c: Context, origin?: string) {
  const env = c.env as Env;
  const allowed = isOriginAllowed(origin, env);

  if (allowed && origin) {
    c.header('Access-Control-Allow-Origin', origin);
    c.header('Access-Control-Allow-Credentials', 'true');
  }

  c.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  c.header(
    'Access-Control-Allow-Headers',
    'Content-Type, Authorization, X-Requested-With'
  );
  c.header('Access-Control-Max-Age', '86400');
}

```

### d1.ts

**Path:** `workers/src/lib/d1.ts`

```typescript
// D1 query helpers
export async function queryOne<T>(
  db: D1Database,
  sql: string,
  ...params: unknown[]
): Promise<T | null> {
  const stmt = db.prepare(sql).bind(...params);
  const result = await stmt.first<T>();
  return result ?? null;
}

export async function queryAll<T>(
  db: D1Database,
  sql: string,
  ...params: unknown[]
): Promise<T[]> {
  const stmt = db.prepare(sql).bind(...params);
  const { results } = await stmt.all<T>();
  return results ?? [];
}

export async function execute(
  db: D1Database,
  sql: string,
  ...params: unknown[]
): Promise<D1Result> {
  const stmt = db.prepare(sql).bind(...params);
  return await stmt.run();
}

// Batch operations
export async function executeBatch(db: D1Database, statements: D1PreparedStatement[]) {
  return await db.batch(statements);
}

// Transaction helper (D1 supports batch as atomic operations)
export async function transaction<T>(
  db: D1Database,
  fn: (db: D1Database) => Promise<T>
): Promise<T> {
  // D1 doesn't have explicit transactions, but batch operations are atomic
  // For now, just execute the function
  return await fn(db);
}

```

### email.ts

**Path:** `workers/src/lib/email.ts`

```typescript
import type { Env } from '../types';

export type NewPostPayload = {
  title: string;
  url?: string;
  excerpt?: string;
  tags?: string[];
  publishedAt?: string;
};

function buildEmailContent(payload: NewPostPayload, siteUrl: string) {
  const url = payload.url || `${siteUrl}/blog`;
  const safeExcerpt = (payload.excerpt || '').slice(0, 300);
  const tags = (payload.tags || []).join(', ');
  const publishedAt = payload.publishedAt || new Date().toISOString();

  const text = [
    `New post published: ${payload.title}`,
    '',
    safeExcerpt ? safeExcerpt : '',
    tags ? `Tags: ${tags}` : '',
    `Published at: ${publishedAt}`,
    `Read: ${url}`,
  ]
    .filter(Boolean)
    .join('\n');

  const html = `
    <div style="font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #0f172a;">
      <h2 style="margin: 0 0 12px;">New post published: ${escapeHtml(payload.title)}</h2>
      ${safeExcerpt ? `<p style="margin: 0 0 12px; color: #334155;">${escapeHtml(safeExcerpt)}</p>` : ''}
      ${tags ? `<p style="margin: 0 0 12px; color: #64748b;"><strong>Tags:</strong> ${escapeHtml(tags)}</p>` : ''}
      <p style="margin: 0 0 16px; color: #64748b;"><strong>Published at:</strong> ${escapeHtml(publishedAt)}</p>
      <p style="margin: 0 0 16px;"><a href="${url}" style="background:#0ea5e9;color:white;padding:10px 14px;border-radius:8px;text-decoration:none;">Read the post</a></p>
      <p style="margin: 0; color: #94a3b8; font-size: 12px;">This is an automated notification.</p>
    </div>
  `;

  return { text, html, url };
}

function escapeHtml(str: string) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

export async function sendNewPostNotification(env: Env, payload: NewPostPayload) {
  // Only send in production
  if (env.ENV !== 'production') {
    return { ok: true, skipped: true, reason: 'non-production env' };
  }

  const apiKey = env.RESEND_API_KEY;
  const from = env.NOTIFY_FROM_EMAIL;
  const toList = (env.NOTIFY_TO_EMAILS || '')
    .split(',')
    .map((s) => s.trim())
    .filter(Boolean);
  const siteUrl = env.PUBLIC_SITE_URL;

  if (!apiKey || !from || !toList.length || !siteUrl) {
    return { ok: false, error: 'Missing email configuration (RESEND_API_KEY, NOTIFY_FROM_EMAIL, NOTIFY_TO_EMAILS, PUBLIC_SITE_URL)' };
  }

  const { text, html } = buildEmailContent(payload, siteUrl);

  const res = await fetch('https://api.resend.com/emails', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      from,
      to: toList,
      subject: `New post: ${payload.title}`,
      text,
      html,
    }),
  });

  if (!res.ok) {
    const err = await res.text();
    return { ok: false, error: `Resend API error: ${res.status} ${err}` };
  }

  const data = await res.json().catch(() => ({}));
  return { ok: true, data };
}

```

### gemini.ts

**Path:** `workers/src/lib/gemini.ts`

```typescript
/**
 * AI Content Generation Module
 *
 * 모든 AI 호출은 자체 백엔드 서버(ai-check.nodove.com)를 통해 처리됩니다.
 * 외부 API(Gemini 등)는 백엔드 서버에서 관리하며, Workers에서는 직접 호출하지 않습니다.
 *
 * 이 구조의 장점:
 * 1. API 키 관리 일원화 - 백엔드에서만 관리
 * 2. 비용 추적 용이 - 백엔드에서 모든 AI 호출 로깅
 * 3. 모델 전환 유연성 - 백엔드만 수정하면 됨
 * 4. 장애 대응 - 백엔드에서 폴백 로직 처리
 */

import type { Env } from '../types';
import { getAiServeUrl, getAiServeApiKey, getAiGatewayCallerKey } from './config';

export type GenerateOptions = {
  temperature?: number;
  maxTokens?: number;
};

/**
 * 백엔드 AI 서버를 통해 콘텐츠를 생성합니다.
 *
 * @param prompt - 생성할 프롬프트
 * @param env - Worker 환경 변수
 * @param options - 생성 옵션 (temperature, maxTokens)
 * @returns 생성된 텍스트
 * @throws 백엔드 서버 오류 시 예외 발생
 */
export async function generateContent(
  prompt: string,
  env: Env,
  options?: GenerateOptions
): Promise<string> {
  const temperature = options?.temperature ?? 0.2;
  const maxTokens = options?.maxTokens ?? 2048;

  // Get AI Serve URL from KV > env > default
  const base = await getAiServeUrl(env);
  const url = `${base.replace(/\/$/, '')}/api/v1/ai/generate`;

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    'User-Agent': 'Blog-Workers/1.0',
    'Accept': 'application/json',
  };
  const apiKey = await getAiServeApiKey(env);
  if (apiKey) {
    headers['X-API-KEY'] = apiKey;
  }
  // Add Gateway Caller Key for Workers-to-Workers calls through ai-check-gateway
  const gatewayCallerKey = await getAiGatewayCallerKey(env);
  if (gatewayCallerKey) {
    headers['X-Gateway-Caller-Key'] = gatewayCallerKey;
  }

  const res = await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify({ prompt, temperature, maxTokens }),
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => '');
    throw new Error(`Backend AI error: ${res.status} ${txt.slice(0, 200)}`);
  }

  const payload = (await res.json().catch(() => null)) as {
    text?: string;
    data?: { text?: string };
    ok?: boolean;
  } | null;

  // 다양한 응답 형식 지원
  const text = payload?.text || payload?.data?.text;
  if (!text) {
    throw new Error('No content in backend AI response');
  }
  return text;
}

/**
 * JSON 파싱 유틸리티
 * LLM 응답에서 JSON을 추출합니다.
 */
export function tryParseJson<T = unknown>(text: string): T | null {
  if (!text || typeof text !== 'string') return null;

  // 1. 직접 파싱 시도
  try {
    return JSON.parse(text) as T;
  } catch {
    // continue
  }

  // 2. ```json 코드블록 추출
  const fenceMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fenceMatch?.[1]) {
    try {
      return JSON.parse(fenceMatch[1].trim()) as T;
    } catch {
      // continue
    }
  }

  // 3. 첫 { ~ 마지막 } 서브스트링
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start >= 0 && end > start) {
    try {
      return JSON.parse(text.slice(start, end + 1)) as T;
    } catch {
      // continue
    }
  }

  return null;
}

```

### jwt.ts

**Path:** `workers/src/lib/jwt.ts`

```typescript
import type { Env, JwtPayload } from '../types';

// Simple HS256 JWT implementation for Cloudflare Workers
// Using Web Crypto API (available in Workers runtime)

const encoder = new TextEncoder();
const decoder = new TextDecoder();

function base64UrlEncode(data: Uint8Array): string {
  const base64 = btoa(String.fromCharCode(...data));
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

function base64UrlDecode(str: string): Uint8Array {
  str = str.replace(/-/g, '+').replace(/_/g, '/');
  while (str.length % 4) str += '=';
  const binary = atob(str);
  return Uint8Array.from(binary, (c) => c.charCodeAt(0));
}

async function hmacSign(message: string, secret: string): Promise<string> {
  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  );
  const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(message));
  return base64UrlEncode(new Uint8Array(signature));
}

export async function signJwt(payload: Omit<JwtPayload, 'iat' | 'exp'>, env: Env): Promise<string> {
  const now = Math.floor(Date.now() / 1000);
  const fullPayload: JwtPayload = {
    ...payload,
    iat: now,
    exp: now + 12 * 3600, // 12 hours
  };

  const header = { alg: 'HS256', typ: 'JWT' };
  const headerB64 = base64UrlEncode(encoder.encode(JSON.stringify(header)));
  const payloadB64 = base64UrlEncode(encoder.encode(JSON.stringify(fullPayload)));

  const message = `${headerB64}.${payloadB64}`;
  const signature = await hmacSign(message, env.JWT_SECRET);

  return `${message}.${signature}`;
}

export async function verifyJwt(token: string, env: Env): Promise<JwtPayload> {
  const parts = token.split('.');
  if (parts.length !== 3) throw new Error('Invalid token format');

  const [headerB64, payloadB64, signatureB64] = parts;
  const message = `${headerB64}.${payloadB64}`;

  // Verify signature
  const expectedSignature = await hmacSign(message, env.JWT_SECRET);
  if (signatureB64 !== expectedSignature) {
    throw new Error('Invalid signature');
  }

  // Decode payload
  const payloadJson = decoder.decode(base64UrlDecode(payloadB64!));
  const payload = JSON.parse(payloadJson) as JwtPayload;

  // Check expiration
  if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {
    throw new Error('Token expired');
  }

  return payload;
}

```

### llm.ts

**Path:** `workers/src/lib/llm.ts`

```typescript
/**
 * Unified LLM Service
 *
 * 모든 AI 호출은 자체 백엔드 서버를 통해 처리됩니다.
 * 외부 API(Gemini 등)는 백엔드 서버에서 관리합니다.
 */

import type { Env } from '../types';
import type { PromptConfig, TaskMode } from './prompts';
import { getFallbackData } from './prompts';
import { getApiBaseUrl, getAiServeApiKey, getAiServeUrl } from './config';

export type LLMRequest = {
  system?: string;
  user: string;
  temperature?: number;
  maxTokens?: number;
  responseFormat?: 'json' | 'text';
};

export type LLMResponse = {
  ok: boolean;
  text: string;
  parsed: unknown | null;
  source: 'backend';
  error?: string;
};

/**
 * JSON 파싱 유틸리티
 * LLM 응답에서 JSON을 추출합니다.
 */
export function tryParseJson<T = unknown>(text: string): T | null {
  if (!text || typeof text !== 'string') return null;

  // 1. 직접 파싱 시도
  try {
    return JSON.parse(text) as T;
  } catch {
    // continue to next method
  }

  // 2. ```json 코드블록 추출
  const fenceMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fenceMatch?.[1]) {
    try {
      return JSON.parse(fenceMatch[1].trim()) as T;
    } catch {
      // continue to next method
    }
  }

  // 3. 첫 { ~ 마지막 } 서브스트링
  const start = text.indexOf('{');
  const end = text.lastIndexOf('}');
  if (start >= 0 && end > start) {
    try {
      return JSON.parse(text.slice(start, end + 1)) as T;
    } catch {
      // continue to next method
    }
  }

  // 4. 첫 [ ~ 마지막 ] 서브스트링 (배열 응답용)
  const arrStart = text.indexOf('[');
  const arrEnd = text.lastIndexOf(']');
  if (arrStart >= 0 && arrEnd > arrStart) {
    try {
      return JSON.parse(text.slice(arrStart, arrEnd + 1)) as T;
    } catch {
      // failed
    }
  }

  return null;
}

/**
 * 백엔드 AI 서버 호출 (/ai/auto-chat 엔드포인트)
 * 대화형 AI 호출에 사용됩니다.
 */
async function callBackendAutoChat(
  request: LLMRequest,
  env: Env
): Promise<{ ok: boolean; text?: string; error?: string }> {
  const backendUrl = await getApiBaseUrl(env);
  const url = `${backendUrl.replace(/\/$/, '')}/api/v1/ai/auto-chat`;

  const message = request.system
    ? `${request.system}\n\n${request.user}`
    : request.user;

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  const apiKey = await getAiServeApiKey(env);
  if (apiKey) {
    headers['X-Internal-Gateway-Key'] = apiKey;
  }

  try {
    const res = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        messages: [{ role: 'user', content: message }],
        temperature: request.temperature,
      }),
    });

    if (!res.ok) {
      const errorText = await res.text().catch(() => '');
      return {
        ok: false,
        error: `Backend AI error: ${res.status} ${errorText.slice(0, 100)}`,
      };
    }

    const result = (await res.json()) as {
      ok?: boolean;
      data?: { text?: string; content?: string; response?: string };
      text?: string;
      content?: string;
      response?: string;
    };

    const text =
      result?.data?.text ||
      result?.data?.content ||
      result?.data?.response ||
      result?.text ||
      result?.content ||
      result?.response ||
      (typeof result === 'string' ? result : '');

    if (!text) {
      return { ok: false, error: 'No content in Backend AI response' };
    }

    return { ok: true, text };
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    return { ok: false, error: `Backend AI fetch failed: ${message}` };
  }
}

/**
 * 백엔드 AI 서버 호출 (/ai/generate 엔드포인트)
 * 단순 텍스트 생성에 사용됩니다.
 */
async function callBackendGenerate(
  request: LLMRequest,
  env: Env
): Promise<{ ok: boolean; text?: string; error?: string }> {
  const base = await getAiServeUrl(env);
  const url = `${base.replace(/\/$/, '')}/ai/generate`;

  const fullPrompt = request.system
    ? `${request.system}\n\n${request.user}`
    : request.user;

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  const apiKey = await getAiServeApiKey(env);
  if (apiKey) {
    headers['X-API-KEY'] = apiKey;
  }

  try {
    const res = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        prompt: fullPrompt,
        temperature: request.temperature,
        maxTokens: request.maxTokens,
      }),
    });

    if (!res.ok) {
      const errorText = await res.text().catch(() => '');
      return {
        ok: false,
        error: `Backend generate error: ${res.status} ${errorText.slice(0, 100)}`,
      };
    }

    const result = (await res.json()) as {
      text?: string;
      data?: { text?: string };
    };

    const text = result?.text || result?.data?.text;
    if (!text) {
      return { ok: false, error: 'No content in backend generate response' };
    }

    return { ok: true, text };
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    return { ok: false, error: `Backend generate fetch failed: ${message}` };
  }
}

/**
 * 통합 LLM 호출 함수
 *
 * 모든 호출은 자체 백엔드 서버를 통해 처리됩니다.
 * 백엔드 서버가 내부적으로 적절한 AI 모델(Gemini, OpenAI 등)을 선택합니다.
 */
export async function callLLM(
  request: LLMRequest,
  env: Env
): Promise<LLMResponse> {
  // /ai/generate 엔드포인트 시도
  const result = await callBackendGenerate(request, env);

  if (result.ok && result.text) {
    const parsed =
      request.responseFormat === 'json' ? tryParseJson(result.text) : null;
    return {
      ok: true,
      text: result.text,
      parsed,
      source: 'backend',
    };
  }

  // /ai/auto-chat 엔드포인트로 폴백 시도
  console.warn('Backend generate failed, trying auto-chat:', result.error);
  const autoChatResult = await callBackendAutoChat(request, env);

  if (autoChatResult.ok && autoChatResult.text) {
    const parsed =
      request.responseFormat === 'json'
        ? tryParseJson(autoChatResult.text)
        : null;
    return {
      ok: true,
      text: autoChatResult.text,
      parsed,
      source: 'backend',
    };
  }

  // 모든 시도 실패
  return {
    ok: false,
    text: '',
    parsed: null,
    source: 'backend',
    error:
      result.error || autoChatResult.error || 'Backend AI server unavailable',
  };
}

/**
 * Task 모드용 LLM 호출 함수
 * PromptConfig를 받아서 LLM을 호출하고 결과를 반환합니다.
 */
export async function callTaskLLM(
  promptConfig: PromptConfig,
  env: Env
): Promise<LLMResponse> {
  return callLLM({
    system: promptConfig.system,
    user: promptConfig.user,
    temperature: promptConfig.temperature,
    maxTokens: promptConfig.maxTokens,
    responseFormat: 'json',
  }, env);
}

/**
 * Task 실행 함수
 * 프롬프트 생성부터 LLM 호출, 폴백 처리까지 전체 흐름을 담당합니다.
 */
export async function executeTask(
  mode: TaskMode,
  promptConfig: PromptConfig,
  payload: Record<string, unknown>,
  env: Env
): Promise<{ ok: boolean; data: unknown; source: string; error?: string }> {
  // LLM 호출
  const response = await callTaskLLM(promptConfig, env);

  if (response.ok && response.parsed) {
    return {
      ok: true,
      data: response.parsed,
      source: response.source,
    };
  }

  // 텍스트 응답이 있지만 파싱 실패한 경우
  if (response.ok && response.text) {
    // 한 번 더 파싱 시도
    const parsed = tryParseJson(response.text);
    if (parsed) {
      return {
        ok: true,
        data: parsed,
        source: response.source,
      };
    }
    
    // 파싱 실패 - raw 텍스트와 함께 반환
    console.warn('LLM response parsing failed, using raw text');
    return {
      ok: true,
      data: { _raw: response.text },
      source: response.source,
    };
  }

  // 완전 실패 - 폴백 데이터 사용
  console.error('LLM call failed, using fallback data:', response.error);
  return {
    ok: false,
    data: getFallbackData(mode, payload as any),
    source: 'fallback',
    error: response.error,
  };
}

```

### prompts.ts

**Path:** `workers/src/lib/prompts.ts`

```typescript
/**
 * Prompt Factory for AI Tasks
 * 
 * 모든 AI 프롬프트를 중앙에서 관리합니다.
 * 프론트엔드는 mode와 payload만 전송하고, 실제 프롬프트는 여기서 생성됩니다.
 */

// Local type definitions (avoiding external dependency for workers isolation)
export type TaskMode = 'sketch' | 'prism' | 'chain' | 'catalyst' | 'summary' | 'custom';

export interface TaskPayload {
  paragraph?: string;
  content?: string;
  postTitle?: string;
  title?: string;
  persona?: string;
  prompt?: string;
  [key: string]: unknown;
}

export type PromptConfig = {
  system: string;
  user: string;
  temperature: number;
  maxTokens: number;
  schema?: JsonSchema;
};

export type JsonSchema = {
  type: string;
  properties?: Record<string, unknown>;
  required?: string[];
  items?: unknown;
};

// 공통 시스템 프롬프트
const COMMON_SYSTEM = `You are a helpful AI assistant for a blog platform.
Always respond in the same language as the input text.
Return STRICT JSON matching the schema provided. Do not include markdown code blocks.`;

/**
 * 텍스트를 안전하게 잘라냅니다.
 */
function safeTruncate(s: string | undefined | null, maxLength: number): string {
  if (!s) return '';
  if (s.length <= maxLength) return s;
  return `${s.slice(0, maxLength)}\n...(truncated)`;
}

/**
 * 모드별 JSON 스키마 정의
 */
const SCHEMAS: Record<string, JsonSchema> = {
  sketch: {
    type: 'object',
    properties: {
      mood: { type: 'string' },
      bullets: { type: 'array', items: { type: 'string' } },
    },
    required: ['mood', 'bullets'],
  },
  prism: {
    type: 'object',
    properties: {
      facets: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            title: { type: 'string' },
            points: { type: 'array', items: { type: 'string' } },
          },
          required: ['title', 'points'],
        },
      },
    },
    required: ['facets'],
  },
  chain: {
    type: 'object',
    properties: {
      questions: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            q: { type: 'string' },
            why: { type: 'string' },
          },
          required: ['q', 'why'],
        },
      },
    },
    required: ['questions'],
  },
  summary: {
    type: 'object',
    properties: {
      summary: { type: 'string' },
      keyPoints: { type: 'array', items: { type: 'string' } },
    },
    required: ['summary'],
  },
};

/**
 * 모드별 temperature 설정
 */
export function getTemperature(mode: TaskMode): number {
  switch (mode) {
    case 'sketch':
      return 0.3;
    case 'prism':
    case 'chain':
    case 'summary':
      return 0.2;
    case 'catalyst':
      return 0.4;
    default:
      return 0.3;
  }
}

/**
 * 모드별 maxTokens 설정
 */
export function getMaxTokens(mode: TaskMode): number {
  switch (mode) {
    case 'sketch':
      return 1024;
    case 'prism':
      return 1536;
    case 'chain':
      return 1024;
    case 'summary':
      return 2048;
    default:
      return 2048;
  }
}

/**
 * Sketch 모드 프롬프트 생성
 * 감정(mood)과 핵심 포인트(bullets)를 추출합니다.
 */
function buildSketchPrompt(payload: TaskPayload): PromptConfig {
  const paragraph = safeTruncate(payload.paragraph || payload.content, 2000);
  const postTitle = safeTruncate(payload.postTitle || payload.title, 120);
  const persona = payload.persona || 'default';

  const user = `Task: Capture the emotional sketch of the following text.

Context:
- Blog Post Title: "${postTitle}"
- Persona: ${persona}

Input Text:
"${paragraph}"

Instructions:
1. Identify the primary emotional tone (mood) in a single word (e.g., curious, excited, skeptical, reflective, hopeful)
2. Extract 3-6 key points as short bullet statements
3. Keep bullets concise (under 100 characters each)
4. Maintain the original language of the input text

Response Schema:
${JSON.stringify(SCHEMAS.sketch, null, 2)}`;

  return {
    system: COMMON_SYSTEM,
    user,
    temperature: getTemperature('sketch'),
    maxTokens: getMaxTokens('sketch'),
    schema: SCHEMAS.sketch,
  };
}

/**
 * Prism 모드 프롬프트 생성
 * 텍스트를 여러 관점(facets)에서 분석합니다.
 */
function buildPrismPrompt(payload: TaskPayload): PromptConfig {
  const paragraph = safeTruncate(payload.paragraph || payload.content, 2000);
  const postTitle = safeTruncate(payload.postTitle || payload.title, 120);

  const user = `Task: Analyze the following text from multiple perspectives (facets).

Context:
- Blog Post Title: "${postTitle}"

Input Text:
"${paragraph}"

Instructions:
1. Identify 2-3 distinct perspectives or angles to analyze the text
2. For each perspective, provide a clear title and 2-4 key points
3. Perspectives could include: core argument, implications, counterpoints, applications, etc.
4. Keep each point concise and insightful
5. Maintain the original language of the input text

Response Schema:
${JSON.stringify(SCHEMAS.prism, null, 2)}`;

  return {
    system: COMMON_SYSTEM,
    user,
    temperature: getTemperature('prism'),
    maxTokens: getMaxTokens('prism'),
    schema: SCHEMAS.prism,
  };
}

/**
 * Chain 모드 프롬프트 생성
 * 후속 질문을 생성합니다.
 */
function buildChainPrompt(payload: TaskPayload): PromptConfig {
  const paragraph = safeTruncate(payload.paragraph || payload.content, 2000);
  const postTitle = safeTruncate(payload.postTitle || payload.title, 120);

  const user = `Task: Generate follow-up questions to deepen understanding of the text.

Context:
- Blog Post Title: "${postTitle}"

Input Text:
"${paragraph}"

Instructions:
1. Generate 3-5 thought-provoking follow-up questions
2. Each question should explore a different aspect: assumptions, implications, applications, alternatives, or deeper meanings
3. For each question, briefly explain why it matters (the "why")
4. Questions should encourage critical thinking and further exploration
5. Maintain the original language of the input text

Response Schema:
${JSON.stringify(SCHEMAS.chain, null, 2)}`;

  return {
    system: COMMON_SYSTEM,
    user,
    temperature: getTemperature('chain'),
    maxTokens: getMaxTokens('chain'),
    schema: SCHEMAS.chain,
  };
}

/**
 * Summary 모드 프롬프트 생성
 */
function buildSummaryPrompt(payload: TaskPayload): PromptConfig {
  const content = safeTruncate(payload.paragraph || payload.content, 4000);
  const title = safeTruncate(payload.postTitle || payload.title, 120);

  const user = `Task: Summarize the following content concisely.

Context:
- Title: "${title}"

Content:
"${content}"

Instructions:
1. Provide a clear, concise summary (2-4 sentences)
2. Extract 3-5 key points
3. Maintain the original language

Response Schema:
${JSON.stringify(SCHEMAS.summary, null, 2)}`;

  return {
    system: COMMON_SYSTEM,
    user,
    temperature: getTemperature('summary'),
    maxTokens: getMaxTokens('summary'),
    schema: SCHEMAS.summary,
  };
}

/**
 * Custom/Catalyst 모드 프롬프트 생성
 * 사용자가 직접 프롬프트를 제공하는 경우
 */
function buildCustomPrompt(payload: TaskPayload): PromptConfig {
  const userPrompt = payload.prompt || payload.paragraph || payload.content || '';

  return {
    system: COMMON_SYSTEM,
    user: safeTruncate(userPrompt, 4000),
    temperature: getTemperature('custom'),
    maxTokens: getMaxTokens('custom'),
  };
}

/**
 * 메인 프롬프트 빌더 함수
 * mode에 따라 적절한 프롬프트를 생성합니다.
 */
export function buildTaskPrompt(mode: TaskMode, payload: TaskPayload): PromptConfig {
  switch (mode) {
    case 'sketch':
      return buildSketchPrompt(payload);
    case 'prism':
      return buildPrismPrompt(payload);
    case 'chain':
      return buildChainPrompt(payload);
    case 'summary':
      return buildSummaryPrompt(payload);
    case 'catalyst':
    case 'custom':
    default:
      return buildCustomPrompt(payload);
  }
}

/**
 * 모드가 유효한지 검증합니다.
 */
export function isValidTaskMode(mode: string): mode is TaskMode {
  return ['sketch', 'prism', 'chain', 'catalyst', 'summary', 'custom'].includes(mode);
}

/**
 * 모드별 기본 폴백 데이터
 * LLM 호출 실패 시 사용
 */
export function getFallbackData(mode: TaskMode, payload: TaskPayload): unknown {
  const paragraph = payload.paragraph || payload.content || '';
  
  switch (mode) {
    case 'sketch':
      // 문장 분리하여 bullets로 사용
      const sentences = paragraph
        .replace(/\n+/g, ' ')
        .split(/[.!?]\s+/)
        .map(s => s.trim())
        .filter(s => s.length > 10)
        .slice(0, 4);
      return {
        mood: 'reflective',
        bullets: sentences.length > 0 
          ? sentences.map(s => s.length > 100 ? `${s.slice(0, 98)}...` : s)
          : ['내용을 분석하는 중 오류가 발생했습니다.'],
      };

    case 'prism':
      return {
        facets: [
          {
            title: '핵심 요점',
            points: [paragraph.slice(0, 140) || '분석 중 오류 발생'],
          },
          {
            title: '생각해볼 점',
            points: ['다양한 관점에서 검토 필요', '추가 맥락 확인 권장'],
          },
        ],
      };

    case 'chain':
      return {
        questions: [
          { q: '이 주장의 핵심 근거는 무엇인가?', why: '논리적 기반 확인' },
          { q: '어떤 전제나 가정이 깔려 있는가?', why: '숨겨진 전제 파악' },
          { q: '실제로 어떻게 적용할 수 있는가?', why: '실용적 가치 탐색' },
        ],
      };

    case 'summary':
      return {
        summary: paragraph.slice(0, 200) || '요약을 생성할 수 없습니다.',
        keyPoints: ['원본 텍스트를 확인해주세요.'],
      };

    default:
      return { error: 'Fallback not available for this mode' };
  }
}

```

### response.ts

**Path:** `workers/src/lib/response.ts`

```typescript
import { Context } from 'hono';
import type { ContentfulStatusCode } from 'hono/utils/http-status';
import type { ApiResponse } from '../types';

export function success<T>(c: Context, data: T, status: ContentfulStatusCode = 200) {
  return c.json<ApiResponse<T>>({ ok: true, data }, { status });
}

export function error(
  c: Context,
  message: string,
  status: ContentfulStatusCode = 500,
  code?: string
) {
  return c.json<ApiResponse>(
    {
      ok: false,
      error: { message, code },
    },
    { status }
  );
}

export function notFound(c: Context, message = 'Not Found') {
  return error(c, message, 404, 'NOT_FOUND');
}

export function badRequest(c: Context, message: string) {
  return error(c, message, 400, 'BAD_REQUEST');
}

export function unauthorized(c: Context, message = 'Unauthorized') {
  return error(c, message, 401, 'UNAUTHORIZED');
}

export function forbidden(c: Context, message = 'Forbidden') {
  return error(c, message, 403, 'FORBIDDEN');
}

export function conflict(c: Context, message: string) {
  return error(c, message, 409, 'CONFLICT');
}

export function serverError(c: Context, message = 'Internal Server Error') {
  return error(c, message, 500, 'INTERNAL_ERROR');
}

```

---

## workers/src/middleware

### auth.ts

**Path:** `workers/src/middleware/auth.ts`

```typescript
import { Context, Next } from 'hono';
import type { Env } from '../types';
import { verifyJwt } from '../lib/jwt';
import { unauthorized } from '../lib/response';

export async function requireAuth(c: Context, next: Next) {
  const env = c.env as Env;
  const authHeader = c.req.header('Authorization');

  if (!authHeader) {
    return unauthorized(c, 'Missing Authorization header');
  }

  const token = authHeader.replace(/^Bearer\s+/i, '').trim();
  if (!token) {
    return unauthorized(c, 'Invalid Authorization header format');
  }

  try {
    const payload = await verifyJwt(token, env);
    // Store user info in context for downstream handlers
    c.set('user', payload);
    await next();
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Invalid token';
    return unauthorized(c, message);
  }
}

export async function requireAdmin(c: Context, next: Next) {
  const env = c.env as Env;
  const authHeader = c.req.header('Authorization');

  if (!authHeader) {
    return unauthorized(c, 'Missing Authorization header');
  }

  const token = authHeader.replace(/^Bearer\s+/i, '').trim();
  if (!token) {
    return unauthorized(c, 'Invalid Authorization header format');
  }

  try {
    const payload = await verifyJwt(token, env);
    if (payload.role !== 'admin') {
      return unauthorized(c, 'Admin role required');
    }
    c.set('user', payload);
    await next();
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Invalid token';
    return unauthorized(c, message);
  }
}

```

### cors.ts

**Path:** `workers/src/middleware/cors.ts`

```typescript
import { Context, Next } from 'hono';
import { setCorsHeaders } from '../lib/cors';

export async function corsMiddleware(c: Context, next: Next) {
  const origin = c.req.header('Origin');

  // Handle preflight
  if (c.req.method === 'OPTIONS') {
    setCorsHeaders(c, origin);
    return c.body(null, 204);
  }

  // Set CORS headers for actual requests
  setCorsHeaders(c, origin);
  await next();
}

```

### error.ts

**Path:** `workers/src/middleware/error.ts`

```typescript
import { Context } from 'hono';
import type { ContentfulStatusCode } from 'hono/utils/http-status';
import { error } from '../lib/response';

const isContentfulStatus = (value: number): value is ContentfulStatusCode => {
  if (!Number.isInteger(value)) return false;
  return value !== 101 && value !== 204 && value !== 205 && value !== 304;
};

export function errorHandler(err: Error, c: Context) {
  console.error('Unhandled error:', {
    message: err.message,
    stack: err.stack,
    requestId: c.get('requestId'),
  });

  const rawStatus = (err as { status?: number }).status;
  const status: ContentfulStatusCode = rawStatus && isContentfulStatus(rawStatus) ? rawStatus : 500;
  return error(c, err.message || 'Internal Server Error', status);
}

```

### logger.ts

**Path:** `workers/src/middleware/logger.ts`

```typescript
import { Context, Next } from 'hono';

export async function loggerMiddleware(c: Context, next: Next) {
  const start = Date.now();
  const requestId = crypto.randomUUID();
  const method = c.req.method;
  const path = c.req.path;

  // Store request ID for downstream use
  c.set('requestId', requestId);

  await next();

  const duration = Date.now() - start;
  const status = c.res.status;

  // Structured logging
  console.log(
    JSON.stringify({
      requestId,
      method,
      path,
      status,
      duration,
      timestamp: new Date().toISOString(),
    })
  );
}

```

---

## workers/src/routes

### ai.ts

**Path:** `workers/src/routes/ai.ts`

```typescript
import { Hono } from 'hono';
import type { Env } from '../types';
import { success, badRequest } from '../lib/response';
import { createAIService, tryParseJson } from '../lib/ai-service';
import type { TaskMode, TaskPayload } from '../lib/prompts';

const ai = new Hono<{ Bindings: Env }>();

// ============================================================================
// Task Endpoints (sketch, prism, chain)
// ============================================================================

// POST /ai/sketch - Generate emotional sketch from paragraph
ai.post('/sketch', async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { paragraph, postTitle, persona } = body;

  if (!paragraph || typeof paragraph !== 'string') {
    return badRequest(c, 'paragraph is required');
  }

  const aiService = createAIService(c.env);
  const result = await aiService.task('sketch', { paragraph, postTitle, persona });

  if (!result.ok) {
    return badRequest(c, result.error || 'AI task failed');
  }
  return success(c, result.data);
});

// POST /ai/prism - Generate idea facets
ai.post('/prism', async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { paragraph, postTitle } = body;

  if (!paragraph || typeof paragraph !== 'string') {
    return badRequest(c, 'paragraph is required');
  }

  const aiService = createAIService(c.env);
  const result = await aiService.task('prism', { paragraph, postTitle });

  if (!result.ok) {
    return badRequest(c, result.error || 'AI task failed');
  }
  return success(c, result.data);
});

// POST /ai/chain - Generate follow-up questions
ai.post('/chain', async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { paragraph, postTitle } = body;

  if (!paragraph || typeof paragraph !== 'string') {
    return badRequest(c, 'paragraph is required');
  }

  const aiService = createAIService(c.env);
  const result = await aiService.task('chain', { paragraph, postTitle });

  if (!result.ok) {
    return badRequest(c, result.error || 'AI task failed');
  }
  return success(c, result.data);
});

// ============================================================================
// Generate Endpoints
// ============================================================================

// POST /ai/generate - Generic AI generation
ai.post('/generate', async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { prompt, temperature } = body;

  if (!prompt || typeof prompt !== 'string') {
    return badRequest(c, 'prompt is required');
  }

  const aiService = createAIService(c.env);
  try {
    const text = await aiService.generate(prompt, {
      temperature: typeof temperature === 'number' ? temperature : 0.2,
    });
    return success(c, { text });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'AI generation failed';
    return badRequest(c, message);
  }
});

// GET /ai/generate/stream - SSE streaming tokens
ai.get('/generate/stream', async (c) => {
  const url = new URL(c.req.url);
  const q = (
    url.searchParams.get('prompt') ||
    url.searchParams.get('q') ||
    url.searchParams.get('text') ||
    ''
  ).toString();
  const t = Number(url.searchParams.get('temperature'));
  const temperature = Number.isFinite(t) ? t : 0.2;

  const headers = new Headers({
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache, no-transform',
    Connection: 'keep-alive',
    'X-Accel-Buffering': 'no',
  });

  const encoder = new TextEncoder();
  function frame(event?: string, data?: unknown): Uint8Array {
    let lines = '';
    if (event && event.trim()) lines += `event: ${event}\n`;
    if (data !== undefined) {
      const payload = typeof data === 'string' ? data : JSON.stringify(data);
      for (const line of String(payload).split(/\n/)) {
        lines += `data: ${line}\n`;
      }
    }
    lines += '\n';
    return encoder.encode(lines);
  }

  if (!q) {
    // Respond with a minimal SSE error stream
    const stream = new ReadableStream<Uint8Array>({
      start(controller) {
        controller.enqueue(frame('error', { message: 'prompt is required' }));
        controller.close();
      },
    });
    return new Response(stream, { headers, status: 400 });
  }

  const aiService = createAIService(c.env);

  const stream = new ReadableStream<Uint8Array>({
    async start(controller) {
      try {
        controller.enqueue(frame('open', { type: 'open' }));

        // Generate once then chunk to simulate token stream
        const text = await aiService.generate(String(q), { temperature });

        const chunkSize = 80;
        for (let i = 0; i < text.length; i += chunkSize) {
          const token = text.slice(i, Math.min(i + chunkSize, text.length));
          controller.enqueue(frame('token', { token }));
          // Small delay helps UX without overloading event loop
          await new Promise((r) => setTimeout(r, 25));
        }

        controller.enqueue(frame('done', { type: 'done' }));
      } catch (err) {
        const message = err instanceof Error ? err.message : 'generation failed';
        controller.enqueue(frame('error', { message }));
      } finally {
        try {
          controller.close();
        } catch {}
      }
    },
  });

  return new Response(stream, { headers, status: 200 });
});

// ============================================================================
// Summarize Endpoint
// ============================================================================

// POST /ai/summarize - Summarize article with memo
ai.post('/summarize', async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { input, text, instructions } = body;
  const content = input || text;

  if (!content || typeof content !== 'string') {
    return badRequest(c, 'input or text is required');
  }

  const aiService = createAIService(c.env);
  const result = await aiService.summarize(content, { instructions });

  return success(c, result);
});

// ============================================================================
// Chat Endpoint
// ============================================================================

// POST /ai/auto-chat - Chat completion
ai.post('/auto-chat', async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { messages, temperature, maxTokens } = body;

  if (!messages || !Array.isArray(messages) || messages.length === 0) {
    return badRequest(c, 'messages array is required');
  }

  const aiService = createAIService(c.env);
  try {
    const result = await aiService.chat(messages, { temperature, maxTokens });
    return success(c, {
      content: result.content,
      model: result.model,
      provider: result.provider,
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Chat failed';
    return badRequest(c, message);
  }
});

// ============================================================================
// Vision Endpoint
// ============================================================================

// POST /ai/vision/analyze - Vision analysis
ai.post('/vision/analyze', async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { imageUrl, imageBase64, mimeType, prompt } = body;

  if (!imageBase64 && !imageUrl) {
    return badRequest(c, 'imageBase64 or imageUrl is required');
  }

  const aiService = createAIService(c.env);
  try {
    // If URL provided, we need to fetch and convert (or let backend handle it)
    const imageData = imageBase64 || imageUrl;
    const description = await aiService.vision(imageData, prompt || 'Describe this image', {
      mimeType: mimeType || 'image/jpeg',
    });
    return success(c, { description });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Vision analysis failed';
    return badRequest(c, message);
  }
});

// ============================================================================
// Health & Status Endpoints
// ============================================================================

// GET /ai/health - Health check
ai.get('/health', async (c) => {
  const aiService = createAIService(c.env);
  const health = await aiService.health();

  return success(c, {
    status: health.ok ? 'healthy' : 'degraded',
    provider: health.provider,
    backend: health.status,
    timestamp: new Date().toISOString(),
  });
});

// GET /ai/status - Status check
ai.get('/status', async (c) => {
  const aiService = createAIService(c.env);
  const info = await aiService.getProviderInfo();
  const health = await aiService.health();

  return success(c, {
    status: health.ok ? 'ok' : 'degraded',
    provider: info.provider,
    features: info.features,
    timestamp: new Date().toISOString(),
  });
});

export default ai;

```

### analytics.ts

**Path:** `workers/src/routes/analytics.ts`

```typescript
import { Hono } from 'hono';
import type { Env, PostStats, EditorPick } from '../types';
import { queryOne, queryAll, execute } from '../lib/d1';
import { success, error } from '../lib/response';

const app = new Hono<{ Bindings: Env }>();

/**
 * POST /api/v1/analytics/view
 * Record a view for a post
 */
app.post('/view', async (c) => {
  try {
    const body = await c.req.json<{ year: string; slug: string }>();
    const { year, slug } = body;

    if (!year || !slug) {
      return error(c, 'year and slug are required', 400);
    }

    const today = new Date().toISOString().split('T')[0];
    const db = c.env.DB;

    // Upsert daily view count
    await execute(
      db,
      `INSERT INTO post_views (post_slug, year, view_date, view_count)
       VALUES (?, ?, ?, 1)
       ON CONFLICT(post_slug, year, view_date)
       DO UPDATE SET view_count = view_count + 1, updated_at = datetime('now')`,
      slug,
      year,
      today
    );

    // Update aggregated stats
    const existingStats = await queryOne<PostStats>(
      db,
      `SELECT * FROM post_stats WHERE post_slug = ? AND year = ?`,
      slug,
      year
    );

    if (existingStats) {
      // Update existing stats
      await execute(
        db,
        `UPDATE post_stats
         SET total_views = total_views + 1,
             last_viewed_at = datetime('now'),
             updated_at = datetime('now')
         WHERE post_slug = ? AND year = ?`,
        slug,
        year
      );
    } else {
      // Create new stats record
      await execute(
        db,
        `INSERT INTO post_stats (post_slug, year, total_views, last_viewed_at)
         VALUES (?, ?, 1, datetime('now'))`,
        slug,
        year
      );
    }

    return success(c, { recorded: true });
  } catch (err) {
    console.error('Failed to record view:', err);
    return error(c, 'Failed to record view', 500);
  }
});

/**
 * GET /api/v1/analytics/stats/:year/:slug
 * Get stats for a specific post
 */
app.get('/stats/:year/:slug', async (c) => {
  try {
    const { year, slug } = c.req.param();
    const db = c.env.DB;

    const stats = await queryOne<PostStats>(
      db,
      `SELECT * FROM post_stats WHERE post_slug = ? AND year = ?`,
      slug,
      year
    );

    return success(c, {
      stats: stats || { total_views: 0, views_7d: 0, views_30d: 0 },
    });
  } catch (err) {
    console.error('Failed to get stats:', err);
    return error(c, 'Failed to get stats', 500);
  }
});

/**
 * GET /api/v1/analytics/editor-picks
 * Get active editor picks
 */
app.get('/editor-picks', async (c) => {
  try {
    const db = c.env.DB;
    const limit = parseInt(c.req.query('limit') || '3');

    const picks = await queryAll<EditorPick>(
      db,
      `SELECT * FROM editor_picks
       WHERE is_active = 1
         AND (expires_at IS NULL OR expires_at > datetime('now'))
       ORDER BY rank ASC
       LIMIT ?`,
      limit
    );

    return success(c, { picks });
  } catch (err) {
    console.error('Failed to get editor picks:', err);
    return error(c, 'Failed to get editor picks', 500);
  }
});

/**
 * GET /api/v1/analytics/trending
 * Get trending posts based on recent views
 */
app.get('/trending', async (c) => {
  try {
    const db = c.env.DB;
    const limit = parseInt(c.req.query('limit') || '5');
    const days = parseInt(c.req.query('days') || '7');

    const sinceDate = new Date();
    sinceDate.setDate(sinceDate.getDate() - days);
    const sinceDateStr = sinceDate.toISOString().split('T')[0];

    const trending = await queryAll<{
      post_slug: string;
      year: string;
      recent_views: number;
      total_views: number;
    }>(
      db,
      `SELECT
         pv.post_slug,
         pv.year,
         SUM(pv.view_count) as recent_views,
         COALESCE(ps.total_views, 0) as total_views
       FROM post_views pv
       LEFT JOIN post_stats ps ON pv.post_slug = ps.post_slug AND pv.year = ps.year
       WHERE pv.view_date >= ?
       GROUP BY pv.post_slug, pv.year
       ORDER BY recent_views DESC
       LIMIT ?`,
      sinceDateStr,
      limit
    );

    return success(c, { trending });
  } catch (err) {
    console.error('Failed to get trending:', err);
    return error(c, 'Failed to get trending', 500);
  }
});

/**
 * POST /api/v1/analytics/refresh-stats
 * Refresh 7d and 30d view counts (should be called by cron)
 */
app.post('/refresh-stats', async (c) => {
  try {
    const db = c.env.DB;

    const now = new Date();
    const date7d = new Date(now);
    date7d.setDate(date7d.getDate() - 7);
    const date30d = new Date(now);
    date30d.setDate(date30d.getDate() - 30);

    const date7dStr = date7d.toISOString().split('T')[0];
    const date30dStr = date30d.toISOString().split('T')[0];

    // Get all posts with views
    const allPosts = await queryAll<{ post_slug: string; year: string }>(
      db,
      `SELECT DISTINCT post_slug, year FROM post_stats`
    );

    for (const post of allPosts) {
      // Calculate 7d views
      const views7d = await queryOne<{ cnt: number }>(
        db,
        `SELECT COALESCE(SUM(view_count), 0) as cnt
         FROM post_views
         WHERE post_slug = ? AND year = ? AND view_date >= ?`,
        post.post_slug,
        post.year,
        date7dStr
      );

      // Calculate 30d views
      const views30d = await queryOne<{ cnt: number }>(
        db,
        `SELECT COALESCE(SUM(view_count), 0) as cnt
         FROM post_views
         WHERE post_slug = ? AND year = ? AND view_date >= ?`,
        post.post_slug,
        post.year,
        date30dStr
      );

      await execute(
        db,
        `UPDATE post_stats
         SET views_7d = ?, views_30d = ?, updated_at = datetime('now')
         WHERE post_slug = ? AND year = ?`,
        views7d?.cnt || 0,
        views30d?.cnt || 0,
        post.post_slug,
        post.year
      );
    }

    return success(c, { refreshed: allPosts.length });
  } catch (err) {
    console.error('Failed to refresh stats:', err);
    return error(c, 'Failed to refresh stats', 500);
  }
});

/**
 * POST /api/v1/analytics/update-editor-picks
 * Auto-update editor picks based on analytics (should be called by cron daily)
 */
app.post('/update-editor-picks', async (c) => {
  try {
    const db = c.env.DB;

    // Scoring algorithm:
    // - 50% weight on 7-day views (recency)
    // - 30% weight on 30-day views (sustained interest)
    // - 20% weight on total views (evergreen content)
    const topPosts = await queryAll<PostStats>(
      db,
      `SELECT *,
         (views_7d * 0.5 + views_30d * 0.3 + total_views * 0.2) as score
       FROM post_stats
       WHERE total_views > 0
       ORDER BY score DESC
       LIMIT 10`
    );

    if (topPosts.length === 0) {
      return success(c, { message: 'No posts with views found' });
    }

    // Deactivate all current picks
    await execute(db, `UPDATE editor_picks SET is_active = 0, updated_at = datetime('now')`);

    // Calculate tomorrow as expiry date
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 1);
    expiresAt.setHours(6, 0, 0, 0); // Expire at 6 AM next day
    const expiresAtStr = expiresAt.toISOString();

    // Insert/update top 3 picks
    const topPicks = topPosts.slice(0, 3);
    for (let i = 0; i < topPicks.length; i++) {
      const postItem = topPicks[i];
      if (!postItem) continue;
      const score =
        postItem.views_7d * 0.5 + postItem.views_30d * 0.3 + postItem.total_views * 0.2;

      // Determine reason
      let reason = 'Popular post';
      if (postItem.views_7d > postItem.views_30d * 0.5) {
        reason = 'Trending this week';
      } else if (postItem.total_views > 100) {
        reason = 'Evergreen favorite';
      }

      await execute(
        db,
        `INSERT INTO editor_picks (post_slug, year, title, rank, score, reason, expires_at, is_active)
         VALUES (?, ?, ?, ?, ?, ?, ?, 1)
         ON CONFLICT(post_slug, year)
         DO UPDATE SET
           rank = ?,
           score = ?,
           reason = ?,
           expires_at = ?,
           is_active = 1,
           picked_at = datetime('now'),
           updated_at = datetime('now')`,
        postItem.post_slug,
        postItem.year,
        '', // title will be filled by frontend
        i + 1,
        score,
        reason,
        expiresAtStr,
        i + 1,
        score,
        reason,
        expiresAtStr
      );
    }

    return success(c, {
      updated: topPicks.length,
      picks: topPicks.map((p, i) => ({
        rank: i + 1,
        slug: p.post_slug,
        year: p.year,
        score: p.views_7d * 0.5 + p.views_30d * 0.3 + p.total_views * 0.2,
      })),
    });
  } catch (err) {
    console.error('Failed to update editor picks:', err);
    return error(c, 'Failed to update editor picks', 500);
  }
});

export default app;

```

### auth.ts

**Path:** `workers/src/routes/auth.ts`

```typescript
import { Hono } from 'hono';
import type { Env } from '../types';
import { success, badRequest, unauthorized } from '../lib/response';
import { signJwt, verifyJwt } from '../lib/jwt';

const auth = new Hono<{ Bindings: Env }>();

// POST /auth/login
auth.post('/login', async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { username, password } = body;

  if (!username || !password) {
    return badRequest(c, 'username and password required');
  }

  // For migration compatibility, check env vars first
  // TODO: After migration, check D1 users table
  const adminUsername = c.env.ADMIN_USERNAME;
  const adminPassword = c.env.ADMIN_PASSWORD;

  if (!adminUsername || !adminPassword) {
    return unauthorized(c, 'Authentication not configured');
  }

  if (username !== adminUsername || password !== adminPassword) {
    return unauthorized(c, 'Invalid credentials');
  }

  const token = await signJwt(
    {
      sub: 'admin',
      role: 'admin',
      username: adminUsername,
    },
    c.env
  );

  return success(c, { token });
});

// GET /auth/me
auth.get('/me', async (c) => {
  const authHeader = c.req.header('Authorization');
  if (!authHeader) {
    return unauthorized(c, 'Missing Authorization header');
  }

  const token = authHeader.replace(/^Bearer\s+/i, '').trim();
  if (!token) {
    return unauthorized(c, 'Invalid Authorization format');
  }

  try {
    const claims = await verifyJwt(token, c.env);
    return success(c, { claims });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unauthorized';
    return unauthorized(c, message);
  }
});

export default auth;

```

### chat.ts

**Path:** `workers/src/routes/chat.ts`

```typescript
/**
 * Chat Routes
 * 
 * 챗봇 및 Inline AI Task(sketch/prism/chain) 처리를 담당합니다.
 * 
 * 엔드포인트:
 * - POST /session - 새 세션 생성 (프록시)
 * - POST /session/:id/message - 챗봇 메시지 (프록시, SSE 지원)
 * - POST /session/:id/task - Inline AI Task (서버 사이드 프롬프트 생성)
 * - POST /aggregate - 통합 질문 처리
 */

import { Hono } from 'hono';
import type { Context } from 'hono';
import type { Env } from '../types';
import { generateContent } from '../lib/gemini';
import { success, badRequest, error } from '../lib/response';
import { 
  buildTaskPrompt, 
  isValidTaskMode, 
  getFallbackData,
  type TaskMode, 
  type TaskPayload 
} from '../lib/prompts';
import { executeTask, tryParseJson } from '../lib/llm';
import { getAiServeUrl, getAiGatewayCallerKey } from '../lib/config';

type ChatContext = { Bindings: Env };

const chat = new Hono<ChatContext>();

/**
 * 업스트림 AI 서비스로 요청을 프록시합니다.
 * 챗봇 메시지(SSE 스트리밍) 및 세션 생성에 사용됩니다.
 */
async function proxyRequest(c: Context<ChatContext>, path: string) {
  // Get AI Serve URL from KV > env > default
  const aiServeBaseUrl = await getAiServeUrl(c.env);
  const upstreamUrl = `${aiServeBaseUrl}${path}`;

  const upstreamHeaders = new Headers(c.req.raw.headers);
  upstreamHeaders.delete('host');

  // Get gateway caller key from KV > env
  const gatewayCallerKey = await getAiGatewayCallerKey(c.env);
  if (gatewayCallerKey) {
    upstreamHeaders.set('X-Gateway-Caller-Key', gatewayCallerKey);
  }
  if (c.env.OPENCODE_AUTH_TOKEN) {
    upstreamHeaders.set('Authorization', `Bearer ${c.env.OPENCODE_AUTH_TOKEN}`);
  } else if (c.env.GITHUB_TOKEN) {
    upstreamHeaders.set('Authorization', `Bearer ${c.env.GITHUB_TOKEN}`);
  }

  const upstreamRequest = new Request(upstreamUrl, {
    method: c.req.method,
    headers: upstreamHeaders,
    body: c.req.raw.body,
    redirect: 'manual',
  });

  const upstreamResponse = await fetch(upstreamRequest);

  const headers = new Headers(upstreamResponse.headers);
  headers.set('Access-Control-Allow-Origin', '*');
  headers.set('Access-Control-Allow-Headers', '*');

  return new Response(upstreamResponse.body, {
    status: upstreamResponse.status,
    headers,
  });
}

/**
 * POST /session - 새 세션 생성
 * 업스트림 서비스로 프록시합니다.
 */
chat.post('/session', async (c: Context<ChatContext>) => {
  return proxyRequest(c, '/session');
});

/**
 * POST /session/:sessionId/message - 챗봇 메시지
 * SSE 스트리밍을 지원하며, 업스트림 서비스로 프록시합니다.
 */
chat.post('/session/:sessionId/message', async (c: Context<ChatContext>) => {
  const { sessionId } = c.req.param();
  return proxyRequest(c, `/session/${sessionId}/message`);
});

/**
 * POST /session/:sessionId/task - Inline AI Task 실행
 * 
 * sketch, prism, chain 등의 AI 작업을 처리합니다.
 * 프론트엔드는 mode와 payload만 전송하고, 프롬프트는 서버에서 생성합니다.
 * 
 * Request Body:
 * {
 *   mode: 'sketch' | 'prism' | 'chain' | 'catalyst' | 'summary' | 'custom',
 *   payload: { paragraph, postTitle, persona, ... },
 *   context?: { url, title }
 * }
 * 
 * Response:
 * {
 *   ok: true,
 *   data: { ... },  // 모드별 결과
 *   mode: string,
 *   source: 'ai-call' | 'gemini' | 'fallback'
 * }
 */
chat.post('/session/:sessionId/task', async (c: Context<ChatContext>) => {
  const body = await c.req.json().catch(() => ({}));
  const { mode, payload, context, prompt: legacyPrompt } = body as {
    mode?: string;
    payload?: TaskPayload;
    context?: { url?: string; title?: string };
    prompt?: string; // 하위 호환성을 위해 유지
  };

  // 모드 검증
  const taskMode: TaskMode = isValidTaskMode(mode || '') ? mode as TaskMode : 'custom';
  const taskPayload: TaskPayload = payload || {};

  // 하위 호환성: 프론트엔드가 아직 prompt를 보내는 경우
  // 새로운 프론트엔드는 payload만 보내므로, legacyPrompt가 있으면 custom 모드로 처리
  if (legacyPrompt && legacyPrompt.trim() && taskMode === 'custom') {
    taskPayload.prompt = legacyPrompt;
  }

  // payload 검증
  const content = taskPayload.paragraph || taskPayload.content || taskPayload.prompt || '';
  if (!content.trim()) {
    return badRequest(c, 'No content provided for task');
  }

  try {
    // 서버 사이드 프롬프트 생성
    const promptConfig = buildTaskPrompt(taskMode, taskPayload);

    // 통합 LLM 레이어를 통해 실행
    const result = await executeTask(taskMode, promptConfig, taskPayload, c.env);

    if (result.ok) {
      return success(c, {
        data: result.data,
        mode: taskMode,
        source: result.source,
      });
    } else {
      // 폴백 데이터 반환 (에러지만 200으로 응답)
      console.warn('Task execution failed, returning fallback:', result.error);
      return success(c, {
        data: result.data,
        mode: taskMode,
        source: 'fallback',
        _fallback: true,
      });
    }
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Task execution failed';
    console.error('Task error:', message);
    
    // 에러 시에도 폴백 데이터 반환 시도
    try {
      const fallbackData = getFallbackData(taskMode, taskPayload);
      return success(c, {
        data: fallbackData,
        mode: taskMode,
        source: 'fallback',
        _fallback: true,
        _error: message,
      });
    } catch {
      return error(c, message, 500, 'INTERNAL_ERROR');
    }
  }
});

/**
 * POST /aggregate - 통합 질문
 * 여러 세션의 요약을 받아 하나의 통합된 답변을 생성합니다.
 */
chat.post('/aggregate', async (c: Context<ChatContext>) => {
  const body = await c.req.json().catch(() => ({}));
  const { prompt } = body as { prompt?: string };

  if (!prompt || typeof prompt !== 'string' || !prompt.trim()) {
    return badRequest(c, 'prompt is required');
  }

  const systemPrompt = [
    '다음 입력에는 여러 대화 세션의 요약과 사용자의 통합 질문이 함께 포함되어 있습니다.',
    '먼저 세션 요약들을 충분히 이해한 뒤, 사용자의 요청에 따라 전체를 한 번에 통합하여 답변해 주세요.',
    '- 공통된 핵심 아이디어',
    '- 서로 다른 관점이나 긴장 지점',
    '- 다음 액션/실천 아이디어',
    '를 중심으로 한국어로 정리해 주세요.',
    '',
    '---',
    '',
    prompt.trim(),
  ].join('\n');

  try {
    const text = await generateContent(systemPrompt, c.env, {
      temperature: 0.2,
    });
    return success(c, { text });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'aggregate failed';
    return error(c, message, 500, 'INTERNAL_ERROR');
  }
});

export default chat;

```

### comments.ts

**Path:** `workers/src/routes/comments.ts`

```typescript
import { Hono } from 'hono';
import type { Env, Comment } from '../types';
import { success, badRequest, notFound } from '../lib/response';
import { queryAll, execute, queryOne } from '../lib/d1';
import { requireAdmin } from '../middleware/auth';
import { isOriginAllowed } from '../lib/cors';

const comments = new Hono<{ Bindings: Env }>();

// GET /comments?postId=xxx - Get comments for a post
comments.get('/', async (c) => {
  const postId = c.req.query('postId');
  if (!postId) {
    return badRequest(c, 'postId is required');
  }

  const db = c.env.DB;
  const items = await queryAll<Comment>(
    db,
    `SELECT id, post_id, author, content, email, status, created_at, updated_at
     FROM comments
     WHERE post_id = ? AND status = 'visible'
     ORDER BY created_at ASC`,
    String(postId).trim().slice(0, 256)
  );

  // Normalize to camelCase and ensure date fallbacks
  const normalized = items.map(item => ({
    id: item.id,
    postId: (item as any).post_id || postId,
    author: item.author,
    content: item.content,
    email: item.email,
    status: item.status,
    createdAt: (item as any).created_at || new Date().toISOString(),
    updatedAt: (item as any).updated_at || new Date().toISOString(),
  }));

  return success(c, { comments: normalized });
});

// POST /comments - Create new comment
comments.post('/', async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { postId, author, content, email } = body as Record<string, string>;

  if (!postId || !author || !content) {
    return badRequest(c, 'postId, author, and content are required');
  }

  // Basic validation
  if (author.length > 64 || content.length > 5000) {
    return badRequest(c, 'Author or content too long');
  }

  const db = c.env.DB;

  // Use the provided postId directly as the canonical thread key
  const normalizedPostId = String(postId).trim().slice(0, 256);

  const commentId = `comment-${crypto.randomUUID()}`;
  const now = new Date().toISOString();

  await execute(
    db,
    `INSERT INTO comments(id, post_id, author, email, content, status, created_at, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
    commentId,
    normalizedPostId,
    author.trim().slice(0, 64),
    email ? email.trim().slice(0, 256) : null,
    content.trim().slice(0, 5000),
    'visible', // or 'pending' if moderation is required
    now,
    now
  );

  return success(c, { id: commentId }, 201);
});

comments.get('/stream', async (c) => {
  const postId = c.req.query('postId');
  if (!postId) {
    return badRequest(c, 'postId is required');
  }

  const origin = c.req.header('Origin') || '';
  const allowed = isOriginAllowed(origin, c.env as Env);

  const encoder = new TextEncoder();
  const stream = new ReadableStream<Uint8Array>({
    async start(controller) {
      const send = (data: unknown) => {
        const payload = `data: ${JSON.stringify(data)}\n\n`;
        controller.enqueue(encoder.encode(payload));
      };

      send({ type: 'hello', postId, ts: Date.now() });
      const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));
      for (let i = 0; i < 8; i++) {
        await sleep(15000);
        send({ type: 'ping', ts: Date.now() });
      }

      controller.close();
    },
  });

  const headers = new Headers({
    'Content-Type': 'text/event-stream; charset=utf-8',
    'Cache-Control': 'no-cache, no-transform',
    Connection: 'keep-alive',
  });
  if (allowed && origin) {
    headers.set('Access-Control-Allow-Origin', origin);
    headers.set('Access-Control-Allow-Credentials', 'true');
  }
  headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
  headers.set('Access-Control-Max-Age', '86400');

  return new Response(stream, { headers });
});

// DELETE /comments/:id - Delete comment (admin only)
comments.delete('/:id', requireAdmin, async (c) => {
  const id = c.req.param('id');
  const db = c.env.DB;

  const existing = await queryOne<Comment>(db, 'SELECT id FROM comments WHERE id = ?', id);
  if (!existing) {
    return notFound(c, 'Comment not found');
  }

  // Soft delete by setting status to 'hidden'
  await execute(db, "UPDATE comments SET status = 'hidden', updated_at = ? WHERE id = ?", new Date().toISOString(), id);

  return success(c, { deleted: true });
});

// ========================================
// COMMENT REACTIONS (STICKERS)
// ========================================

// Available emoji reactions
const ALLOWED_EMOJIS = ['👍', '❤️', '😂', '😮', '😢', '🔥', '🎉', '💡'];

// GET /comments/:commentId/reactions - Get reactions for a comment
comments.get('/:commentId/reactions', async (c) => {
  const commentId = c.req.param('commentId');
  const db = c.env.DB;

  interface ReactionCount {
    emoji: string;
    count: number;
  }
  
  const reactions = await queryAll<ReactionCount>(
    db,
    `SELECT emoji, COUNT(*) as count
     FROM comment_reactions
     WHERE comment_id = ?
     GROUP BY emoji
     ORDER BY count DESC`,
    commentId
  );

  return success(c, { reactions });
});

// GET /comments/reactions/batch?commentIds=id1,id2,id3 - Get reactions for multiple comments
comments.get('/reactions/batch', async (c) => {
  const commentIdsParam = c.req.query('commentIds');
  if (!commentIdsParam) {
    return badRequest(c, 'commentIds is required');
  }

  const commentIds = commentIdsParam.split(',').slice(0, 100); // Limit to 100 comments
  if (commentIds.length === 0) {
    return success(c, { reactions: {} });
  }

  const db = c.env.DB;
  const placeholders = commentIds.map(() => '?').join(',');

  interface ReactionRow {
    comment_id: string;
    emoji: string;
    count: number;
  }

  const rows = await queryAll<ReactionRow>(
    db,
    `SELECT comment_id, emoji, COUNT(*) as count
     FROM comment_reactions
     WHERE comment_id IN (${placeholders})
     GROUP BY comment_id, emoji`,
    ...commentIds
  );

  // Group by comment_id
  const reactions: Record<string, Array<{ emoji: string; count: number }>> = {};
  for (const row of rows) {
    if (!reactions[row.comment_id]) {
      reactions[row.comment_id] = [];
    }
    reactions[row.comment_id]!.push({ emoji: row.emoji, count: row.count });
  }

  return success(c, { reactions });
});

// POST /comments/:commentId/reactions - Add a reaction
comments.post('/:commentId/reactions', async (c) => {
  const commentId = c.req.param('commentId');
  const body = await c.req.json().catch(() => ({}));
  const { emoji, fingerprint } = body as { emoji: string; fingerprint: string };

  if (!emoji || !fingerprint) {
    return badRequest(c, 'emoji and fingerprint are required');
  }

  if (!ALLOWED_EMOJIS.includes(emoji)) {
    return badRequest(c, 'Invalid emoji');
  }

  if (fingerprint.length > 64) {
    return badRequest(c, 'Invalid fingerprint');
  }

  const db = c.env.DB;

  // Check if comment exists
  const comment = await queryOne<{ id: string }>(
    db,
    'SELECT id FROM comments WHERE id = ? AND status = ?',
    commentId,
    'visible'
  );
  if (!comment) {
    return notFound(c, 'Comment not found');
  }

  // Try to insert reaction (will fail if duplicate due to unique constraint)
  const reactionId = `reaction-${crypto.randomUUID()}`;
  const now = new Date().toISOString();

  try {
    await execute(
      db,
      `INSERT INTO comment_reactions(id, comment_id, emoji, user_fingerprint, created_at)
       VALUES (?, ?, ?, ?, ?)`,
      reactionId,
      commentId,
      emoji,
      fingerprint.slice(0, 64),
      now
    );
    return success(c, { added: true, emoji }, 201);
  } catch (err: any) {
    // Unique constraint violation - user already reacted with this emoji
    if (err.message?.includes('UNIQUE constraint')) {
      return success(c, { added: false, message: 'Already reacted' });
    }
    throw err;
  }
});

// DELETE /comments/:commentId/reactions - Remove a reaction
comments.delete('/:commentId/reactions', async (c) => {
  const commentId = c.req.param('commentId');
  const body = await c.req.json().catch(() => ({}));
  const { emoji, fingerprint } = body as { emoji: string; fingerprint: string };

  if (!emoji || !fingerprint) {
    return badRequest(c, 'emoji and fingerprint are required');
  }

  const db = c.env.DB;

  await execute(
    db,
    `DELETE FROM comment_reactions
     WHERE comment_id = ? AND emoji = ? AND user_fingerprint = ?`,
    commentId,
    emoji,
    fingerprint.slice(0, 64)
  );

  return success(c, { removed: true });
});

export default comments;

```

### config.ts

**Path:** `workers/src/routes/config.ts`

```typescript
/**
 * Config Routes
 * 
 * KV 기반 동적 설정 관리 엔드포인트입니다.
 * AI 서버 URL 등을 재배포 없이 변경할 수 있습니다.
 * 
 * 모든 엔드포인트는 admin 권한이 필요합니다.
 */

import { Hono } from 'hono';
import type { Env } from '../types';
import { success, badRequest, error } from '../lib/response';
import { requireAdmin } from '../middleware/auth';
import {
  CONFIG_KEYS,
  setConfigValue,
  deleteConfigValue,
  getAllConfig,
  clearConfigCache,
} from '../lib/config';

const config = new Hono<{ Bindings: Env }>();

/**
 * GET /config
 * 현재 설정 값들을 조회합니다 (source 포함)
 */
config.get('/', requireAdmin, async (c) => {
  try {
    const configs = await getAllConfig(c.env);
    return success(c, {
      configs,
      keys: Object.keys(CONFIG_KEYS),
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to get config';
    return error(c, message, 500);
  }
});

/**
 * PUT /config/:key
 * 설정 값을 업데이트합니다
 * 
 * Body: { value: string }
 */
config.put('/:key', requireAdmin, async (c) => {
  const key = c.req.param('key');
  const body = await c.req.json().catch(() => ({}));
  const { value } = body as { value?: string };

  // Validate key
  const validKeys = Object.keys(CONFIG_KEYS) as Array<keyof typeof CONFIG_KEYS>;
  if (!key || !validKeys.includes(key as keyof typeof CONFIG_KEYS)) {
    return badRequest(c, `Invalid config key: ${key}. Valid keys: ${validKeys.join(', ')}`);
  }

  // Validate value
  if (typeof value !== 'string' || !value.trim()) {
    return badRequest(c, 'value is required and must be a non-empty string');
  }

  // URL validation for URL keys
  if (key.includes('URL')) {
    try {
      new URL(value);
    } catch {
      return badRequest(c, `Invalid URL format: ${value}`);
    }
  }

  try {
    await setConfigValue(c.env.KV, key as keyof typeof CONFIG_KEYS, value.trim());
    return success(c, {
      key,
      value: key.includes('KEY') ? '***' + value.slice(-4) : value,
      message: `Config ${key} updated successfully`,
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to set config';
    return error(c, message, 500);
  }
});

/**
 * DELETE /config/:key
 * 설정 값을 삭제합니다 (env/default로 폴백)
 */
config.delete('/:key', requireAdmin, async (c) => {
  const key = c.req.param('key');

  // Validate key
  const validKeys = Object.keys(CONFIG_KEYS) as Array<keyof typeof CONFIG_KEYS>;
  if (!key || !validKeys.includes(key as keyof typeof CONFIG_KEYS)) {
    return badRequest(c, `Invalid config key: ${key}. Valid keys: ${validKeys.join(', ')}`);
  }

  try {
    await deleteConfigValue(c.env.KV, key as keyof typeof CONFIG_KEYS);
    return success(c, {
      key,
      message: `Config ${key} deleted. Will now use env/default value.`,
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to delete config';
    return error(c, message, 500);
  }
});

/**
 * POST /config/clear-cache
 * 인메모리 캐시를 클리어합니다
 */
config.post('/clear-cache', requireAdmin, async (c) => {
  clearConfigCache();
  return success(c, {
    message: 'Config cache cleared',
  });
});

export default config;

```

### gateway.ts

**Path:** `workers/src/routes/gateway.ts`

```typescript
/**
 * AI Gateway Routes
 *
 * 모든 AI 호출은 자체 백엔드 서버(ai-check.nodove.com)를 통해 처리됩니다.
 * 외부 API(Gemini 등)는 백엔드 서버에서 관리하며, Workers에서는 직접 호출하지 않습니다.
 *
 * Endpoints:
 * - POST /gateway/call/auto-chat - AI chat proxy
 * - GET  /gateway/call/health - Health check
 * - GET  /gateway/call/status - Status check
 * - POST /gateway/vision/analyze - Vision analysis
 * - GET  /gateway/vision/health - Health check
 */

import { Hono } from 'hono';
import type { Env } from '../types';
import { success, badRequest, serverError } from '../lib/response';
import { getApiBaseUrl, getAiServeApiKey } from '../lib/config';

const gateway = new Hono<{ Bindings: Env }>();

// ============================================================================
// Configuration helpers
// ============================================================================

const CONFIG_KEYS = {
  AI_AGENT_BACKEND_URL: 'config:ai_agent_backend_url',
} as const;

async function getAiAgentBackendUrl(env: Env): Promise<string> {
  try {
    const kvValue = await env.KV.get(CONFIG_KEYS.AI_AGENT_BACKEND_URL);
    if (kvValue) return kvValue;
  } catch {}
  // Fall back to API_BASE_URL (Tunnel)
  return getApiBaseUrl(env);
}

// ============================================================================
// AI Call Gateway
// ============================================================================

/**
 * Proxy request to backend AI agent server
 */
async function proxyToBackendAi(
  request: Request,
  env: Env,
  path: string
): Promise<Response> {
  const backendUrl = await getAiAgentBackendUrl(env);
  const url = new URL(path, backendUrl);

  // Copy query params
  const originalUrl = new URL(request.url);
  originalUrl.searchParams.forEach((value, key) => {
    url.searchParams.set(key, value);
  });

  const headers = new Headers(request.headers);
  headers.set('Host', new URL(backendUrl).host);

  // Add internal key if configured
  const apiKey = await getAiServeApiKey(env);
  if (apiKey) {
    headers.set('X-Internal-Gateway-Key', apiKey);
  }

  // Remove sensitive headers
  headers.delete('X-Gateway-Caller-Key');

  const body = ['GET', 'HEAD'].includes(request.method)
    ? undefined
    : await request.blob();

  const forwarded = new Request(url.toString(), {
    method: request.method,
    headers,
    body,
    redirect: 'manual',
  });

  return fetch(forwarded);
}

// POST /gateway/call/auto-chat
gateway.post('/call/auto-chat', async (c) => {
  try {
    const response = await proxyToBackendAi(c.req.raw, c.env, '/api/v1/ai/auto-chat');
    return new Response(response.body, {
      status: response.status,
      headers: response.headers,
    });
  } catch (err) {
    console.error('Backend AI proxy failed:', err);
    return serverError(c, 'AI service unavailable');
  }
});

// GET /gateway/call/health
gateway.get('/call/health', async (c) => {
  const backendUrl = await getAiAgentBackendUrl(c.env);

  return success(c, {
    status: 'ok',
    mode: 'backend',
    backendUrl,
    timestamp: new Date().toISOString(),
  });
});

// GET /gateway/call/status
gateway.get('/call/status', async (c) => {
  try {
    const backendUrl = await getAiAgentBackendUrl(c.env);
    const apiKey = await getAiServeApiKey(c.env);

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };
    if (apiKey) {
      headers['X-Internal-Gateway-Key'] = apiKey;
    }

    const response = await fetch(`${backendUrl}/api/v1/ai/status`, {
      method: 'GET',
      headers,
    });

    if (response.ok) {
      const data = await response.json();
      return success(c, { mode: 'backend', backend: data });
    }
    return success(c, { mode: 'backend', backend: { status: 'error', code: response.status } });
  } catch (err) {
    return success(c, { mode: 'backend', backend: { status: 'unreachable' } });
  }
});

// ============================================================================
// AI Vision Gateway
// ============================================================================

const DEFAULT_VISION_PROMPT = `이 이미지를 분석해주세요. 다음 내용을 간결하게 설명해주세요:
1. 이미지에 보이는 주요 요소들
2. 전체적인 분위기나 맥락
3. 텍스트가 있다면 해당 내용

한국어로 2-3문장으로 간결하게 요약해주세요.`;

/**
 * Fetch image and convert to base64
 */
async function fetchImageAsBase64(
  imageUrl: string
): Promise<{ base64: string; mimeType: string }> {
  const response = await fetch(imageUrl);
  if (!response.ok) {
    throw new Error(`Failed to fetch image: ${response.status}`);
  }

  const contentType = response.headers.get('content-type') || 'image/jpeg';
  const arrayBuffer = await response.arrayBuffer();
  const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));

  return { base64, mimeType: contentType };
}

/**
 * Analyze image via backend AI server
 */
async function analyzeWithBackend(
  env: Env,
  imageBase64: string,
  mimeType: string,
  prompt: string
): Promise<string> {
  const backendUrl = await getAiAgentBackendUrl(env);
  const url = `${backendUrl}/api/v1/ai/vision/analyze`;

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  const apiKey = await getAiServeApiKey(env);
  if (apiKey) {
    headers['X-Internal-Gateway-Key'] = apiKey;
  }

  const response = await fetch(url, {
    method: 'POST',
    headers,
    body: JSON.stringify({ imageBase64, mimeType, prompt }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Backend vision error: ${response.status} ${errorText.slice(0, 200)}`);
  }

  const data = (await response.json()) as {
    ok?: boolean;
    data?: { description?: string; text?: string };
    description?: string;
    text?: string;
  };

  // 다양한 응답 형식 지원
  const description =
    data?.data?.description ||
    data?.data?.text ||
    data?.description ||
    data?.text;

  if (!description) throw new Error('No description in backend response');
  return description;
}

// POST /gateway/vision/analyze
gateway.post('/vision/analyze', async (c) => {
  type VisionRequestBody = {
    imageUrl?: string;
    imageBase64?: string;
    mimeType?: string;
    prompt?: string;
  };
  const body: VisionRequestBody = await c.req
    .json<VisionRequestBody>()
    .catch(() => ({}));

  let imageBase64: string;
  let mimeType: string;

  // Get image data
  if (body.imageBase64) {
    imageBase64 = body.imageBase64;
    mimeType = body.mimeType || 'image/jpeg';
  } else if (body.imageUrl) {
    try {
      const fetched = await fetchImageAsBase64(body.imageUrl);
      imageBase64 = fetched.base64;
      mimeType = fetched.mimeType;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to fetch image';
      return badRequest(c, message);
    }
  } else {
    return badRequest(c, 'imageUrl or imageBase64 required');
  }

  const prompt = body.prompt || DEFAULT_VISION_PROMPT;

  try {
    const description = await analyzeWithBackend(c.env, imageBase64, mimeType, prompt);
    return success(c, { description, provider: 'backend' });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Vision analysis failed';
    console.error('Vision analysis failed:', message);
    return serverError(c, message);
  }
});

// GET /gateway/vision/health
gateway.get('/vision/health', async (c) => {
  const backendUrl = await getAiAgentBackendUrl(c.env);

  return success(c, {
    status: 'ok',
    mode: 'backend',
    backendUrl,
    timestamp: new Date().toISOString(),
  });
});

// ============================================================================
// Gateway Configuration Admin (for runtime config changes)
// ============================================================================

// GET /gateway/config - Get current gateway configuration
gateway.get('/config', async (c) => {
  const backendUrl = await getAiAgentBackendUrl(c.env);
  const apiKey = await getAiServeApiKey(c.env);

  return success(c, {
    mode: 'backend',
    backendUrl,
    hasApiKey: !!apiKey,
  });
});

// PUT /gateway/config - Update gateway configuration (admin only)
gateway.put('/config', async (c) => {
  // TODO: Add admin auth check here
  type ConfigUpdateBody = {
    backendUrl?: string;
  };
  const body: ConfigUpdateBody = await c.req
    .json<ConfigUpdateBody>()
    .catch(() => ({}));

  try {
    if (body.backendUrl) {
      // Validate URL format
      new URL(body.backendUrl);
      await c.env.KV.put(CONFIG_KEYS.AI_AGENT_BACKEND_URL, body.backendUrl);
    }

    return success(c, { updated: true });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to update config';
    return badRequest(c, message);
  }
});

export default gateway;

```

### images.ts

**Path:** `workers/src/routes/images.ts`

```typescript
import { Hono } from 'hono';
import type { Env } from '../types';
import { success, badRequest, notFound } from '../lib/response';
import { execute } from '../lib/d1';
import { requireAdmin } from '../middleware/auth';
import { getAiServeUrl } from '../lib/config';

const images = new Hono<{ Bindings: Env }>();

// POST /images/presign - Generate presigned URL for R2 upload (admin only)
images.post('/presign', requireAdmin, async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { filename, contentType, postId } = body;

  if (!filename) {
    return badRequest(c, 'filename is required');
  }

  const r2 = c.env.R2;
  if (!r2) {
    return badRequest(c, 'R2 bucket is not configured');
  }
  
  // Generate a unique key for R2
  const sanitized = filename.replace(/[^a-zA-Z0-9._-]/g, '-');
  const timestamp = Date.now();
  const key = postId
    ? `posts/${postId}/${timestamp}-${sanitized}`
    : `uploads/${new Date().getFullYear()}/${timestamp}-${sanitized}`;

  // For presigned URL approach, we'd use R2's presigned URL API
  // Since R2 doesn't directly support presigned URLs via Workers binding,
  // we'll use direct upload approach instead

  return success(c, {
    key,
    uploadUrl: `/images/upload-direct`, // Client will POST here
    metadata: {
      contentType: contentType || 'application/octet-stream',
    },
  });
});

// POST /images/upload-direct - Direct upload to R2 (admin only)
images.post('/upload-direct', requireAdmin, async (c) => {
  const formData = await c.req.formData();
  const file = formData.get('file') as File | null;
  const postId = formData.get('postId') as string | null;

  if (!file) {
    return badRequest(c, 'file is required');
  }

  const r2 = c.env.R2;
  if (!r2) {
    return badRequest(c, 'R2 bucket is not configured');
  }
  const db = c.env.DB;

  // Generate R2 key
  const sanitized = file.name.replace(/[^a-zA-Z0-9._-]/g, '-');
  const timestamp = Date.now();
  const key = postId
    ? `posts/${postId}/${timestamp}-${sanitized}`
    : `uploads/${new Date().getFullYear()}/${timestamp}-${sanitized}`;

  // Upload to R2
  const buffer = await file.arrayBuffer();
  await r2.put(key, buffer, {
    httpMetadata: {
      contentType: file.type || 'application/octet-stream',
    },
  });

  // Generate public URL (assuming R2 public bucket or custom domain)
  const assetsBase = (c.env.ASSETS_BASE_URL || 'https://assets-b.nodove.com').replace(/\/$/, '');
  const url = `${assetsBase}/${key}`;

  // Save metadata to D1
  const attachmentId = `attach-${crypto.randomUUID()}`;
  if (postId) {
    await execute(
      db,
      `INSERT INTO attachments(id, post_id, url, r2_key, content_type, size_bytes, created_at)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      attachmentId,
      postId,
      url,
      key,
      file.type,
      file.size,
      new Date().toISOString()
    );
  }

  return success(c, {
    id: attachmentId,
    url,
    key,
    size: file.size,
  }, 201);
});

// POST /images/chat-upload - Direct upload for AI Chat images (public, origin-guarded)
// Also performs AI vision analysis and returns the description
images.post('/chat-upload', async c => {
  const contentType = c.req.header('content-type') || '';
  if (!contentType.toLowerCase().includes('multipart/form-data')) {
    return badRequest(c, 'multipart/form-data required');
  }

  const formData = await c.req.formData();
  const file = formData.get('file') as File | null;

  if (!file) {
    return badRequest(c, 'file is required');
  }

  const r2 = c.env.R2;
  if (!r2) {
    return badRequest(c, 'R2 bucket is not configured');
  }

  const sanitized = file.name.replace(/[^a-zA-Z0-9._-]/g, '-');
  const timestamp = Date.now();
  const key = `ai-chat/${new Date().getFullYear()}/${timestamp}-${sanitized}`;

  const buffer = await file.arrayBuffer();
  await r2.put(key, buffer, {
    httpMetadata: {
      contentType: file.type || 'application/octet-stream',
    },
  });

  const assetsBase = (c.env.ASSETS_BASE_URL || 'https://assets.blog.nodove.com').replace(/\/$/, '');
  const url = `${assetsBase}/${key}`;

  // Perform AI vision analysis via backend server
  let imageAnalysis: string | null = null;
  
  if (file.type?.startsWith('image/')) {
    try {
      // Convert to base64 for vision API
      const base64 = btoa(String.fromCharCode(...new Uint8Array(buffer)));
      
      // Call backend vision endpoint
      const aiServeUrl = await getAiServeUrl(c.env);
      const visionRes = await fetch(`${aiServeUrl.replace(/\/$/, '')}/api/v1/ai/vision/analyze`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          imageBase64: base64,
          mimeType: file.type,
        }),
      });

      if (visionRes.ok) {
        const visionData = await visionRes.json<{ ok: boolean; description?: string }>();
        if (visionData.ok && visionData.description) {
          imageAnalysis = visionData.description;
        }
      }
    } catch (err) {
      // Vision analysis failed, but upload succeeded - continue without analysis
      console.error('Vision analysis failed:', err);
    }
  }

  return success(
    c,
    {
      url,
      key,
      size: file.size,
      contentType: file.type || 'application/octet-stream',
      imageAnalysis, // AI vision analysis result (null if not available)
    },
    201
  );
});

// DELETE /images/:key - Delete image from R2 (admin only)
images.delete('/:key', requireAdmin, async (c) => {
  const key = c.req.param('key');
  const r2 = c.env.R2;
  if (!r2) {
    return badRequest(c, 'R2 bucket is not configured');
  }
  const db = c.env.DB;

  // Delete from R2
  await r2.delete(key);

  // Delete metadata from D1
  await execute(db, 'DELETE FROM attachments WHERE r2_key = ?', key);

  return success(c, { deleted: true });
});

export default images;

```

### memories.ts

**Path:** `workers/src/routes/memories.ts`

```typescript
import { Hono } from 'hono';
import type { Env } from '../types';
import { success, badRequest, notFound, serverError } from '../lib/response';
import { queryAll, execute, queryOne } from '../lib/d1';

const memories = new Hono<{ Bindings: Env }>();

// Types
interface UserMemory {
  id: string;
  user_id: string;
  memory_type: string;
  category: string | null;
  content: string;
  source_type: string | null;
  source_id: string | null;
  importance_score: number;
  access_count: number;
  last_accessed_at: string | null;
  expires_at: string | null;
  is_active: number;
  created_at: string;
  updated_at: string;
}

interface ChatSession {
  id: string;
  user_id: string;
  title: string | null;
  summary: string | null;
  question_mode: string;
  article_slug: string | null;
  message_count: number;
  total_tokens: number;
  is_archived: number;
  is_deleted: number;
  last_message_at: string | null;
  created_at: string;
  updated_at: string;
}

interface ChatMessage {
  id: string;
  session_id: string;
  user_id: string;
  role: string;
  content: string;
  content_type: string;
  metadata: string | null;
  created_at: string;
}

// ========================================
// MEMORY ENDPOINTS
// ========================================

// GET /memories/:userId - Get all active memories for a user
memories.get('/:userId', async (c) => {
  const userId = c.req.param('userId');
  if (!userId) return badRequest(c, 'userId is required');

  const limit = Math.min(parseInt(c.req.query('limit') || '50'), 100);
  const offset = parseInt(c.req.query('offset') || '0');
  const memoryType = c.req.query('type');
  const category = c.req.query('category');

  const db = c.env.DB;

  let query = `
    SELECT id, user_id, memory_type, category, content, source_type, source_id,
           importance_score, access_count, last_accessed_at, expires_at,
           is_active, created_at, updated_at
    FROM user_memories
    WHERE user_id = ? AND is_active = 1
  `;
  const params: any[] = [userId];

  if (memoryType) {
    query += ` AND memory_type = ?`;
    params.push(memoryType);
  }
  if (category) {
    query += ` AND category = ?`;
    params.push(category);
  }

  query += ` ORDER BY importance_score DESC, created_at DESC LIMIT ? OFFSET ?`;
  params.push(limit, offset);

  const items = await queryAll<UserMemory>(db, query, ...params);

  // Get total count
  let countQuery = `SELECT COUNT(*) as count FROM user_memories WHERE user_id = ? AND is_active = 1`;
  const countParams: any[] = [userId];
  if (memoryType) {
    countQuery += ` AND memory_type = ?`;
    countParams.push(memoryType);
  }
  if (category) {
    countQuery += ` AND category = ?`;
    countParams.push(category);
  }

  const countResult = await queryOne<{ count: number }>(db, countQuery, ...countParams);

  return success(c, {
    memories: items.map(m => ({
      id: m.id,
      userId: m.user_id,
      memoryType: m.memory_type,
      category: m.category,
      content: m.content,
      sourceType: m.source_type,
      sourceId: m.source_id,
      importanceScore: m.importance_score,
      accessCount: m.access_count,
      lastAccessedAt: m.last_accessed_at,
      expiresAt: m.expires_at,
      createdAt: m.created_at,
      updatedAt: m.updated_at,
    })),
    total: countResult?.count || 0,
  });
});

// POST /memories/:userId - Create a new memory
memories.post('/:userId', async (c) => {
  const userId = c.req.param('userId');
  if (!userId) return badRequest(c, 'userId is required');

  const body = await c.req.json().catch(() => ({}));
  const {
    memoryType = 'fact',
    category,
    content,
    sourceType,
    sourceId,
    importanceScore = 0.5,
    expiresAt,
  } = body as {
    memoryType?: string;
    category?: string;
    content: string;
    sourceType?: string;
    sourceId?: string;
    importanceScore?: number;
    expiresAt?: string;
  };

  if (!content || typeof content !== 'string') {
    return badRequest(c, 'content is required');
  }

  if (content.length > 10000) {
    return badRequest(c, 'Content too large (max 10KB)');
  }

  const db = c.env.DB;
  const now = new Date().toISOString();
  const id = `mem-${crypto.randomUUID()}`;

  await execute(
    db,
    `INSERT INTO user_memories
     (id, user_id, memory_type, category, content, source_type, source_id,
      importance_score, expires_at, created_at, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    id, userId, memoryType, category || null, content,
    sourceType || null, sourceId || null,
    Math.max(0, Math.min(1, importanceScore)),
    expiresAt || null, now, now
  );

  return success(c, { id, created: true }, 201);
});

// POST /memories/:userId/batch - Create multiple memories at once
memories.post('/:userId/batch', async (c) => {
  const userId = c.req.param('userId');
  if (!userId) return badRequest(c, 'userId is required');

  const body = await c.req.json().catch(() => ({}));
  const { memories: memoryItems } = body as {
    memories: Array<{
      memoryType?: string;
      category?: string;
      content: string;
      sourceType?: string;
      sourceId?: string;
      importanceScore?: number;
    }>;
  };

  if (!Array.isArray(memoryItems) || memoryItems.length === 0) {
    return badRequest(c, 'memories array is required');
  }

  if (memoryItems.length > 20) {
    return badRequest(c, 'Maximum 20 memories per batch');
  }

  const db = c.env.DB;
  const now = new Date().toISOString();
  const createdIds: string[] = [];

  for (const item of memoryItems) {
    if (!item.content || typeof item.content !== 'string') continue;
    if (item.content.length > 10000) continue;

    const id = `mem-${crypto.randomUUID()}`;
    await execute(
      db,
      `INSERT INTO user_memories
       (id, user_id, memory_type, category, content, source_type, source_id,
        importance_score, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      id, userId,
      item.memoryType || 'fact',
      item.category || null,
      item.content,
      item.sourceType || null,
      item.sourceId || null,
      Math.max(0, Math.min(1, item.importanceScore || 0.5)),
      now, now
    );
    createdIds.push(id);
  }

  return success(c, { ids: createdIds, created: createdIds.length }, 201);
});

// PATCH /memories/:userId/:memoryId - Update a memory
memories.patch('/:userId/:memoryId', async (c) => {
  const userId = c.req.param('userId');
  const memoryId = c.req.param('memoryId');
  if (!userId || !memoryId) return badRequest(c, 'userId and memoryId are required');

  const body = await c.req.json().catch(() => ({}));
  const { content, category, importanceScore, isActive } = body as {
    content?: string;
    category?: string;
    importanceScore?: number;
    isActive?: boolean;
  };

  const db = c.env.DB;
  const now = new Date().toISOString();

  // Check ownership
  const existing = await queryOne<UserMemory>(
    db,
    `SELECT id FROM user_memories WHERE id = ? AND user_id = ?`,
    memoryId, userId
  );

  if (!existing) return notFound(c, 'Memory not found');

  // Build update query dynamically
  const updates: string[] = ['updated_at = ?'];
  const params: any[] = [now];

  if (content !== undefined) {
    if (content.length > 10000) return badRequest(c, 'Content too large');
    updates.push('content = ?');
    params.push(content);
  }
  if (category !== undefined) {
    updates.push('category = ?');
    params.push(category);
  }
  if (importanceScore !== undefined) {
    updates.push('importance_score = ?');
    params.push(Math.max(0, Math.min(1, importanceScore)));
  }
  if (isActive !== undefined) {
    updates.push('is_active = ?');
    params.push(isActive ? 1 : 0);
  }

  params.push(memoryId);

  await execute(
    db,
    `UPDATE user_memories SET ${updates.join(', ')} WHERE id = ?`,
    ...params
  );

  return success(c, { updated: true });
});

// DELETE /memories/:userId/:memoryId - Soft delete a memory
memories.delete('/:userId/:memoryId', async (c) => {
  const userId = c.req.param('userId');
  const memoryId = c.req.param('memoryId');
  if (!userId || !memoryId) return badRequest(c, 'userId and memoryId are required');

  const db = c.env.DB;
  const now = new Date().toISOString();

  const result = await execute(
    db,
    `UPDATE user_memories SET is_active = 0, updated_at = ? WHERE id = ? AND user_id = ?`,
    now, memoryId, userId
  );

  if (result.meta?.changes === 0) return notFound(c, 'Memory not found');

  return success(c, { deleted: true });
});

// POST /memories/:userId/access/:memoryId - Record memory access (for ranking)
memories.post('/:userId/access/:memoryId', async (c) => {
  const userId = c.req.param('userId');
  const memoryId = c.req.param('memoryId');
  if (!userId || !memoryId) return badRequest(c, 'userId and memoryId are required');

  const db = c.env.DB;
  const now = new Date().toISOString();

  await execute(
    db,
    `UPDATE user_memories
     SET access_count = access_count + 1, last_accessed_at = ?, updated_at = ?
     WHERE id = ? AND user_id = ?`,
    now, now, memoryId, userId
  );

  return success(c, { recorded: true });
});

// ========================================
// CHAT SESSION ENDPOINTS
// ========================================

// GET /memories/:userId/sessions - Get all chat sessions for a user
memories.get('/:userId/sessions', async (c) => {
  const userId = c.req.param('userId');
  if (!userId) return badRequest(c, 'userId is required');

  const limit = Math.min(parseInt(c.req.query('limit') || '20'), 50);
  const offset = parseInt(c.req.query('offset') || '0');
  const includeArchived = c.req.query('includeArchived') === 'true';

  const db = c.env.DB;

  let query = `
    SELECT id, user_id, title, summary, question_mode, article_slug,
           message_count, total_tokens, is_archived, last_message_at, created_at, updated_at
    FROM chat_sessions
    WHERE user_id = ? AND is_deleted = 0
  `;
  const params: any[] = [userId];

  if (!includeArchived) {
    query += ` AND is_archived = 0`;
  }

  query += ` ORDER BY last_message_at DESC NULLS LAST, created_at DESC LIMIT ? OFFSET ?`;
  params.push(limit, offset);

  const sessions = await queryAll<ChatSession>(db, query, ...params);

  return success(c, {
    sessions: sessions.map(s => ({
      id: s.id,
      userId: s.user_id,
      title: s.title,
      summary: s.summary,
      questionMode: s.question_mode,
      articleSlug: s.article_slug,
      messageCount: s.message_count,
      totalTokens: s.total_tokens,
      isArchived: Boolean(s.is_archived),
      lastMessageAt: s.last_message_at,
      createdAt: s.created_at,
      updatedAt: s.updated_at,
    })),
  });
});

// POST /memories/:userId/sessions - Create a new chat session
memories.post('/:userId/sessions', async (c) => {
  const userId = c.req.param('userId');
  if (!userId) return badRequest(c, 'userId is required');

  const body = await c.req.json().catch(() => ({}));
  const { title, questionMode = 'general', articleSlug } = body as {
    title?: string;
    questionMode?: string;
    articleSlug?: string;
  };

  const db = c.env.DB;
  const now = new Date().toISOString();
  const id = `chat-${crypto.randomUUID()}`;

  await execute(
    db,
    `INSERT INTO chat_sessions
     (id, user_id, title, question_mode, article_slug, created_at, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    id, userId, title || null, questionMode, articleSlug || null, now, now
  );

  return success(c, { id, created: true }, 201);
});

// GET /memories/:userId/sessions/:sessionId - Get a chat session with messages
memories.get('/:userId/sessions/:sessionId', async (c) => {
  const userId = c.req.param('userId');
  const sessionId = c.req.param('sessionId');
  if (!userId || !sessionId) return badRequest(c, 'userId and sessionId are required');

  const limit = Math.min(parseInt(c.req.query('limit') || '100'), 200);

  const db = c.env.DB;

  const session = await queryOne<ChatSession>(
    db,
    `SELECT * FROM chat_sessions WHERE id = ? AND user_id = ? AND is_deleted = 0`,
    sessionId, userId
  );

  if (!session) return notFound(c, 'Session not found');

  const messages = await queryAll<ChatMessage>(
    db,
    `SELECT id, session_id, user_id, role, content, content_type, metadata, created_at
     FROM chat_messages
     WHERE session_id = ?
     ORDER BY created_at ASC
     LIMIT ?`,
    sessionId, limit
  );

  return success(c, {
    session: {
      id: session.id,
      userId: session.user_id,
      title: session.title,
      summary: session.summary,
      questionMode: session.question_mode,
      articleSlug: session.article_slug,
      messageCount: session.message_count,
      totalTokens: session.total_tokens,
      isArchived: Boolean(session.is_archived),
      lastMessageAt: session.last_message_at,
      createdAt: session.created_at,
      updatedAt: session.updated_at,
    },
    messages: messages.map(m => ({
      id: m.id,
      sessionId: m.session_id,
      role: m.role,
      content: m.content,
      contentType: m.content_type,
      metadata: m.metadata ? JSON.parse(m.metadata) : null,
      createdAt: m.created_at,
    })),
  });
});

// POST /memories/:userId/sessions/:sessionId/messages - Add message to session
memories.post('/:userId/sessions/:sessionId/messages', async (c) => {
  const userId = c.req.param('userId');
  const sessionId = c.req.param('sessionId');
  if (!userId || !sessionId) return badRequest(c, 'userId and sessionId are required');

  const body = await c.req.json().catch(() => ({}));
  const { role, content, contentType = 'text', metadata } = body as {
    role: string;
    content: string;
    contentType?: string;
    metadata?: Record<string, any>;
  };

  if (!role || !content) return badRequest(c, 'role and content are required');
  if (!['user', 'assistant', 'system'].includes(role)) {
    return badRequest(c, 'Invalid role');
  }
  if (content.length > 50000) return badRequest(c, 'Content too large (max 50KB)');

  const db = c.env.DB;
  const now = new Date().toISOString();

  // Verify session ownership
  const session = await queryOne<ChatSession>(
    db,
    `SELECT id FROM chat_sessions WHERE id = ? AND user_id = ? AND is_deleted = 0`,
    sessionId, userId
  );

  if (!session) return notFound(c, 'Session not found');

  const msgId = `msg-${crypto.randomUUID()}`;

  await execute(
    db,
    `INSERT INTO chat_messages (id, session_id, user_id, role, content, content_type, metadata, created_at)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
    msgId, sessionId, userId, role, content, contentType,
    metadata ? JSON.stringify(metadata) : null, now
  );

  // Update session stats
  await execute(
    db,
    `UPDATE chat_sessions
     SET message_count = message_count + 1,
         last_message_at = ?,
         updated_at = ?
     WHERE id = ?`,
    now, now, sessionId
  );

  return success(c, { id: msgId, created: true }, 201);
});

// POST /memories/:userId/sessions/:sessionId/messages/batch - Add multiple messages
memories.post('/:userId/sessions/:sessionId/messages/batch', async (c) => {
  const userId = c.req.param('userId');
  const sessionId = c.req.param('sessionId');
  if (!userId || !sessionId) return badRequest(c, 'userId and sessionId are required');

  const body = await c.req.json().catch(() => ({}));
  const { messages: msgItems } = body as {
    messages: Array<{
      role: string;
      content: string;
      contentType?: string;
      metadata?: Record<string, any>;
    }>;
  };

  if (!Array.isArray(msgItems) || msgItems.length === 0) {
    return badRequest(c, 'messages array is required');
  }
  if (msgItems.length > 50) {
    return badRequest(c, 'Maximum 50 messages per batch');
  }

  const db = c.env.DB;
  const now = new Date().toISOString();

  // Verify session ownership
  const session = await queryOne<ChatSession>(
    db,
    `SELECT id FROM chat_sessions WHERE id = ? AND user_id = ? AND is_deleted = 0`,
    sessionId, userId
  );

  if (!session) return notFound(c, 'Session not found');

  const createdIds: string[] = [];

  for (const msg of msgItems) {
    if (!msg.role || !msg.content) continue;
    if (!['user', 'assistant', 'system'].includes(msg.role)) continue;
    if (msg.content.length > 50000) continue;

    const msgId = `msg-${crypto.randomUUID()}`;
    await execute(
      db,
      `INSERT INTO chat_messages (id, session_id, user_id, role, content, content_type, metadata, created_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      msgId, sessionId, userId, msg.role, msg.content,
      msg.contentType || 'text',
      msg.metadata ? JSON.stringify(msg.metadata) : null, now
    );
    createdIds.push(msgId);
  }

  // Update session stats
  await execute(
    db,
    `UPDATE chat_sessions
     SET message_count = message_count + ?,
         last_message_at = ?,
         updated_at = ?
     WHERE id = ?`,
    createdIds.length, now, now, sessionId
  );

  return success(c, { ids: createdIds, created: createdIds.length }, 201);
});

// PATCH /memories/:userId/sessions/:sessionId - Update session (title, summary, archive)
memories.patch('/:userId/sessions/:sessionId', async (c) => {
  const userId = c.req.param('userId');
  const sessionId = c.req.param('sessionId');
  if (!userId || !sessionId) return badRequest(c, 'userId and sessionId are required');

  const body = await c.req.json().catch(() => ({}));
  const { title, summary, isArchived } = body as {
    title?: string;
    summary?: string;
    isArchived?: boolean;
  };

  const db = c.env.DB;
  const now = new Date().toISOString();

  // Check ownership
  const existing = await queryOne<ChatSession>(
    db,
    `SELECT id FROM chat_sessions WHERE id = ? AND user_id = ? AND is_deleted = 0`,
    sessionId, userId
  );

  if (!existing) return notFound(c, 'Session not found');

  const updates: string[] = ['updated_at = ?'];
  const params: any[] = [now];

  if (title !== undefined) {
    updates.push('title = ?');
    params.push(title);
  }
  if (summary !== undefined) {
    updates.push('summary = ?');
    params.push(summary);
  }
  if (isArchived !== undefined) {
    updates.push('is_archived = ?');
    params.push(isArchived ? 1 : 0);
  }

  params.push(sessionId);

  await execute(
    db,
    `UPDATE chat_sessions SET ${updates.join(', ')} WHERE id = ?`,
    ...params
  );

  return success(c, { updated: true });
});

// DELETE /memories/:userId/sessions/:sessionId - Soft delete session
memories.delete('/:userId/sessions/:sessionId', async (c) => {
  const userId = c.req.param('userId');
  const sessionId = c.req.param('sessionId');
  if (!userId || !sessionId) return badRequest(c, 'userId and sessionId are required');

  const db = c.env.DB;
  const now = new Date().toISOString();

  const result = await execute(
    db,
    `UPDATE chat_sessions SET is_deleted = 1, updated_at = ? WHERE id = ? AND user_id = ?`,
    now, sessionId, userId
  );

  if (result.meta?.changes === 0) return notFound(c, 'Session not found');

  return success(c, { deleted: true });
});

// ========================================
// CONTEXT RETRIEVAL (for chat integration)
// ========================================

// GET /memories/:userId/context - Get relevant memories for chat context
memories.get('/:userId/context', async (c) => {
  const userId = c.req.param('userId');
  if (!userId) return badRequest(c, 'userId is required');

  const maxTokens = Math.min(parseInt(c.req.query('maxTokens') || '2000'), 4000);
  const categories = c.req.query('categories')?.split(',').filter(Boolean);

  const db = c.env.DB;
  const now = new Date().toISOString();

  // Get active, non-expired memories sorted by importance and recency
  let query = `
    SELECT id, memory_type, category, content, importance_score, access_count
    FROM user_memories
    WHERE user_id = ? AND is_active = 1
      AND (expires_at IS NULL OR expires_at > ?)
  `;
  const params: any[] = [userId, now];

  if (categories && categories.length > 0) {
    query += ` AND category IN (${categories.map(() => '?').join(',')})`;
    params.push(...categories);
  }

  query += ` ORDER BY importance_score DESC, access_count DESC, created_at DESC LIMIT 50`;

  const items = await queryAll<UserMemory>(db, query, ...params);

  // Build context string with token budget
  const contextParts: string[] = [];
  let currentTokens = 0;
  const CHARS_PER_TOKEN = 4; // rough estimate

  for (const mem of items) {
    const memText = `[${mem.memory_type}${mem.category ? '/' + mem.category : ''}] ${mem.content}`;
    const memTokens = Math.ceil(memText.length / CHARS_PER_TOKEN);

    if (currentTokens + memTokens > maxTokens) break;

    contextParts.push(memText);
    currentTokens += memTokens;

    // Record access asynchronously (fire and forget)
    execute(
      db,
      `UPDATE user_memories SET access_count = access_count + 1, last_accessed_at = ? WHERE id = ?`,
      now, mem.id
    ).catch(() => {});
  }

  return success(c, {
    context: contextParts.join('\n'),
    memoryCount: contextParts.length,
    estimatedTokens: currentTokens,
  });
});

export default memories;

```

### memos.ts

**Path:** `workers/src/routes/memos.ts`

```typescript
import { Hono } from 'hono';
import type { Env } from '../types';
import { success, badRequest, notFound } from '../lib/response';
import { queryAll, execute, queryOne } from '../lib/d1';

const memos = new Hono<{ Bindings: Env }>();

// Types
interface MemoContent {
  id: string;
  user_id: string;
  content: string;
  version: number;
  created_at: string;
  updated_at: string;
}

interface MemoVersion {
  id: number;
  memo_id: string;
  user_id: string;
  version: number;
  content: string;
  content_length: number;
  change_summary: string | null;
  created_at: string;
}

// GET /memos/:userId - Get current memo content for a user
memos.get('/:userId', async (c) => {
  const userId = c.req.param('userId');
  if (!userId) {
    return badRequest(c, 'userId is required');
  }

  const db = c.env.DB;
  const memo = await queryOne<MemoContent>(
    db,
    `SELECT id, user_id, content, version, created_at, updated_at
     FROM memo_content
     WHERE user_id = ?
     LIMIT 1`,
    userId
  );

  if (!memo) {
    // Return empty memo if none exists
    return success(c, {
      memo: {
        id: null,
        userId,
        content: '',
        version: 0,
        createdAt: null,
        updatedAt: null,
      },
    });
  }

  return success(c, {
    memo: {
      id: memo.id,
      userId: memo.user_id,
      content: memo.content,
      version: memo.version,
      createdAt: memo.created_at,
      updatedAt: memo.updated_at,
    },
  });
});

// PUT /memos/:userId - Save memo content (creates version if significant change)
memos.put('/:userId', async (c) => {
  const userId = c.req.param('userId');
  if (!userId) {
    return badRequest(c, 'userId is required');
  }

  const body = await c.req.json().catch(() => ({}));
  const { content, createVersion = false, changeSummary } = body as {
    content: string;
    createVersion?: boolean;
    changeSummary?: string;
  };

  if (typeof content !== 'string') {
    return badRequest(c, 'content is required');
  }

  // Limit content size (100KB)
  if (content.length > 100000) {
    return badRequest(c, 'Content too large (max 100KB)');
  }

  const db = c.env.DB;
  const now = new Date().toISOString();

  // Check if memo exists
  const existing = await queryOne<MemoContent>(
    db,
    `SELECT id, version, content FROM memo_content WHERE user_id = ?`,
    userId
  );

  if (!existing) {
    // Create new memo
    const memoId = `memo-${crypto.randomUUID()}`;
    await execute(
      db,
      `INSERT INTO memo_content (id, user_id, content, version, created_at, updated_at)
       VALUES (?, ?, ?, 1, ?, ?)`,
      memoId,
      userId,
      content,
      now,
      now
    );

    // Create initial version
    await execute(
      db,
      `INSERT INTO memo_versions (memo_id, user_id, version, content, content_length, change_summary, created_at)
       VALUES (?, ?, 1, ?, ?, ?, ?)`,
      memoId,
      userId,
      content,
      content.length,
      'Initial save',
      now
    );

    return success(c, { id: memoId, version: 1 }, 201);
  }

  // Update existing memo
  const newVersion = createVersion ? existing.version + 1 : existing.version;

  await execute(
    db,
    `UPDATE memo_content SET content = ?, version = ?, updated_at = ? WHERE id = ?`,
    content,
    newVersion,
    now,
    existing.id
  );

  // Create version snapshot if requested
  if (createVersion) {
    await execute(
      db,
      `INSERT INTO memo_versions (memo_id, user_id, version, content, content_length, change_summary, created_at)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      existing.id,
      userId,
      newVersion,
      content,
      content.length,
      changeSummary || null,
      now
    );

    // Keep only last 50 versions
    await execute(
      db,
      `DELETE FROM memo_versions
       WHERE memo_id = ? AND id NOT IN (
         SELECT id FROM memo_versions WHERE memo_id = ? ORDER BY version DESC LIMIT 50
       )`,
      existing.id,
      existing.id
    );
  }

  return success(c, { id: existing.id, version: newVersion });
});

// GET /memos/:userId/versions - Get version history for a user's memo
memos.get('/:userId/versions', async (c) => {
  const userId = c.req.param('userId');
  if (!userId) {
    return badRequest(c, 'userId is required');
  }

  const limit = Math.min(parseInt(c.req.query('limit') || '20'), 50);
  const offset = parseInt(c.req.query('offset') || '0');

  const db = c.env.DB;

  // Get memo_id first
  const memo = await queryOne<MemoContent>(
    db,
    `SELECT id FROM memo_content WHERE user_id = ?`,
    userId
  );

  if (!memo) {
    return success(c, { versions: [], total: 0 });
  }

  // Get versions (without full content for list view)
  const versions = await queryAll<MemoVersion>(
    db,
    `SELECT id, memo_id, user_id, version, content_length, change_summary, created_at
     FROM memo_versions
     WHERE memo_id = ?
     ORDER BY version DESC
     LIMIT ? OFFSET ?`,
    memo.id,
    limit,
    offset
  );

  // Get total count
  const countResult = await queryOne<{ count: number }>(
    db,
    `SELECT COUNT(*) as count FROM memo_versions WHERE memo_id = ?`,
    memo.id
  );

  return success(c, {
    versions: versions.map((v) => ({
      id: v.id,
      memoId: v.memo_id,
      version: v.version,
      contentLength: v.content_length,
      changeSummary: v.change_summary,
      createdAt: v.created_at,
    })),
    total: countResult?.count || 0,
  });
});

// GET /memos/:userId/versions/:version - Get specific version content
memos.get('/:userId/versions/:version', async (c) => {
  const userId = c.req.param('userId');
  const versionStr = c.req.param('version');

  if (!userId || !versionStr) {
    return badRequest(c, 'userId and version are required');
  }

  const version = parseInt(versionStr);
  if (isNaN(version)) {
    return badRequest(c, 'Invalid version number');
  }

  const db = c.env.DB;

  // Get memo_id first
  const memo = await queryOne<MemoContent>(
    db,
    `SELECT id FROM memo_content WHERE user_id = ?`,
    userId
  );

  if (!memo) {
    return notFound(c, 'Memo not found');
  }

  const versionData = await queryOne<MemoVersion>(
    db,
    `SELECT id, memo_id, user_id, version, content, content_length, change_summary, created_at
     FROM memo_versions
     WHERE memo_id = ? AND version = ?`,
    memo.id,
    version
  );

  if (!versionData) {
    return notFound(c, 'Version not found');
  }

  return success(c, {
    version: {
      id: versionData.id,
      memoId: versionData.memo_id,
      version: versionData.version,
      content: versionData.content,
      contentLength: versionData.content_length,
      changeSummary: versionData.change_summary,
      createdAt: versionData.created_at,
    },
  });
});

// POST /memos/:userId/restore/:version - Restore a specific version
memos.post('/:userId/restore/:version', async (c) => {
  const userId = c.req.param('userId');
  const versionStr = c.req.param('version');

  if (!userId || !versionStr) {
    return badRequest(c, 'userId and version are required');
  }

  const version = parseInt(versionStr);
  if (isNaN(version)) {
    return badRequest(c, 'Invalid version number');
  }

  const db = c.env.DB;
  const now = new Date().toISOString();

  // Get memo_id first
  const memo = await queryOne<MemoContent>(
    db,
    `SELECT id, version FROM memo_content WHERE user_id = ?`,
    userId
  );

  if (!memo) {
    return notFound(c, 'Memo not found');
  }

  // Get the version to restore
  const versionData = await queryOne<MemoVersion>(
    db,
    `SELECT content FROM memo_versions WHERE memo_id = ? AND version = ?`,
    memo.id,
    version
  );

  if (!versionData) {
    return notFound(c, 'Version not found');
  }

  // Create new version with restored content
  const newVersion = memo.version + 1;

  await execute(
    db,
    `UPDATE memo_content SET content = ?, version = ?, updated_at = ? WHERE id = ?`,
    versionData.content,
    newVersion,
    now,
    memo.id
  );

  // Save version snapshot
  await execute(
    db,
    `INSERT INTO memo_versions (memo_id, user_id, version, content, content_length, change_summary, created_at)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    memo.id,
    userId,
    newVersion,
    versionData.content,
    versionData.content.length,
    `Restored from version ${version}`,
    now
  );

  return success(c, {
    id: memo.id,
    version: newVersion,
    restoredFrom: version,
  });
});

// DELETE /memos/:userId - Delete memo and all versions
memos.delete('/:userId', async (c) => {
  const userId = c.req.param('userId');
  if (!userId) {
    return badRequest(c, 'userId is required');
  }

  const db = c.env.DB;

  const memo = await queryOne<MemoContent>(
    db,
    `SELECT id FROM memo_content WHERE user_id = ?`,
    userId
  );

  if (!memo) {
    return notFound(c, 'Memo not found');
  }

  // Delete versions first (cascade should handle this, but being explicit)
  await execute(db, `DELETE FROM memo_versions WHERE memo_id = ?`, memo.id);
  await execute(db, `DELETE FROM memo_content WHERE id = ?`, memo.id);

  return success(c, { deleted: true });
});

export default memos;

```

### og.ts

**Path:** `workers/src/routes/og.ts`

```typescript
import { Hono } from 'hono';
import type { Env } from '../types';

const og = new Hono<{ Bindings: Env }>();

function escapeXml(unsafe = ''): string {
  return String(unsafe)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// GET /og - Generate OG image (SVG)
og.get('/', async (c) => {
  const { title, subtitle, theme, w, h, bg, fg } = c.req.query();

  const width = Math.max(320, parseInt(w || '1200', 10) || 1200);
  const height = Math.max(180, parseInt(h || '630', 10) || 630);

  const isDark = theme !== 'light';
  const background = bg || (isDark ? '#0b1220' : '#ffffff');
  const foreground = fg || (isDark ? '#ffffff' : '#111111');

  const safeTitle = escapeXml(title || 'Blog Post').slice(0, 140);
  const safeSubtitle = escapeXml(subtitle || '').slice(0, 200);

  const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <defs>
    <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0%" stop-color="${background}" stop-opacity="1" />
      <stop offset="100%" stop-color="${background}" stop-opacity="0.88" />
    </linearGradient>
  </defs>
  <rect width="100%" height="100%" fill="url(#g)"/>
  <g transform="translate(64, 64)">
    <rect x="-16" y="-16" width="32" height="32" rx="4" fill="${foreground}" opacity="0.12" />
    <text x="0" y="0" fill="${foreground}" font-family="ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial" font-size="56" font-weight="700" dominant-baseline="hanging">
      ${safeTitle}
    </text>
    ${safeSubtitle ? `<text x="0" y="88" fill="${foreground}" opacity="0.8" font-family="ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial" font-size="28" font-weight="500" dominant-baseline="hanging">${safeSubtitle}</text>` : ''}
  </g>
  <text x="${width - 64}" y="${height - 48}" text-anchor="end" fill="${foreground}" opacity="0.6" font-family="ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial" font-size="22">blog.nodove.com</text>
</svg>`;

  c.header('Content-Type', 'image/svg+xml');
  c.header('Cache-Control', 'public, max-age=86400'); // 24 hours
  return c.body(svg);
});

export default og;

```

### posts.ts

**Path:** `workers/src/routes/posts.ts`

```typescript
import { Hono } from 'hono';
import type { Env, Post } from '../types';
import { success, badRequest, notFound } from '../lib/response';
import { queryAll, queryOne, execute } from '../lib/d1';
import { requireAdmin } from '../middleware/auth';

const posts = new Hono<{ Bindings: Env }>();

// GET /posts - List all posts (with optional filters)
posts.get('/', async (c) => {
  const { status, limit, offset, tag } = c.req.query();
  const db = c.env.DB;

  let sql = `
    SELECT p.*, GROUP_CONCAT(t.name) as tags
    FROM posts p
    LEFT JOIN post_tags pt ON p.id = pt.post_id
    LEFT JOIN tags t ON pt.tag_id = t.id
  `;

  const conditions: string[] = [];
  const params: unknown[] = [];

  if (status) {
    conditions.push('p.status = ?');
    params.push(status);
  } else {
    // Default to published only for public access
    conditions.push('p.status = ?');
    params.push('published');
  }

  if (tag) {
    conditions.push(
      'p.id IN (SELECT pt2.post_id FROM post_tags pt2 JOIN tags t2 ON pt2.tag_id = t2.id WHERE t2.name = ?)'
    );
    params.push(tag);
  }

  if (conditions.length > 0) {
    sql += ' WHERE ' + conditions.join(' AND ');
  }

  sql += ' GROUP BY p.id ORDER BY p.created_at DESC';

  const limitNum = Math.min(parseInt(limit || '50', 10), 100);
  const offsetNum = parseInt(offset || '0', 10);
  sql += ` LIMIT ? OFFSET ?`;
  params.push(limitNum, offsetNum);

  const items = await queryAll<Post & { tags: string }>(db, sql, ...params);

  // Parse tags from comma-separated string
  const formatted = items.map((item) => ({
    ...item,
    tags: item.tags ? item.tags.split(',') : [],
  }));

  return success(c, { items: formatted });
});

// GET /posts/:slug - Get single post by slug
posts.get('/:slug', async (c) => {
  const slug = c.req.param('slug');
  const db = c.env.DB;

  const post = await queryOne<Post>(
    db,
    'SELECT * FROM posts WHERE slug = ? AND status = ?',
    slug,
    'published'
  );

  if (!post) {
    return notFound(c, 'Post not found');
  }

  // Get tags for this post
  const tags = await queryAll<{ name: string }>(
    db,
    `SELECT t.name FROM tags t
     JOIN post_tags pt ON t.id = pt.tag_id
     WHERE pt.post_id = ?`,
    post.id
  );

  return success(c, {
    post: { ...post, tags: tags.map((t) => t.name) },
  });
});

// POST /posts - Create new post (admin only)
posts.post('/', requireAdmin, async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const { title, slug, content, excerpt, cover_image_url, status, tags } = body;

  if (!title || !slug || !content) {
    return badRequest(c, 'title, slug, and content are required');
  }

  const db = c.env.DB;
  const postId = `post-${crypto.randomUUID()}`;
  const authorId = 'admin-default'; // TODO: Get from authenticated user

  const now = new Date().toISOString();

  await execute(
    db,
    `INSERT INTO posts(id, slug, title, content, excerpt, cover_image_url, status, author_id, published_at, created_at, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    postId,
    slug,
    title,
    content,
    excerpt || null,
    cover_image_url || null,
    status || 'published',
    authorId,
    status === 'published' ? now : null,
    now,
    now
  );

  // Handle tags if provided
  if (Array.isArray(tags) && tags.length > 0) {
    for (const tagName of tags) {
      // Insert tag if not exists
      await execute(db, 'INSERT OR IGNORE INTO tags(name) VALUES (?)', tagName);
      // Get tag ID
      const tag = await queryOne<{ id: number }>(db, 'SELECT id FROM tags WHERE name = ?', tagName);
      if (tag) {
        await execute(db, 'INSERT INTO post_tags(post_id, tag_id) VALUES (?, ?)', postId, tag.id);
      }
    }
  }

  return success(c, { id: postId, slug }, 201);
});

// PUT /posts/:slug - Update post (admin only)
posts.put('/:slug', requireAdmin, async (c) => {
  const slug = c.req.param('slug');
  const body = await c.req.json().catch(() => ({}));
  const { title, content, excerpt, cover_image_url, status, tags } = body;

  const db = c.env.DB;

  const existing = await queryOne<Post>(db, 'SELECT * FROM posts WHERE slug = ?', slug);
  if (!existing) {
    return notFound(c, 'Post not found');
  }

  const now = new Date().toISOString();
  const publishedAt = status === 'published' && !existing.published_at ? now : existing.published_at;

  await execute(
    db,
    `UPDATE posts 
     SET title = COALESCE(?, title),
         content = COALESCE(?, content),
         excerpt = COALESCE(?, excerpt),
         cover_image_url = COALESCE(?, cover_image_url),
         status = COALESCE(?, status),
         published_at = ?,
         updated_at = ?
     WHERE id = ?`,
    title,
    content,
    excerpt,
    cover_image_url,
    status,
    publishedAt,
    now,
    existing.id
  );

  // Update tags if provided
  if (Array.isArray(tags)) {
    // Delete existing tag associations
    await execute(db, 'DELETE FROM post_tags WHERE post_id = ?', existing.id);

    // Insert new tags
    for (const tagName of tags) {
      await execute(db, 'INSERT OR IGNORE INTO tags(name) VALUES (?)', tagName);
      const tag = await queryOne<{ id: number }>(db, 'SELECT id FROM tags WHERE name = ?', tagName);
      if (tag) {
        await execute(db, 'INSERT INTO post_tags(post_id, tag_id) VALUES (?, ?)', existing.id, tag.id);
      }
    }
  }

  return success(c, { updated: true });
});

// DELETE /posts/:slug - Delete post (admin only)
posts.delete('/:slug', requireAdmin, async (c) => {
  const slug = c.req.param('slug');
  const db = c.env.DB;

  const existing = await queryOne<Post>(db, 'SELECT id FROM posts WHERE slug = ?', slug);
  if (!existing) {
    return notFound(c, 'Post not found');
  }

  await execute(db, 'DELETE FROM posts WHERE id = ?', existing.id);

  return success(c, { deleted: true });
});

export default posts;

```

### rag.ts

**Path:** `workers/src/routes/rag.ts`

```typescript
/**
 * RAG Routes (Workers)
 * 
 * Cloudflare Tunnel을 통해 Backend API의 RAG 엔드포인트를 호출합니다.
 * 
 * 엔드포인트:
 * - POST /rag/search - 시맨틱 검색 (프록시)
 * - POST /rag/embed - 텍스트 임베딩 생성 (프록시)
 * - GET /rag/health - RAG 서비스 상태 확인 (프록시)
 */

import { Hono } from 'hono';
import type { Context } from 'hono';
import type { ContentfulStatusCode } from 'hono/utils/http-status';
import type { Env } from '../types';
import { success, error } from '../lib/response';
import { getApiBaseUrl } from '../lib/config';

type RagContext = { Bindings: Env };

const rag = new Hono<RagContext>();

/**
 * Backend RAG API로 요청을 프록시합니다.
 */
async function proxyToBackend(
  c: Context<RagContext>,
  path: string,
  method: 'GET' | 'POST' = 'POST'
) {
  const apiBaseUrl = await getApiBaseUrl(c.env);
  const upstreamUrl = `${apiBaseUrl}/api/v1/rag${path}`;

  const headers: HeadersInit = {
    'Content-Type': 'application/json',
  };

  const requestInit: RequestInit = {
    method,
    headers,
  };

  if (method === 'POST') {
    const body = await c.req.text();
    requestInit.body = body;
  }

  try {
    const response = await fetch(upstreamUrl, requestInit);
    const data = await response.json();

    if (!response.ok) {
      return error(c, (data as any).error || 'RAG request failed', response.status as ContentfulStatusCode);
    }

    return c.json(data);
  } catch (err) {
    const message = err instanceof Error ? err.message : 'RAG proxy failed';
    console.error('RAG proxy error:', message);
    return error(c, message, 500, 'RAG_PROXY_ERROR');
  }
}

/**
 * POST /search - 시맨틱 검색
 * 
 * Request Body:
 * {
 *   query: string,      // 검색 쿼리
 *   n_results?: number  // 반환할 결과 수 (기본 5)
 * }
 */
rag.post('/search', async (c) => {
  return proxyToBackend(c, '/search', 'POST');
});

/**
 * POST /embed - 텍스트 임베딩 생성
 * 
 * Request Body:
 * {
 *   texts: string[]  // 임베딩할 텍스트 배열
 * }
 */
rag.post('/embed', async (c) => {
  return proxyToBackend(c, '/embed', 'POST');
});

/**
 * GET /health - RAG 서비스 상태 확인
 */
rag.get('/health', async (c) => {
  return proxyToBackend(c, '/health', 'GET');
});

export default rag;

```

### translate.ts

**Path:** `workers/src/routes/translate.ts`

```typescript
import { Hono } from 'hono';
import type { ContentfulStatusCode } from 'hono/utils/http-status';
import type { Env } from '../types';
import { queryOne, execute } from '../lib/d1';
import { success, error } from '../lib/response';
import { generateContent } from '../lib/gemini';

const app = new Hono<{ Bindings: Env }>();

// Supported languages
const SUPPORTED_LANGS = ['ko', 'en'] as const;
type SupportedLang = (typeof SUPPORTED_LANGS)[number];

const LANG_NAMES: Record<SupportedLang, string> = {
  ko: 'Korean',
  en: 'English',
};

// Translation cache type
type TranslationCache = {
  id: number;
  post_slug: string;
  year: string;
  source_lang: string;
  target_lang: string;
  title: string;
  description: string | null;
  content: string;
  content_hash: string;
  is_ai_generated: number;
  created_at: string;
  updated_at: string;
};

// Simple hash function for content comparison
function hashContent(content: string): string {
  let hash = 0;
  for (let i = 0; i < content.length; i++) {
    const char = content.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return hash.toString(16);
}

// Truncate content for translation (to stay within token limits)
function truncateForTranslation(content: string, maxChars: number = 30000): string {
  if (content.length <= maxChars) return content;
  return content.slice(0, maxChars) + '\n\n[... content truncated for translation ...]';
}

/**
 * POST /api/v1/translate
 * Translate a blog post to target language
 */
app.post('/', async (c) => {
  try {
    const body = await c.req.json<{
      year: string;
      slug: string;
      targetLang: string;
      sourceLang?: string;
      title: string;
      description?: string;
      content: string;
      forceRefresh?: boolean;
    }>();

    const { year, slug, targetLang, title, description, content, forceRefresh } = body;
    const sourceLang = body.sourceLang || 'ko';
    
    console.log(`[translate] Request: ${year}/${slug} ${sourceLang} -> ${targetLang}`);

    // Validate inputs
    if (!year || !slug || !targetLang || !title || !content) {
      return error(c, 'year, slug, targetLang, title, and content are required', 400);
    }

    if (!SUPPORTED_LANGS.includes(targetLang as SupportedLang)) {
      return error(c, `Unsupported target language: ${targetLang}`, 400);
    }

    if (sourceLang === targetLang) {
      return success(c, {
        title,
        description: description || '',
        content,
        cached: false,
        message: 'Source and target languages are the same',
      });
    }

    const db = c.env.DB;
    const contentHash = hashContent(content);

    // Check cache first (unless forceRefresh)
    if (!forceRefresh) {
      const cached = await queryOne<TranslationCache>(
        db,
        `SELECT * FROM post_translations_cache 
         WHERE post_slug = ? AND year = ? AND target_lang = ?`,
        slug,
        year,
        targetLang
      );

      if (cached && cached.content_hash === contentHash) {
        return success(c, {
          title: cached.title,
          description: cached.description || '',
          content: cached.content,
          cached: true,
          isAiGenerated: cached.is_ai_generated === 1,
        });
      }
    }

    // Generate translation using AI
    const sourceLangName = LANG_NAMES[sourceLang as SupportedLang] || sourceLang;
    const targetLangName = LANG_NAMES[targetLang as SupportedLang] || targetLang;
    
    console.log(`[translate] Cache miss, calling AI for ${year}/${slug}`);

    // Translate title
    const titlePrompt = `Translate the following blog post title from ${sourceLangName} to ${targetLangName}. 
Return ONLY the translated title, nothing else.

Title: ${title}`;

    const translatedTitle = await generateContent(titlePrompt, c.env, {
      temperature: 0.1,
      maxTokens: 256,
    });

    // Translate description if provided
    let translatedDescription = '';
    if (description) {
      const descPrompt = `Translate the following blog post description from ${sourceLangName} to ${targetLangName}.
Return ONLY the translated description, nothing else.

Description: ${description}`;

      translatedDescription = await generateContent(descPrompt, c.env, {
        temperature: 0.1,
        maxTokens: 512,
      });
    }

    // Translate content (in chunks if necessary for very long posts)
    const truncatedContent = truncateForTranslation(content);
    const contentPrompt = `You are a professional translator. Translate the following blog post content from ${sourceLangName} to ${targetLangName}.

IMPORTANT RULES:
1. Preserve ALL markdown formatting exactly (headers, code blocks, lists, links, images, etc.)
2. Do NOT translate code snippets inside \`\`\` blocks
3. Do NOT translate URLs or file paths
4. Preserve technical terms when appropriate (with translation in parentheses if needed)
5. Maintain the same paragraph structure
6. Return ONLY the translated content, no explanations

Content:
${truncatedContent}`;

    const translatedContent = await generateContent(contentPrompt, c.env, {
      temperature: 0.2,
      maxTokens: 16000,
    });

    // Clean up the responses
    const cleanTitle = translatedTitle.trim().replace(/^["']|["']$/g, '');
    const cleanDescription = translatedDescription.trim().replace(/^["']|["']$/g, '');
    const cleanContent = translatedContent.trim();

    // Cache the translation
    await execute(
      db,
      `INSERT INTO post_translations_cache 
         (post_slug, year, source_lang, target_lang, title, description, content, content_hash, is_ai_generated)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1)
       ON CONFLICT(post_slug, year, target_lang)
       DO UPDATE SET
         source_lang = ?,
         title = ?,
         description = ?,
         content = ?,
         content_hash = ?,
         is_ai_generated = 1,
         updated_at = datetime('now')`,
      slug,
      year,
      sourceLang,
      targetLang,
      cleanTitle,
      cleanDescription,
      cleanContent,
      contentHash,
      sourceLang,
      cleanTitle,
      cleanDescription,
      cleanContent,
      contentHash
    );

    return success(c, {
      title: cleanTitle,
      description: cleanDescription,
      content: cleanContent,
      cached: false,
      isAiGenerated: true,
    });
  } catch (err) {
    console.error('[translate] Translation failed:', err);
    const message = err instanceof Error ? err.message : 'Translation failed';
    
    // Provide more specific error messages
    let statusCode: ContentfulStatusCode = 500;
    let errorMessage = message;
    
    if (message.includes('Backend AI error')) {
      statusCode = 502;
      errorMessage = 'AI 서버와 통신 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.';
    } else if (message.includes('timeout') || message.includes('TIMEOUT')) {
      statusCode = 504;
      errorMessage = 'AI 응답 지연 중입니다. 잠시 후 다시 시도해주세요.';
    }
    
    return error(c, errorMessage, statusCode);
  }
});

/**
 * GET /api/v1/translate/:year/:slug/:targetLang
 * Get cached translation for a post
 */
app.get('/:year/:slug/:targetLang', async (c) => {
  try {
    const { year, slug, targetLang } = c.req.param();
    const db = c.env.DB;

    const cached = await queryOne<TranslationCache>(
      db,
      `SELECT * FROM post_translations_cache 
       WHERE post_slug = ? AND year = ? AND target_lang = ?`,
      slug,
      year,
      targetLang
    );

    if (!cached) {
      return error(c, 'Translation not found', 404);
    }

    return success(c, {
      title: cached.title,
      description: cached.description || '',
      content: cached.content,
      cached: true,
      isAiGenerated: cached.is_ai_generated === 1,
      createdAt: cached.created_at,
      updatedAt: cached.updated_at,
    });
  } catch (err) {
    console.error('Failed to get translation:', err);
    return error(c, 'Failed to get translation', 500);
  }
});

/**
 * DELETE /api/v1/translate/:year/:slug/:targetLang
 * Delete cached translation
 */
app.delete('/:year/:slug/:targetLang', async (c) => {
  try {
    const { year, slug, targetLang } = c.req.param();
    const db = c.env.DB;

    await execute(
      db,
      `DELETE FROM post_translations_cache 
       WHERE post_slug = ? AND year = ? AND target_lang = ?`,
      slug,
      year,
      targetLang
    );

    return success(c, { deleted: true });
  } catch (err) {
    console.error('Failed to delete translation:', err);
    return error(c, 'Failed to delete translation', 500);
  }
});

export default app;

```

---

## workers/terminal-gateway

### package.json

**Path:** `workers/terminal-gateway/package.json`

```json
{
  "name": "terminal-gateway",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy",
    "deploy:prod": "wrangler deploy --env production"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20241127.0",
    "typescript": "^5.6.3",
    "wrangler": "^3.114.0"
  }
}

```

### tsconfig.json

**Path:** `workers/terminal-gateway/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "lib": ["ES2022"],
    "types": ["@cloudflare/workers-types"],
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

```

### wrangler.toml

**Path:** `workers/terminal-gateway/wrangler.toml`

```toml
#:schema node_modules/wrangler/config-schema.json
name = "terminal-gateway"
main = "src/index.ts"
compatibility_date = "2024-09-01"
compatibility_flags = ["nodejs_compat"]
account_id = "f6f11e2a4e5178d2f37476785018f761"

# Secrets (set via wrangler secret put):
# - ORIGIN_SECRET_KEY: Secret key to authenticate with origin server
# - JWT_SECRET: Secret key for JWT token verification (same as blog-api)

[vars]
ENV = "development"
# Origin server URL (Cloudflare Tunnel will route to this)
TERMINAL_ORIGIN = "https://terminal-origin.nodove.com"

# KV namespace for rate limiting and session tracking
[[kv_namespaces]]
binding = "KV"
id = "8bb28b36c3cb42da8ed7aca89f8cf0fe"

# Production environment
[env.production]
name = "terminal-gateway-prod"

[env.production.vars]
ENV = "production"
TERMINAL_ORIGIN = "https://terminal-origin.nodove.com"

[[env.production.kv_namespaces]]
binding = "KV"
id = "3d45140577d94404bc5f4bf000b07488"

```

---

## workers/terminal-gateway/src

### auth.ts

**Path:** `workers/terminal-gateway/src/auth.ts`

```typescript
/**
 * Terminal Gateway - JWT Authentication
 */

import type { Env, JWTPayload } from './types';

/**
 * Base64URL decode
 */
function base64UrlDecode(str: string): string {
  // Add padding if needed
  const padded = str + '==='.slice(0, (4 - (str.length % 4)) % 4);
  const base64 = padded.replace(/-/g, '+').replace(/_/g, '/');
  return atob(base64);
}

/**
 * Verify JWT token and extract payload
 * Uses simple HMAC-SHA256 verification
 */
export async function verifyToken(
  token: string | null,
  env: Env
): Promise<JWTPayload | null> {
  if (!token) {
    return null;
  }

  try {
    const parts = token.split('.');
    if (parts.length !== 3) {
      console.error('Invalid JWT format');
      return null;
    }

    const [headerB64, payloadB64, signatureB64] = parts;

    // Decode payload first to check expiration
    const payloadJson = base64UrlDecode(payloadB64);
    const payload = JSON.parse(payloadJson) as JWTPayload;

    // Check expiration
    const now = Math.floor(Date.now() / 1000);
    if (payload.exp && payload.exp < now) {
      console.error('Token expired');
      return null;
    }

    // Verify signature using Web Crypto API
    const encoder = new TextEncoder();
    const key = await crypto.subtle.importKey(
      'raw',
      encoder.encode(env.JWT_SECRET),
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['verify']
    );

    // Decode signature from base64url
    const signaturePadded =
      signatureB64 + '==='.slice(0, (4 - (signatureB64.length % 4)) % 4);
    const signatureBase64 = signaturePadded
      .replace(/-/g, '+')
      .replace(/_/g, '/');
    const signatureBytes = Uint8Array.from(atob(signatureBase64), (c) =>
      c.charCodeAt(0)
    );

    const data = encoder.encode(`${headerB64}.${payloadB64}`);
    const valid = await crypto.subtle.verify('HMAC', key, signatureBytes, data);

    if (!valid) {
      console.error('Invalid signature');
      return null;
    }

    return payload;
  } catch (err) {
    console.error('Token verification failed:', err);
    return null;
  }
}

/**
 * Extract token from request
 * Supports: query param, Authorization header, cookie
 */
export function extractToken(request: Request): string | null {
  const url = new URL(request.url);

  // 1. Query parameter
  const queryToken = url.searchParams.get('token');
  if (queryToken) {
    return queryToken;
  }

  // 2. Authorization header (Bearer token)
  const authHeader = request.headers.get('Authorization');
  if (authHeader?.startsWith('Bearer ')) {
    return authHeader.slice(7);
  }

  // 3. Cookie
  const cookies = request.headers.get('Cookie') || '';
  const tokenCookie = cookies
    .split(';')
    .find((c) => c.trim().startsWith('terminal_token='));
  if (tokenCookie) {
    return tokenCookie.split('=')[1]?.trim() || null;
  }

  return null;
}

```

### index.ts

**Path:** `workers/terminal-gateway/src/index.ts`

```typescript
/**
 * Terminal Gateway - Main Entry Point
 *
 * Cloudflare Worker that acts as a security gateway for WebSocket connections
 * to the Docker terminal origin server.
 *
 * Features:
 * - JWT authentication
 * - Rate limiting (IP-based)
 * - Single session per user
 * - Secret key injection for origin authentication
 * - Geo-blocking (optional)
 */

import type { Env } from './types';
import { verifyToken, extractToken } from './auth';
import {
  checkRateLimit,
  hasActiveSession,
  createSession,
  deleteSession,
} from './ratelimit';

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    // Health check endpoint
    if (url.pathname === '/health') {
      return new Response(
        JSON.stringify({ status: 'ok', env: env.ENV }),
        {
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    // Only handle /terminal path
    if (url.pathname !== '/terminal' && url.pathname !== '/terminal/') {
      return new Response('Not Found', { status: 404 });
    }

    // 1. Check WebSocket upgrade request
    const upgradeHeader = request.headers.get('Upgrade');
    if (!upgradeHeader || upgradeHeader.toLowerCase() !== 'websocket') {
      return new Response('Expected Upgrade: websocket', { status: 426 });
    }

    // 2. Extract and verify token
    const token = extractToken(request);
    const user = await verifyToken(token, env);

    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    const userId = user.sub;
    const clientIP = request.headers.get('CF-Connecting-IP') || 'unknown';

    // 3. Rate limiting check
    const rateLimitResult = await checkRateLimit(clientIP, env.KV);
    if (!rateLimitResult.allowed) {
      return new Response('Too Many Requests', {
        status: 429,
        headers: {
          'Retry-After': String(
            rateLimitResult.resetAt - Math.floor(Date.now() / 1000)
          ),
          'X-RateLimit-Remaining': '0',
          'X-RateLimit-Reset': String(rateLimitResult.resetAt),
        },
      });
    }

    // 4. Check for existing session (1 session per user)
    const existingSession = await hasActiveSession(userId, env.KV);
    if (existingSession) {
      return new Response('Session already active', { status: 409 });
    }

    // 5. Optional: Geo-blocking
    const country = request.cf?.country as string | undefined;
    const blockedCountries = ['CN', 'RU', 'KP']; // Example blocked countries
    if (country && blockedCountries.includes(country)) {
      console.log(`Blocked connection from country: ${country}`);
      return new Response('Forbidden', { status: 403 });
    }

    // 6. Create session
    await createSession(userId, clientIP, env.KV);

    // 7. Prepare origin request with injected headers
    const originUrl = `${env.TERMINAL_ORIGIN}/terminal`;
    const originHeaders = new Headers(request.headers);

    // Inject secret key for origin authentication
    originHeaders.set('X-Origin-Secret', env.ORIGIN_SECRET_KEY);
    originHeaders.set('X-User-ID', userId);
    originHeaders.set('X-User-Email', user.email || '');
    originHeaders.set('X-Client-IP', clientIP);
    originHeaders.set('X-Request-ID', crypto.randomUUID());

    const originRequest = new Request(originUrl, {
      method: request.method,
      headers: originHeaders,
    });

    // 8. Proxy to origin
    try {
      const response = await fetch(originRequest);

      // If connection fails or closes, clean up session
      if (!response.ok || response.status >= 400) {
        await deleteSession(userId, env.KV);
      }

      return response;
    } catch (err) {
      console.error('Origin connection failed:', err);
      await deleteSession(userId, env.KV);
      return new Response('Bad Gateway', { status: 502 });
    }
  },
};

```

### ratelimit.ts

**Path:** `workers/terminal-gateway/src/ratelimit.ts`

```typescript
/**
 * Terminal Gateway - Rate Limiting
 * 
 * Uses KV to track connection attempts per IP
 * Limits: 5 connections per minute, 1 concurrent session per user
 */

import type { Env, RateLimitResult, SessionInfo } from './types';

const RATE_LIMIT_WINDOW = 60; // 1 minute in seconds
const RATE_LIMIT_MAX = 5; // max connections per window
const SESSION_TTL = 15 * 60; // 15 minutes session TTL

/**
 * Check rate limit for an IP address
 */
export async function checkRateLimit(
  clientIP: string,
  kv: KVNamespace
): Promise<RateLimitResult> {
  const key = `ratelimit:${clientIP}`;
  const now = Math.floor(Date.now() / 1000);

  try {
    const data = await kv.get(key);
    let count = 0;
    let windowStart = now;

    if (data) {
      const parsed = JSON.parse(data);
      // Check if we're still in the same window
      if (now - parsed.windowStart < RATE_LIMIT_WINDOW) {
        count = parsed.count;
        windowStart = parsed.windowStart;
      }
    }

    // Check if limit exceeded
    if (count >= RATE_LIMIT_MAX) {
      return {
        allowed: false,
        remaining: 0,
        resetAt: windowStart + RATE_LIMIT_WINDOW,
      };
    }

    // Increment counter
    count++;
    await kv.put(
      key,
      JSON.stringify({ count, windowStart }),
      { expirationTtl: RATE_LIMIT_WINDOW }
    );

    return {
      allowed: true,
      remaining: RATE_LIMIT_MAX - count,
      resetAt: windowStart + RATE_LIMIT_WINDOW,
    };
  } catch (err) {
    console.error('Rate limit check failed:', err);
    // Allow on error (fail open)
    return { allowed: true, remaining: 1, resetAt: now + RATE_LIMIT_WINDOW };
  }
}

/**
 * Check if user already has an active session
 */
export async function hasActiveSession(
  userId: string,
  kv: KVNamespace
): Promise<boolean> {
  const key = `session:${userId}`;
  try {
    const session = await kv.get(key);
    if (!session) {
      return false;
    }

    const info = JSON.parse(session) as SessionInfo;
    const now = Date.now();

    // Check if session is still valid (activity within last 5 minutes)
    if (now - info.lastActivity > 5 * 60 * 1000) {
      // Session expired, clean up
      await kv.delete(key);
      return false;
    }

    return true;
  } catch (err) {
    console.error('Session check failed:', err);
    return false;
  }
}

/**
 * Create a new session for user
 */
export async function createSession(
  userId: string,
  clientIP: string,
  kv: KVNamespace
): Promise<void> {
  const key = `session:${userId}`;
  const session: SessionInfo = {
    userId,
    clientIP,
    connectedAt: Date.now(),
    lastActivity: Date.now(),
  };

  await kv.put(key, JSON.stringify(session), { expirationTtl: SESSION_TTL });
}

/**
 * Update session activity timestamp
 */
export async function updateSessionActivity(
  userId: string,
  kv: KVNamespace
): Promise<void> {
  const key = `session:${userId}`;
  try {
    const data = await kv.get(key);
    if (data) {
      const session = JSON.parse(data) as SessionInfo;
      session.lastActivity = Date.now();
      await kv.put(key, JSON.stringify(session), { expirationTtl: SESSION_TTL });
    }
  } catch (err) {
    console.error('Session update failed:', err);
  }
}

/**
 * Delete user session
 */
export async function deleteSession(
  userId: string,
  kv: KVNamespace
): Promise<void> {
  const key = `session:${userId}`;
  await kv.delete(key);
}

```

### types.ts

**Path:** `workers/terminal-gateway/src/types.ts`

```typescript
/**
 * Terminal Gateway - Type Definitions
 */

export interface Env {
  // Environment variables
  ENV: string;
  TERMINAL_ORIGIN: string;

  // Secrets
  ORIGIN_SECRET_KEY: string;
  JWT_SECRET: string;

  // KV Namespace
  KV: KVNamespace;
}

export interface JWTPayload {
  sub: string; // user id
  email?: string;
  exp: number;
  iat: number;
}

export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetAt: number;
}

export interface SessionInfo {
  userId: string;
  clientIP: string;
  connectedAt: number;
  lastActivity: number;
}

```

---


name: Backend Build & Deploy (SSH Compose)

# =============================================================================
# Full Stack Deployment with Virtual Agent Service (VAS)
# =============================================================================
# Architecture:
#   cloudflared -> nginx -> api -> vas-proxy -> vas-core -> LLM
#
# Services deployed:
#   - api: Node.js backend (built from Dockerfile)
#   - nginx: Reverse proxy
#   - cloudflared: Cloudflare Tunnel
#   - vas-core: OpenCode LLM engine
#   - vas-admin: Token management UI
#   - vas-bootstrap: Auto JWT token generator
#   - vas-proxy: Simplified /auto-chat API
#   - embedding-server: TEI for RAG
#   - chromadb: Vector database
#   - terminal-server: Docker PTY server
#
# Required secrets:
#   - SSH_HOST, SSH_USER, SSH_PRIVATE_KEY, SSH_PORT (optional)
#   - REMOTE_DIR: Remote deployment directory
#   - BACKEND_ENV_FILE: Full .env file contents
#   - PUBLIC_API_BASE_URL: Public API URL for health checks
# =============================================================================

on:
  push:
    paths:
      - 'backend/**'
      - '.github/workflows/backend-deploy.yml'
    branches: [ main ]
  workflow_dispatch:
    inputs:
      ref:
        description: 'Ref (branch/sha) to deploy'
        required: false
        default: ''
      skip_build:
        description: 'Skip build, only pull and restart (for config changes)'
        required: false
        default: false
        type: boolean

permissions:
  contents: read

concurrency:
  group: backend-deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      IMAGE_NAME: blog-backend
      IMAGE_TAG: ${{ github.sha }}
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
      REMOTE_DIR: ${{ secrets.REMOTE_DIR }}
      PUBLIC_API_BASE_URL: ${{ secrets.PUBLIC_API_BASE_URL }}
      PUBLIC_FRONTEND_ORIGIN: https://noblog.nodove.com

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.ref || github.ref }}

      - name: Set up Docker Buildx
        if: ${{ github.event.inputs.skip_build != 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Build backend API image (local load)
        if: ${{ github.event.inputs.skip_build != 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Build VAS Core image
        if: ${{ github.event.inputs.skip_build != 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: ./backend/opencode-serve
          file: ./backend/opencode-serve/ai-serve.Dockerfile
          push: false
          load: true
          tags: vas-core:${{ env.IMAGE_TAG }}

      - name: Build VAS Admin image
        if: ${{ github.event.inputs.skip_build != 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: ./backend/opencode-serve/go-proxy-admin
          file: ./backend/opencode-serve/go-proxy-admin/Dockerfile
          push: false
          load: true
          tags: vas-admin:${{ env.IMAGE_TAG }}

      - name: Build Terminal Server image
        if: ${{ github.event.inputs.skip_build != 'true' }}
        uses: docker/build-push-action@v5
        with:
          context: ./backend/terminal-server
          file: ./backend/terminal-server/Dockerfile
          push: false
          load: true
          tags: terminal-server:${{ env.IMAGE_TAG }}

      - name: Save images artifact (gzip)
        if: ${{ github.event.inputs.skip_build != 'true' }}
        run: |
          docker save \
            "${IMAGE_NAME}:${IMAGE_TAG}" \
            "vas-core:${IMAGE_TAG}" \
            "vas-admin:${IMAGE_TAG}" \
            "terminal-server:${IMAGE_TAG}" \
            | gzip > backend-images.tar.gz
          ls -lh backend-images.tar.gz

      - name: Start ssh-agent and add key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add remote host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p "${SSH_PORT}" -H "${SSH_HOST}" >> ~/.ssh/known_hosts

      - name: Prepare .env from secret
        run: |
          if [ -z "${{ secrets.BACKEND_ENV_FILE }}" ]; then
            echo "BACKEND_ENV_FILE secret is missing." >&2; exit 1;
          fi
          printf "%s" "${{ secrets.BACKEND_ENV_FILE }}" > /tmp/backend.env

      - name: Upload artifacts to remote
        run: |
          test -n "${REMOTE_DIR}" || { echo "REMOTE_DIR secret is missing" >&2; exit 1; }
          ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "mkdir -p ${REMOTE_DIR}/opencode-serve"

          # Upload images (if built)
          if [ -f backend-images.tar.gz ]; then
            scp -P "${SSH_PORT}" backend-images.tar.gz "${SSH_USER}@${SSH_HOST}:${REMOTE_DIR}/"
          fi

          # Upload config files
          scp -P "${SSH_PORT}" backend/nginx.conf "${SSH_USER}@${SSH_HOST}:${REMOTE_DIR}/nginx.conf"
          scp -P "${SSH_PORT}" /tmp/backend.env "${SSH_USER}@${SSH_HOST}:${REMOTE_DIR}/.env"

          # Upload VAS proxy script and bootstrap script
          scp -P "${SSH_PORT}" backend/opencode-serve/auto-chat-proxy.js "${SSH_USER}@${SSH_HOST}:${REMOTE_DIR}/opencode-serve/"
          scp -P "${SSH_PORT}" backend/opencode-serve/bootstrap-token.sh "${SSH_USER}@${SSH_HOST}:${REMOTE_DIR}/opencode-serve/"

      - name: Deploy full stack on remote
        env:
          SHA: ${{ github.sha }}
          SKIP_BUILD: ${{ github.event.inputs.skip_build }}
        run: |
          ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "REMOTE_DIR='${REMOTE_DIR}' SHA='${SHA}' bash -s" <<'REMOTE_EOF'
          set -euo pipefail
          DC="docker compose"
          if ! $DC version >/dev/null 2>&1; then DC="docker-compose"; fi
          cd "${REMOTE_DIR}"
          IMAGE_TAG="${SHA}"
          IMAGE_NAME="blog-backend"

          # Load images if present
          if [ -f backend-images.tar.gz ]; then
            echo "Loading images on remote..."
            gzip -dc backend-images.tar.gz | docker load
            rm -f backend-images.tar.gz
          fi

          # Generate runtime compose file with full VAS stack
          cat > compose.runtime.yml <<'YML'
          # =======================================================================
          # Runtime Compose - Single Entry Point Architecture
          # =======================================================================
          # Cloudflare Tunnel → nginx:80 → Internal Services
          #
          # Routes:
          #   /api/*       → api:5080
          #   /ai/*        → vas-proxy:7016
          #   /vas/*       → vas-core:7012
          #   /vas-admin/* → vas-admin:7080
          #   /terminal/*  → terminal-server:8080
          # =======================================================================

          services:
            # Cloudflare Tunnel (connects to nginx only)
            cloudflared:
              image: cloudflare/cloudflared:latest
              command: tunnel --no-autoupdate run
              environment:
                - TUNNEL_TOKEN=${CLOUDFLARE_TUNNEL_TOKEN}
              depends_on:
                nginx:
                  condition: service_healthy
              networks:
                - backend
              restart: unless-stopped

            # Nginx Reverse Proxy (Single Entry Point)
            nginx:
              image: nginx:alpine
              depends_on:
                api:
                  condition: service_healthy
              expose:
                - "80"
              volumes:
                - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
              networks:
                - backend
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "wget", "-q", "--spider", "http://localhost/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 10s

            # Backend API Server
            api:
              image: blog-backend:IMAGE_TAG_PLACEHOLDER
              env_file: .env
              environment:
                - APP_ENV=production
                - HOST=0.0.0.0
                - PORT=5080
                - AI_SERVE_BASE_URL=http://vas-proxy:7016
                - VAS_CORE_URL=http://vas-core:7012
                - AI_SERVE_DEFAULT_PROVIDER=github-copilot
                - AI_SERVE_DEFAULT_MODEL=gpt-4.1
              expose:
                - "5080"
              networks:
                - backend
              depends_on:
                embedding-server:
                  condition: service_started
                chromadb:
                  condition: service_healthy
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "wget", "-q", "--spider", "http://localhost:5080/api/v1/healthz"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 15s

            # TEI Embedding Server
            embedding-server:
              image: ghcr.io/huggingface/text-embeddings-inference:cpu-1.2.3
              command: --model-id sentence-transformers/all-MiniLM-L6-v2
              ports:
                - "127.0.0.1:8180:80"
              volumes:
                - tei-data:/data
              networks:
                - backend
              restart: unless-stopped

            # ChromaDB
            chromadb:
              image: chromadb/chroma:0.5.23
              environment:
                - IS_PERSISTENT=TRUE
                - PERSIST_DIRECTORY=/chroma/chroma
                - ANONYMIZED_TELEMETRY=FALSE
              ports:
                - "127.0.0.1:8100:8000"
              volumes:
                - chroma-data:/chroma/chroma
              networks:
                - backend
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "wget", "-q", "--spider", "http://localhost:8000/api/v1/heartbeat"]
                interval: 30s
                timeout: 10s
                retries: 3

            # Terminal Server
            terminal-server:
              image: terminal-server:IMAGE_TAG_PLACEHOLDER
              environment:
                - ORIGIN_SECRET_KEY=${ORIGIN_SECRET_KEY:-default-secret-change-me}
                - SANDBOX_IMAGE=${SANDBOX_IMAGE:-alpine:latest}
              expose:
                - "8080"
              volumes:
                - /var/run/docker.sock:/var/run/docker.sock:ro
              networks:
                - backend
              restart: unless-stopped

            # VAS Core (OpenCode Engine)
            vas-core:
              image: vas-core:IMAGE_TAG_PLACEHOLDER
              restart: unless-stopped
              expose:
                - "7012"
              environment:
                NODE_ENV: production
                OPENCODE_HOST: 0.0.0.0
                OPENCODE_PORT: 7012
              command:
                - /app/node_modules/.bin/opencode
                - serve
                - --hostname
                - 0.0.0.0
                - --port
                - "7012"
              volumes:
                - vas-data:/home/node/.local/share/opencode
                - vas-logs:/var/log/opencode
                - vas-config:/home/node/.config/opencode
              networks:
                - backend
              healthcheck:
                test: ["CMD-SHELL", "node -e \"const http=require('http'); http.get('http://localhost:7012/app', ()=>process.exit(0)).on('error', ()=>process.exit(1));\" "]
                interval: 30s
                timeout: 5s
                retries: 3
                start_period: 10s
              security_opt:
                - no-new-privileges:true

            # VAS Bootstrap (Auto JWT Token)
            vas-bootstrap:
              image: curlimages/curl:latest
              restart: "no"
              user: "0:0"
              entrypoint: ["/bin/sh", "/app/bootstrap-token.sh"]
              environment:
                ADMIN_URL: http://vas-admin:7080
                TOKEN_FILE: /app/shared/auto-token.jwt
                MAX_RETRIES: "60"
                RETRY_INTERVAL: "2"
              volumes:
                - ./opencode-serve/bootstrap-token.sh:/app/bootstrap-token.sh:ro
                - vas-shared:/app/shared
              networks:
                - backend
              depends_on:
                vas-admin:
                  condition: service_started

            # VAS Proxy (/auto-chat API)
            vas-proxy:
              image: node:20-alpine
              restart: unless-stopped
              command: ["node", "/app/auto-chat-proxy.js"]
              environment:
                OPENCODE_BASE: http://vas-core:7012
                PROXY_PORT: 7016
                DEFAULT_PROVIDER: github-copilot
                DEFAULT_MODEL: gpt-4.1
                DEFAULT_SESSION_TITLE: Auto Session
                OPENCODE_BEARER_TOKEN_FILE: /app/shared/auto-token.jwt
                TOKEN_FILE_POLL_INTERVAL: "3000"
                TOKEN_FILE_MAX_WAIT: "300000"
                MESSAGE_TIMEOUT: "120000"
              expose:
                - "7016"
              volumes:
                - ./opencode-serve/auto-chat-proxy.js:/app/auto-chat-proxy.js:ro
                - vas-shared:/app/shared:ro
              networks:
                - backend
              depends_on:
                vas-core:
                  condition: service_healthy
                vas-bootstrap:
                  condition: service_completed_successfully
              security_opt:
                - no-new-privileges:true
              healthcheck:
                test: ["CMD-SHELL", "wget -q -O- http://localhost:7016/health || exit 1"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 120s

            # VAS Admin (Token Management)
            vas-admin:
              image: vas-admin:IMAGE_TAG_PLACEHOLDER
              restart: unless-stopped
              expose:
                - "7080"
              environment:
                OPENCODE_BASE: http://vas-core:7012
                ADMIN_JWT_SECRET: ${ADMIN_JWT_SECRET:-auto-generated-secret-change-in-production}
                ADMIN_PORT: 7080
                ADMIN_DB_PATH: /app/data/vas-admin.db
                ADMIN_EMAIL: ${ADMIN_EMAIL:-admin@example.com}
                ADMIN_PASSWORD: ${ADMIN_PASSWORD:-}
                AUTO_BOOTSTRAP: "true"
              volumes:
                - vas-admin-data:/app/data
              networks:
                - backend
              depends_on:
                vas-core:
                  condition: service_healthy
              security_opt:
                - no-new-privileges:true

          networks:
            backend:
              driver: bridge

          volumes:
            tei-data:
            chroma-data:
            vas-data:
            vas-logs:
            vas-config:
            vas-admin-data:
            vas-shared:
          YML

          # Replace image tag placeholder
          sed -i "s/IMAGE_TAG_PLACEHOLDER/${IMAGE_TAG}/g" compose.runtime.yml

          echo "Bringing up full stack..."
          $DC -f compose.runtime.yml up -d --remove-orphans

          # Wait for services to be healthy
          echo "Waiting for API health check..."
          for i in $(seq 1 60); do
            if curl -fsS http://localhost:5080/api/v1/healthz >/dev/null 2>&1; then
              echo "API Health OK"
              break
            fi
            echo "API Retry $i/60"; sleep 2;
          done

          echo "Waiting for VAS Proxy health check..."
          for i in $(seq 1 60); do
            if curl -fsS http://localhost:7016/health >/dev/null 2>&1; then
              echo "VAS Proxy Health OK"
              break
            fi
            echo "VAS Proxy Retry $i/60"; sleep 2;
          done

          # Final status
          echo ""
          echo "=== Service Status ==="
          $DC -f compose.runtime.yml ps

          # Verify critical services are running
          if ! curl -fsS http://localhost:5080/api/v1/healthz >/dev/null 2>&1; then
            echo "FATAL: API health check failed"
            $DC -f compose.runtime.yml logs --no-color api | tail -n 100
            exit 1
          fi

          echo ""
          echo "Deployment successful!"
          REMOTE_EOF

      - name: External health check (public domain)
        if: ${{ env.PUBLIC_API_BASE_URL != '' }}
        run: |
          echo "Checking public health at ${PUBLIC_API_BASE_URL}/api/v1/healthz ..."
          for i in $(seq 1 30); do
            if curl -fsS "${PUBLIC_API_BASE_URL}/api/v1/healthz" >/dev/null; then
              echo "Public health OK"; exit 0;
            fi
            echo "Retry $i/30"; sleep 2;
          done
          echo "Public health check failed at ${PUBLIC_API_BASE_URL}/api/v1/healthz" >&2
          exit 1

      - name: Verify public runtime config
        if: ${{ env.PUBLIC_API_BASE_URL != '' }}
        run: |
          echo "Fetching ${PUBLIC_API_BASE_URL}/api/v1/public/config"
          cfg=$(curl -fsS "${PUBLIC_API_BASE_URL}/api/v1/public/config")
          echo "$cfg"
          echo "$cfg" | grep -q '"ok":\s*true' || { echo 'Config ok=false' >&2; exit 1; }
          echo "$cfg" | grep -q "\"apiBaseUrl\":\s*\"${PUBLIC_API_BASE_URL}\"" || { echo 'apiBaseUrl mismatch' >&2; exit 1; }

      - name: Check CORS header for frontend origin
        if: ${{ env.PUBLIC_API_BASE_URL != '' }}
        run: |
          echo "Checking CORS for origin ${PUBLIC_FRONTEND_ORIGIN}"
          headers=$(curl -fsS -D - -o /dev/null -H "Origin: ${PUBLIC_FRONTEND_ORIGIN}" "${PUBLIC_API_BASE_URL}/api/v1/healthz")
          echo "$headers"
          printf "%s" "$headers" | awk 'tolower($0) ~ /^access-control-allow-origin:/ {print}' | grep -q "${PUBLIC_FRONTEND_ORIGIN}" || {
            echo "CORS header missing or mismatched for origin ${PUBLIC_FRONTEND_ORIGIN}" >&2; exit 1; }

      - name: Verify VAS Proxy via public endpoint
        if: ${{ env.PUBLIC_API_BASE_URL != '' }}
        run: |
          echo "Checking VAS integration via ${PUBLIC_API_BASE_URL}/api/v1/ai/health ..."
          # Note: This endpoint should exist in your API to proxy health check to vas-proxy
          response=$(curl -fsS "${PUBLIC_API_BASE_URL}/api/v1/ai/health" 2>&1 || echo '{"error":"endpoint not found"}')
          echo "$response"
          # Allow this to fail gracefully if endpoint doesn't exist yet
          echo "VAS public check completed (check logs above for status)"

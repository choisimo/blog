name: Deploy Blog + n8n Workflow Stack

# =============================================================================
# Blog Backend + n8n Workflow CI/CD Pipeline (PRIMARY BACKEND DEPLOYMENT)
# =============================================================================
#
# This is the PRIMARY workflow for deploying backend services.
# Previously, backend-deploy.yml was also used but has been deprecated to avoid
# conflicts (same triggers, different compose files, port conflicts).
#
# NOTE: Primary API Gateway is now Cloudflare Workers (see deploy-api-gateway.yml).
# This workflow deploys the n8n workflow engine and supporting backend services.
# AI services have been migrated to Cloudflare Workers (see deploy-ai-check-gateway.yml).
#
# Architecture:
#   GitHub Actions → Build Images → Push to GHCR → SSH Deploy → docker compose up
#
# Services Deployed:
#   - Blog API (ghcr.io/choisimo/blog-api) - Backend for n8n integration
#   - OpenCode Backend (ghcr.io/choisimo/opencode-backend) - AI API orchestration
#   - OpenCode Serve (ghcr.io/choisimo/opencode-serve) - AI model serving
#   - Terminal Server (ghcr.io/choisimo/blog-terminal)
#   - n8n + Workers - Workflow automation
#   - PostgreSQL, Redis, MongoDB, Qdrant, ChromaDB, etc.
#
# Deployment Directory: ~/blog-stack
#
# Required Secrets: See README-CICD.md
# =============================================================================

on:
  push:
    branches: [main]
    paths:
      - 'backend/**'
      - 'shared/**'
      - '.github/workflows/deploy-blog-workflow.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      skip_build:
        description: 'Skip build, only deploy (for config changes)'
        required: false
        default: false
        type: boolean
      image_tag:
        description: 'Custom image tag (default: git SHA)'
        required: false
        default: ''

permissions:
  contents: read
  packages: write

concurrency:
  group: backend-deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  DEPLOY_DIR: blog-stack

jobs:
  # ===========================================================================
  # Job 1: Build and Push Docker Images
  # ===========================================================================
  build-and-push:
    name: Build & Push Images
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_build != 'true' }}

    outputs:
      image_tag: ${{ steps.meta.outputs.version }}
      sha_short: ${{ steps.vars.outputs.sha_short }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up variables
        id: vars
        run: |
          SHA_SHORT=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "sha_short=${SHA_SHORT}" >> $GITHUB_OUTPUT
          echo "SHA Short: ${SHA_SHORT}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta - API
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/blog-api
          tags: |
            type=sha,prefix=
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=raw,value=${{ github.event.inputs.image_tag }},enable=${{ github.event.inputs.image_tag != '' }}

      # Build Blog API
      - name: Build and push Blog API
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build Terminal Server
      - name: Build and push Terminal Server
        uses: docker/build-push-action@v5
        with:
          context: ./backend/terminal-server
          file: ./backend/terminal-server/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/blog-terminal:${{ steps.vars.outputs.sha_short }}
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/blog-terminal:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Note: OpenCode Backend and OpenCode Serve images are managed separately
      # and pulled directly from GHCR during deployment.
      # Images: ghcr.io/choisimo/opencode-backend:latest
      #         ghcr.io/choisimo/opencode-serve:latest

  # ===========================================================================
  # Job 2: Deploy to Server
  # ===========================================================================
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: always() && (needs.build-and-push.result == 'success' || github.event.inputs.skip_build == 'true')

    env:
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
      IMAGE_TAG: ${{ needs.build-and-push.outputs.sha_short || github.event.inputs.image_tag || 'latest' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p "${{ env.SSH_PORT }}" -H "${{ env.SSH_HOST }}" >> ~/.ssh/known_hosts

      - name: Generate .env file
        run: |
          cat > /tmp/blog-stack.env << 'ENVEOF'
          # =============================================================================
          # Blog + n8n Workflow Stack Environment Variables
          # Generated by GitHub Actions at ${{ github.event.head_commit.timestamp }}
          # Commit: ${{ github.sha }}
          # =============================================================================

          # Application
          APP_ENV=${{ vars.APP_ENV || 'production' }}
          IMAGE_TAG=${{ env.IMAGE_TAG }}
          GITHUB_REPOSITORY_OWNER=${{ github.repository_owner }}

          # URLs
          SITE_BASE_URL=${{ vars.SITE_BASE_URL || 'https://noblog.nodove.com' }}
          API_BASE_URL=${{ vars.API_BASE_URL || 'https://api.nodove.com' }}

          # PostgreSQL
          POSTGRES_DB=${{ vars.POSTGRES_DB || 'blog' }}
          POSTGRES_USER=${{ vars.POSTGRES_USER || 'bloguser' }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}

          # Redis
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}

          # MongoDB
          MONGO_USER=${{ vars.MONGO_USER || 'mongouser' }}
          MONGO_PASSWORD=${{ secrets.MONGO_PASSWORD }}
          MONGO_DB=${{ vars.MONGO_DB || 'blog' }}

          # Qdrant
          QDRANT_API_KEY=${{ secrets.QDRANT_API_KEY }}

          # AI Configuration
          AI_DEFAULT_MODEL=${{ vars.AI_DEFAULT_MODEL || 'gemini-1.5-flash' }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          GOOGLE_API_KEY=${{ secrets.GEMINI_API_KEY }}
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
          VAS_API_KEY=

          # AI Admin
          ADMIN_JWT_SECRET=${{ secrets.ADMIN_JWT_SECRET }}
          ADMIN_EMAIL=${{ vars.ADMIN_EMAIL || 'admin@nodove.com' }}
          ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}

          # n8n (all URLs use blog-bw.nodove.com)
          N8N_USER=${{ vars.N8N_USER || 'admin' }}
          N8N_PASS=${{ secrets.N8N_PASS }}
          N8N_ENCRYPTION_KEY=${{ secrets.N8N_ENCRYPTION_KEY }}
          N8N_API_KEY=${{ secrets.N8N_API_KEY }}
          N8N_WEBHOOK_URL=${{ vars.N8N_WEBHOOK_URL || 'https://blog-bw.nodove.com/' }}
          N8N_HOST=${{ vars.N8N_HOST || 'blog-bw.nodove.com' }}
          N8N_EDITOR_BASE_URL=${{ vars.N8N_EDITOR_BASE_URL || 'https://blog-bw.nodove.com' }}
          N8N_WORKER_REPLICAS=${{ vars.N8N_WORKER_REPLICAS || '2' }}

          # Cloudflare
          CF_ACCOUNT_ID=${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CF_API_TOKEN=${{ secrets.CLOUDFLARE_API_TOKEN }}
          D1_DATABASE_ID=${{ secrets.CLOUDFLARE_D1_DATABASE_ID }}
          R2_BUCKET_NAME=${{ vars.R2_BUCKET_NAME || 'blog' }}
          R2_ASSETS_BASE_URL=${{ secrets.ASSETS_BASE_URL || 'https://assets-b.nodove.com' }}

          # GitHub
          GITHUB_TOKEN=${{ secrets.GH_PAT_TOKEN }}
          GITHUB_REPO_OWNER=${{ vars.GITHUB_REPO_OWNER || 'choisimo' }}
          GITHUB_REPO_NAME=${{ vars.GITHUB_REPO_NAME || 'blog' }}

          # Admin Auth
          ADMIN_BEARER_TOKEN=${{ secrets.ADMIN_BEARER_TOKEN }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          ADMIN_USERNAME=${{ vars.ADMIN_USERNAME || 'admin' }}

          # Terminal Server
          ORIGIN_SECRET_KEY=${{ secrets.ORIGIN_SECRET_KEY }}
          SANDBOX_IMAGE=${{ vars.SANDBOX_IMAGE || 'alpine:latest' }}

          # MinIO
          MINIO_USER=${{ vars.MINIO_USER || 'minioadmin' }}
          MINIO_PASSWORD=${{ secrets.MINIO_PASSWORD }}

          # Firecrawl
          FIRECRAWL_API_TOKEN=${{ secrets.FIRECRAWL_API_TOKEN }}

          # Monitoring (optional)
          GRAFANA_PASSWORD=${{ secrets.GRAFANA_PASSWORD }}
          PGADMIN_EMAIL=${{ vars.PGADMIN_EMAIL || 'admin@nodove.com' }}
          PGADMIN_PASSWORD=${{ secrets.PGADMIN_PASSWORD }}
          ENVEOF

      - name: Upload files to server
        run: |
          # Create deployment directory in user's home
          ssh -p "${{ env.SSH_PORT }}" "${{ env.SSH_USER }}@${{ env.SSH_HOST }}" \
            "mkdir -p ~/${{ env.DEPLOY_DIR }}/{scripts,n8n-workflows,n8n_files,opencode-config,ssl}"

          # Upload .env
          scp -P "${{ env.SSH_PORT }}" /tmp/blog-stack.env \
            "${{ env.SSH_USER }}@${{ env.SSH_HOST }}:~/${{ env.DEPLOY_DIR }}/.env"

          # Upload compose file
          scp -P "${{ env.SSH_PORT }}" backend/docker-compose.blog-workflow.yml \
            "${{ env.SSH_USER }}@${{ env.SSH_HOST }}:~/${{ env.DEPLOY_DIR }}/docker-compose.yml"

          # Upload nginx config (consolidated)
          scp -P "${{ env.SSH_PORT }}" backend/nginx/nginx.conf \
            "${{ env.SSH_USER }}@${{ env.SSH_HOST }}:~/${{ env.DEPLOY_DIR }}/nginx.conf"

          # Upload bootstrap script
          if [ -f backend/opencode-serve/bootstrap-token.sh ]; then
            scp -P "${{ env.SSH_PORT }}" backend/opencode-serve/bootstrap-token.sh \
              "${{ env.SSH_USER }}@${{ env.SSH_HOST }}:~/${{ env.DEPLOY_DIR }}/scripts/bootstrap-token.sh"
          fi

          # Upload n8n workflows
          if [ -d backend/n8n-workflows ]; then
            scp -P "${{ env.SSH_PORT }}" -r backend/n8n-workflows/* \
              "${{ env.SSH_USER }}@${{ env.SSH_HOST }}:~/${{ env.DEPLOY_DIR }}/n8n-workflows/" || true
          fi

      - name: Setup SSL certificates
        run: |
          ssh -p "${{ env.SSH_PORT }}" "${{ env.SSH_USER }}@${{ env.SSH_HOST }}" << 'SSL_SCRIPT'
          DEPLOY_DIR="$HOME/${{ env.DEPLOY_DIR }}"
          
          # Create SSL directory
          mkdir -p "$DEPLOY_DIR/ssl"
          
          # Check if SSL secrets are provided
          if [ -n "${{ secrets.SSL_CERT }}" ] && [ -n "${{ secrets.SSL_KEY }}" ]; then
            echo "Using SSL certificates from secrets..."
            
            # Write SSL certificate from secrets (use nginx expected names)
            cat > "$DEPLOY_DIR/ssl/origin.crt" << 'CERT_EOF'
          ${{ secrets.SSL_CERT }}
          CERT_EOF
            
            cat > "$DEPLOY_DIR/ssl/origin.key" << 'KEY_EOF'
          ${{ secrets.SSL_KEY }}
          KEY_EOF
            
            # Set proper permissions
            chmod 644 "$DEPLOY_DIR/ssl/origin.crt"
            chmod 600 "$DEPLOY_DIR/ssl/origin.key"
            
            echo "SSL certificates configured from secrets"
          else
            echo "No SSL secrets found, generating self-signed certificate..."
            
            # Generate self-signed certificate if it doesn't exist
            if [ ! -f "$DEPLOY_DIR/ssl/origin.crt" ] || [ ! -f "$DEPLOY_DIR/ssl/origin.key" ]; then
              openssl req -x509 -nodes -days 5475 -newkey rsa:2048 \
                -keyout "$DEPLOY_DIR/ssl/origin.key" \
                -out "$DEPLOY_DIR/ssl/origin.crt" \
                -subj "/CN=*.nodove.com/O=Nodove/C=KR" \
                -addext "subjectAltName=DNS:*.nodove.com,DNS:nodove.com" \
                2>/dev/null
              
              chmod 600 "$DEPLOY_DIR/ssl/origin.key"
              chmod 644 "$DEPLOY_DIR/ssl/origin.crt"
              echo "Self-signed SSL certificate generated"
            else
              echo "SSL certificates already exist"
            fi
          fi
          
          ls -la "$DEPLOY_DIR/ssl/"
          SSL_SCRIPT

      - name: Deploy stack on server
        run: |
          ssh -p "${{ env.SSH_PORT }}" "${{ env.SSH_USER }}@${{ env.SSH_HOST }}" << 'DEPLOY_SCRIPT'
          set -euo pipefail

          DEPLOY_DIR="$HOME/${{ env.DEPLOY_DIR }}"
          cd "$DEPLOY_DIR"

          echo "=== Deployment Started ==="
          echo "Directory: $DEPLOY_DIR"
          echo "Image Tag: ${{ env.IMAGE_TAG }}"
          date

          # Determine compose command
          DC="docker compose"
          if ! $DC version >/dev/null 2>&1; then
            DC="docker-compose"
          fi

          # Login to GHCR
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          # =====================================================
          # Clean up ALL conflicting compose projects and containers
          # =====================================================
          echo ""
          echo "=== Comprehensive Cleanup ==="
          
          # Stop all compose projects that might conflict
          echo "Stopping any existing compose projects..."
          for compose_file in docker-compose.yml compose.runtime.yml docker-compose.blog-workflow.yml; do
            if [ -f "$compose_file" ]; then
              echo "Stopping services from $compose_file..."
              $DC -f "$compose_file" down --remove-orphans 2>/dev/null || true
            fi
          done
          
          # Also check in other potential directories
          for dir in ~/blog-backend /opt/blog-stack /opt/blog-backend; do
            for compose_file in compose.runtime.yml docker-compose.yml; do
              if [ -f "$dir/$compose_file" ]; then
                echo "Stopping services from $dir/$compose_file..."
                (cd "$dir" && $DC -f "$compose_file" down --remove-orphans 2>/dev/null) || true
              fi
            done
          done
          
          # Stop any containers using critical ports
          echo ""
          echo "=== Checking Port Conflicts ==="
          for port in 80 443 8080 8443 5432 6379 27017 5678; do
            CONTAINER=$(docker ps --filter "publish=$port" --format "{{.Names}}" 2>/dev/null | head -1)
            if [ -n "$CONTAINER" ]; then
              echo "Stopping container using port $port: $CONTAINER"
              docker stop "$CONTAINER" 2>/dev/null || true
              docker rm -f "$CONTAINER" 2>/dev/null || true
            fi
          done
          
          # Stop any containers with blog- or similar prefixes
          echo ""
          echo "=== Cleaning Up Old Containers ==="
          docker ps -a --filter "name=blog-" --format "{{.Names}}" | while read name; do
            if [ -n "$name" ]; then
              echo "Removing container: $name"
              docker rm -f "$name" 2>/dev/null || true
            fi
          done
          
          # Remove any dangling networks
          docker network prune -f 2>/dev/null || true

          # Pull latest images
          echo ""
          echo "=== Pulling Images ==="
          $DC -f docker-compose.yml pull || true
          
          # Pull OpenCode images separately (always pull latest, continue on failure)
          echo ""
          echo "=== Pulling OpenCode Images ==="
          docker pull ghcr.io/choisimo/opencode-backend:latest 2>/dev/null || echo "WARN: Could not pull opencode-backend image"
          docker pull ghcr.io/choisimo/opencode-serve:latest 2>/dev/null || echo "WARN: Could not pull opencode-serve image"

          # Start/Update services
          echo ""
          echo "=== Starting Services ==="
          $DC -f docker-compose.yml up -d --remove-orphans --force-recreate

          # Wait for critical services
          echo ""
          echo "=== Health Checks ==="

          # Wait for PostgreSQL
          echo "Waiting for PostgreSQL..."
          for i in $(seq 1 30); do
            if $DC -f docker-compose.yml exec -T postgres pg_isready -U bloguser >/dev/null 2>&1; then
              echo "PostgreSQL: OK"
              break
            fi
            echo "PostgreSQL: Retry $i/30"
            sleep 2
          done

          # Wait for Redis
          echo "Waiting for Redis..."
          for i in $(seq 1 20); do
            if $DC -f docker-compose.yml exec -T redis redis-cli ping >/dev/null 2>&1; then
              echo "Redis: OK"
              break
            fi
            echo "Redis: Retry $i/20"
            sleep 2
          done

          # Wait for API
          echo "Waiting for API..."
          for i in $(seq 1 60); do
            if curl -sf http://localhost:8080/api/v1/healthz >/dev/null 2>&1; then
              echo "API: OK"
              break
            fi
            echo "API: Retry $i/60"
            sleep 3
          done

          # Wait for n8n
          echo "Waiting for n8n..."
          for i in $(seq 1 30); do
            if curl -sf http://localhost:5678/healthz >/dev/null 2>&1; then
              echo "n8n: OK"
              break
            fi
            echo "n8n: Retry $i/30"
            sleep 3
          done

          # Wait for OpenCode Services
          echo "Waiting for OpenCode Serve..."
          for i in $(seq 1 30); do
            if curl -sf http://localhost:7012/app >/dev/null 2>&1 || wget -q --spider http://localhost:7012/app 2>/dev/null; then
              echo "OpenCode Serve: OK"
              break
            fi
            echo "OpenCode Serve: Retry $i/30"
            sleep 3
          done

          echo "Waiting for OpenCode Backend..."
          for i in $(seq 1 30); do
            if curl -sf http://localhost:7016/health >/dev/null 2>&1 || wget -q --spider http://localhost:7016/health 2>/dev/null; then
              echo "OpenCode Backend: OK"
              break
            fi
            echo "OpenCode Backend: Retry $i/30"
            sleep 3
          done

          # Final status
          echo ""
          echo "=== Service Status ==="
          $DC -f docker-compose.yml ps

          # Verify critical endpoints
          echo ""
          echo "=== Endpoint Verification ==="
          
          API_STATUS=$(curl -sf http://localhost:8080/api/v1/healthz && echo "OK" || echo "FAILED")
          echo "API Health: $API_STATUS"

          N8N_STATUS=$(curl -sf http://localhost:5678/healthz && echo "OK" || echo "FAILED")
          echo "n8n Health: $N8N_STATUS"

          OPENCODE_SERVE_STATUS=$(curl -sf http://localhost:7012/app && echo "OK" || wget -q --spider http://localhost:7012/app 2>/dev/null && echo "OK" || echo "FAILED")
          echo "OpenCode Serve Health: $OPENCODE_SERVE_STATUS"

          OPENCODE_BACKEND_STATUS=$(curl -sf http://localhost:7016/health && echo "OK" || echo "FAILED")
          echo "OpenCode Backend Health: $OPENCODE_BACKEND_STATUS"

          if [ "$API_STATUS" != "OK" ]; then
            echo ""
            echo "=== API Logs (last 50 lines) ==="
            $DC -f docker-compose.yml logs --tail=50 api
            exit 1
          fi

          echo ""
          echo "=== Deployment Completed Successfully ==="
          date
          DEPLOY_SCRIPT

      - name: Verify public endpoints
        if: ${{ vars.API_BASE_URL != '' }}
        continue-on-error: true
        run: |
          echo "Checking public API at ${{ vars.API_BASE_URL }}/api/v1/healthz ..."
          for i in $(seq 1 30); do
            if curl -sf "${{ vars.API_BASE_URL }}/api/v1/healthz" >/dev/null; then
              echo "Public API: OK"
              break
            fi
            echo "Retry $i/30"
            sleep 3
          done

          N8N_URL="${{ vars.N8N_WEBHOOK_URL || 'https://blog-bw.nodove.com/' }}"
          echo ""
          echo "Checking n8n at ${N8N_URL}healthz ..."
          curl -sf "${N8N_URL}healthz" && echo "n8n Webhook: OK" || echo "n8n Webhook: FAILED (may require auth)"

      - name: Notify deployment result
        if: always()
        run: |
          N8N_URL="${{ vars.N8N_WEBHOOK_URL || 'https://blog-bw.nodove.com/' }}"
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment successful!"
            echo "  - API: ${{ vars.API_BASE_URL }}"
            echo "  - n8n: ${N8N_URL}"
            echo "  - Image: ghcr.io/${{ github.repository_owner }}/blog-api:${{ env.IMAGE_TAG }}"
          else
            echo "❌ Deployment failed"
            echo "Check the logs above for details"
          fi

  # ===========================================================================
  # Job 3: Setup API Credentials (Auto Token Generation & Distribution)
  # ===========================================================================
  setup-credentials:
    name: Setup API Credentials
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always() && needs.deploy.result == 'success'

    env:
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_PORT: ${{ secrets.SSH_PORT || '22' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add host to known_hosts
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          # Use timeout and retry for ssh-keyscan
          for i in 1 2 3; do
            if ssh-keyscan -p "${{ env.SSH_PORT }}" -H "${{ env.SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "ssh-keyscan succeeded on attempt $i"
              break
            fi
            echo "ssh-keyscan attempt $i failed, retrying..."
            sleep 5
          done
          chmod 600 ~/.ssh/known_hosts

      - name: Upload credentials setup script
        run: |
          scp -P "${{ env.SSH_PORT }}" backend/scripts/setup-api-credentials.sh \
            "${{ env.SSH_USER }}@${{ env.SSH_HOST }}:~/${{ env.DEPLOY_DIR }}/scripts/"

      - name: Generate API Token and Setup n8n Credentials
        continue-on-error: true
        run: |
          ssh -p "${{ env.SSH_PORT }}" "${{ env.SSH_USER }}@${{ env.SSH_HOST }}" << 'CRED_SCRIPT'
          set -euo pipefail
          cd ~/blog-stack

          echo "=== API Credentials Auto-Setup ==="
          date

          # Environment for credential setup
          export BLOG_API_URL="http://localhost:5080"
          export N8N_URL="http://localhost:5678"
          export ADMIN_USERNAME="${{ vars.ADMIN_USERNAME || 'admin' }}"
          export ADMIN_PASSWORD="${{ secrets.ADMIN_PASSWORD }}"
          export N8N_USER="${{ vars.N8N_USER || 'admin' }}"
          export N8N_PASS="${{ secrets.N8N_PASS }}"
          export JWT_SECRET="${{ secrets.JWT_SECRET }}"
          export TOKEN_FILE="/tmp/blog-api-token.jwt"

          # Wait for API to be fully ready (may take time after deploy)
          echo ""
          echo "=== Waiting for Blog API ==="
          max_retries=60
          retry=0
          while [ $retry -lt $max_retries ]; do
            if curl -sf "http://localhost:5080/api/v1/healthz" > /dev/null 2>&1; then
              echo "Blog API is ready!"
              break
            fi
            retry=$((retry + 1))
            echo "Waiting for Blog API... ($retry/$max_retries)"
            sleep 2
          done

          if [ $retry -eq $max_retries ]; then
            echo "WARNING: Blog API not ready after ${max_retries} retries, skipping credential setup"
            exit 0
          fi

          # Generate JWT token directly (inline, more reliable than script)
          echo ""
          echo "=== Step 1: Generate JWT Token ==="
          
          RESPONSE=$(curl -sf "http://localhost:5080/api/v1/auth/login" \
            -H "Content-Type: application/json" \
            -d "{\"username\": \"${ADMIN_USERNAME}\", \"password\": \"${ADMIN_PASSWORD}\"}" \
            2>/dev/null) || {
            echo "WARNING: Failed to authenticate with Blog API"
            echo "Response: $RESPONSE"
            exit 0
          }
          
          API_TOKEN=$(echo "$RESPONSE" | jq -r '.data.token // .token // empty' 2>/dev/null)
          
          if [ -z "$API_TOKEN" ] || [ "$API_TOKEN" = "null" ]; then
            echo "WARNING: Failed to extract token from response"
            echo "Response: $RESPONSE"
            exit 0
          fi
          
          echo "Token generated: ${API_TOKEN:0:20}..."
          echo "$API_TOKEN" > /tmp/blog-api-token.jwt
          chmod 600 /tmp/blog-api-token.jwt

          # Wait for n8n to be ready
          echo ""
          echo "=== Waiting for n8n ==="
          max_retries=30
          retry=0
          while [ $retry -lt $max_retries ]; do
            if curl -sf "http://localhost:5678/healthz" > /dev/null 2>&1; then
              echo "n8n is ready!"
              break
            fi
            retry=$((retry + 1))
            echo "Waiting for n8n... ($retry/$max_retries)"
            sleep 2
          done

          if [ $retry -eq $max_retries ]; then
            echo "WARNING: n8n not ready, skipping credential setup"
            exit 0
          fi

          # Setup n8n Credentials
          echo ""
          echo "=== Step 2: Setup n8n Credentials ==="
          
          # Check if credential already exists
          EXISTING_CRED=$(curl -sf "http://localhost:5678/api/v1/credentials" \
            -u "${N8N_USER}:${N8N_PASS}" \
            -H "Accept: application/json" 2>/dev/null | \
            jq -r '.data[] | select(.name == "Blog API Auth") | .id' 2>/dev/null || echo "")

          CRED_DATA=$(cat <<EOF
          {
            "name": "Blog API Auth",
            "type": "httpHeaderAuth",
            "data": {
              "name": "Authorization",
              "value": "Bearer ${API_TOKEN}"
            }
          }
          EOF
          )

          if [ -n "$EXISTING_CRED" ]; then
            echo "Updating existing credential (ID: $EXISTING_CRED)..."
            curl -sf "http://localhost:5678/api/v1/credentials/${EXISTING_CRED}" \
              -X PATCH \
              -u "${N8N_USER}:${N8N_PASS}" \
              -H "Content-Type: application/json" \
              -d "$CRED_DATA" > /dev/null 2>&1 && echo "Updated!" || echo "Update failed"
          else
            echo "Creating new credential..."
            curl -sf "http://localhost:5678/api/v1/credentials" \
              -X POST \
              -u "${N8N_USER}:${N8N_PASS}" \
              -H "Content-Type: application/json" \
              -d "$CRED_DATA" > /dev/null 2>&1 && echo "Created!" || echo "Creation failed (may already exist)"
          fi

          echo ""
          echo "=== Credentials Setup Complete ==="
          CRED_SCRIPT

      - name: Retrieve generated token
        id: get_token
        run: |
          TOKEN=$(ssh -p "${{ env.SSH_PORT }}" "${{ env.SSH_USER }}@${{ env.SSH_HOST }}" \
            "cat /tmp/blog-api-token.jwt 2>/dev/null || echo ''")
          
          if [ -n "$TOKEN" ]; then
            echo "token=${TOKEN}" >> $GITHUB_OUTPUT
            echo "Token retrieved successfully"
          else
            echo "No token found, workers will use fallback secrets"
          fi

      - name: Setup Node.js for Workers
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: workers/package-lock.json

      - name: Install Wrangler
        working-directory: workers
        run: npm install --save-dev wrangler@4

      - name: Setup Cloudflare Workers Secrets
        if: steps.get_token.outputs.token != ''
        working-directory: workers
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "=== Setting up Cloudflare Workers Secrets ==="
          
          API_TOKEN="${{ steps.get_token.outputs.token }}"
          
          # API Gateway - set BLOG_API_TOKEN for backend authentication
          echo "Setting secrets for blog-api-gateway..."
          echo "$API_TOKEN" | npx wrangler secret put BLOG_API_TOKEN --name blog-api-gateway --env production 2>/dev/null || \
            echo "WARN: Failed to set BLOG_API_TOKEN for api-gateway"
          
          # AI Check Gateway - set AUTH_JWT_SECRET for token validation
          echo "Setting secrets for ai-check-gateway..."
          echo "${{ secrets.JWT_SECRET }}" | npx wrangler secret put AUTH_JWT_SECRET --name ai-check-gateway --env production 2>/dev/null || \
            echo "WARN: Failed to set AUTH_JWT_SECRET for ai-check-gateway"
          
          # Also set the API token for ai-check-gateway if it needs to call Blog API
          echo "$API_TOKEN" | npx wrangler secret put BLOG_API_TOKEN --name ai-check-gateway --env production 2>/dev/null || \
            echo "WARN: Failed to set BLOG_API_TOKEN for ai-check-gateway"
          
          echo "=== Workers Secrets Setup Complete ==="

      - name: Verify credentials setup
        run: |
          ssh -p "${{ env.SSH_PORT }}" "${{ env.SSH_USER }}@${{ env.SSH_HOST }}" << 'VERIFY_SCRIPT'
          set -euo pipefail
          cd ~/blog-stack
          
          echo "=== Verifying Credentials Setup ==="
          
          # Check n8n credentials
          N8N_USER="${{ vars.N8N_USER || 'admin' }}"
          N8N_PASS="${{ secrets.N8N_PASS }}"
          
          CRED_CHECK=$(curl -sf "http://localhost:5678/api/v1/credentials" \
            -u "${N8N_USER}:${N8N_PASS}" \
            -H "Accept: application/json" 2>/dev/null | jq -r '.data | length' || echo "0")
          
          echo "n8n Credentials count: $CRED_CHECK"
          
          # List credential names
          curl -sf "http://localhost:5678/api/v1/credentials" \
            -u "${N8N_USER}:${N8N_PASS}" \
            -H "Accept: application/json" 2>/dev/null | \
            jq -r '.data[].name' 2>/dev/null || echo "Could not list credentials"
          
          # Cleanup temp token
          rm -f /tmp/blog-api-token.jwt
          
          echo ""
          echo "=== Verification Complete ==="
          VERIFY_SCRIPT

  # ===========================================================================
  # Job 4: Import n8n Workflows (Optional)
  # ===========================================================================
  import-workflows:
    name: Import n8n Workflows
    runs-on: ubuntu-latest
    needs: [deploy, setup-credentials]
    if: always() && needs.deploy.result == 'success'

    env:
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_PORT: ${{ secrets.SSH_PORT || '22' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add host to known_hosts
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          # Use timeout and retry for ssh-keyscan
          for i in 1 2 3; do
            if ssh-keyscan -p "${{ env.SSH_PORT }}" -H "${{ env.SSH_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "ssh-keyscan succeeded on attempt $i"
              break
            fi
            echo "ssh-keyscan attempt $i failed, retrying..."
            sleep 5
          done
          chmod 600 ~/.ssh/known_hosts

      - name: Import workflows to n8n
        continue-on-error: true
        run: |
          ssh -p "${{ env.SSH_PORT }}" "${{ env.SSH_USER }}@${{ env.SSH_HOST }}" << 'IMPORT_SCRIPT'
          set -euo pipefail
          cd ~/blog-stack

          DC="docker compose"
          if ! $DC version >/dev/null 2>&1; then DC="docker-compose"; fi

          echo "=== Importing n8n Workflows ==="

          # Import each workflow file
          for workflow in n8n-workflows/*.json; do
            if [ -f "$workflow" ]; then
              name=$(basename "$workflow" .json)
              echo "Importing: $name"
              $DC -f docker-compose.yml exec -T n8n \
                n8n import:workflow --input="/workflows/$(basename $workflow)" 2>/dev/null || \
                echo "  Warning: Failed to import $name (may already exist)"
            fi
          done

          echo "=== Workflow Import Complete ==="
          IMPORT_SCRIPT

  # ===========================================================================
  # Job 5: E2E Testing - External Access Verification
  # ===========================================================================
  e2e-test:
    name: E2E External Access Test
    runs-on: ubuntu-latest
    needs: [deploy, setup-credentials, import-workflows]
    if: always() && needs.deploy.result == 'success'

    env:
      API_BASE_URL: ${{ vars.API_BASE_URL || 'https://blog-b.nodove.com' }}
      N8N_WEBHOOK_URL: ${{ vars.N8N_WEBHOOK_URL || 'https://blog-bw.nodove.com' }}
      SITE_BASE_URL: ${{ vars.SITE_BASE_URL || 'https://noblog.nodove.com' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Wait for services to stabilize
        run: |
          echo "Waiting 30 seconds for services to fully stabilize..."
          sleep 30

      - name: E2E Test - API Health Check
        id: api_health
        run: |
          echo "=== Testing API Health ==="
          API_URL="${{ env.API_BASE_URL }}/api/v1/healthz"
          echo "Testing: $API_URL"
          
          RESPONSE=$(curl -sf -w "\n%{http_code}" "$API_URL" 2>/dev/null || echo -e "\n000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)
          
          echo "HTTP Status: $HTTP_CODE"
          echo "Response: $BODY"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "API Health: PASS"
          else
            echo "result=fail" >> $GITHUB_OUTPUT
            echo "API Health: FAIL"
          fi

      - name: E2E Test - API Posts Endpoint
        id: api_posts
        run: |
          echo "=== Testing API Posts Endpoint ==="
          POSTS_URL="${{ env.API_BASE_URL }}/api/v1/posts?limit=5"
          echo "Testing: $POSTS_URL"
          
          RESPONSE=$(curl -sf -w "\n%{http_code}" "$POSTS_URL" 2>/dev/null || echo -e "\n000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)
          
          echo "HTTP Status: $HTTP_CODE"
          echo "Response (truncated): ${BODY:0:500}"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "API Posts: PASS"
          else
            echo "result=fail" >> $GITHUB_OUTPUT
            echo "API Posts: FAIL"
          fi

      - name: E2E Test - n8n Health
        id: n8n_health
        run: |
          echo "=== Testing n8n Health ==="
          N8N_URL="${{ env.N8N_WEBHOOK_URL }}/healthz"
          echo "Testing: $N8N_URL"
          
          RESPONSE=$(curl -sf -w "\n%{http_code}" "$N8N_URL" 2>/dev/null || echo -e "\n000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          
          echo "HTTP Status: $HTTP_CODE"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "n8n Health: PASS"
          else
            echo "result=fail" >> $GITHUB_OUTPUT
            echo "n8n Health: FAIL (may require authentication)"
          fi

      - name: E2E Test - AI Endpoints
        id: ai_endpoints
        run: |
          echo "=== Testing AI Endpoints ==="
          echo "NOTE: Primary AI API is now handled by Cloudflare Workers (ai-check-gateway)."
          echo "This test checks n8n webhook integration for complex AI workflows."
          
          # Test AI health endpoint via n8n webhook (for workflow integration)
          AI_HEALTH_URL="${{ env.N8N_WEBHOOK_URL }}/webhook/ai/health"
          echo "Testing AI Health via n8n: $AI_HEALTH_URL"
          
          RESPONSE=$(curl -sf -w "\n%{http_code}" "$AI_HEALTH_URL" 2>/dev/null || echo -e "\n000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)
          
          echo "HTTP Status: $HTTP_CODE"
          echo "Response: ${BODY:0:200}"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "ai_health=pass" >> $GITHUB_OUTPUT
            echo "AI Health Webhook: PASS"
          else
            echo "ai_health=skip" >> $GITHUB_OUTPUT
            echo "AI Health Webhook: SKIP (n8n workflow not configured or using Workers instead)"
          fi

      - name: E2E Test - Frontend Site
        id: frontend
        run: |
          echo "=== Testing Frontend Site ==="
          SITE_URL="${{ env.SITE_BASE_URL }}"
          echo "Testing: $SITE_URL"
          
          RESPONSE=$(curl -sf -w "\n%{http_code}" "$SITE_URL" 2>/dev/null || echo -e "\n000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          
          echo "HTTP Status: $HTTP_CODE"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "Frontend Site: PASS"
          else
            echo "result=fail" >> $GITHUB_OUTPUT
            echo "Frontend Site: FAIL"
          fi

      - name: E2E Test - SSL Certificate Check
        id: ssl_check
        run: |
          echo "=== Testing SSL Certificates ==="
          
          # Extract domain from API URL
          API_DOMAIN=$(echo "${{ env.API_BASE_URL }}" | sed 's|https://||' | cut -d'/' -f1)
          echo "Checking SSL for: $API_DOMAIN"
          
          # Check SSL certificate expiry
          CERT_INFO=$(echo | openssl s_client -servername "$API_DOMAIN" -connect "$API_DOMAIN:443" 2>/dev/null | openssl x509 -noout -dates 2>/dev/null || echo "")
          
          if [ -n "$CERT_INFO" ]; then
            echo "$CERT_INFO"
            EXPIRY=$(echo "$CERT_INFO" | grep "notAfter" | cut -d'=' -f2)
            echo "Certificate expires: $EXPIRY"
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "SSL Check: PASS"
          else
            echo "result=fail" >> $GITHUB_OUTPUT
            echo "SSL Check: FAIL - Could not retrieve certificate"
          fi

      - name: E2E Test - API Response Time
        id: response_time
        run: |
          echo "=== Testing API Response Time ==="
          API_URL="${{ env.API_BASE_URL }}/api/v1/healthz"
          
          # Measure response time (5 requests)
          TOTAL_TIME=0
          SUCCESS_COUNT=0
          
          for i in 1 2 3 4 5; do
            TIME=$(curl -sf -o /dev/null -w "%{time_total}" "$API_URL" 2>/dev/null || echo "0")
            if [ "$TIME" != "0" ]; then
              TOTAL_TIME=$(echo "$TOTAL_TIME + $TIME" | bc)
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              echo "Request $i: ${TIME}s"
            else
              echo "Request $i: FAILED"
            fi
          done
          
          if [ "$SUCCESS_COUNT" -gt 0 ]; then
            AVG_TIME=$(echo "scale=3; $TOTAL_TIME / $SUCCESS_COUNT" | bc)
            echo "Average response time: ${AVG_TIME}s"
            
            # Pass if average response time < 2 seconds
            if [ "$(echo "$AVG_TIME < 2" | bc)" -eq 1 ]; then
              echo "result=pass" >> $GITHUB_OUTPUT
              echo "Response Time: PASS (avg ${AVG_TIME}s)"
            else
              echo "result=warn" >> $GITHUB_OUTPUT
              echo "Response Time: WARN - Slow response (avg ${AVG_TIME}s)"
            fi
          else
            echo "result=fail" >> $GITHUB_OUTPUT
            echo "Response Time: FAIL - No successful requests"
          fi

      - name: Generate E2E Test Report
        if: always()
        run: |
          echo ""
          echo "=========================================="
          echo "       E2E TEST REPORT SUMMARY"
          echo "=========================================="
          echo ""
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Environment: ${{ vars.APP_ENV || 'production' }}"
          echo ""
          echo "┌─────────────────────────────────────────┐"
          echo "│ Service Health Checks                   │"
          echo "├─────────────────────────────────────────┤"
          printf "│ %-25s %13s │\n" "API Health:" "${{ steps.api_health.outputs.result == 'pass' && '✅ PASS' || '❌ FAIL' }}"
          printf "│ %-25s %13s │\n" "API Posts Endpoint:" "${{ steps.api_posts.outputs.result == 'pass' && '✅ PASS' || '❌ FAIL' }}"
          printf "│ %-25s %13s │\n" "n8n Health:" "${{ steps.n8n_health.outputs.result == 'pass' && '✅ PASS' || '⚠️ SKIP' }}"
          printf "│ %-25s %13s │\n" "AI Health Webhook:" "${{ steps.ai_endpoints.outputs.ai_health == 'pass' && '✅ PASS' || '⚠️ SKIP' }}"
          printf "│ %-25s %13s │\n" "Frontend Site:" "${{ steps.frontend.outputs.result == 'pass' && '✅ PASS' || '❌ FAIL' }}"
          printf "│ %-25s %13s │\n" "SSL Certificate:" "${{ steps.ssl_check.outputs.result == 'pass' && '✅ PASS' || '❌ FAIL' }}"
          printf "│ %-25s %13s │\n" "Response Time:" "${{ steps.response_time.outputs.result == 'pass' && '✅ PASS' || (steps.response_time.outputs.result == 'warn' && '⚠️ SLOW' || '❌ FAIL') }}"
          echo "└─────────────────────────────────────────┘"
          echo ""
          echo "Endpoints Tested:"
          echo "  - API: ${{ env.API_BASE_URL }}"
          echo "  - n8n: ${{ env.N8N_WEBHOOK_URL }}"
          echo "  - Frontend: ${{ env.SITE_BASE_URL }}"
          echo ""
          echo "=========================================="

      - name: Fail if critical tests failed
        if: always()
        run: |
          if [ "${{ steps.api_health.outputs.result }}" != "pass" ]; then
            echo "CRITICAL: API Health check failed!"
            exit 1
          fi
          
          if [ "${{ steps.ssl_check.outputs.result }}" != "pass" ]; then
            echo "WARNING: SSL check failed, but continuing..."
          fi
          
          echo "All critical E2E tests passed!"

---
title: "awk와 sed, 그리고 xargs에 빚진 작은 승리들"
date: "2025-10-27"
category: "Linux"
tags: ['awk', 'sed', 'xargs', '리눅스쉘', '자동화']
excerpt: "파이프라인 하나로 서버를 살린 순간을 떠올리며, 내가 사랑하는 세 가지 쉘 친구들을 일기처럼 적어 봤습니다."
readTime: "7분"
---

터미널 앞에서 밤을 새운 날이면, 저는 늘 같은 친구들을 떠올립니다. `sed`, `awk`, `xargs`. 처음에는 매뉴얼을 붙잡고 외워야 했던 낯선 이름들이었는데, 어느새 제 일상에 가장 든든한 동료가 되어 버렸죠. 오늘은 왜 이 셋을 사랑하게 됐는지, 그리고 어떻게 서로 손을 잡고 제 업무를 구해냈는지 이야기해 보려고 합니다.

### sed를 만나고 텍스트가 말을 듣기 시작했다

서버 로그를 보고 있으면, 단 한 줄의 타이포 때문에 서비스가 멈춰 서기도 합니다. 그럴 때마다 저는 `sed`를 불러냅니다. "Stream Editor"라는 근사한 이름을 가진 이 친구는 흐르는 텍스트를 조용히 갈아엎는 데 특화돼 있죠. 처음에는 `sed 's/hello/world/' text.txt` 같은 단순 치환만 써 봤습니다. 그런데 `sed 's/hello/world/g'`처럼 `g` 플래그를 붙이면 한 줄에 있는 모든 문자열을 바꿀 수 있고, `sed -i` 옵션까지 더하면 파일을 직접 고쳐 준다는 사실을 깨닫는 순간, 진짜 마법을 본 느낌이었어요.

예전에 운영 중인 서비스에서 "DEBUG" 메시지가 하루 밤사이에 로그를 뒤덮은 적이 있습니다. 새벽에 일어나자마자 `sed -i 's/DEBUG/INFO/g' app.log`를 실행하면서, 이 친구가 없었다면 얼마나 많은 파일을 손으로 열고 있었을지 상상했습니다. 어떤 날은 `sed '/error/d' error.log`처럼 특정 단어를 포함한 줄을 싹 지워버리기도 했고요. 스트림처럼 흘러가는 텍스트를 실시간으로 다듬을 수 있다는 건, 쉘에서 데이터를 다루는 감각 자체를 바꿔 주었습니다.

### awk 덕분에 텍스트가 테이블로 보이기 시작했다

`awk`를 처음 접했을 때, "이건 작은 데이터베이스 같다"는 생각을 했습니다. 줄을 읽고, 공백이나 콜론 같은 구분자를 기준으로 필드를 나눠서, 원하는 열만 쏙 빼 올 수 있으니까요. `/etc/passwd`를 열어 `awk -F':' '{print $1, $6}' /etc/passwd`라고 치면 사용자 이름과 홈 디렉터리가 나란히 정렬되어 나옵니다. 기존에는 `cut`이나 `grep`으로 조합하던 작업이 한 줄에 정리되는 걸 보고 감탄했던 기억이 있습니다.

또 다른 날에는 서버 접근 로그에서 특정 조건을 찾고 싶었습니다. "세 번째 필드가 500보다 큰 줄만 보여줘"라고 말하면 `awk '$3 > 500 {print $0}' data.txt`로 답합니다. 패턴 매칭도 자유롭죠. `awk '/root/ {print $1}' /etc/passwd`처럼 정규식을 붙이면 특정 단어가 있는 줄만 골라낼 수 있습니다. 저는 여기에 `BEGIN`과 `END` 블록을 더해서 제목과 꼬릿말을 넣곤 합니다. `awk -F':' 'BEGIN {print "--- User List ---"} {print $1} END {print "--- END ---"}' /etc/passwd` 같은 모양이죠. 작은 리포트를 즉석에서 꾸밀 수 있다는 건, 쉘 스크립트를 좀 더 살가운 형태로 만들어 줬습니다.

### xargs는 파이프라인의 마지막 연결고리였다

`sed`와 `awk`가 데이터를 다듬는 역할이라면, `xargs`는 그 데이터를 다른 명령의 인자로 깔끔하게 넘겨주는 역할을 맡습니다. 처음 `find . -name "*.tmp" | xargs rm`을 실행했을 때, "Argument list too long" 오류를 피해가는 방법을 알게 되었죠. 작은 파일이 수천 개 쌓여 있을 때, 이 명령어는 정말 목숨줄 같은 존재였습니다.

저는 `xargs -n 1` 옵션을 종종 씁니다. `ls | xargs -n 1 echo`처럼 목록을 하나씩 처리하고 싶을 때요. 더 신중한 작업이라면 `-p`를 붙여 사용자가 직접 Y/N을 입력하도록 합니다. `find . -name "*.log" | xargs -p rm`처럼, 중요한 로그를 지우기 전에 마지막 한 번 더 묻는 셈이죠. 어느 날은 `xargs -I {}`를 더해 플레이스홀더 자리에 명령어를 심어 놓기도 했습니다. 유연하게 인자를 다루는 방법을 알게 되면서, 파이프라인이 훨씬 안정적으로 변했습니다.

### 세 친구가 힘을 합친 날의 이야기

이제 세 명령어를 합쳐 진짜 위기를 넘긴 경험을 얘기해 볼게요. `my_process`라는 프로세스가 누수를 일으키고 있던 하루, 저는 이렇게 한 줄을 적었습니다.

```
ps -ef | grep 'my_process' | awk '{print $2}' | xargs kill -9
```

`ps -ef`로 프로세스를 열거하고, `grep`으로 필요한 줄만 집어낸 뒤, `awk`로 PID만 추리고, 마지막에 `xargs kill -9`로 단번에 정리했습니다. 예전 같으면 PID를 직접 확인한 다음 하나씩 `kill`을 눌렀을 겁니다. 하지만 이 조합 덕분에 새벽 두 시에 서버를 살릴 수 있었어요.

또 어떤 날은 디렉터리가 로그 파일로 잔뜩 오염되어 있었죠. 저는 `find . -name "*.log" | xargs sed -i 's/DEBUG/INFO/g'`라는 명령으로 모든 로그의 레벨을 올려 버렸습니다. `find`가 파일을 찾고, `xargs`가 목록을 `sed`로 넘기며, `sed`는 각 파일 안에서 텍스트를 수정했습니다. 명령어 세 개가 릴레이하듯 책임을 나누는 모습에 혼자 미소를 지었습니다.

디스크 사용량이 90%를 넘어설 때만 메일을 보내는 스크립트를 짠 적도 있습니다. `df -h | grep '/dev/sd' | awk '{ sub(/%/, "", $5); if ($5 >= 90) print $0 }'`까지는 익숙했는데, 거기에 `xargs -I {} echo "{} is almost full." | mail -s "Disk Alert" admin@example.com`을 더하는 순간, 문자열이 멋지게 하나의 알림으로 변하더군요. 실무에서는 메일 명령과 인증이 더 필요하지만, 저는 이 예제를 통해 "필요한 줄만 추리고, 메시지를 만들어, 다른 시스템에 넘기는 일"이 얼마나 자연스러워졌는지 깨달았습니다.

최근에는 웹 서버 로그에서 가장 많이 요청된 IP를 찾는 작업을 맡았습니다. `cat access.log | awk '{print $1}' | sort | uniq -c | sort -rn | head -n 10`처럼, `awk`로 첫 번째 필드만 뽑아내고, `sort`와 `uniq`으로 빈도를 계산한 뒤 다시 정렬해 상위 10개를 출력했죠. 여기서는 `sed`나 `xargs`가 직접 등장하지는 않았지만, 데이터를 잘라내고 올바른 형태로 넘겨주는 `awk`의 힘을 다시 느꼈습니다. 이 한 줄로 모니터링 대시보드에 넣을 레포트를 빠르게 만들어, 팀에 공유했습니다.

### 쉘 작업이 두렵지 않은 이유

돌이켜 보면, `sed`, `awk`, `xargs` 덕분에 저는 쉘에서 데이터를 자유롭게 다룰 수 있게 되었습니다. 텍스트를 수정하고, 필요한 필드만 꺼내고, 다른 명령어에 자연스럽게 넘겨주는 과정이 더 이상 낯설지 않습니다. 가장 단순한 치환에서부터, 서버를 살리는 긴 파이프라인까지. 저는 이 친구들이 제게 가르쳐 준 사고방식을 아직도 곱씹곤 합니다.

어쩌면 셸을 두려워하는 사람들에게 하고 싶은 말이 있습니다. "처음엔 명령어를 외우느라 머리가 지끈하지만, 어느 순간 이 친구들이 여러분의 손발이 되어 줄 거예요." 하루의 마무리로 로그 파일을 정리하면서, 저는 늘 이렇게 중얼거립니다. "오늘도 sed, awk, xargs 덕분에 살았다."

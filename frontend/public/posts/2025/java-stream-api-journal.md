---
title: "람다와 파이프라인 사이, 스트림 API에 빠져들던 밤"
date: "2025-10-27"
category: "Java"
tags: ['Java', 'StreamAPI', 'Lambda', 'FunctionalProgramming', '병렬스트림']
excerpt: "람다 표현식과 스트림 파이프라인을 처음 만났을 때의 놀람, 컬렉터와 병렬 스트림 튜닝까지 기록한 1인칭 에세이"
readTime: "11분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

2014년 JDK 8이 출시되던 날, 나는 회사 교육장에서 처음 람다 표현식을 살펴봤다. `list.stream().filter(x -> x > 10).map(x -> x * 2)`라는 한 줄이 화면에 떠오르는 순간, 우리는 모두 조용해졌고 누군가가 속삭였다. “이건 자바가 아니잖아.” 사실 자바였고, 그날 이후 나는 스트림 API에 흠뻑 빠졌다.

기존의 `for` 루프와 `Iterator`를 돌며 조건문을 일일이 추가하던 습관에서 벗어나, 선언형으로 데이터 흐름을 표기하는 방식은 내 사고방식을 바꿨다. 스트림 체인을 구성할 때마다 `filter`, `map`, `flatMap`, `distinct`, `sorted`가 하나의 문장처럼 연결되었다. “어떤 데이터가 어디로 흐르고 있는지”가 명확했기 때문에, 코드를 읽는 시간이 크게 줄어들었다. 처음에는 함수형 인터페이스와 람다 문법이 낯설었지만, 곧 익숙해졌다. 동료들과 우리는 서로의 코드에 람다를 가장 자연스럽게 녹여 넣는 방법을 자랑하곤 했다.

그러나 스트림은 단순한 문법 변환이 아니었다. 중간 연산이 지연 계산(lazy evaluation)된다는 사실을 이해하자, 성능을 가늠하는 눈이 생겼다. `.map().filter()`와 `.filter().map()`의 순서를 바꾸는 것만으로도 실행 시간이 달라졌고, `peek()`를 잘못 사용하면 전체 파이프라인을 이해하기 어려워졌다. 컬렉터(`Collectors.toList()`, `toMap()`, `groupingBy()`)의 강력함은 데이터를 집계하는 시나리오를 크게 단순화해 줬다. 특히 `groupingBy`와 `mapping`을 중첩해서 사용하는 순간, 나는 “SQL 대신 이걸 쓸 수 있는 영역이 있겠구나”라고 생각했다.

동료들과 병렬 스트림에 대한 실험도 자주 했다. `.parallel()`을 붙이는 것이 만능이라고 생각했던 시절, 작은 데이터셋에서 오히려 성능이 저하되는 현상을 목격했다. 포크조인 풀의 기본 스레드 수를 이해하고, CPU 코어 수보다 많은 병렬 작업을 던지는 것이 항상 이득은 아니라는 사실을 깨달았다. 우리는 집계 연산이 병렬 실행에 적합한지, 변환 함수가 thread-safe한지, 박싱/언박싱 비용이 낭비되는지 매번 체크했다. 스트림 파이프라인을 빌드할 때마다 벤치마크를 작성한 덕분에, “병렬은 선택 사항이다”라는 문장을 팀 내 표어처럼 붙여 두었다.

`Optional`과 함께 사용하면서 스트림은 더욱 진가를 발휘했다. 널 체크 대신 스트림으로 컬렉션을 흘려보내고, `findFirst`, `orElse` 같은 메서드들을 조합하면 코드가 의도대로 읽혔다. 다만, 스트림이 항상 정답은 아니었다. 복잡한 상태를 다뤄야 하거나, 누적 로직을 세밀하게 제어해야 하는 경우에는 전통적인 루프가 더 명확했다. 우리는 “스트림은 읽기 쉽고 선언적인 로직에만 쓰자”라는 규칙을 정했다. 남용을 경계하되, 필요할 때는 주저하지 않는 균형감이 필요했다.

Collector 커스터마이징을 위한 `Collector.of()`는 또 다른 모험이었다. 불변 리스트를 반환하거나, 특정 순서를 유지하며 병렬 실행 시 combiner가 어떻게 동작하는지 실험했다. Mutable reduction이 부적절하면 데이터 무결성이 깨지고, 병렬 파이프라인에서 예기치 않게 순서가 바뀔 수 있다는 사실을 문서에 기록했다. 스트림 API가 제공하는 계약을 지키는 것이 얼마나 중요한지 새삼 깨달았다.

시간이 지나면서 스트림은 내 일상의 일부가 되었다. `Stream.iterate`, `Stream.generate`로 무한 스트림을 만들고 제한을 걸어 테스트 데이터를 생성하기도 했다. Kotlin이나 Python의 제너레이터와도 비교해 보며, 자바가 제공하는 함수형 도구상자에 점점 익숙해졌다. 무엇보다, 스트림 파이프라인을 리뷰할 때마다 “이 흐름이 비슷한 로직을 반복하는 다른 팀에게도 도움이 될까?”를 묻는 습관이 생겼다.

오늘도 Pull Request를 살펴보다가 스트림을 사용할 수 있는 부분을 발견했다. 기존의 중첩 루프를 스트림으로 바꾸고, `.collect(Collectors.groupingBy())`로 데이터를 정리했다. 리뷰 코멘트에는 “읽기 흐름이 훨씬 명확해졌네요”라는 피드백이 달렸다. 스트림 API가 코드를 단순히 줄이기 위한 것이 아니라, 의도를 더 명확히 표현하고 협업을 돕는 도구라는 사실을 다시 한번 느꼈다. 람다와 파이프라인 사이를 오가며 보냈던 밤들이 오늘의 나를 만들었다는 사실에, 나는 조용히 웃어 본다.

---
title: "스레드 덤프와 데드락 다이어그램, 자바 동시성의 밤을 기록하다"
date: "2025-10-27"
category: "Java"
tags: ['Java', 'Concurrency', 'Thread', 'ExecutorService', '락']
excerpt: "Thread, synchronized, ExecutorService, ForkJoinPool을 오가며 레이스와 데드락을 추적했던 내 1인칭 동시성 일기"
readTime: "12분"
---

> **이 글은 소설 형식으로 구성된 창작 에세이입니다.**

자바를 처음 배울 때, `Thread`를 상속받아 `run()` 메서드를 오버라이드하는 것만으로도 세상을 다 가진 줄 알았다. 그러나 첫 번째 레이스 컨디션을 마주한 날, 나는 동시성의 무게를 실감했다. 로그 파일에 “balance: -10”이 찍혀 있는 것을 보고 멍하니 모니터를 바라보던 그 밤, 나는 가장 먼저 락(lock)의 세계에 발을 들여놓았다.

`synchronized` 키워드를 붙인다고 모든 문제가 해결되는 건 아니었다. 공유 리소스를 보호하기 위해 메서드 전체를 동기화했더니, 시스템이 순식간에 느려졌다. 락 경합이 지표에 빨간색 경고를 뿜기 시작했고, 나는 내 실수를 깨달았다. 필요한 구간만 좁혀 잠그고, 가능한 한 빠르게 락을 해제해야 한다는 교훈을 Figma 다이어그램으로 그려 팀 위키에 기록했다. `wait()`와 `notify()`를 사용하던 시절, 실수로 `notify()` 대신 `notifyAll()`을 써야 한다는 사실을 놓쳤다가 스레드가 도미노처럼 잠드는 모습을 지켜보기도 했다.

ExecutorService가 등장했을 때는 마치 새로운 세계가 열린 것 같았다. 스레드를 직접 만들고 관리하는 대신, 쓰레드 풀에 작업을 제출하는 방식은 안전하고 우아했다. `Executors.newFixedThreadPool()`로 워커를 만들고, `Future`를 받아 결과를 기다리며, CPU 코어 수에 맞춰 풀 사이즈를 조정했다. 한 번은 작업 큐가 끝없이 쌓여 서비스가 멈춰 버렸는데, 그때 `CallerRunsPolicy`와 `DiscardOldestPolicy`를 비교하며 스트레스를 조절하는 법을 배웠다. 그 이후로는 항상 큐 길이와 쓰레드 수를 계산하는 습관이 생겼다.

`java.util.concurrent` 패키지를 탐험하던 시절은 작은 연구 프로젝트였다. `ReentrantLock`의 공정성(fairness) 옵션이 성능과 어떤 상충 관계를 가지는지 벤치마크를 돌렸고, `ReadWriteLock`이 읽기 위주의 시스템에서 얼마나 효율적으로 동작하는지 측정했다. `CountDownLatch`로 스레드 동기화를 깔끔하게 구현했을 때, “이제 복잡한 타이머 대신 이걸 쓰자”라는 문장을 팀 노션에 올렸다. `ConcurrentHashMap`의 세그먼트 구조를 이해하려고 소스 코드를 프린트해 회의실에 붙여 놓기도 했다.

ForkJoinPool이 등장했을 때도 새로운 챕터가 열렸다. 분할 정복 알고리즘을 `RecursiveTask`로 구현하고, 워크 스틸링(work stealing)이 실제로 어떻게 부하를 분산하는지 로그로 확인했다. “병렬 스트림”이 JDK 8에 추가되었을 때, 나는 조심스럽게 프로덕션에 적용했지만, 데이터 크기가 작으면 오히려 느려지는 역효과를 겪었다. 그때 “병렬은 도구이지 만능이 아니다”라는 문장을 노트에 적어 두었다. 이후로는 병렬 실행의 비용과 이득을 항상 측정값으로 확인했다.

한편, 데드락은 여전히 두려운 존재였다. 한 번은 두 개의 서비스가 서로 상대편의 락을 기다리며 얼어붙는 현상을 모니터링하다가, JStack으로 스레드 덤프를 뜨는 손이 떨렸다. `Found one Java-level deadlock:`이라는 문장을 읽고, 스택 트레이스를 역추적해 순환 의존을 끊어낼 때까지 서너 시간을 소비했다. 그 사건 이후 나는 항상 락 획득 순서를 도식화하고, 가능한 한 락을 줄이는 설계를 우선하게 되었다.

요즘 나는 CompletableFuture와 Project Loom 이야기를 동시에 다룬다. 콜백 지옥을 벗어나기 위해 체이닝된 Future를 사용하고, 넌블로킹 I/O 기반의 `CompletableFuture.supplyAsync()`를 적극 활용한다. Loom의 가상 스레드 실험을 하며 “이제 스레드 수에 대한 걱정이 조금 줄어들지도 모르겠다”는 희망을 품었다. 아직은 조심스럽지만, 자바 동시성의 다음 페이지가 이미 열리고 있다는 걸 느낀다.

오늘도 배포 전 체크리스트에서 로그를 훑었다. `Thread dump`의 상태는 양호했고, 메트릭스 대시보드에서 컨텍스트 스위치 수와 CPU 사용량은 안정적이었다. 모니터를 바라보며 나는 중얼거렸다. “동시성은 항상 겸손을 요구한다.” 지난 10여 년간 락과 스레드, 실행기와 풀을 다루며 배운 가장 소중한 교훈이다. 그리고 나는 내일도 동일한 체크리스트를 반복할 것이다. 그 리듬 속에서 우리는 조금씩 더 안전한 동시성을 만들어 간다.

---
title: "Happens-before를 붙잡기까지, 자바 메모리 모델을 해부한 내 여정"
date: "2025-10-28"
category: "Java"
tags: ['Java', '메모리모델', 'volatile', 'HappensBefore', 'JMM']
excerpt: "JMM 명세와 volatile, synchronized, reorder의 경계를 파헤치며 가시성과 순서를 이해한 개발자의 기록"
readTime: "12분"
---

처음에는 멀티스레드 코드가 이상하게 동작하면 “CPU가 느린가?” 정도만 생각했다. 그러나 `double-checked locking`이 깨져 버리고, `volatile`이 없던 `singleton`이 간헐적으로 초기화되지 않은 상태를 반환하는 모습을 본 순간, 나는 자바 메모리 모델(JMM)이라는 미지의 세계를 파고들어야 했다. 2004년 JSR-133이 등장한 이후의 JMM 명세서를 출력해 노트에 밑줄을 그으며 공부하던 밤, 나는 “happens-before”라는 단어가 단순한 이론이 아니라 생존 가이드라는 사실을 깨달았다.

CPU는 명령을 마음대로 재배치하고, 컴파일러는 최적화를 수행하며, 캐시는 각 코어에서 독립적으로 움직인다. 이 현실을 이해하지 못하면 `count++` 같은 단순한 연산조차 신뢰할 수 없다는 사실이 충격적이었다. 나는 Whiteboard에 메모리 가시성, 순서 보장, 원자성의 삼각형을 그리고, 스레드를 두 개만 띄워도 데이터가 엉키는 시나리오를 반복 시뮬레이션했다. 그 과정에서 `volatile`의 진짜 의미를 이해했다. 단순한 키워드가 아니라, 읽기-쓰기 시점에 메모리 장벽을 세우는 장치였다.

`synchronized` 블록을 사용할 때만 해도 순서와 가시성을 보장할 수 있었다. 하지만 락을 줄이고 싶었던 나는 `volatile`과 명시적인 happens-before 관계를 설정하는 방법을 연구했다. `ExecutorService`에서 제출되는 작업 간에 `CountDownLatch`를 이용해 순서를 강제한다든지, `AtomicInteger`의 `getAndIncrement`가 CAS 기반으로 어떻게 안전한 업데이트를 제공하는지 소스 코드를 통해 확인했다. `Unsafe` 클래스의 `storeFence()`와 `loadFence()`를 실험하며, 실제로 CPU 명령어가 어떻게 배치되는지 disassemble 결과를 들여다보던 순간은 지금도 잊지 못한다.

JMM 명세를 읽으며 가장 마음에 남았던 문장은 “프로그램의 의미는 happens-before 그래프의 연결 관계로 정의된다”였다. 나는 실제 서비스 장애에서 이 문장을 떠올렸다. 한 번은 로그 수집기가 종종 오래된 데이터를 출력하는 문제가 있었다. 원인은 background 스레드가 캐시를 갱신할 때 `volatile` 없이 필드를 교체한 것이었다. 캐시 참조를 `volatile`로 바꾸고 나서야 최신 내용이 보장됐다. 그날 이후로 나는 공유 데이터를 담는 필드에 `volatile`을 붙일지, 아니면 `AtomicReference`로 감쌀지부터 고민하는 습관이 생겼다.

`final` 필드의 불변성 보장 역시 흥미로운 주제였다. 생성자가 끝나기 전에 다른 스레드에게 `this`를 노출하면 `final` 필드도 제대로 보이지 않을 수 있다는 사실을 테스트 코드로 확인했다. “생성자 밖으로 빠져나가기 전에 모든 필드를 초기화해야 한다”는 조언은 단순한 규칙이 아니라, 메모리 모델을 지키기 위한 필수 조건이었다. 그 이후로는 Builder 패턴과 불변 객체를 적극 도입했다. 객체가 불변이면 happens-before를 걱정할 필요가 크게 줄어들기 때문이다.

JMM을 이해하기 위해선 단순히 명세를 읽는 것만으로는 부족했다. 나는 `jdeps`로 바이트코드를 뜯어보고, `-XX:+PrintAssembly`를 켠 상태로 JIT 컴파일 결과를 분석했다. 가끔은 `perf` 도구와 함께 CPU 캐시 미스를 측정해 보기도 했다. 이런 실험들은 “컴파일러 최적화는 우리 코드를 예상치 못한 순서로 재배치한다”는 사실을 피부로 느끼게 해 주었다. happens-before 그래프를 손으로 그려 보는 일은 이제 일상의 일부가 되었다.

요즘 들어서는 `VarHandle` API와 JDK 9 이후 도구들을 살펴보고 있다. JMM의 핵심이 변하지 않았다는 사실에 안도하면서도, 더 세밀한 제어가 가능해진 점에 흥분한다. Project Loom에서 가상 스레드가 대거 등장하면, JMM이 어떻게 동작할지, 어떤 새로운 함정이 있을지 벌써부터 노트에 시나리오를 적어두고 있다. happens-before 원칙이 우리에게 계속해서 guiding star가 되어 줄 것이라 믿는다.

오늘도 코드 리뷰를 하다가 공유 필드에 `volatile`이 없는 것을 발견했다. 댓글로 “여기 happens-before 관계가 보장되는지 확인했나요?”라고 남겼다. 몇 년 전의 나였다면 이런 리뷰를 남기기 어려웠을 것이다. JMM과 함께한 시간들이 내 사고방식을 바꾸었다. 메모리 모델은 눈에 보이지 않는 거대한 지형이지만, 우리가 안전하게 코드를 실행할 수 있도록 길을 안내해 준다. 이제 나는 그 길을 조금이나마 이해했고, 앞으로도 그 지도를 계속 업데이트할 생각이다.

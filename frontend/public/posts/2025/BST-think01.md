---
title: "BST TreeInsertion 횟수 구하기 고민한 내용 정리"
date: "2025-10-17"
category: "Algorithm"
tags: ['Machine Learning', 'BST', '최적화', '줌인']
excerpt: "BST 트리 호출 횟수 구하기를 보다가 떠오른 최적화 방안 생각 정리"
readTime: "7분"
---

BST를 처음 만들어보던 어느 날, 뭔가 석연치 않은 기분이 들었습니다. 각 레벨을 일일이 순회하는 방식이 너무 비효율적으로 느껴졌거든요. "이게 맞나?" 싶어서 잠시 손을 멈추고 생각에 잠겼습니다.

곰곰이 생각해보니 재미있는 아이디어가 떠올랐습니다. 전체 트리를 위에서 아래로 순회하는 대신, 가중치 같은 걸 써서 대략적인 위치를
먼저 예측하면 어떨까? 마치 지도에서 확대하기 전에 "아, 여기쯤이겠구나" 하고 감을 잡는 것처럼요. 그러면 중간 레이어는
건너뛰고 근접한 위치에서만 탐색하면 되니까 훨씬 빠를 것 같았습니다.

## 아이디어를 풀어보다

머릿속으로 정리하니 네 가지 핵심이 보였습니다. 먼저 위치 예측인데요, 가중치와 편향을 사용하면 데이터가 어디쯤 있을지 O(1) 시간에
추정할 수 있겠더라고요. 다음은 국소 탐색입니다. 예측한 위치 주변만 살펴보면 호출 횟수를 대폭 줄일 수 있겠죠. 그리고 데이터
분포를 학습하는 건데, 트리를 일일이 순회하는 대신 패턴을 익혀서 접근하는 방식입니다. 마지막으로 캐시 친화적인 구조라는 점도
눈에 들어왔습니다. 연속된 메모리를 접근하면 성능도 좋아지니까요.

문제는 제가 BST도 처음 구현하는 입장이었다는 겁니다. 게다가 이 아이디어가 머신러닝처럼 느껴지는데, 머신러닝은 공부해본 적도 없었어요.

## 처음부터 다시

그래서 처음부터 차근차근 생각해보기로 했습니다. 벡터 공간에서 가중치를 적용하면 가장 근접한 값을 찾을 수 있겠더라고요. LLM에서
쓰는 가중치와 bias를 활용하면 탐색 범위를 좁힐 수 있을 것 같았습니다. 마치 원시인이 가장 효율적으로 음식을 찾는
방식처럼요.

그러다 문득 "가중치 곱하기 키 더하기 bias"라는 식이 떠올랐습니다. 이걸 쓰면 벡터 공간상에서 대략적인 위치를 바로 알 수 있을 것
 같았어요. 그런데 곧 의문이 들었습니다. 일차원적인 트리 구조에 굳이 고차원 연산이 필요할까? 같은 차원에서 모두 처리할 수
있지 않을까? 다행히 트리는 이미 정렬되어 있으니 그나마 다행이었습니다.

하지만 역전파처럼 오차를 어떻게 파악할지가 고민이었습니다. 잘못된 리프 노드에서 예상값을 적용하면 오히려 역효과가 날 수 있거든요.
일단 배열 같은 유동적인 자료구조를 쓰면 좋겠다고 생각했습니다. 공간 연산이니 벡터 자료구조가 적합할 것 같았어요.

그러다 깨달았습니다. 가중치와 편향을 어떻게 구현할지 막연히 생각만 하다가는 방향을 잃겠더라고요. 시냅스 연결처럼 평균 가중치와
편향도를 구하면 되겠다 싶었는데, 곧 제가 잘못 생각하고 있다는 걸 알았습니다. 바로 앞만 보고 달리다가는 길을 잃을 수
있으니까요. 지도를 다시 그려야겠다고 생각했습니다.

## 지도를 다시 그리다

지구본을 떠올려봤습니다. 특정 지역을 보려면 확대만 하면 되는데, 대략적인 위치를 알아야 가능하잖아요. 우리가 어떻게 그걸 구분할까요?
트리 구조에서는 크기 차이로 구분할 수 있겠더라고요. 예상 위치는 그 크기에 가중치를 곱하고 근처 편향을 적용하면 찾을 수 있을 것
 같았습니다. 그 이후에는 경사하강법처럼 주변을 살펴보면 되고요.

머리가 복잡해지니 핵심만 다시 짚어봤습니다. 일단 중심을 찾는 것. 그리고 크기에 따라 예상 위치를 추적하는 것. 결국 이 두 가지로 압축되더라고요.

지금 돌아보면 처음 BST를 구현하면서 떠올린 최적화 아이디어가 제법 흥미로웠습니다. 아직 완성된 건 아니지만, 이런 식으로 하나씩 풀어가다 보면 언젠가 실제로 동작하는 구조를 만들 수 있을 것 같습니다.

---
title: "타입 변수와 야생의 캐스팅: 제네릭을 길들이던 내 기록"
date: "2025-10-25"
category: "Java"
tags: ['Java', 'Generics', '타입시스템', 'Erasure', '컬렉션']
excerpt: "로 타입과 ClassCastException에 질려, 제네릭이 도입되던 현장을 지켜보며 타입 안정성을 붙잡은 개발자 일기"
readTime: "10분"
---

지금 와서 생각하면 믿기 어렵지만, 2003년 이전의 나는 `List`에 무엇이 들어가는지 매번 머릿속으로 기억해야 했다. 로 타입(raw type)으로 선언된 컬렉션에 문자열과 숫자가 뒤섞여 있고, 런타임에야 `ClassCastException`이 터지는 장면은 일상이었다. 한 번은 야근 도중 로그 분석기를 돌리다가, 잘못된 타입 캐스팅 때문에 새벽에 배포를 롤백해야 했다. 그날 이후 나는 “컴파일러가 조금만 더 도와줬으면 좋겠다”고 투덜거렸다.

2004년, 제네릭이 포함된 JDK 5가 베타로 공개되었을 때, 우리 팀 스터디 룸은 작은 전쟁터가 됐다. `List<String>`이라는 문법이 등장했고, 이전 세대의 리플렉션 코드가 컴파일 경고를 쏟아냈다. 그러나 첫 번째 실험에서 `String`만을 담는 리스트가 캐스팅 없이 깔끔하게 동작하는 걸 보고, 나는 모니터 앞에서 조용히 미소를 지었다. 타입 안전성이 코드를 얼마나 단단하게 만들어 주는지 체감한 첫 순간이었다.

물론 포기할 수 없는 과제도 있었다. 제네릭이 래퍼런스 타입에만 적용된다는 사실을 깨달았고, 오토박싱이 성능을 얼마나 악화시킬 수 있는지 벤치마크를 돌려 보았다. `List<int>`를 허용하지 않는 JVM의 타입 시스템을 욕하며 `List<Integer>`에 억지로 박싱한 숫자를 넣어야 할 때면, “지워짐(erasure) 때문에 어쩔 수 없지”라는 말을 되뇌었다. 컴파일 타임에만 존재하고 런타임에는 사라지는 타입 변수, `instanceof`와 `new T()`가 허용되지 않는다는 제약은 분명 불편했다. 하지만 타입 안전성을 위해 지불할 만한 값이라는 결론에 도달했다.

제네릭 와일드카드(`?`, `? extends T`, `? super T`)와의 씨름은 또 다른 모험이었다. 생산자-소비자(PECS) 규칙을 이해하려던 밤, 나는 화이트보드에 “Producer Extends, Consumer Super”라는 문장을 적어 두고 반복해서 읽었다. 공변성과 반공변성을 명확하게 이해하고 나니, API 설계에 대한 시각이 달라졌다. “내가 제공하는 컬렉션이 어떤 타입을 허용해야 하지?”라는 질문을 먼저 던지게 되었고, 불필요한 복사를 줄이며 유연한 메서드 시그니처를 만들어낼 수 있었다.

새로운 API를 만들 때 제네릭 메서드를 추가하는 일도 즐거운 도전이었다. `<T extends Comparable<T>>` 같은 선언을 작성하면서, 타입 시스템이 동작하도록 설계했다는 사실에 감탄했다. “컴파일러가 이렇게 똑똑해져도 되는 걸까?”라는 농담을 하던 동료도 결국 제네릭 메서드 덕분에 템플릿 코드량이 줄어든 것을 인정했다. 그날 우리는 서로에게 하이파이브를 하며 “이제 런타임 오류에 덜 시달려도 되겠네”라고 말했다.

시간이 지나면서 나는 제네릭을 단지 문법이 아니라, API의 계약을 표현하는 언어로 사용하게 되었다. 호출자가 어떤 타입을 기대해야 하는지, 내가 제공하는 데이터 구조가 어떤 값을 저장하고 꺼낼 수 있는지 명확히 전달할 수 있었다. JSR-14와 커뮤니티 논의 덕분에 탄생한 제네릭이, 내 코드베이스의 버그를 얼마나 줄였는지 따져보는 일은 여전히 감동이다. 가끔 JVM의 타입 소거 때문에 어색한 캐스팅을 해야 할 때면 툴툴거리기도 하지만, 그래도 나는 지금이 과거보다 훨씬 안전하고 예측 가능한 시대임을 안다.

오늘도 새 프로젝트를 시작하며 `List<Order>`를 선언했다. 아무런 주석 없이도 코드가 의도를 전달하고, IDE가 타입을 추론한다. “우리가 이런 환경을 누릴 수 있는 건 제네릭 덕분이야.” 모니터를 응시하며 문득 혼잣말을 했다. 과거의 나였으면 몰랐을, 현재의 당연함이 떠올랐기 때문이다. 제네릭은 내게 컴파일러와 신뢰를 쌓는 방법을 알려줬고, 그 덕분에 나는 타입 안전성이라는 든든한 동료를 얻었다.

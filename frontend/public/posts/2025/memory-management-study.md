---
title: "메모리 관리 공부하다가 깨달은 페이징 시스템의 진짜 장점"
date: "2025-01-01"
category: "Computer Science"
tags: ["메모리관리", "페이징", "MMU", "스와핑", "운영체제"]
excerpt: "운영체제 메모리 관리를 공부하면서 페이징과 스와핑이 왜 필요했는지 이해한 과정"
readTime: "3분"
---

운영체제 수업에서 메모리 관리 부분을 공부할 때, 처음엔 왜 이렇게 복잡한 시스템을 만들었는지 이해가 안됐다. 하지만 옛날 방식의 문제점을 알고 나니 페이징이 정말 획기적인 해결책이었다는 걸 깨달았다.

## 처음엔 단순했던 메모리 관리

![1768280399652](image/memory-management-study/1768280399652.png)

초기 컴퓨터는 메모리 관리가 단순했다. 그냥 프로세스를 메모리에 연속으로 쭉 넣는 방식이었다.

### MMU의 기본 원리

**MMU(Memory Management Unit)**가 하는 일은 생각보다 단순하다:

- **베이스 레지스터**: 프로세스가 시작되는 물리 메모리 위치
- **리밋 레지스터**: 프로세스가 사용할 수 있는 메모리 크기

CPU가 논리 주소 346을 요청하면, MMU는 이렇게 처리한다:

1. 346이 리밋 레지스터(740) 범위 내인지 확인
2. 맞다면 베이스 레지스터(14000)를 더해서 물리 주소 14346으로 변환
3. 해당 메모리에 접근

이 방식은 간단하지만 치명적인 문제가 있었다.

## 외부 단편화라는 악마

시간이 지나면서 프로세스들이 생성되고 종료되다 보니, 메모리 곳곳에 **홀(Hole)**이라는 빈 공간이 생겼다.

구체적인 예시를 보면:

1. Process 1(10MB), 2(20MB), 3(15MB)가 연속으로 할당됨
2. Process 2가 종료되어 20MB 홀이 생김
3. Process 4(15MB)가 들어가면서 5MB 홀이 남음
4. 다른 곳에도 10MB, 10MB 홀이 생김

이제 총 여유 공간은 25MB(5+10+10)인데, 20MB 크기의 Process 5는 들어갈 수 없다! 연속된 공간이 없기 때문이다.

이게 바로 **외부 단편화** 문제다. 메모리는 충분한데 사용할 수 없는 상황이 생긴다.

## 페이징 - 획기적인 해결책

페이징은 이 문제를 아예 다른 관점에서 접근했다. **"연속으로 배치할 필요가 없다면?"**

### 핵심 아이디어

- **프레임(Frame)**: 물리 메모리를 고정 크기로 나눈 블록
- **페이지(Page)**: 프로세스도 같은 크기로 나눈 블록
- **비연속 배치**: 페이지들을 아무 프레임에나 배치 가능

프로세스 입장에서는 여전히 연속된 메모리를 사용하는 것처럼 보이지만, 실제로는 여기저기 흩어져 있다. CPU를 속이는 셈이다!

### 주소 변환 과정

논리 주소는 두 부분으로 나뉜다:

- **페이지 번호(p)**: 어떤 페이지인지
- **페이지 오프셋(d)**: 페이지 내에서의 위치

물리 주소로 변환할 때:

1. 페이지 번호로 페이지 테이블에서 프레임 번호 찾기
2. 프레임 번호 + 페이지 오프셋 = 물리 주소

## 페이징의 장단점

### 장점

- **외부 단편화 완전 해결**: 어떤 프레임에나 페이지 배치 가능
- **메모리 보호**: 각 프로세스마다 독립적인 페이지 테이블
- **공유 메모리**: 여러 프로세스가 같은 프레임 참조 가능

### 단점

- **내부 단편화**: 마지막 페이지에서 공간 낭비 발생
- **오버헤드**: 페이지 테이블 관리 비용
- **TLB 미스**: 주소 변환 시간 증가

하지만 외부 단편화로 시스템이 멈추는 것보다는 훨씬 낫다.

## 스와핑으로 메모리 확장

페이징과 함께 **스와핑(Swapping)**도 중요한 개념이다.

### 스와핑의 필요성

- 메모리보다 큰 프로그램 실행 가능
- 더 많은 프로세스 동시 실행
- 메모리 활용도 극대화

### 동작 과정

1. **스왑 아웃**: 사용하지 않는 페이지를 디스크로 이동
2. **스왑 인**: 필요한 페이지를 메모리로 로드
3. **페이지 폴트**: 접근하려는 페이지가 메모리에 없을 때 발생

스왑 공간을 관리하는 것도 중요한데, 디스크의 특정 영역을 스왑 공간으로 할당해서 사용한다.

## 실제 성능에 미치는 영향

페이징 시스템의 성능은 주로 다음 요소들에 달려있다:

### 지역성 원리

프로그램은 보통 특정 메모리 영역을 집중적으로 사용한다:

- **시간적 지역성**: 최근 사용한 데이터를 다시 사용할 확률이 높음
- **공간적 지역성**: 인근 메모리를 연속해서 사용할 확률이 높음

이 덕분에 TLB 히트율이나 페이지 폴트 발생률을 예측할 수 있다.

### 페이지 크기 선택

- **작은 페이지**: 내부 단편화는 줄지만 페이지 테이블이 커짐
- **큰 페이지**: 페이지 테이블은 작아지지만 내부 단편화 증가

보통 4KB~16KB 사이에서 시스템 특성에 맞게 선택한다.

## 마무리

처음엔 복잡해 보였던 페이징 시스템이지만, 외부 단편화라는 심각한 문제를 해결하기 위한 필연적인 발전이었다는 걸 이해하고 나니 모든 게 명확해졌다.

특히 CPU를 속여서 연속된 메모리를 쓰는 것처럼 보이게 하면서도, 실제로는 비연속적으로 배치하여 메모리를 효율적으로 사용하는 아이디어가 정말 인상적이었다.

현대 운영체제에서 가상 메모리 시스템이 얼마나 정교하게 발전했는지도 새삼 느끼게 된다.

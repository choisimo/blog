---
title: "PATH에 새 친구를 초대하는 방법"
date: "2025-11-01"
category: "Linux"
tags: ["PATH", "리눅스", "환경설정", "터미널", "작업자동화"]
excerpt: "심볼릭 링크가 말을 안 듣던 날, PATH를 다시 다듬으며 정리한 나만의 에세이."
readTime: "7분"
---

![1768279427689](image/path-new-friend-essay/1768279427689.png)

차가운 공기가 내려앉은 고요한 새벽에, 리눅스 서버 마이그레이션 (우분투 -> 로키) 작업 중에 새로 받아 둔 도구 하나를 터미널에서 바로 부르고 싶었는데 이름만 치면 “command not found”라는 차가운 대답이 돌아왔다. “어제 분명 /usr/local/bin에 심볼릭 링크를 만들었는데 왜 못 알아듣지?”라는 생각이 머리를 스쳤고, 링크는 멀쩡한데 쉘은 시큰둥한 이 상황이 꽤나 낯설게 느껴졌다.

잠깐 숨을 고르고 가장 기본적인 질문부터 던졌다. “쉘은 실행 파일을 어디서 찾더라?” 결국 PATH 변수의 순서대로 디렉터리를 훑다가 이름이 맞는 파일을 발견하면 손을 내밀어 준다는 당연한 원리가 떠올랐다. 그러니 링크든 바이너리든 PATH 속 디렉터리에 있어야 하고, 실행 권한까지 갖춰야 한다. 나는 제일 먼저 `echo $PATH`로 예상한 경로가 실제로 포함되어 있는지 확인했고, zsh에서는 `rehash`, bash에서는 `hash -r`로 캐시를 날려야 새 링크가 보인다는 사실을 다시 상기했다. 한 번이라도 잊으면 “왜 또 안 되지?” 하며 시간을 낭비하기 쉬운 지점이다.

이어서 링크가 제대로 붙었는지를 차근차근 점검했다. `ls -l /usr/local/bin/프로그램`으로 링크가 절대경로를 향하는지 확인하고, 본체에는 `chmod +x`가 붙었는지 살펴보는 과정이다. 스크립트라면 첫 줄의 shebang까지 챙겨야 쉘이 머뭇거리지 않는다. 여기까지는 늘 하던 체크였지만, 이번에는 sudo로 실행했을 때만 실패하는 이상한 반응이 덧붙었다. 원인은 secure_path였다. `sudo env | grep ^PATH=`로 확인해 보니 /usr/local/bin이 빠져 있었고, 결국 `sudo visudo`에서 기존 값을 유지한 채 `/usr/local/bin`을 끼워 넣어야 했다.

문제는 여기서 끝이 아니었다. GUI 런처로 실행할 때 PATH가 다르게 잡혀서 또다시 “not found”가 뜨는 걸 보고야 말았다. 로그인 셸이 아니면 `/etc/profile`이나 `~/.zprofile`이 건너뛰어지기도 하니, 결국 `~/.zshrc`나 `~/.bashrc`에 PATH를 덧씌워 두는 편이 마음이 편하다. GNOME 터미널, KDE 콘솔 등 환경마다 초기화 스크립트가 다르다는 사실도 이번에 뼈저리게 느꼈다. “분명 같은 계정인데 왜 여기서는 안 되지?”라는 의문에 빠지기 전에 각 환경이 PATH를 어떻게 불러오는지 살피는 버릇을 들였다.

한편, 어느 순간 링크를 눌렀는데도 “Permission denied”가 뜬다면 파티션에 `noexec` 옵션이 걸려 있는지 의심해 볼 만하다. `mount | grep noexec`로 금세 알아볼 수 있다. 나는 한 번, 보안을 강화한 USB 저장소에서 프로그램을 돌리려다 이 옵션을 만나서 한참 헤맸다. 링크도, 권한도 문제없는데 여전히 실행이 안 된다면 여기까지 체크리스트에 넣어 두면 마음이 든든해진다.

그날 이후 나는 “개인용”과 “전역용” 경로를 분리해서 관리하기로 했다. 개인적으로 쓰는 도구는 `~/.local/bin`에 모아 두기로 마음먹었다. 우선 디렉터리를 만들고(`mkdir -p ~/.local/bin`), 링크나 래퍼 스크립트를 두는 것이다. 예를 들어:

```bash
ln -s /절대/경로/프로그램 ~/.local/bin/프로그램
```

혹은 원본 경로가 바뀔 수 있을 때는 짧은 래퍼를 만든다.

```bash
cat > ~/.local/bin/프로그램 <<'EOF'
#!/usr/bin/env bash
exec /절대/경로/프로그램 "$@"
EOF
chmod +x ~/.local/bin/프로그램
```

그다음 `~/.zshrc`나 `~/.bashrc`에 `export PATH="$HOME/.local/bin:$PATH"`를 넣고, 해당 셸에서 `source`를 한 뒤 `rehash`나 `hash -r`를 해주면 끝이다. 이렇게 해 두니 새 프로그램을 들일 때마다 시스템 디렉터리를 건드리지 않아도 되고, 혹시나 실수로 링크를 잘못 만들었어도 내 홈 디렉터리 안에서 문제를 해결할 수 있어 마음이 편해졌다.

그래도 전역으로 공유해야 할 도구가 있을 때는 `/usr/local/bin`을 포기할 수 없다. 이럴 때는 링크를 만들면 끝이 아니라, PATH 순서 속에서 그 디렉터리가 앞쪽에 있는지 다시 체크해야 한다. `/etc/profile.d/local-path.sh` 같은 스크립트를 만들어 시스템 전체에 `export PATH="/usr/local/bin:/usr/local/sbin:$PATH"`를 선언하고, 새 로그인 세션에서 반영되는지도 꼭 확인한다. 서버를 재부팅하기 어렵다면 임시로 각 계정의 셸 설정에도 같은 내용을 추가해 두는 편이 안전했다.

이렇게 하나씩 짚어 보니 결국 PATH와 권한, 그리고 쉘의 기억력 사이의 균형 싸움이었다. 링크가 말을 안 듣는 날에는 “혹시 캐시?” “혹시 secure_path?” “혹시 noexec?” 하고 자문해 보는 습관이 생겼다. 덕분에 요즘은 새 프로그램을 들이는 일이 예전보다 훨씬 단순해졌다.

마지막으로 나는 항상 `which -a 프로그램`과 `프로그램 --help`를 실행해 보며 마무리를 짓는다. 터미널이 조용히 응답해 줄 때의 안도감이란. 언젠가 다시 PATH가 삐끗거릴 때, 이 글이 내 자신에게도 작은 리마인더가 되어 주었으면 한다. “모든 길은 PATH에 있다”는 약간의 농담과 함께요.

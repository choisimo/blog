---
title: "게으름의 미학"

date: "2026-01-03"

category: "Tech & Philosophy"

tags: ['시스템 설계', '자동화', 'DevOps', '개발 철학', '생산성']

excerpt: "나의 귀찮음이 만들어낸 부지런한 컨테이너"

readTime: "8분"
---

![img](/images/2026/귀차니즘.png)

### 게으름쟁이의 역설

진정한 게으름쟁이는 일을 미루는 사람이 아니다. 오히려 그 반대다. 미래의 내가 같은 일을 반복하지 않도록, 현재의 내가 치열하게 시스템을 만드는 사람이다. 한 번의 수고로 백 번의 편안함을 얻는 것. 이것이야말로 진정한 게으름의 미학이다.

나에게도 그런 순간이 있었다. 새 노트북을 받을 때마다, 새로운 환경에서 작업할 때마다 반복되는 지루한 의식. SSH 키를 복사하고, 설정 파일을 찾아 헤매고, 서버 주소를 메모장에서 뒤지고. 한두 번은 괜찮았다. 하지만 열 번째쯤 되자 화가 났다.

"왜 나는 매번 이 짓을 반복하고 있는 거지?"

그날 밤, 나는 결심했다. 지구상 어떤 컴퓨터 앞에 앉더라도, 단 5분 안에 나만의 완벽한 작업 환경을 소환할 수 있는 시스템을 만들겠다고.

### 쉘 스크립트의 한계

처음엔 간단했다. bash 스크립트 몇 줄이면 충분할 것 같았다. 서버 목록을 텍스트 파일에 저장하고, 간단한 함수로 SSH 접속을 자동화했다. 처음 몇 주는 잘 작동했다.

하지만 서버가 늘어나기 시작했다. 개발 서버, 스테이징 서버, 프로덕션 서버. 각각 다른 SSH 키를 사용하고, 다른 포트를 쓰고, 다른 사용자 이름을 가진다. 스크립트는 점점 복잡해졌다. if문이 중첩되고, 변수가 꼬이고, 에러 처리는 엉망이 되었다.

어느 날 스크립트가 100줄을 넘어가는 순간, 깨달았다. 이건 유지보수가 불가능하다. 3개월 후의 나는 이 코드를 이해하지 못할 것이다. 더 우아하고, 더 강력하며, 무엇보다 더 게으른 방법이 필요했다.

### 설계의 시작

나는 단순한 스크립트 모음이 아니라, 하나의 플랫폼을 만들기로 했다. 이름은 `remote-manager`. 이 시스템은 세 가지 원칙을 따른다.

첫째, 이식성(Portability). 어떤 컴퓨터에서든 동일하게 작동해야 한다. Docker 컨테이너로 모든 것을 패키징하면 된다. 호스트 시스템이 무엇이든, 내 컨테이너 안은 언제나 나의 영역이다.

둘째, 보안(Security). SSH 키는 민감한 정보다. GitHub에 올릴 수는 없지만, 그렇다고 매번 수동으로 복사할 수도 없다. SOPS와 Age를 사용해 암호화하기로 했다. 코드는 공개 저장소에, 키는 안전하게 암호화되어 함께 저장된다.

셋째, 편의성(Convenience). 복잡한 명령어는 싫다. `ssh -i ~/.ssh/production.pem ubuntu@192.168.1.100 -p 2222` 같은 걸 매번 칠 수는 없다. 대신 `remote open prod-web`이라고만 입력하면 모든 게 자동으로 처리되어야 한다. (~/.ssh/config 에 정의하는 것조차 귀찮다!!)

### Go 언어를 선택한 이유

bash 스크립트 대신 Go 언어로 CLI 도구를 만들기로 했다. 처음엔 과한 선택처럼 보였다. 하지만 Go는 완벽한 선택이었다.

단일 바이너리로 컴파일된다. 의존성 지옥이 없다. 빠르다. 타입 안정성이 있어 버그가 줄어든다. 무엇보다, 코드가 명확하다. 6개월 후에 다시 봐도 이해할 수 있다.

`remote open db-prod`를 입력하면 무슨 일이 벌어질까? Go로 작성된 CLI는 YAML 파일에서 서버 정보를 읽는다. IP 주소, SSH 키 경로, 포트, 사용자 이름. 모든 정보를 파싱하고, 적절한 SSH 명령어를 구성한 뒤, 자동으로 연결한다. 사용자는 그저 서버의 별명만 기억하면 된다.

### 내 방을 어디든 가져가기

가장 신경 쓴 부분은 환경 설정이었다. 나는 zsh를 쓴다. oh-my-zsh 플러그인이 설치되어 있고, 특정 테마를 사용하며, 수십 개의 alias가 설정되어 있다. vim 설정도 마찬가지다. 이 모든 것 없이는 일할 수 없다.

그래서 내 모든 설정 파일을 Docker 이미지에 구워버렸다. `.zshrc`, `.vimrc`, 플러그인, 테마. 전부 다. 이제 어떤 컴퓨터에서든 `docker run`을 하는 순간, 그곳은 나의 방이 된다. 낯선 환경에서 느끼는 불편함이 사라진다.

PC방에서 급하게 서버에 접속해야 할 때도, 친구 노트북을 빌렸을 때도, 새 회사에서 첫 출근했을 때도. Docker만 설치되어 있다면, 나는 언제나 익숙한 환경에서 일할 수 있다.

### 보안과 편의성의 균형

SSH 키를 어떻게 관리할 것인가. 이것이 가장 큰 고민이었다.

처음엔 git-crypt를 고려했다. 간단하고 효과적이다. 하지만 더 정교한 통제가 필요했다. 특정 파일만 암호화하고, 여러 사람과 협업할 때 각자 다른 키로 복호화할 수 있어야 했다.

이를 위해 여러 방안을 며칠 고민하다가 SOPS(Secrets OPerationS)와 Age를 도입했다. SOPS는 YAML, JSON 파일의 특정 필드만 암호화할 수 있다. Age는 현대적이고 간단한 암호화 도구다. 이 둘의 조합은 완벽했다.

키 파일들은 GitHub에 올라갈 때 암호화된다. 하지만 컨테이너가 시작될 때, entrypoint 스크립트가 자동으로 복호화한다. 사용자는 처음 한 번만 마스터 암호를 입력하면 된다. 그 후로는 모든 게 투명하게 작동한다.

보안은 철저하게, 사용은 편리하게. 이것이 내가 원했던 균형이었다.

### 5분의 마법

이제 시나리오는 완벽하다.

새 노트북을 받았다고 상상해보자. 아무것도 설치되어 있지 않다. Docker만 있으면 된다.

터미널을 열고 저장소를 클론한다. `make run`을 입력한다. 마스터 암호를 한 번 입력한다. 그게 전부다.

컨테이너가 뜬다. 화려한 zsh 테마가 나를 반긴다. `remote ls`를 치자 관리 중인 모든 서버 목록이 깔끔하게 정렬되어 나타난다. 몬스터를 한 모금 마시고, `remote open web-01`을 입력한다. 순식간에 프로덕션 서버에 접속된다.

5분도 걸리지 않았다. 이제 다른 사람들이 환경 설정하느라 저혈압을 치료하고 있을 때, 나는 당분 채우러 냉장고로 갈 수 있다.

### 자동화의 철학

이 프로젝트를 하면서 깨달은 게 있다. 자동화는 단순히 시간을 절약하는 것이 아니다. 그것은 사고방식의 전환이다.

반복되는 작업을 발견했을 때, 우리에게는 두 가지 선택지가 있다. 그냥 참고 계속하거나, 시스템을 만들거나. 대부분의 사람들은 전자를 택한다. "이 정도는 그냥 하는 게 빠르지"라고 생각한다.

하지만 진짜 문제는 시간이 아니다. 반복 작업은 우리의 정신을 갉아먹는다. 창의적으로 생각해야 할 뇌의 용량을 단순 작업이 차지한다. 그리고 무엇보다, 실수할 가능성이 항상 존재한다.

자동화는 이 모든 것을 해결한다. 한 번 제대로 만들어두면, 그 후로는 완벽하게 작동한다. 실수가 없다. 빠르다. 그리고 무엇보다, 내 머리를 자유롭게 한다. (정신 건강에 이롭다.)

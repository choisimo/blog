---
title: "모든 것은 파일이다"

date: "2026-01-02"

category: "Tech & Philosophy"

tags: ['시스템 프로그래밍', '리눅스', '커널', '파이프', 'I/O', '아키텍처']

excerpt: "cat | grep 이라는 단순한 명령어 뒤에 숨겨진 커널의 정교한 메커니즘. 모든 것을 파일로 추상화한 유닉스 철학의 고마움"

readTime: "10분"
---

![img](/images/2026/museums-victoria-WGeO6dW5GZM-unsplash.jpg)

### 보이지 않는 연결 처리

터미널에 `cat *.c | grep "function"`을 입력한다. 화면에는 함수 정의들이 순식간에 출력된다. 너무나 자연스러운 광경이라 우리는 그 뒤에서 무슨 일이 벌어지는지 궁금해하지 않는다. 하지만 이 단순해 보이는 명령어 하나에는, 운영체제 커널의 가장 정교한 메커니즘 중 하나가 숨어 있다.

두 개의 프로그램이 서로 대화한다. `cat`은 파일을 읽어 무언가에게 전달하고, `grep`은 어디선가 데이터를 받아 필터링한다. 그런데 이 둘은 서로의 존재를 모른다. 각자 자신의 일만 할 뿐이다. 마치 두 사람이 벽 너머로 파이프를 통해 물건을 주고받지만, 상대방의 얼굴을 본 적이 없는 것처럼.

이것이 가능한 이유는 유닉스의 가장 근본적인 철학 때문이다. "모든 것은 파일이다(Everything is a File)." 키보드 입력도, 모니터 출력도, 네트워크 소켓도, 심지어 프로세스 간 통신 채널도. 커널의 관점에서 이 모든 것은 그저 파일 디스크립터(File Descriptor)라는 정수 하나로 표현될 뿐이다.

### 세 개의 문

프로그램이 시작될 때, 운영체제는 그 프로그램을 위해 세 개의 문을 열어둔다.

0번 문(stdin)은 입력을 위한 문이다. 기본적으로 키보드와 연결되어 있다. 1번 문(stdout)은 출력을 위한 문이다. 보통 터미널 화면으로 향한다. 2번 문(stderr)은 에러 메시지를 위한 문이다. 역시 화면으로 향한다.

프로그램은 이 문들이 어디로 연결되어 있는지 알 필요가 없다. 그저 0번에서 읽고, 1번으로 쓸 뿐이다. 이 단순함이야말로 유닉스 설계의 천재성이다. 프로그램은 자신이 키보드에서 읽는지, 파일에서 읽는지, 다른 프로그램으로부터 읽는지 전혀 모른다. 그저 읽기만 하면 된다.

이 추상화 덕분에 우리는 프로그램들을 레고 블록처럼 조립할 수 있다. 한 프로그램의 출력을 다른 프로그램의 입력으로 연결하는 것. 이것이 바로 파이프의 본질이다.

### 외과 수술처럼 정교한 연결

`cat file.c | grep "function"`을 실행하면 쉘(Shell)은 마치 외과의사처럼 정밀한 수술을 시작한다.

먼저 커널에게 파이프를 만들어달라고 요청한다. `pipe()` 시스템 콜이 호출되는 순간, 커널 메모리 어딘가에 작은 버퍼가 생성된다. 디스크에 파일을 만드는 것이 아니다. 메모리 상에만 존재하는 가상의 파일이다. 이 파이프는 두 개의 끝을 가진다. 한쪽은 쓰기 전용, 다른 한쪽은 읽기 전용.

그 다음 쉘은 자기 자신을 복제한다. `fork()` 시스템 콜로 자식 프로세스를 만든다. 이 자식은 `cat`이 될 운명이다. 하지만 `cat`으로 변신하기 전에, 중요한 일을 한다. 자신의 1번 문(stdout)을 파이프의 쓰기 끝으로 교체하는 것이다. `dup2()` 시스템 콜이 이 마법을 수행한다.

이제 이 프로세스가 `execvp("cat", ...)`을 호출하면, 프로세스는 완전히 `cat` 프로그램으로 변신한다. 하지만 `cat`은 자신의 1번 문이 바뀌었다는 사실을 모른다. 그저 평소처럼 1번 문으로 출력할 뿐이다. 그런데 그 출력은 화면이 아니라 파이프로 흘러간다.

동시에 쉘은 또 다른 자식을 만든다. 이번엔 `grep`이 될 프로세스다. 이 자식은 자신의 0번 문(stdin)을 파이프의 읽기 끝으로 교체한다. 그리고 `grep`으로 변신한다. `grep` 역시 자신이 키보드가 아닌 파이프에서 읽고 있다는 사실을 모른다.

결과적으로 `cat`이 파일을 읽어 1번 문으로 출력하면, 그 데이터는 파이프를 통해 `grep`의 0번 문으로 들어간다. 두 프로그램은 서로를 모르지만, 완벽하게 협업한다. 이것이 파이프의 마법이다.

### 커널 내부의 춤

파이프 안쪽, 커널의 영역에서는 더 복잡한 일들이 벌어진다.

`cat`이 `write()` 시스템 콜을 호출하면, 커널은 파이프의 버퍼에 공간이 있는지 확인한다. 만약 버퍼가 가득 차 있다면 어떻게 될까? `cat` 프로세스는 그 자리에서 멈춘다. 정확히는 대기 상태(Sleep)로 전환된다. CPU를 내려놓고 기다린다. 누군가 파이프에서 데이터를 읽어가서 공간이 생길 때까지.

반대편에서 `grep`이 `read()` 시스템 콜을 호출했는데 파이프가 비어있다면? `grep` 역시 잠든다. 누군가 데이터를 써줄 때까지.

이 동기화는 뮤텍스(Mutex)와 대기 큐(Wait Queue)로 구현된다. `cat`이 데이터를 쓰고 나면, 커널은 잠들어 있던 `grep`을 깨운다. `grep`이 데이터를 읽어가면, 잠들어 있던 `cat`을 깨운다. 이 춤은 데이터가 모두 전달될 때까지 계속된다.

버퍼의 크기는 보통 64KB다. 충분히 큰 것 같지만, 대용량 데이터를 다룰 때는 병목이 될 수 있다. 그래서 리눅스는 `splice()`라는 고급 시스템 콜을 제공한다. 이것은 데이터를 유저 공간으로 복사하지 않고, 커널 내부에서 직접 버퍼를 옮긴다. 제로 카피(Zero-Copy) 최적화다.

### 버퍼링의 미묘함

흥미로운 점은 버퍼링이 여러 레벨에서 일어난다는 것이다.

커널 레벨의 파이프 버퍼 외에도, C 표준 라이브러리(glibc)는 자체적인 버퍼를 가진다. `printf()`를 호출한다고 해서 즉시 `write()` 시스템 콜이 발생하는 것이 아니다. 데이터는 먼저 라이브러리의 버퍼에 쌓인다.

그런데 이 버퍼링 방식은 출력 대상에 따라 달라진다. 터미널에 출력할 때는 줄 단위 버퍼링(Line Buffered)을 사용한다. 개행 문자(`\n`)를 만날 때마다 실제로 출력한다. 반응성을 위해서다.

하지만 파이프에 출력할 때는 완전 버퍼링(Fully Buffered)을 사용한다. 보통 4KB나 8KB가 쌓일 때까지 기다렸다가 한 번에 출력한다. 시스템 콜 횟수를 줄여 효율을 높이기 위해서다.

그래서 `cat file.c`를 실행하면 한 줄씩 출력되는 것처럼 보이지만, `cat file.c | grep "function"`을 실행하면 내부적으로는 블록 단위로 처리된다. 같은 프로그램이지만, 출력 대상에 따라 다르게 동작하는 것이다.

### 현대 아키텍처로의 여행

이 파이프 메커니즘은 1970년대 유닉스에서 시작되었지만, 오늘날 가장 현대적인 시스템에서도 핵심 역할을 한다.

Docker 컨테이너를 예로 들어보자. `docker logs -f my-container`를 실행하면 무슨 일이 벌어질까?

컨테이너 안의 애플리케이션은 단순히 `stdout`과 `stderr`로 로그를 출력한다. 12-Factor App 원칙에 따라, 로그를 파일에 쓰지 않는다. 그저 표준 출력으로 뱉을 뿐이다.

하지만 컨테이너 런타임(containerd나 runc)은 컨테이너를 시작할 때, 파이프를 생성하고 컨테이너의 `stdout`과 `stderr`를 가로챈다. 정확히 쉘이 `cat | grep`을 실행할 때 하는 것과 같은 방식으로.

파이프의 반대편에는 Docker 데몬이나 로깅 드라이버가 앉아서 데이터를 읽는다. 이 데이터를 JSON 파일로 저장하거나, Syslog로 전송하거나, Fluentd 같은 로그 수집기로 보낸다.

이 설계는 우아하다. 애플리케이션은 로그를 어디에 저장할지 고민할 필요가 없다. 그저 `stdout`으로 출력하면 된다. 인프라 레이어가 알아서 처리한다. 관심사의 분리(Separation of Concerns)가 완벽하게 구현된 것이다.

### 함정과 교훈

하지만 이 메커니즘에는 함정이 있다.

파이프 버퍼가 가득 차면 어떻게 될까? 애플리케이션이 `write()`를 호출했는데 버퍼에 공간이 없다면, 그 프로세스는 블로킹된다. 멈춘다. 로그를 수집하는 쪽이 느려서 파이프를 비우지 못하면, 애플리케이션 전체가 멈출 수 있다.

실제로 프로덕션 환경에서 이런 일이 일어난다. 로그 수집 에이전트가 다운되거나 네트워크가 느려지면, 애플리케이션이 로그를 출력하려다가 블로킹되어 서비스 전체가 먹통이 되는 것이다.

그래서 고성능 시스템에서는 비동기 로깅을 사용한다. 로그를 메모리 큐에 넣고 별도의 스레드나 프로세스가 비동기로 처리하게 한다. 혹은 사이드카 패턴을 사용해 로그 수집을 완전히 분리한다.

또 다른 함정은 SIGPIPE 시그널이다. 파이프의 읽는 쪽이 사라졌는데 쓰는 쪽이 계속 쓰려고 하면, 커널은 SIGPIPE 시그널을 보낸다. 이 시그널을 처리하지 않으면 프로세스가 갑자기 종료된다. 안정적인 데몬을 만들려면 이런 엣지 케이스를 모두 고려해야 한다.

### 추상화의 힘

결국 이 모든 이야기는 추상화에 관한 것이다.

"모든 것은 파일이다"라는 단순한 추상화 하나가, 얼마나 강력한 시스템을 만들어낼 수 있는지. 프로그램들은 서로를 모르지만 완벽하게 협업한다. 새로운 프로그램을 만들 때 다른 프로그램과의 통신 프로토콜을 정의할 필요가 없다. 그저 `stdin`에서 읽고 `stdout`으로 쓰면 된다.

이 철학은 50년이 지난 지금도 유효하다. Docker, Kubernetes, 서버리스 플랫폼. 이 모든 현대적인 시스템들의 밑바닥에는 여전히 파일 디스크립터와 파이프가 있다.

복잡한 시스템을 설계할 때, 우리는 종종 새로운 것을 발명하려 한다. 새로운 프로토콜, 새로운 인터페이스, 새로운 추상화. 하지만 때로는 가장 오래된 아이디어가 가장 좋은 해답이다.

`cat | grep`이라는 단순한 명령어 뒤에 숨겨진 정교함을 이해하면, 우리는 더 나은 시스템을 설계할 수 있다. 병목 지점을 예측하고, 엣지 케이스를 처리하며, 추상화의 경계를 올바르게 그을 수 있다.

---

터미널에 무심코 명령어를 입력하는 그 짧은 순간, 잠시 멈춰 생각해 봅니다. 이 텍스트 한 줄이 실행되기 위해 커널 깊은 곳에서는 얼마나 치열한 일들이 벌어지고 있는지 말이죠. 프로세스가 복제되고, 파일 디스크립터가 연결되며, 메모리 버퍼가 쉼 없이 오갑니다. 겉으로는 고요해 보이는 프롬프트 뒤편에는 수많은 시스템의 '헌신'이 숨쉬고 있습니다.

우리의 삶도 이와 다르지 않습니다. 우리가 누리는 평온한 일상은 거저 주어지는 것이 아닙니다. 매일 아침 깨끗한 거리를 걸을 수 있는 건 새벽을 여는 환경미화원분들 덕분이며, 스위치만 켜면 쏟아지는 전기와 물, 끊김 없는 인터넷망 뒤에는 수많은 사람들의 보이지 않는 노고가 깔려 있습니다.

운영체제가 복잡한 연산을 감추고 단순한 인터페이스를 제공하듯, 우리 사회 또한 누군가의 수고로움 덕분에 '당연한 편리함'으로 유지됩니다. 오늘, 모니터 속의 커널 코드뿐만 아니라 창문 밖, 보이지 않는 곳에서 세상을 지탱하는 수많은 존재들에게도 감사의 마음을 가져보는 시간을 가져보는 것은 어떨까요? 궁극적으로 그것이 '공부'를 하는 진정한 의미가 아닐까 생각해봅니다.

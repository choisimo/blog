---
title: "Nginx 설정 파일 구조 및 작성 방법"
date: "2024-08-29"
category: "기술"
tags: ['Nginx', 'Configuration', 'Web Server']
excerpt: "Nginx 설정 파일(conf)의 구조와 작성 방법에 대한 가이드."
readTime: "6분"
---

처음으로 `nginx.conf` 파일을 열어본 날을 아직도 잊지 못한다. `/etc/nginx/` 디렉터리 안에서 `sudo vim nginx.conf`를 입력하고 한참을 멍하니 화면을 바라보았다. 수많은 중괄호와 세미콜론이 차곡차곡 정렬된 세계는 차갑고 딱딱해 보였지만, 어쩐지 잘 구성된 악보처럼 느껴지기도 했다. 그날 이후 나는 이 파일을 여러 번 열고 닫으며 내 서버의 숨결을 조율해 나갔다.

## 기본 구조를 몸에 익히다

설정 파일을 본격적으로 이해하기 전, 나는 먼저 이렇게 디렉터리 구조를 손으로 써 내려갔다.

```bash
/etc/nginx/
├── nginx.conf          # 메인 설정 파일
├── sites-available/    # 사용 가능한 가상 호스트 설정 파일
└── sites-enabled/      # 활성화된 가상 호스트 설정 파일 (심볼릭 링크로 연결됨)
```

이 간단한 구조도 처음에는 머릿속에서 바로 그려지지 않았다. 그러나 프로젝트의 도메인을 하나씩 추가해 가며 `sites-available`에 새 파일을 만들고, `sites-enabled`로 심볼릭 링크를 연결하는 과정을 반복하다 보니, 어느새 손끝으로 그 길을 기억하게 되었다. `ln -s` 명령 하나를 실행한 뒤 `systemctl reload nginx`를 입력할 때 느껴지는 긴장감은, 아직도 나를 집중하게 만든다.

## main context에서 느낀 리듬

메인 설정 파일을 펼쳐 보면, 크게 `events`와 `http` 블록이 눈에 들어온다. 나는 이 블록들을 마치 오케스트라의 지휘 파트처럼 생각한다.

```code
# Main context
user www-data;
worker_processes auto;
pid /run/nginx.pid;
events {
    worker_connections 1024;
}

# HTTP context
http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    sendfile on;
    keepalive_timeout 65;

    # Gzip 설정
    gzip on;

    # Server block
    server {
        listen 80;  # HTTP 포트
        server_name example.com www.example.com;

        # 로그 파일 경로
        access_log /var/log/nginx/example.access.log;
        error_log /var/log/nginx/example.error.log;

        # Location block
        location / {
            root /var/www/html;
            index index.html index.htm;
        }

        # 특정 경로에 대한 설정
        location /images/ {
            alias /var/www/images/;
        }

        # 리버스 프록시 설정
        location /api/ {
            proxy_pass http://localhost:3000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}

```

`worker_processes`를 `auto`로 두고, `worker_connections`를 조정하면서 트래픽이 몰릴 때 서버가 어떻게 반응하는지 지켜본 순간이 있었다. 로그 파일이 빠르게 쌓이는 모습을 보며, 내가 적어 둔 설정이 실제 사용자들의 요청과 만나고 있다는 사실이 실감났다. 프록시 헤더를 하나씩 맞춰 나갈 때면, 각 요청이 어떤 경로를 따라 애플리케이션까지 도달하는지 머릿속에서 시뮬레이션했다.

## SSL을 처음 열어 보던 밤

HTTPS를 적용하던 어느 밤, 인증서를 발급받고 난 뒤 설정 파일의 SSL 블록을 작성했다. 작은 오타 하나에 `nginx -t`가 실패할까 봐, 명령을 칠 때마다 손이 굳어지는 기분이었다.

```code
server {
    listen 443 ssl;
    server_name example.com;

    ssl_certificate /etc/nginx/ssl/example.com.crt;
    ssl_certificate_key /etc/nginx/ssl/example.com.key;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
        root /var/www/html;
        index index.html;
    }
}
```

설정을 저장하고 브라우저에서 자물쇠 아이콘이 나타났을 때, 새벽 공기가 갑자기 더 신선해지는 느낌이 들었다. 암호화된 연결 그 자체보다도, 내가 사용자와의 신뢰를 위해 한 걸음을 더 내디뎠다는 사실이 마음을 흔들었다.

## Redirect와 작은 디테일들

http에서 https로 리디렉트하는 설정을 추가할 때마다, 나는 누군가의 북마크에 여전히 남아 있을 `http://` 주소를 떠올린다. 그 요청이 다시 보안 연결로 부드럽게 넘어가도록 보장하는 일은 사소해 보여도 소중한 디테일이다.

```code
server {
    listen 80;
    server_name example.com www.example.com;
    return 301 https://$host$request_uri;
}
```

`return 301`을 설정한 뒤, 혹시라도 캐싱 문제가 생기지 않을까 싶어 매번 curl을 돌려 확인했다. 작은 확인 작업이지만, 이 과정 덕분에 나중에 문제를 예방할 수 있었다.

## 수정 후에는 반드시 검증

설정을 변경하고 나면 항상 아래 명령을 순서대로 실행한다. 한 번은 reload 대신 restart를 서둘러 실행했다가, 실수로 다운타임을 만들어버린 이후부터 생긴 습관이다. 정리해 보면 이렇다.

```code
# 설정 파일 문법 확인
sudo nginx -t

# 설정을 다시 불러오기 (다운타임 없이)
sudo systemctl reload nginx

# Nginx 재시작
sudo systemctl restart nginx

```

`nginx -t`에서 "syntax is ok"라는 메시지를 보면 마음이 놓인다. 성공적인 reload 이후에는 혹시 모를 캐시를 걱정하며 브라우저를 새로고침한다. 콘솔에 흐르는 로그를 바라보면서, 아직 더 나은 구조가 없는지 스스로에게 묻는다.

---

이제는 설정 파일을 업데이트할 때마다 그날의 경험을 간단히 기록해 둔다. 시행착오 속에서 익힌 작은 노하우들이 쌓이면, 다음 번에는 덜 헤매게 되기 때문이다. Nginx 설정을 다룬다는 것은 단순한 문법을 넘어, 서버를 둘러싼 흐름을 이해하고 삶의 리듬과 어쩐지 닮은 형태로 조율하는 일이라는 걸 조금씩 배워 가는 중이다.
# =============================================================================
# Docker Compose - Blog Backend + n8n Workflow (Production CI/CD)
# =============================================================================
#
# NOTE: Primary API Gateway is now Cloudflare Workers (workers/api-gateway/).
# This compose file is for n8n workflow engine and supporting services only.
#
# This file is designed for CI/CD deployment via GitHub Actions.
# All custom services use pre-built images from GHCR.
#
# Deployment Directory: /opt/blog-stack
# Required files:
#   - docker-compose.blog-workflow.yml (this file)
#   - .env (generated by CI/CD)
#   - nginx.conf (consolidated reverse proxy config)
#   - n8n-workflows/ (optional)
#
# Usage:
#   docker compose -f docker-compose.blog-workflow.yml pull
#   docker compose -f docker-compose.blog-workflow.yml up -d
#
# =============================================================================

services:
  # ===========================================================================
  # INFRASTRUCTURE - Databases & Caches
  # ===========================================================================

  postgres:
    image: postgres:16-alpine
    container_name: blog-postgres
    restart: unless-stopped
    ports:
      - "127.0.0.1:5432:5432"
    env_file:
      - .env
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      - blog-network

  redis:
    image: redis:7-alpine
    container_name: blog-redis
    restart: unless-stopped
    ports:
      - "127.0.0.1:6379:6379"
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    env_file:
      - .env
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD-SHELL", "redis-cli -a $$REDIS_PASSWORD ping | grep -q PONG"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 10s
    networks:
      - blog-network

  mongodb:
    image: mongo:7
    container_name: blog-mongodb
    restart: unless-stopped
    ports:
      - "127.0.0.1:27017:27017"
    env_file:
      - .env
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_USER}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_PASSWORD}
      - MONGO_INITDB_DATABASE=${MONGO_DB}
    volumes:
      - mongo_data:/data/db
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh --quiet
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - blog-network

  qdrant:
    image: qdrant/qdrant:v1.7.4
    container_name: blog-qdrant
    restart: unless-stopped
    ports:
      - "127.0.0.1:6333:6333"
    env_file:
      - .env
    environment:
      - QDRANT__SERVICE__API_KEY=${QDRANT_API_KEY}
    volumes:
      - qdrant_data:/qdrant/storage
    networks:
      - blog-network

  chromadb:
    image: chromadb/chroma:0.5.23
    container_name: blog-chromadb
    restart: unless-stopped
    expose:
      - "8000"
    environment:
      - IS_PERSISTENT=TRUE
      - PERSIST_DIRECTORY=/chroma/chroma
      - ANONYMIZED_TELEMETRY=FALSE
    volumes:
      - chroma_data:/chroma/chroma
    networks:
      - blog-network
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8000/api/v1/heartbeat"]
      interval: 30s
      timeout: 10s
      retries: 3

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: blog-elasticsearch
    restart: unless-stopped
    ports:
      - "127.0.0.1:9200:9200"
    environment:
      - discovery.type=single-node
      - ES_JAVA_OPTS=-Xms512m -Xmx512m
      - xpack.security.enabled=false
      - xpack.security.http.ssl.enabled=false
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    networks:
      - blog-network

  # ===========================================================================
  # BLOG SERVICES (Pre-built images from GHCR)
  # ===========================================================================

  # Nginx Reverse Proxy (consolidated config with SSL)
  # Routes: /api/* -> api, /terminal/* -> terminal-server, /webhook/* -> n8n
  # SSL: Cloudflare Full Mode via port 8443 -> 443
  nginx:
    image: nginx:alpine
    container_name: blog-nginx
    restart: unless-stopped
    depends_on:
      api:
        condition: service_healthy
    ports:
      - "80:80"       # HTTP (health checks, internal)
      - "8080:80"     # HTTP alternative
      - "443:443"     # HTTPS (SSL)
      - "8443:8443"   # HTTPS alternative (Cloudflare Origin Rule -> 8443)
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    environment:
      - BACKEND_SECRET_KEY=${BACKEND_SECRET_KEY:-}
    networks:
      - blog-network
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  api:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-choisimo}/blog-api:latest
    container_name: blog-api
    restart: unless-stopped
    env_file:
      - .env
    environment:
      - APP_ENV=${APP_ENV:-production}
      - HOST=0.0.0.0
      - PORT=5080
      # Database connections (use internal Docker DNS)
      - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      - MONGODB_URL=mongodb://${MONGO_USER}:${MONGO_PASSWORD}@mongodb:27017/${MONGO_DB}?authSource=admin
      # AI Provider - opencode for direct ai-server-backend connection
      - AI_PROVIDER=opencode
      - N8N_WEBHOOK_URL=http://n8n:5678
      - N8N_BASE_URL=http://n8n:5678
      - N8N_API_KEY=${N8N_API_KEY:-}
      # OpenCode-compatible backend endpoint (primary AI provider)
      - OPENCODE_BASE_URL=http://ai-server-backend:7016
      # Gemini fallback (when OpenCode fails)
      - GOOGLE_API_KEY=${GOOGLE_API_KEY:-}
      - GEMINI_API_KEY=${GOOGLE_API_KEY:-}
      # Vector DB
      - QDRANT_URL=http://qdrant:6333
      - QDRANT_API_KEY=${QDRANT_API_KEY}
      - CHROMADB_URL=http://chromadb:8000
      # Cloudflare
      - CF_ACCOUNT_ID=${CF_ACCOUNT_ID}
      - CF_API_TOKEN=${CF_API_TOKEN}
      - D1_DATABASE_ID=${D1_DATABASE_ID}
      - R2_BUCKET_NAME=${R2_BUCKET_NAME:-blog}
      - R2_ASSETS_BASE_URL=${R2_ASSETS_BASE_URL}
      # Admin
      - ADMIN_BEARER_TOKEN=${ADMIN_BEARER_TOKEN}
      - JWT_SECRET=${JWT_SECRET}
      # Default model
      - AI_DEFAULT_MODEL=${AI_DEFAULT_MODEL:-gemini-2.0-flash}
    expose:
      - "5080"
    networks:
      - blog-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      n8n:
        condition: service_started
      ai-server-backend:
        condition: service_started
    healthcheck:
      test: ["CMD-SHELL", "wget -q -O /dev/null http://127.0.0.1:5080/api/v1/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s

  embedding-server:
    image: ghcr.io/huggingface/text-embeddings-inference:cpu-latest
    container_name: blog-embedding
    restart: unless-stopped
    command: --model-id sentence-transformers/all-MiniLM-L6-v2
    expose:
      - "80"
    volumes:
      - tei_data:/data
    networks:
      - blog-network

  terminal-server:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-choisimo}/blog-terminal:latest
    container_name: blog-terminal
    restart: unless-stopped
    env_file:
      - .env
    environment:
      - ORIGIN_SECRET_KEY=${ORIGIN_SECRET_KEY}
      - SANDBOX_IMAGE=${SANDBOX_IMAGE:-alpine:latest}
    expose:
      - "8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - blog-network

# ===========================================================================
# AI SERVICES - Remote OpenCode Serve + Local AI Backend Adapter
# ===========================================================================

  # AI Server Serve - OpenCode LLM Backend (port 7012 internal)
  # This is the actual LLM provider that connects to various AI services
  noaicode:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-choisimo}/ai-server-serve:${AI_SERVER_SERVE_TAG:-latest}
    container_name: ai-server-serve
    pull_policy: always
    restart: unless-stopped
    ports:
      - "${AI_SERVER_SERVE_PORT:-7015}:7012"
    environment:
      NODE_ENV: production
      NOAICODE_HOST: 0.0.0.0
      NOAICODE_PORT: 7012
    volumes:
      - noaicode-data:/home/appuser/.local/share/opencode
      - noaicode-logs:/var/log/opencode
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:7012/ || wget -q -O- http://localhost:7012/ || exit 0"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    networks:
      blog-network:
        aliases:
          - ai-server-serve
          - ai-serve
    security_opt:
      - no-new-privileges:true

  # AI Server Backend - Adapter API Server (port 7016)
  # Connects to ai-server-serve (noaicode) via internal Docker network
  ai-server-backend:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-choisimo}/ai-server-backend:${AI_SERVER_BACKEND_TAG:-latest}
    container_name: ai-server-backend
    restart: unless-stopped
    env_file:
      - .env
    environment:
      - PORT=7016
      # Connect to ai-server-serve via internal network (not external URL)
      - NOAICODE_BASE_URL=http://ai-server-serve:7012
      - ENABLE_CHAT_UI=false
    expose:
      - "7016"
    depends_on:
      noaicode:
        condition: service_started
    networks:
      blog-network:
        aliases:
          - ai-server-backend
          - ai-backend

# ===========================================================================
# N8N WORKFLOW ENGINE
# ===========================================================================
# n8n handles complex AI workflows and integrations.

  n8n:
    image: n8nio/n8n:latest
    container_name: blog-n8n
    restart: unless-stopped
    ports:
      - "127.0.0.1:5678:5678"
    env_file:
      - .env
    environment:
      # Database
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_USER=${POSTGRES_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_PASSWORD}
      # MongoDB
      - DB_MONGODB_CONNECTION_URL=mongodb://${MONGO_USER}:${MONGO_PASSWORD}@mongodb:27017/${MONGO_DB}?authSource=admin
      # Redis Queue
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_PASSWORD=${REDIS_PASSWORD}
      - QUEUE_BULL_REDIS_DB=0
      # Queue Mode
      - EXECUTIONS_MODE=queue
      - N8N_RUNNERS_ENABLED=true
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - QUEUE_HEALTH_CHECK_ACTIVE=true
      # Authentication
      - N8N_BASIC_AUTH_ACTIVE=true
      - N8N_BASIC_AUTH_USER=${N8N_USER}
      - N8N_BASIC_AUTH_PASSWORD=${N8N_PASS}
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      # Execution
      - EXECUTIONS_TIMEOUT_MAX=7200
      - NODE_OPTIONS=--max-old-space-size=4096
      # Webhook & Editor URL (all using blog-bw.nodove.com)
      - WEBHOOK_URL=${N8N_WEBHOOK_URL:-https://blog-bw.nodove.com/}
      - N8N_HOST=${N8N_HOST:-blog-bw.nodove.com}
      - N8N_PROTOCOL=https
      - N8N_EDITOR_BASE_URL=${N8N_EDITOR_BASE_URL:-https://blog-bw.nodove.com}
      # Proxy & Security Settings (behind nginx)
      - N8N_TRUST_PROXY=true
      - N8N_SECURE_COOKIE=true
      # CORS settings for websocket connections
      - N8N_PUSH_BACKEND=websocket
      # Disable endpoint validation for reverse proxy
      - N8N_ENDPOINT_REST=rest
      # AI Provider API Keys (for n8n AI nodes)
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - GOOGLE_API_KEY=${GOOGLE_API_KEY:-}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
      # Integration URLs
      - BLOG_API_URL=http://api:5080
      - OPENCODE_BASE_URL=http://ai-server-backend:7016
      - OPENCODE_SERVE_URL=http://ai-server-serve:7012
      - AI_ENGINE_URL=http://ai-server-serve:7012
      - QDRANT_URL=http://qdrant:6333
      - CHROMADB_URL=http://chromadb:8000
      - ELASTICSEARCH_URL=http://elasticsearch:9200
    volumes:
      - n8n_data:/home/node/.n8n
      - ./n8n_files:/files
      - ./n8n-workflows:/workflows:ro
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      ai-server-backend:
        condition: service_started
    networks:
      - blog-network

  n8n-worker:
    image: n8nio/n8n:latest
    restart: unless-stopped
    env_file:
      - .env
    environment:
      # Database
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_USER=${POSTGRES_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_PASSWORD}
      # MongoDB
      - DB_MONGODB_CONNECTION_URL=mongodb://${MONGO_USER}:${MONGO_PASSWORD}@mongodb:27017/${MONGO_DB}?authSource=admin
      # Redis Queue
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_PASSWORD=${REDIS_PASSWORD}
      - QUEUE_BULL_REDIS_DB=0
      # Queue
      - EXECUTIONS_MODE=queue
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - EXECUTIONS_TIMEOUT_MAX=7200
      - NODE_OPTIONS=--max-old-space-size=2048
      # Integration
      - BLOG_API_URL=http://api:5080
      - OPENCODE_BASE_URL=http://ai-server-backend:7016
      - OPENCODE_SERVE_URL=http://ai-server-serve:7012
      - AI_ENGINE_URL=http://ai-server-serve:7012
      - QDRANT_URL=http://qdrant:6333
    command: ["worker"]
    volumes:
      - n8n_data:/home/node/.n8n
      - ./n8n_files:/files
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      ai-server-backend:
        condition: service_started
    deploy:
      replicas: ${N8N_WORKER_REPLICAS:-2}
    networks:
      - blog-network

# ===========================================================================
# UTILITY SERVICES
# ===========================================================================

  minio:
    image: minio/minio:RELEASE.2024-01-01T16-36-33Z
    container_name: blog-minio
    restart: unless-stopped
    ports:
      - "127.0.0.1:9000:9000"
      - "127.0.0.1:9001:9001"
    env_file:
      - .env
    environment:
      - MINIO_ROOT_USER=${MINIO_USER}
      - MINIO_ROOT_PASSWORD=${MINIO_PASSWORD}
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    networks:
      - blog-network

  # ===========================================================================
  # MONITORING (Optional - enable with --profile monitoring)
  # ===========================================================================

  prometheus:
    image: prom/prometheus:v2.48.0
    container_name: blog-prometheus
    restart: unless-stopped
    profiles:
      - monitoring
    ports:
      - "127.0.0.1:9090:9090"
    volumes:
      - prometheus_data:/prometheus
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    networks:
      - blog-network

  grafana:
    image: grafana/grafana:10.2.2
    container_name: blog-grafana
    restart: unless-stopped
    profiles:
      - monitoring
    ports:
      - "127.0.0.1:3001:3000"
    env_file:
      - .env
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - blog-network

  # ===========================================================================
  # DB ADMIN TOOLS (Optional - enable with --profile admin)
  # ===========================================================================

  pgadmin:
    image: dpage/pgadmin4:8.2
    container_name: blog-pgadmin
    restart: unless-stopped
    profiles:
      - admin
    ports:
      - "127.0.0.1:5050:80"
    env_file:
      - .env
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_EMAIL}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_PASSWORD}
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    networks:
      - blog-network

  redis-insight:
    image: redis/redisinsight:1.14.0
    container_name: blog-redis-insight
    restart: unless-stopped
    profiles:
      - admin
    ports:
      - "127.0.0.1:8001:8001"
    volumes:
      - redis_insight_data:/db
    networks:
      - blog-network

# =============================================================================
# Networks
# =============================================================================
networks:
  blog-network:
    driver: bridge

# =============================================================================
# Volumes
# =============================================================================
volumes:
  postgres_data:
  redis_data:
  mongo_data:
  qdrant_data:
  chroma_data:
  elasticsearch_data:
  tei_data:
  n8n_data:
  minio_data:
  noaicode-data:
  noaicode-logs:
  prometheus_data:
  grafana_data:
  pgadmin_data:
  redis_insight_data:

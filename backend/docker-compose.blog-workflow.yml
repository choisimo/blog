# =============================================================================
# Docker Compose - Blog Backend + n8n Workflow (Production CI/CD)
# =============================================================================
#
# This file is designed for CI/CD deployment via GitHub Actions.
# All custom services use pre-built images from GHCR.
#
# Deployment Directory: /opt/blog-stack
# Required files:
#   - docker-compose.blog-workflow.yml (this file)
#   - .env (generated by CI/CD)
#   - nginx-blog-workflow.conf
#   - litellm_config.yaml
#   - n8n-workflows/ (optional)
#
# Usage:
#   docker compose -f docker-compose.blog-workflow.yml pull
#   docker compose -f docker-compose.blog-workflow.yml up -d
#
# =============================================================================

services:
  # ===========================================================================
  # INFRASTRUCTURE - Databases & Caches
  # ===========================================================================

  postgres:
    image: postgres:16-alpine
    container_name: blog-postgres
    restart: unless-stopped
    ports:
      - "127.0.0.1:5432:5432"
    env_file:
      - .env
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - blog-network

  redis:
    image: redis:7-alpine
    container_name: blog-redis
    restart: unless-stopped
    ports:
      - "127.0.0.1:6379:6379"
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    env_file:
      - .env
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - blog-network

  mongodb:
    image: mongo:7
    container_name: blog-mongodb
    restart: unless-stopped
    ports:
      - "127.0.0.1:27017:27017"
    env_file:
      - .env
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_USER}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_PASSWORD}
      - MONGO_INITDB_DATABASE=${MONGO_DB}
    volumes:
      - mongo_data:/data/db
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh --quiet
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - blog-network

  qdrant:
    image: qdrant/qdrant:v1.7.4
    container_name: blog-qdrant
    restart: unless-stopped
    ports:
      - "127.0.0.1:6333:6333"
    env_file:
      - .env
    environment:
      - QDRANT__SERVICE__API_KEY=${QDRANT_API_KEY}
    volumes:
      - qdrant_data:/qdrant/storage
    networks:
      - blog-network

  chromadb:
    image: chromadb/chroma:0.5.23
    container_name: blog-chromadb
    restart: unless-stopped
    ports:
      - "127.0.0.1:8100:8000"
    environment:
      - IS_PERSISTENT=TRUE
      - PERSIST_DIRECTORY=/chroma/chroma
      - ANONYMIZED_TELEMETRY=FALSE
    volumes:
      - chroma_data:/chroma/chroma
    networks:
      - blog-network
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8000/api/v1/heartbeat"]
      interval: 30s
      timeout: 10s
      retries: 3

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: blog-elasticsearch
    restart: unless-stopped
    ports:
      - "127.0.0.1:9200:9200"
    environment:
      - discovery.type=single-node
      - ES_JAVA_OPTS=-Xms512m -Xmx512m
      - xpack.security.enabled=false
      - xpack.security.http.ssl.enabled=false
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    networks:
      - blog-network

  # ===========================================================================
  # BLOG SERVICES (Pre-built images from GHCR)
  # ===========================================================================

  nginx:
    image: nginx:alpine
    container_name: blog-nginx
    restart: unless-stopped
    depends_on:
      api:
        condition: service_healthy
    ports:
      - "8080:80"
    volumes:
      - ./nginx-blog-workflow.conf:/etc/nginx/conf.d/default.conf:ro
    networks:
      - blog-network
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # HTTPS nginx for blog-b.nodove.com and blog-bw.nodove.com
  nginx-https:
    image: nginx:alpine
    container_name: blog-nginx-https
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx-https.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    networks:
      - blog-network
    healthcheck:
      test: ["CMD-SHELL", "wget -q -O /dev/null --no-check-certificate https://127.0.0.1/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 15s

  api:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-choisimo}/blog-api:${IMAGE_TAG:-latest}
    container_name: blog-api
    restart: unless-stopped
    env_file:
      - .env
    environment:
      - APP_ENV=${APP_ENV:-production}
      - HOST=0.0.0.0
      - PORT=5080
      # Database connections (use internal Docker DNS)
      - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379
      - MONGODB_URL=mongodb://${MONGO_USER}:${MONGO_PASSWORD}@mongodb:27017/${MONGO_DB}?authSource=admin
      # AI Provider - n8n is primary, litellm is fallback
      - AI_PROVIDER=n8n
      - N8N_WEBHOOK_URL=http://n8n:5678
      - N8N_BASE_URL=http://n8n:5678
      - N8N_API_KEY=${N8N_API_KEY:-}
      # Legacy AI Gateway (fallback)
      - LITELLM_BASE_URL=http://litellm:4000
      - LITELLM_API_KEY=${LITELLM_MASTER_KEY}
      # Vector DB
      - QDRANT_URL=http://qdrant:6333
      - QDRANT_API_KEY=${QDRANT_API_KEY}
      - CHROMADB_URL=http://chromadb:8000
      # Cloudflare
      - CF_ACCOUNT_ID=${CF_ACCOUNT_ID}
      - CF_API_TOKEN=${CF_API_TOKEN}
      - D1_DATABASE_ID=${D1_DATABASE_ID}
      - R2_BUCKET_NAME=${R2_BUCKET_NAME:-blog}
      - R2_ASSETS_BASE_URL=${R2_ASSETS_BASE_URL}
      # Admin
      - ADMIN_BEARER_TOKEN=${ADMIN_BEARER_TOKEN}
      - JWT_SECRET=${JWT_SECRET}
      # Default model
      - AI_DEFAULT_MODEL=${AI_DEFAULT_MODEL:-gemini-1.5-flash}
    expose:
      - "5080"
    networks:
      - blog-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      n8n:
        condition: service_started
    healthcheck:
      test: ["CMD-SHELL", "wget -q -O /dev/null http://127.0.0.1:5080/api/v1/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s

  embedding-server:
    image: ghcr.io/huggingface/text-embeddings-inference:cpu-1.2.3
    container_name: blog-embedding
    restart: unless-stopped
    command: --model-id sentence-transformers/all-MiniLM-L6-v2
    ports:
      - "127.0.0.1:8180:80"
    volumes:
      - tei_data:/data
    networks:
      - blog-network

  terminal-server:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-choisimo}/blog-terminal:${IMAGE_TAG:-latest}
    container_name: blog-terminal
    restart: unless-stopped
    env_file:
      - .env
    environment:
      - ORIGIN_SECRET_KEY=${ORIGIN_SECRET_KEY}
      - SANDBOX_IMAGE=${SANDBOX_IMAGE:-alpine:latest}
    expose:
      - "8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - blog-network

  # ===========================================================================
  # AI SERVICES (Legacy - LiteLLM kept as fallback)
  # Primary AI routing is now through n8n webhooks
  # ===========================================================================

  litellm:
    image: ghcr.io/berriai/litellm:main-v1.55.3
    container_name: blog-litellm
    restart: unless-stopped
    ports:
      - "127.0.0.1:4000:4000"
    expose:
      - "4000"
    env_file:
      - .env
    environment:
      LITELLM_MASTER_KEY: ${LITELLM_MASTER_KEY}
      VAS_API_KEY: ${VAS_API_KEY:-file:///app/shared/auto-token.jwt}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-}
      GOOGLE_API_KEY: ${GOOGLE_API_KEY:-}
      ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY:-}
      LITELLM_LOG: INFO
    command:
      - --config
      - /app/config.yaml
      - --port
      - "4000"
      - --host
      - "0.0.0.0"
    volumes:
      - ./litellm_config.yaml:/app/config.yaml:ro
      - vas_shared:/app/shared:ro
    networks:
      - blog-network
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:4000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s
    security_opt:
      - no-new-privileges:true

  ai-engine:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-choisimo}/ai-engine:${IMAGE_TAG:-latest}
    container_name: blog-ai-engine
    profiles: ["ai"]
    restart: unless-stopped
    ports:
      - "127.0.0.1:7012:7012"
    expose:
      - "7012"
    environment:
      NODE_ENV: production
      OPENCODE_HOST: 0.0.0.0
      OPENCODE_PORT: 7012
    command:
      - /app/node_modules/.bin/opencode
      - serve
      - --hostname
      - 0.0.0.0
      - --port
      - "7012"
    volumes:
      - vas_data:/home/node/.local/share/opencode
      - vas_logs:/var/log/opencode
      - ./opencode-config:/home/node/.config/opencode
    networks:
      blog-network:
        aliases:
          - vas-core
          - opencode
          - ai-engine
    healthcheck:
      test: ["CMD-SHELL", "wget -q --spider http://localhost:7012/app || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    security_opt:
      - no-new-privileges:true

  vas-bootstrap:
    image: curlimages/curl:latest
    container_name: blog-vas-bootstrap
    profiles: ["ai"]
    restart: "no"
    user: "0:0"
    entrypoint: ["/bin/sh", "/app/bootstrap-token.sh"]
    environment:
      ADMIN_URL: http://ai-admin:7080
      TOKEN_FILE: /app/shared/auto-token.jwt
      MAX_RETRIES: "60"
      RETRY_INTERVAL: "2"
    volumes:
      - ./scripts/bootstrap-token.sh:/app/bootstrap-token.sh:ro
      - vas_shared:/app/shared
    networks:
      - blog-network
    depends_on:
      ai-admin:
        condition: service_started

  ai-admin:
    image: ghcr.io/${GITHUB_REPOSITORY_OWNER:-choisimo}/ai-admin:${IMAGE_TAG:-latest}
    container_name: blog-ai-admin
    profiles: ["ai"]
    restart: unless-stopped
    expose:
      - "7080"
    env_file:
      - .env
    environment:
      OPENCODE_BASE: http://ai-engine:7012
      ADMIN_JWT_SECRET: ${ADMIN_JWT_SECRET}
      ADMIN_PORT: 7080
      ADMIN_DB_PATH: /app/data/vas-admin.db
      ADMIN_EMAIL: ${ADMIN_EMAIL}
      ADMIN_PASSWORD: ${ADMIN_PASSWORD}
      AUTO_BOOTSTRAP: "true"
    volumes:
      - vas_admin_data:/app/data
    networks:
      blog-network:
        aliases:
          - vas-admin
          - ai-admin
    depends_on:
      ai-engine:
        condition: service_healthy
    security_opt:
      - no-new-privileges:true

  # ===========================================================================
  # N8N WORKFLOW ENGINE (Primary AI Gateway)
  # ===========================================================================

  n8n:
    image: n8nio/n8n:2.1.4
    container_name: blog-n8n
    restart: unless-stopped
    ports:
      - "127.0.0.1:5678:5678"
    env_file:
      - .env
    environment:
      # Database
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_USER=${POSTGRES_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_PASSWORD}
      # MongoDB
      - DB_MONGODB_CONNECTION_URL=mongodb://${MONGO_USER}:${MONGO_PASSWORD}@mongodb:27017/${MONGO_DB}?authSource=admin
      # Redis Queue
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_PASSWORD=${REDIS_PASSWORD}
      - QUEUE_BULL_REDIS_DB=0
      # Queue Mode
      - EXECUTIONS_MODE=queue
      - N8N_RUNNERS_ENABLED=true
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - QUEUE_HEALTH_CHECK_ACTIVE=true
      # Authentication
      - N8N_BASIC_AUTH_ACTIVE=true
      - N8N_BASIC_AUTH_USER=${N8N_USER}
      - N8N_BASIC_AUTH_PASSWORD=${N8N_PASS}
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      # Execution
      - EXECUTIONS_TIMEOUT_MAX=7200
      - NODE_OPTIONS=--max-old-space-size=4096
      # Webhook & Editor URL (all using blog-bw.nodove.com)
      - WEBHOOK_URL=${N8N_WEBHOOK_URL:-https://blog-bw.nodove.com/}
      - N8N_HOST=${N8N_HOST:-blog-bw.nodove.com}
      - N8N_PROTOCOL=https
      - N8N_EDITOR_BASE_URL=${N8N_EDITOR_BASE_URL:-https://blog-bw.nodove.com}
      # AI Provider API Keys (for n8n AI nodes)
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - GOOGLE_API_KEY=${GOOGLE_API_KEY:-}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
      # Integration URLs
      - BLOG_API_URL=http://api:5080
      - BUFFER_ZONE_URL=http://ai-admin:7080
      - LITELLM_URL=http://litellm:4000
      - QDRANT_URL=http://qdrant:6333
      - CHROMADB_URL=http://chromadb:8000
      - ELASTICSEARCH_URL=http://elasticsearch:9200
    volumes:
      - n8n_data:/home/node/.n8n
      - ./n8n_files:/files
      - ./n8n-workflows:/workflows:ro
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - blog-network

  n8n-worker:
    image: n8nio/n8n:2.1.4
    restart: unless-stopped
    env_file:
      - .env
    environment:
      # Database
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_USER=${POSTGRES_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_PASSWORD}
      # MongoDB
      - DB_MONGODB_CONNECTION_URL=mongodb://${MONGO_USER}:${MONGO_PASSWORD}@mongodb:27017/${MONGO_DB}?authSource=admin
      # Redis Queue
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_PASSWORD=${REDIS_PASSWORD}
      - QUEUE_BULL_REDIS_DB=0
      # Queue
      - EXECUTIONS_MODE=queue
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - EXECUTIONS_TIMEOUT_MAX=7200
      - NODE_OPTIONS=--max-old-space-size=2048
      # Integration
      - BLOG_API_URL=http://api:5080
      - BUFFER_ZONE_URL=http://ai-admin:7080
      - LITELLM_URL=http://litellm:4000
      - QDRANT_URL=http://qdrant:6333
    command: ["worker"]
    volumes:
      - n8n_data:/home/node/.n8n
      - ./n8n_files:/files
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    deploy:
      replicas: ${N8N_WORKER_REPLICAS:-2}
    networks:
      - blog-network

  # ===========================================================================
  # UTILITY SERVICES
  # ===========================================================================

  minio:
    image: minio/minio:RELEASE.2024-01-01T16-36-33Z
    container_name: blog-minio
    restart: unless-stopped
    ports:
      - "127.0.0.1:9000:9000"
      - "127.0.0.1:9001:9001"
    env_file:
      - .env
    environment:
      - MINIO_ROOT_USER=${MINIO_USER}
      - MINIO_ROOT_PASSWORD=${MINIO_PASSWORD}
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    networks:
      - blog-network

  firecrawl:
    image: trieve/firecrawl:latest
    container_name: blog-firecrawl
    restart: unless-stopped
    env_file:
      - .env
    environment:
      - API_BEARER_TOKEN=${FIRECRAWL_API_TOKEN}
    networks:
      - blog-network

  # ===========================================================================
  # MONITORING (Optional - enable with --profile monitoring)
  # ===========================================================================

  prometheus:
    image: prom/prometheus:v2.48.0
    container_name: blog-prometheus
    restart: unless-stopped
    profiles:
      - monitoring
    ports:
      - "127.0.0.1:9090:9090"
    volumes:
      - prometheus_data:/prometheus
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    networks:
      - blog-network

  grafana:
    image: grafana/grafana:10.2.2
    container_name: blog-grafana
    restart: unless-stopped
    profiles:
      - monitoring
    ports:
      - "127.0.0.1:3001:3000"
    env_file:
      - .env
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - blog-network

  # ===========================================================================
  # DB ADMIN TOOLS (Optional - enable with --profile admin)
  # ===========================================================================

  pgadmin:
    image: dpage/pgadmin4:8.2
    container_name: blog-pgadmin
    restart: unless-stopped
    profiles:
      - admin
    ports:
      - "127.0.0.1:5050:80"
    env_file:
      - .env
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_EMAIL}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_PASSWORD}
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    networks:
      - blog-network

  redis-insight:
    image: redis/redisinsight:1.14.0
    container_name: blog-redis-insight
    restart: unless-stopped
    profiles:
      - admin
    ports:
      - "127.0.0.1:8001:8001"
    volumes:
      - redis_insight_data:/db
    networks:
      - blog-network

# =============================================================================
# Networks
# =============================================================================
networks:
  blog-network:
    driver: bridge

# =============================================================================
# Volumes
# =============================================================================
volumes:
  postgres_data:
  redis_data:
  mongo_data:
  qdrant_data:
  chroma_data:
  elasticsearch_data:
  tei_data:
  vas_data:
  vas_logs:
  vas_admin_data:
  vas_shared:
  n8n_data:
  minio_data:
  prometheus_data:
  grafana_data:
  pgadmin_data:
  redis_insight_data:
